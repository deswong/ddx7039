diff -burN linux-2.6.8.1-orig/Makefile linux-2.6.8.1/Makefile
--- linux-2.6.8.1-orig/Makefile	2004-08-14 19:55:35.000000000 +0900
+++ linux-2.6.8.1/Makefile	2007-01-24 13:25:24.000000000 +0900
@@ -1,8 +1,8 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 8
-EXTRAVERSION = .1
-NAME=Zonked Quokka
+EXTRAVERSION =.1-ken1.0.0
+NAME=
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
@@ -172,8 +172,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= arm
+CROSS_COMPILE	?= arm-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
diff -burN linux-2.6.8.1-orig/arch/arm/Kconfig linux-2.6.8.1/arch/arm/Kconfig
--- linux-2.6.8.1-orig/arch/arm/Kconfig	2004-08-14 19:55:33.000000000 +0900
+++ linux-2.6.8.1/arch/arm/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -75,6 +75,11 @@
 config ARCH_CLPS7500
 	bool "Cirrus-CL-PS7500FE"
 
+config ARCH_EP93XX
+	bool "Cirrus Logic EP93xx"
+	help
+	  Cirrus Logic EP93xx based systems.
+
 config ARCH_CLPS711X
 	bool "CLPS711x/EP721x-based"
 
@@ -182,6 +187,8 @@
 
 source "arch/arm/mach-lh7a40x/Kconfig"
 
+source "arch/arm/mach-ep93xx/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -622,7 +629,7 @@
 
 source "net/Kconfig"
 
-if ARCH_CLPS7500 || ARCH_IOP3XX || ARCH_IXP4XX || ARCH_L7200 || ARCH_LH7A40X || ARCH_PXA || ARCH_RPC || ARCH_S3C2410 || ARCH_SA1100 || ARCH_SHARK || FOOTBRIDGE
+if ARCH_CLPS7500 || ARCH_IOP3XX || ARCH_IXP4XX || ARCH_L7200 || ARCH_LH7A40X || ARCH_PXA || ARCH_RPC || ARCH_S3C2410 || ARCH_SA1100 || ARCH_SHARK || FOOTBRIDGE || ARCH_EP9312 || ARCH_EP9315 || ARCH_EP9315A
 source "drivers/ide/Kconfig"
 endif
 
diff -burN linux-2.6.8.1-orig/arch/arm/Makefile linux-2.6.8.1/arch/arm/Makefile
--- linux-2.6.8.1-orig/arch/arm/Makefile	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/arch/arm/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -55,8 +55,8 @@
 tune-$(CONFIG_CPU_V6)		:=-mtune=strongarm
 
 # Need -Uarm for gcc < 3.x
-CFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) $(call check_gcc,-malignment-traps,-mshort-load-bytes) -msoft-float -Wa,-mno-fpu -Uarm
-AFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -msoft-float -Wa,-mno-fpu
+CFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) $(call check_gcc,-malignment-traps,-mshort-load-bytes) -msoft-float -Uarm
+AFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -msoft-float
 
 CHECK		:= $(CHECK) -D__arm__=1
 
@@ -94,6 +94,7 @@
  machine-$(CONFIG_ARCH_S3C2410)	   := s3c2410
  machine-$(CONFIG_ARCH_LH7A40X)	   := lh7a40x
  machine-$(CONFIG_ARCH_VERSATILE_PB) := versatile
+ machine-$(CONFIG_ARCH_EP93XX)     := ep93xx
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
diff -burN linux-2.6.8.1-orig/arch/arm/boot/Makefile linux-2.6.8.1/arch/arm/boot/Makefile
--- linux-2.6.8.1-orig/arch/arm/boot/Makefile	2004-08-14 19:54:50.000000000 +0900
+++ linux-2.6.8.1/arch/arm/boot/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -62,6 +62,9 @@
    zreladdr-$(CONFIG_ARCH_VERSATILE_PB)	:= 0x00008000
 params_phys-$(CONFIG_ARCH_VERSATILE_PB)	:= 0x00000100
 initrd_phys-$(CONFIG_ARCH_VERSATILE_PB)	:= 0x00800000
+   zreladdr-$(CONFIG_ARCH_EP93XX)	:= $(CONFIG_EP93XX_ZREL_ADDR)
+params_phys-$(CONFIG_ARCH_EP93XX)	:= $(CONFIG_EP93XX_PARAMS_PHYS)
+initrd_phys-$(CONFIG_ARCH_EP93XX)	:= $(CONFIG_EP93XX_INITRD_PHYS)
 
 ZRELADDR    := $(zreladdr-y)
 PARAMS_PHYS := $(params_phys-y)
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9301_defconfig linux-2.6.8.1/arch/arm/configs/edb9301_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9301_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9301_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,802 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+CONFIG_ARCH_EDB9301=y
+# CONFIG_ARCH_EDB9302 is not set
+# CONFIG_ARCH_EDB9302A is not set
+# CONFIG_ARCH_EDB9307 is not set
+# CONFIG_ARCH_EDB9307A is not set
+# CONFIG_ARCH_EDB9312 is not set
+# CONFIG_ARCH_EDB9315 is not set
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+CONFIG_EP93XX_FLASH_SIZE_16=y
+# CONFIG_EP93XX_FLASH_SIZE_32 is not set
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+CONFIG_EP93XX_FLASH_WIDTH_16=y
+# CONFIG_EP93XX_FLASH_WIDTH_32 is not set
+# CONFIG_EP93XX_SDCS0 is not set
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+CONFIG_EP93XX_SDCS3=y
+CONFIG_EP93XX_SYNC_BOOT=y
+CONFIG_ARCH_EP9301=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x01000000
+CONFIG_EP93XX_PHYS_ADDR=0x00000000
+CONFIG_EP93XX_ZREL_ADDR=0x00008000
+CONFIG_EP93XX_PARAMS_PHYS=0x00000100
+CONFIG_EP93XX_INITRD_PHYS=0x01000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+# CONFIG_JFFS_PROC_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4271=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9302A_defconfig linux-2.6.8.1/arch/arm/configs/edb9302A_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9302A_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9302A_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,968 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+# CONFIG_ARCH_EDB9302 is not set
+CONFIG_ARCH_EDB9302A=y
+# CONFIG_ARCH_EDB9307 is not set
+# CONFIG_ARCH_EDB9307A is not set
+# CONFIG_ARCH_EDB9312 is not set
+# CONFIG_ARCH_EDB9315 is not set
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+CONFIG_EP93XX_FLASH_SIZE_16=y
+# CONFIG_EP93XX_FLASH_SIZE_32 is not set
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+CONFIG_EP93XX_FLASH_WIDTH_16=y
+# CONFIG_EP93XX_FLASH_WIDTH_32 is not set
+CONFIG_EP93XX_SDCS0=y
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+# CONFIG_EP93XX_SDCS3 is not set
+# CONFIG_EP93XX_SYNC_BOOT is not set
+CONFIG_EP93XX_FPU=y
+# CONFIG_EP93XX_FPU_ACC is not set
+CONFIG_ARCH_EP9302A=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_PHYS_ADDR=0xc0000000
+CONFIG_EP93XX_ZREL_ADDR=0xc0008000
+CONFIG_EP93XX_PARAMS_PHYS=0xc0000100
+CONFIG_EP93XX_INITRD_PHYS=0xc1000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_EP93XX_SPI is not set
+# CONFIG_KEYBOARD_EP93XX_KEYPAD is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS_PROC_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4271=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_RW_DETECT=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+CONFIG_USB_GADGET_EP931X=y
+CONFIG_USB_EP931X=y
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_FILE_STORAGE_TEST=y
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9302_defconfig linux-2.6.8.1/arch/arm/configs/edb9302_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9302_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9302_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,956 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+CONFIG_ARCH_EDB9302=y
+# CONFIG_ARCH_EDB9302A is not set
+# CONFIG_ARCH_EDB9307 is not set
+# CONFIG_ARCH_EDB9307A is not set
+# CONFIG_ARCH_EDB9312 is not set
+# CONFIG_ARCH_EDB9315 is not set
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+CONFIG_EP93XX_FLASH_SIZE_16=y
+# CONFIG_EP93XX_FLASH_SIZE_32 is not set
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+CONFIG_EP93XX_FLASH_WIDTH_16=y
+# CONFIG_EP93XX_FLASH_WIDTH_32 is not set
+# CONFIG_EP93XX_SDCS0 is not set
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+CONFIG_EP93XX_SDCS3=y
+CONFIG_EP93XX_SYNC_BOOT=y
+CONFIG_EP93XX_FPU=y
+# CONFIG_EP93XX_FPU_ACC is not set
+CONFIG_ARCH_EP9302=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x01000000
+CONFIG_EP93XX_PHYS_ADDR=0x00000000
+CONFIG_EP93XX_ZREL_ADDR=0x00008000
+CONFIG_EP93XX_PARAMS_PHYS=0x00000100
+CONFIG_EP93XX_INITRD_PHYS=0x01000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_EP93XX_SPI is not set
+# CONFIG_KEYBOARD_EP93XX_KEYPAD is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+# CONFIG_JFFS_PROC_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4271=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_RW_DETECT=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9307A_defconfig linux-2.6.8.1/arch/arm/configs/edb9307A_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9307A_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9307A_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,997 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+# CONFIG_ARCH_EDB9302 is not set
+# CONFIG_ARCH_EDB9302A is not set
+# CONFIG_ARCH_EDB9307 is not set
+CONFIG_ARCH_EDB9307A=y
+# CONFIG_ARCH_EDB9312 is not set
+# CONFIG_ARCH_EDB9315 is not set
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+CONFIG_EP93XX_FLASH_SIZE_16=y
+# CONFIG_EP93XX_FLASH_SIZE_32 is not set
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+CONFIG_EP93XX_FLASH_WIDTH_16=y
+# CONFIG_EP93XX_FLASH_WIDTH_32 is not set
+CONFIG_EP93XX_SDCS0=y
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+# CONFIG_EP93XX_SDCS3 is not set
+# CONFIG_EP93XX_SYNC_BOOT is not set
+CONFIG_EP93XX_FPU=y
+# CONFIG_EP93XX_FPU_ACC is not set
+CONFIG_ARCH_EP9307A=y
+CONFIG_EP93XX_FRAMEBUFFER=y
+CONFIG_EP93XX_GRAPHICS=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x01000000
+CONFIG_EP93XX_PHYS_ADDR=0xc0000000
+CONFIG_EP93XX_ZREL_ADDR=0xc0008000
+CONFIG_EP93XX_PARAMS_PHYS=0xc0000100
+CONFIG_EP93XX_INITRD_PHYS=0xc1000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_EP93XX_SPI is not set
+# CONFIG_KEYBOARD_EP93XX_KEYPAD is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+CONFIG_TOUCHSCREEN_EP93XX=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_EP93XX_SERIAL_FLASH=y
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS_PROC_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EP93XX=y
+CONFIG_FB_EP93XX_CRT=y
+# CONFIG_FB_EP93XX_LCD is not set
+# CONFIG_FB_EP93XX_NTSC is not set
+# CONFIG_FB_EP93XX_PAL is not set
+# CONFIG_FB_EP93XX_8BPP is not set
+CONFIG_FB_EP93XX_16BPP=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4271=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_RW_DETECT=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+CONFIG_USB_GADGET_EP931X=y
+CONFIG_USB_EP931X=y
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_FILE_STORAGE_TEST=y
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9307_defconfig linux-2.6.8.1/arch/arm/configs/edb9307_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9307_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9307_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,983 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+# CONFIG_ARCH_EDB9302 is not set
+# CONFIG_ARCH_EDB9302A is not set
+CONFIG_ARCH_EDB9307=y
+# CONFIG_ARCH_EDB9307A is not set
+# CONFIG_ARCH_EDB9312 is not set
+# CONFIG_ARCH_EDB9315 is not set
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+# CONFIG_EP93XX_FLASH_SIZE_16 is not set
+CONFIG_EP93XX_FLASH_SIZE_32=y
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+# CONFIG_EP93XX_FLASH_WIDTH_16 is not set
+CONFIG_EP93XX_FLASH_WIDTH_32=y
+# CONFIG_EP93XX_SDCS0 is not set
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+CONFIG_EP93XX_SDCS3=y
+CONFIG_EP93XX_SYNC_BOOT=y
+CONFIG_EP93XX_FPU=y
+# CONFIG_EP93XX_FPU_ACC is not set
+CONFIG_ARCH_EP9307=y
+CONFIG_EP93XX_FRAMEBUFFER=y
+CONFIG_EP93XX_GRAPHICS=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x02000000
+CONFIG_EP93XX_PHYS_ADDR=0x00000000
+CONFIG_EP93XX_ZREL_ADDR=0x00008000
+CONFIG_EP93XX_PARAMS_PHYS=0x00000100
+CONFIG_EP93XX_INITRD_PHYS=0x01000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_EP93XX_SPI is not set
+# CONFIG_KEYBOARD_EP93XX_KEYPAD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+CONFIG_TOUCHSCREEN_EP93XX=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS_PROC_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EP93XX=y
+CONFIG_FB_EP93XX_CRT=y
+# CONFIG_FB_EP93XX_LCD is not set
+# CONFIG_FB_EP93XX_NTSC is not set
+# CONFIG_FB_EP93XX_PAL is not set
+# CONFIG_FB_EP93XX_8BPP is not set
+CONFIG_FB_EP93XX_16BPP=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4228A=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_RW_DETECT=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9312_defconfig linux-2.6.8.1/arch/arm/configs/edb9312_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9312_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9312_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1013 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+# CONFIG_ARCH_EDB9302 is not set
+# CONFIG_ARCH_EDB9302A is not set
+# CONFIG_ARCH_EDB9307 is not set
+# CONFIG_ARCH_EDB9307A is not set
+CONFIG_ARCH_EDB9312=y
+# CONFIG_ARCH_EDB9315 is not set
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+# CONFIG_EP93XX_FLASH_SIZE_16 is not set
+CONFIG_EP93XX_FLASH_SIZE_32=y
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+# CONFIG_EP93XX_FLASH_WIDTH_16 is not set
+CONFIG_EP93XX_FLASH_WIDTH_32=y
+# CONFIG_EP93XX_SDCS0 is not set
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+CONFIG_EP93XX_SDCS3=y
+CONFIG_EP93XX_SYNC_BOOT=y
+CONFIG_EP93XX_FPU=y
+# CONFIG_EP93XX_FPU_ACC is not set
+CONFIG_ARCH_EP9312=y
+CONFIG_EP93XX_FRAMEBUFFER=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x02000000
+CONFIG_EP93XX_PHYS_ADDR=0x00000000
+CONFIG_EP93XX_ZREL_ADDR=0x00008000
+CONFIG_EP93XX_PARAMS_PHYS=0x00000100
+CONFIG_EP93XX_INITRD_PHYS=0x01000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDE_EP93XX=y
+CONFIG_BLK_DEV_IDE_DMA_EP93XX=y
+CONFIG_IDE_ARM=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=640
+CONFIG_INPUT_TSDEV_SCREEN_Y=480
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_EP93XX_SPI is not set
+# CONFIG_KEYBOARD_EP93XX_KEYPAD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+CONFIG_TOUCHSCREEN_EP93XX=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+# CONFIG_JFFS_PROC_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EP93XX=y
+# CONFIG_FB_EP93XX_CRT is not set
+CONFIG_FB_EP93XX_LCD=y
+# CONFIG_FB_EP93XX_NTSC is not set
+# CONFIG_FB_EP93XX_PAL is not set
+# CONFIG_FB_EP93XX_8BPP is not set
+CONFIG_FB_EP93XX_16BPP=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4228A=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_RW_DETECT=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9315A_defconfig linux-2.6.8.1/arch/arm/configs/edb9315A_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9315A_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9315A_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1032 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+# CONFIG_ARCH_EDB9302 is not set
+# CONFIG_ARCH_EDB9302A is not set
+# CONFIG_ARCH_EDB9307 is not set
+# CONFIG_ARCH_EDB9307A is not set
+# CONFIG_ARCH_EDB9312 is not set
+# CONFIG_ARCH_EDB9315 is not set
+CONFIG_ARCH_EDB9315A=y
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+CONFIG_EP93XX_FLASH_SIZE_16=y
+# CONFIG_EP93XX_FLASH_SIZE_32 is not set
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+CONFIG_EP93XX_FLASH_WIDTH_16=y
+# CONFIG_EP93XX_FLASH_WIDTH_32 is not set
+CONFIG_EP93XX_SDCS0=y
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+# CONFIG_EP93XX_SDCS3 is not set
+# CONFIG_EP93XX_SYNC_BOOT is not set
+CONFIG_EP93XX_FPU=y
+# CONFIG_EP93XX_FPU_ACC is not set
+CONFIG_ARCH_EP9315A=y
+CONFIG_EP93XX_FRAMEBUFFER=y
+CONFIG_EP93XX_GRAPHICS=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x01000000
+CONFIG_EP93XX_PHYS_ADDR=0xc0000000
+CONFIG_EP93XX_ZREL_ADDR=0xc0008000
+CONFIG_EP93XX_PARAMS_PHYS=0xc0000100
+CONFIG_EP93XX_INITRD_PHYS=0xc1000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDE_EP93XX=y
+CONFIG_BLK_DEV_IDE_DMA_EP93XX=y
+CONFIG_IDE_ARM=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=640
+CONFIG_INPUT_TSDEV_SCREEN_Y=480
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_EP93XX_SPI is not set
+# CONFIG_KEYBOARD_EP93XX_KEYPAD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+CONFIG_TOUCHSCREEN_EP93XX=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS_PROC_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EP93XX=y
+CONFIG_FB_EP93XX_CRT=y
+# CONFIG_FB_EP93XX_LCD is not set
+# CONFIG_FB_EP93XX_NTSC is not set
+# CONFIG_FB_EP93XX_PAL is not set
+# CONFIG_FB_EP93XX_8BPP is not set
+CONFIG_FB_EP93XX_16BPP=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4271=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_RW_DETECT=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+CONFIG_USB_GADGET_EP931X=y
+CONFIG_USB_EP931X=y
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_FILE_STORAGE_TEST=y
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/edb9315_defconfig linux-2.6.8.1/arch/arm/configs/edb9315_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/edb9315_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/edb9315_defconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1075 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+# CONFIG_ARCH_EDB9302 is not set
+# CONFIG_ARCH_EDB9302A is not set
+# CONFIG_ARCH_EDB9307 is not set
+# CONFIG_ARCH_EDB9307A is not set
+# CONFIG_ARCH_EDB9312 is not set
+CONFIG_ARCH_EDB9315=y
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+# CONFIG_EP93XX_FLASH_SIZE_16 is not set
+CONFIG_EP93XX_FLASH_SIZE_32=y
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+# CONFIG_EP93XX_FLASH_WIDTH_16 is not set
+CONFIG_EP93XX_FLASH_WIDTH_32=y
+# CONFIG_EP93XX_SDCS0 is not set
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+CONFIG_EP93XX_SDCS3=y
+CONFIG_EP93XX_SYNC_BOOT=y
+CONFIG_EP93XX_FPU=y
+# CONFIG_EP93XX_FPU_ACC is not set
+CONFIG_ARCH_EP9315=y
+CONFIG_EP93XX_FRAMEBUFFER=y
+CONFIG_EP93XX_GRAPHICS=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x02000000
+CONFIG_EP93XX_PHYS_ADDR=0x00000000
+CONFIG_EP93XX_ZREL_ADDR=0x00008000
+CONFIG_EP93XX_PARAMS_PHYS=0x00000100
+CONFIG_EP93XX_INITRD_PHYS=0x01000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_TCIC is not set
+CONFIG_PCMCIA_EP93XX=y
+CONFIG_PCMCIA_PROBE=y
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+# CONFIG_MTD_PCMCIA is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_PCMCIA_WAVELAN is not set
+# CONFIG_PCMCIA_NETWAVE is not set
+
+#
+# Wireless 802.11 Frequency Hopping cards support
+#
+# CONFIG_PCMCIA_RAYCS is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+CONFIG_HERMES=y
+# CONFIG_ATMEL is not set
+
+#
+# Wireless 802.11b Pcmcia/Cardbus cards support
+#
+CONFIG_PCMCIA_HERMES=y
+# CONFIG_AIRO_CS is not set
+# CONFIG_PCMCIA_WL3501 is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=y
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=y
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDE_EP93XX=y
+CONFIG_BLK_DEV_IDE_DMA_EP93XX=y
+CONFIG_IDE_ARM=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=640
+CONFIG_INPUT_TSDEV_SCREEN_Y=480
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_EP93XX_SPI is not set
+# CONFIG_KEYBOARD_EP93XX_KEYPAD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+CONFIG_TOUCHSCREEN_EP93XX=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS_PROC_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EP93XX=y
+# CONFIG_FB_EP93XX_CRT is not set
+CONFIG_FB_EP93XX_LCD=y
+# CONFIG_FB_EP93XX_NTSC is not set
+# CONFIG_FB_EP93XX_PAL is not set
+# CONFIG_FB_EP93XX_8BPP is not set
+CONFIG_FB_EP93XX_16BPP=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+CONFIG_CODEC_CS4228A=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# PCMCIA devices
+#
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_RW_DETECT=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/configs/x88_defconfig linux-2.6.8.1/arch/arm/configs/x88_defconfig
--- linux-2.6.8.1-orig/arch/arm/configs/x88_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/configs/x88_defconfig	2007-01-24 12:21:38.000000000 +0900
@@ -0,0 +1,978 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+CONFIG_ARCH_EP93XX=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
+
+#
+# Cirrus Logic EP93xx options
+#
+# CONFIG_ARCH_EDB9301 is not set
+# CONFIG_ARCH_EDB9302 is not set
+# CONFIG_ARCH_EDB9302A is not set
+CONFIG_ARCH_EDB9307=y
+# CONFIG_ARCH_EDB9307A is not set
+# CONFIG_ARCH_EDB9312 is not set
+# CONFIG_ARCH_EDB9315 is not set
+# CONFIG_ARCH_EDB9315A is not set
+# CONFIG_EP93XX_CS0 is not set
+# CONFIG_EP93XX_CS1 is not set
+# CONFIG_EP93XX_CS2 is not set
+# CONFIG_EP93XX_CS3 is not set
+CONFIG_EP93XX_CS6=y
+# CONFIG_EP93XX_CS7 is not set
+
+#
+# FLASH chip options
+#
+# CONFIG_EP93XX_FLASH_SIZE_2 is not set
+# CONFIG_EP93XX_FLASH_SIZE_4 is not set
+# CONFIG_EP93XX_FLASH_SIZE_8 is not set
+CONFIG_EP93XX_FLASH_SIZE_16=y
+# CONFIG_EP93XX_FLASH_SIZE_32 is not set
+# CONFIG_EP93XX_FLASH_SIZE_64 is not set
+CONFIG_EP93XX_FLASH_WIDTH_16=y
+# CONFIG_EP93XX_FLASH_WIDTH_32 is not set
+CONFIG_EP93XX_SDCS0=y
+# CONFIG_EP93XX_SDCS1 is not set
+# CONFIG_EP93XX_SDCS2 is not set
+# CONFIG_EP93XX_SDCS3 is not set
+# CONFIG_EP93XX_SYNC_BOOT is not set
+CONFIG_EP93XX_FPU=y
+CONFIG_EP93XX_FPU_ACC=y
+CONFIG_ARCH_EP9307=y
+CONFIG_EP93XX_FRAMEBUFFER=y
+CONFIG_EP93XX_GRAPHICS=y
+CONFIG_EP93XX_FLASH_BASE=0x60000000
+CONFIG_EP93XX_FLASH_SIZE=0x02000000
+CONFIG_EP93XX_PHYS_ADDR=0xc0000000
+CONFIG_EP93XX_ZREL_ADDR=0xc0008000
+CONFIG_EP93XX_PARAMS_PHYS=0xc0000100
+CONFIG_EP93XX_INITRD_PHYS=0xc1000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+
+#
+# General setup
+#
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_PM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="/root=/dev/ram"
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+CONFIG_MTD_ROM=y
+CONFIG_MTD_ABSENT=y
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+CONFIG_MTD_EDB93XX=y
+# CONFIG_MTD_IMPA7 is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_EP93XX_ETHERNET=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_EP93XX=y
+CONFIG_SERIAL_EP93XX_CONSOLE=y
+# CONFIG_EP93XX_SERIAL_FLASH is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_EP93XX_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_EP93XX=y
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_RTC_ISL1208 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS_PROC_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_KOI8_R=y
+CONFIG_NLS_KOI8_U=y
+CONFIG_NLS_UTF8=y
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EP93XX=y
+# CONFIG_FB_EP93XX_CRT is not set
+# CONFIG_FB_EP93XX_LCD is not set
+# CONFIG_FB_EP93XX_NTSC is not set
+# CONFIG_FB_EP93XX_PAL is not set
+CONFIG_FB_EP93XX_KENWOOD_LCD=y
+# CONFIG_FB_EP93XX_8BPP is not set
+CONFIG_FB_EP93XX_16BPP=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Bootsplash configuration
+#
+CONFIG_BOOTSPLASH=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_EP93XX_IIS=y
+# CONFIG_CODEC_CS4228A is not set
+CONFIG_CODEC_KENWOOD=y
+# CONFIG_SND_EP93XX_AC97 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811HS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -burN linux-2.6.8.1-orig/arch/arm/kernel/calls.S linux-2.6.8.1/arch/arm/kernel/calls.S
--- linux-2.6.8.1-orig/arch/arm/kernel/calls.S	2004-08-14 19:56:24.000000000 +0900
+++ linux-2.6.8.1/arch/arm/kernel/calls.S	2007-01-24 13:03:31.000000000 +0900
@@ -288,6 +288,12 @@
 		.long	sys_pciconfig_iobase
 		.long	sys_pciconfig_read
 		.long	sys_pciconfig_write
+/* 274 */	.long	sys_mq_open
+		.long	sys_mq_unlink
+		.long	sys_mq_timedsend
+		.long	sys_mq_timedreceive
+		.long	sys_mq_notify      
+		.long	sys_mq_getsetattr
 __syscall_end:
 
 		.rept	NR_syscalls - (__syscall_end - __syscall_start) / 4
diff -burN linux-2.6.8.1-orig/arch/arm/kernel/entry-armv.S linux-2.6.8.1/arch/arm/kernel/entry-armv.S
--- linux-2.6.8.1-orig/arch/arm/kernel/entry-armv.S	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/arch/arm/kernel/entry-armv.S	2007-01-24 13:03:31.000000000 +0900
@@ -884,6 +884,39 @@
                .macro  irq_prio_table
                .endm
 
+#elif defined(CONFIG_ARCH_EP93XX)
+
+		.macro  disable_fiq
+		.endm
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\irqstat, =VIC0IRQSTATUS
+		ldr	\irqstat, [\irqstat, #0]
+
+		mov	\irqnr, #0
+
+1001:		tst	\irqstat, #1
+		bne	1003f
+		add	\irqnr, \irqnr, #1
+		mov	\irqstat, \irqstat, lsr #1
+		cmp	\irqnr, #32
+		bcc	1001b
+
+		ldr	\irqstat, =VIC1IRQSTATUS
+		ldr	\irqstat, [\irqstat, #0]
+
+1002:		tst	\irqstat, #1
+		bne	1003f
+		add	\irqnr, \irqnr, #1
+		mov	\irqstat, \irqstat, lsr #1
+		cmp	\irqnr, #64
+		bcc	1002b
+1003:
+		.endm
+
+		.macro  irq_prio_table
+		.endm
+
 #else
 #error Unknown architecture
 #endif
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/Kconfig linux-2.6.8.1/arch/arm/mach-ep93xx/Kconfig
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,318 @@
+if ARCH_EP93XX
+
+menu "Cirrus Logic EP93xx options"
+
+choice
+	prompt "Board type"
+	default ARCH_EDB9315
+	---help---
+	  The type of EP93xx board on which this kernel is to be run.
+
+config ARCH_EDB9301
+	bool "EDB9301"
+	select ARCH_EP9301
+	---help---
+	  This is an evaluation board from Cirrus Logic for the EP9301
+	  processor.  The board includes two serial ports, Ethernet, audio, and
+	  expansion headers.  It comes with 32MB SDRAM and 16MB FLASH ROM.
+
+config ARCH_EDB9302
+	bool "EDB9302"
+	select ARCH_EP9302
+	---help---
+	  This is an evaluation board from Cirrus Logic for the EP9302
+	  processor.  The board includes two serial ports, Ethernet, audio,
+	  USB, and expansion headers.  It comes with 32MB SDRAM and 16MB FLASH
+	  ROM.
+
+config ARCH_EDB9302A
+	bool "EDB9302A"
+	select ARCH_EP9302A
+	---help---
+	  This is an evaluation board from Cirrus Logic for the EP9302A
+	  processor.  The board includes two serial ports, Ethernet, audio,
+	  USB, and expansion headers.  It comes with 32MB SDRAM and 16MB FLASH
+	  ROM.
+
+config ARCH_EDB9307
+	bool "EDB9307"
+	select ARCH_EP9307
+	---help---
+	  This is an evaluation board from Cirrus Logic for the EP9307
+	  processor.  The board includes two serial ports, Ethernet, audio,
+	  USB, IrDA, VGA/TV, consumer IR, and expansion headers.  It comes with
+	  64MB SDRAM and 32MB FLASH ROM.
+
+config ARCH_EDB9307A
+        bool "EDB9307A"
+        select ARCH_EP9307A
+        ---help---
+          This is an evaluation board from Cirrus Logic for the EP9307A
+	  Low cost processor.  The board includes one serial port, Ethernet, audio,
+          USB Client/Host, IrDA, VGA/TV, LCD, consumer IR, and expansion headers.  It comes with
+          64MB SDRAM and 16MB FLASH ROM.
+
+config ARCH_EDB9312
+	bool "EDB9312"
+	select ARCH_EP9312
+	---help---
+	  This is an evaluation board from Cirrus Logic for the EP9312
+	  processor.  The board includes two serial ports, Ethernet, audio,
+	  USB, IrDA, VGA/LCD/TV, IDE, consumer IR, and expansion headers.  It
+	  comes with 64MB SDRAM and 32MB FLASH ROM.
+
+config ARCH_EDB9315
+	bool "EDB9315"
+	select ARCH_EP9315
+	---help---
+	  This is an evaluation board from Cirrus Logic for the EP9315
+	  processor.  The board includes two serial ports, Ethernet, audio,
+	  USB, IrDA, VGA/LCD/TV, IDE, PCMCIA, consumer IR, and expansion
+	  headers.  It comes with 64MB SDRAM and 32MB FLASH ROM.
+
+config ARCH_EDB9315A
+        bool "EDB9315A"
+        select ARCH_EP9315A
+        ---help---
+          This is an evaluation board from Cirrus Logic for the EP9315A
+          processor.  The board includes two serial ports, Ethernet, audio,
+          USB, IrDA, VGA/LCD/TV, IDE, consumer IR, and expansion
+          headers.  It comes with 64MB SDRAM and 16MB FLASH ROM.
+
+endchoice
+
+choice
+	prompt "FLASH chip select"
+	default EP93XX_CS6
+	---help---
+	  The SMC chip select used to access the FLASH on the board.  This must
+	  match the hardware setting or the MTD driver will not be able to
+	  access the on-board FLASH.  Leave this at CSn6 if you are not sure.
+
+config EP93XX_CS0
+	bool "CSn0"
+	---help---
+	  FLASH is connected to the CSn0 pin of the EP93xx.
+
+config EP93XX_CS1
+	bool "CSn1"
+	---help---
+	  FLASH is connected to the CSn1 pin of the EP93xx.
+
+config EP93XX_CS2
+	bool "CSn2"
+	---help---
+	  FLASH is connected to the CSn2 pin of the EP93xx.
+
+config EP93XX_CS3
+	bool "CSn3"
+	---help---
+	  FLASH is connected to the CSn3 pin of the EP93xx.
+
+config EP93XX_CS6
+	bool "CSn6"
+	---help---
+	  FLASH is connected to the CSn6 pin of the EP93xx.
+
+config EP93XX_CS7
+	bool "CSn7"
+	---help---
+	  FLASH is connected to the CSn7 pin of the EP93xx.
+
+endchoice
+
+menu "FLASH chip options"
+	
+choice
+	prompt "FLASH size"
+	default EP93XX_FLASH_SIZE_16
+
+config EP93XX_FLASH_SIZE_2
+	bool "2MB"
+
+config EP93XX_FLASH_SIZE_4
+	bool "4MB"
+
+config EP93XX_FLASH_SIZE_8
+	bool "8MB"
+
+config EP93XX_FLASH_SIZE_16
+	bool "16MB"
+
+config EP93XX_FLASH_SIZE_32
+	bool "32MB"
+
+config EP93XX_FLASH_SIZE_64
+	bool "64MB"
+endchoice
+
+choice
+	prompt "FLASH width"
+	default EP93XX_FLASH_WIDTH_16
+
+config EP93XX_FLASH_WIDTH_16
+	bool "16bit"
+
+config EP93XX_FLASH_WIDTH_32
+	bool "32bit"
+endchoice
+endmenu
+
+choice
+	prompt "SDRAM chip select"
+	default EP93XX_SDCS3
+	---help---
+	  The SDRAM chip select used to access the SDRAM on the board.  This
+	  must match the hardware setting or the kernel will not run.  Leave
+	  this at SDCSn3 if you are not sure.
+
+config EP93XX_SDCS0
+	bool "SDCSn0"
+	---help---
+	  SDRAM is connected to the SDCDn0 pin of the EP93xx.
+
+config EP93XX_SDCS1
+	bool "SDCSn1"
+	---help---
+	  SDRAM is connected to the SDCDn1 pin of the EP93xx.
+
+config EP93XX_SDCS2
+	bool "SDCSn2"
+	---help---
+	  SDRAM is connected to the SDCDn2 pin of the EP93xx.
+
+config EP93XX_SDCS3
+	bool "SDCSn3"
+	---help---
+	  SDRAM is connected to the SDCDn3 pin of the EP93xx.
+
+endchoice
+
+config EP93XX_SYNC_BOOT
+	bool "Synchronous boot mode"
+	default y
+	---help---
+	  The boot mode of the board.  For internal boot mode, this really
+	  amounts to the physical addresses associated with CSn0 and SDCSn3;
+	  in synchronous boot mode CSn0 is at 0xf000.0000 and SDCSn3 is at
+	  0x0000.0000, and in asynchonous boot mode they are swapped.  For
+	  external boot mode, however, this same mapping applies but also
+	  determines what is executed since the ARM will start executing at
+	  physical address 0x0000.0000.
+
+	  This must match the hardware setting of the kernel will not run.
+	  Leave this set if you are not sure.
+
+
+config EP93XX_FPU
+	bool "Crunch FPU Support"
+	depends on ARCH_EP9302 || ARCH_EP9302A || ARCH_EP9307 || ARCH_EP9307A || ARCH_EP9312 || ARCH_EP9315 || ARCH_EP9315A || ARCH_EP9315A
+	---help---
+	Enable the Crunch floating point coprocessor and
+	let Linux save/restore the context of the Crunch FPU. 
+
+config EP93XX_FPU_ACC
+	bool "Save Crunch FPU Accumulators"
+	depends on EP93XX_FPU
+	---help---
+	Linux can save/store the Crunch accumulator registers.
+	This is only necessary if you wrote assembly code which uses
+	these accumulators and runs in more than one task/thread.
+	The crunch enabled version of GCC-3.4.3 does not generate code
+	which uses the accumulators.
+
+
+config ARCH_EP9301
+	bool
+
+config ARCH_EP9302
+	bool
+
+config ARCH_EP9302A
+	bool
+
+config ARCH_EP9307
+	bool
+	select EP93XX_FRAMEBUFFER
+	select EP93XX_GRAPHICS
+
+config ARCH_EP9307A
+	bool
+	select EP93XX_FRAMEBUFFER
+	select EP93XX_GRAPHICS
+	
+config ARCH_EP9312
+	bool
+	select EP93XX_FRAMEBUFFER
+
+config ARCH_EP9315
+	bool
+	select EP93XX_FRAMEBUFFER
+	select EP93XX_GRAPHICS
+
+config ARCH_EP9315A
+        bool
+        select EP93XX_FRAMEBUFFER
+        select EP93XX_GRAPHICS
+
+config EP93XX_FRAMEBUFFER
+	bool
+
+config EP93XX_GRAPHICS
+	bool
+
+config EP93XX_FLASH_BASE
+	hex
+	default 0x00000000 if EP93XX_CS0 && ! EP93XX_SYNC_BOOT
+	default 0x10000000 if EP93XX_CS1
+	default 0x20000000 if EP93XX_CS2
+	default 0x30000000 if EP93XX_CS3
+	default 0x60000000 if EP93XX_CS6
+	default 0x70000000 if EP93XX_CS7
+	default 0xf0000000 if EP93XX_CS0 && EP93XX_SYNC_BOOT
+
+config EP93XX_FLASH_SIZE
+	hex
+	default 0x01000000 if ARCH_EDB9301
+	default 0x01000000 if ARCH_EDB9302
+	default 0x02000000 if ARCH_EDB9307
+	default 0x02000000 if ARCH_EDB9312
+	default 0x02000000 if ARCH_EDB9315
+	default 0x01000000 if ARCH_EDB9315A
+	default 0x01000000 if ARCH_EDB9307A
+
+config EP93XX_PHYS_ADDR
+	hex
+	default 0x00000000 if EP93XX_SDCS3 && EP93XX_SYNC_BOOT
+	default 0xc0000000 if EP93XX_SDCS0
+	default 0xd0000000 if EP93XX_SDCS1
+	default 0xe0000000 if EP93XX_SDCS2
+	default 0xf0000000 if EP93XX_SDCS3 && ! EP93XX_SYNC_BOOT
+
+config EP93XX_ZREL_ADDR
+	hex
+	default 0x00008000 if EP93XX_SDCS3 && EP93XX_SYNC_BOOT
+	default 0xc0008000 if EP93XX_SDCS0
+	default 0xd0008000 if EP93XX_SDCS1
+	default 0xe0008000 if EP93XX_SDCS2
+	default 0xf0008000 if EP93XX_SDCS3 && ! EP93XX_SYNC_BOOT
+
+config EP93XX_PARAMS_PHYS
+	hex
+	default 0x00000100 if EP93XX_SDCS3 && EP93XX_SYNC_BOOT
+	default 0xc0000100 if EP93XX_SDCS0
+	default 0xd0000100 if EP93XX_SDCS1
+	default 0xe0000100 if EP93XX_SDCS2
+	default 0xf0000100 if EP93XX_SDCS3 && ! EP93XX_SYNC_BOOT
+
+config EP93XX_INITRD_PHYS
+	hex
+	default 0x01000000 if EP93XX_SDCS3 && EP93XX_SYNC_BOOT
+	default 0xc1000000 if EP93XX_SDCS0
+	default 0xd1000000 if EP93XX_SDCS1
+	default 0xe1000000 if EP93XX_SDCS2
+	default 0xf1000000 if EP93XX_SDCS3 && ! EP93XX_SYNC_BOOT
+
+endmenu
+
+endif
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/Makefile linux-2.6.8.1/arch/arm/mach-ep93xx/Makefile
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,14 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y			:= arch.o irq.o mm.o time.o ssp.o dma_ep93xx.o pcmcia_io.o
+obj-m			:=
+obj-n			:=
+obj-			:=
+
+obj-$(CONFIG_EP93XX_FPU) += crunch.o
+obj-$(CONFIG_KGDB_SERIAL) += kgdb-serial.o
+
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/arch.c linux-2.6.8.1/arch/arm/mach-ep93xx/arch.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/arch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/arch.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,533 @@
+/*
+ *  linux/arch/arm/mach-ep93xx/arch.c
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ * (c) Copyright 2002-2003 Cirrus Logic, Inc., Austin, Tx 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/utsname.h>
+#include <linux/mtd/physmap.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/memory.h>
+#include <asm/arch/platform.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/arch/ssp.h>
+#include <asm/arch/crunch.h>
+
+extern void crunch_init(void);
+int crunch_is_enabled=0;
+
+extern void ep93xx_map_io(void);
+extern void ep93xx_init_irq(void);
+extern void ep93xx_init_time(void);
+
+/*
+* We have added a CONFIG to determine what the size of the
+* Flash Chip we are using. From 2MB to 64MB for now.
+* No more HARDCODED VALUES
+*/
+
+#ifdef CONFIG_EP93XX_FLASH_SIZE_2
+#undef CONFIG_EP93XX_FLASH_SIZE
+#define CONFIG_EP93XX_FLASH_SIZE 0x200000
+#endif
+
+#ifdef CONFIG_EP93XX_FLASH_SIZE_4
+#undef CONFIG_EP93XX_FLASH_SIZE
+#define CONFIG_EP93XX_FLASH_SIZE 0x400000
+#endif
+
+#ifdef CONFIG_EP93XX_FLASH_SIZE_8
+#undef CONFIG_EP93XX_FLASH_SIZE
+#define CONFIG_EP93XX_FLASH_SIZE 0x800000
+#endif
+
+#ifdef CONFIG_EP93XX_FLASH_SIZE_16
+#undef CONFIG_EP93XX_FLASH_SIZE
+#define CONFIG_EP93XX_FLASH_SIZE 0x01000000
+#endif
+
+#ifdef CONFIG_EP93XX_FLASH_SIZE_32
+#undef CONFIG_EP93XX_FLASH_SIZE
+#define CONFIG_EP93XX_FLASH_SIZE 0x02000000
+#endif
+
+#ifdef CONFIG_EP93XX_FLASH_SIZE_64
+#undef CONFIG_EP93XX_FLASH_SIZE
+#define CONFIG_EP93XX_FLASH_SIZE 0x04000000
+#endif
+
+/*
+* We added a CONFIG to determine what the Width is for the Flash Chip.
+* is it a 16bit or 32bit width.
+* No more HARDCODED VALUES
+*/
+
+#ifdef CONFIG_EP93XX_FLASH_WIDTH_16
+#undef CONFIG_EP93XX_FLASH_WIDTH
+#define CONFIG_EP93XX_FLASH_WIDTH 2
+#endif
+
+#ifdef CONFIG_EP93XX_FLASH_WIDTH_32
+#undef CONFIG_EP93XX_FLASH_WIDTH
+#define CONFIG_EP93XX_FLASH_WIDTH 4
+#endif
+
+static struct flash_platform_data ep93xx_flash_data = {
+	.map_name	= "cfi_probe",
+	.width		= CONFIG_EP93XX_FLASH_WIDTH,
+};
+
+static struct resource ep93xx_flash_resource = {
+	.start		= CONFIG_EP93XX_FLASH_BASE,
+	.end		= CONFIG_EP93XX_FLASH_BASE + CONFIG_EP93XX_FLASH_SIZE - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device ep93xx_flash_device = {
+	.name		= "edb93xxflash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &ep93xx_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &ep93xx_flash_resource,
+};
+
+static struct resource ep93xx_ethernet_resources[] = {
+	[0] = {
+		.start		= HwRegToPhys(MAC_BASE),
+		.end		= HwRegToPhys(MAC_BASE) + 0xffff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_MAC,
+		.end		= IRQ_MAC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ep93xx_ethernet_device = {
+	.name		= "ep93xxethernet",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= ep93xx_ethernet_resources,
+};
+
+static struct resource ep93xx_raster_resources[] = {
+	[0] = {
+		.start		= HwRegToPhys(RASTER_BASE),
+#ifdef CONFIG_EP93XX_GRAPHICS
+		.end		= HwRegToPhys(RASTER_BASE) + 0x1ffff,
+#else
+		.end		= HwRegToPhys(RASTER_BASE) + 0xffff,
+#endif
+		.flags		= IORESOURCE_MEM,
+	},
+#ifdef CONFIG_EP93XX_GRAPHICS
+	[1] = {
+		.start		= IRQ_GRAPHICS,
+		.end		= IRQ_GRAPHICS,
+		.flags		= IORESOURCE_IRQ,
+	},
+#endif
+};
+
+static struct platform_device ep93xx_raster_device = {
+	.name		= "ep93xxfb",
+	.id		= 0,
+#ifdef CONFIG_EP93XX_GRAPHICS
+	.num_resources	= 2,
+#else
+	.num_resources	= 1,
+#endif
+	.resource	= ep93xx_raster_resources,
+};
+
+static struct resource ep93xx_usb_resources[] = {
+	[0] = {
+		.start		= HwRegToPhys(USB_BASE),
+		.end		= HwRegToPhys(USB_BASE) + 0x8C,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_USH,
+		.end		= IRQ_USH,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ep93xx_usbhost_dma_mask = 0xffffffffUL;
+
+static struct platform_device ep93xx_usb_device = {
+	.name		= "ep93xxusb",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= ep93xx_usb_resources,
+	.dev = {
+		.dma_mask               = &ep93xx_usbhost_dma_mask,
+		.coherent_dma_mask      = 0xffffffffUL,
+	},
+};
+
+static struct resource ep93xx_i2s_resources[] = {
+	[0] = {
+		.start		= HwRegToPhys(I2S_BASE),
+		.end		= HwRegToPhys(I2S_BASE), + 0x6C,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= NO_IRQ,
+		.end		= NO_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ep93xx_i2s_dma_mask = 0xffffffffUL;
+
+static struct platform_device ep93xx_i2s_device = {
+	.name		= "ep93xxi2s",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= ep93xx_i2s_resources,
+	.dev = {
+		.dma_mask               = &ep93xx_i2s_dma_mask,
+		.coherent_dma_mask      = 0xffffffffUL,
+	},
+};
+
+static struct resource ep93xx_ac97_resources[] = {
+	[0] = {
+		.start		= HwRegToPhys(AC97_BASE),
+		.end		= HwRegToPhys(AC97_BASE), + 0x6C,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= NO_IRQ,
+		.end		= NO_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ep93xx_ac97_dma_mask = 0xffffffffUL;
+
+static struct platform_device ep93xx_ac97_device = {
+	.name		= "ep93xx-ac97",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= ep93xx_ac97_resources,
+	.dev = {
+		.dma_mask               = &ep93xx_ac97_dma_mask,
+		.coherent_dma_mask      = 0xffffffffUL,
+	},
+};
+
+static struct resource ep93xx_gadget_resources[] = {
+	[0] = {
+		.start		= 0x70000000,
+		.end		= 0x70000000 + 0xff,
+		.flags		= IORESOURCE_MEM,
+	},
+#if (defined(CONFIG_ARCH_EP9315A) || defined(CONFIG_ARCH_EP9307A) || defined(CONFIG_ARCH_EP9302A))
+	[1] = {
+		.start		= IRQ_EXT0,
+		.end		= IRQ_EXT0,
+		.flags		= IORESOURCE_IRQ,
+	},
+#else
+        [1] = {
+                .start          = IRQ_EXT1,
+                .end            = IRQ_EXT1,
+                .flags          = IORESOURCE_IRQ,
+        },
+
+#endif
+
+};
+
+
+static u64 ep93xx_gadget_dma_mask = 0xffffffffUL;
+
+static struct platform_device ep93xx_gadget_device = {
+	.name		= "ep93xx-udc",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= ep93xx_gadget_resources,
+	.dev = {
+		.dma_mask               = &ep93xx_gadget_dma_mask,
+		.coherent_dma_mask      = 0xffffffffUL,
+	},
+};
+
+
+static struct resource ep93xx_pcmcia_resources[] = {
+        [0] = {
+                .start          = PCMCIA_BASE_PHYS,
+                .end            = PCMCIA_BASE_PHYS, + PCMCIA_SIZE,
+                .flags          = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start          = IRQ_GPIO0,
+                .end            = IRQ_GPIO7,
+                .flags          = IORESOURCE_IRQ,
+        },
+};
+                                                                                                                             
+static u64 ep93xx_pcmcia_dma_mask = 0xffffffffUL;
+                                                                                                                             
+static struct platform_device ep93xx_pcmcia_device = {
+        .name           = "ep93xx-pcmcia",
+        .id             = 0,
+        .num_resources  = 2,
+        .resource       = ep93xx_pcmcia_resources,
+        .dev = {
+                .dma_mask               = &ep93xx_pcmcia_dma_mask,
+                .coherent_dma_mask      = 0xffffffffUL,
+        },
+};
+
+
+
+static struct platform_device *edb93xx_devices[] __initdata = {
+	&ep93xx_flash_device,
+	&ep93xx_ethernet_device,
+	&ep93xx_raster_device,
+	&ep93xx_usb_device,
+	&ep93xx_i2s_device,
+	&ep93xx_ac97_device,
+	&ep93xx_gadget_device,
+	&ep93xx_pcmcia_device,
+};
+
+
+/*
+ * Setup proper timing for flash memory
+ */
+static void setup_sram_bus_timing(void)
+{
+    int val;
+    
+#ifdef CONFIG_EP93XX_CS0
+#define SMC_CONTROL SMCBCR0
+#endif
+#ifdef CONFIG_EP93XX_CS1
+#define SMC_CONTROL SMCBCR1
+#endif
+#ifdef CONFIG_EP93XX_CS2
+#define SMC_CONTROL SMCBCR2
+#endif
+#ifdef CONFIG_EP93XX_CS3
+#define SMC_CONTROL SMCBCR3
+#endif
+#ifdef CONFIG_EP93XX_CS6
+#define SMC_CONTROL SMCBCR6
+#endif
+#ifdef CONFIG_EP93XX_CS7
+#define SMC_CONTROL SMCBCR7
+#endif
+
+#define WST1_MASK	(0x01f << 5)
+#define WST2_MASK	(0x01f << 11)
+#define IDCY_MASK	(0x0f << 0)
+
+#define WST1_VAL	(21<<5)
+#define WST2_VAL	(5<<11)
+#define IDCY_VAL	(5)
+
+	val=inl(SMC_CONTROL);	
+	val &= ~(WST1_MASK | WST2_MASK | IDCY_MASK);
+	val |= ( WST1_VAL | WST2_VAL | IDCY_VAL );
+	outl(val,SMC_CONTROL);
+}
+
+
+static void __init
+ep93xx_init(void)
+{
+	unsigned int uiTemp;
+	int SSP_Handle;
+
+	/*
+	 * Setup proper timing for flash memory
+	 */
+	setup_sram_bus_timing();
+
+	/*
+	 * Add the platform devices.
+	 */
+	platform_add_devices(edb93xx_devices, ARRAY_SIZE(edb93xx_devices));
+
+	/*
+	 * Enable halt mode.
+	 */
+	uiTemp = inl(SYSCON_DEVCFG) | SYSCON_DEVCFG_SHena;
+	SysconSetLocked(SYSCON_DEVCFG, uiTemp);
+
+	/*
+	 * Set the bus priority.
+	 */
+	outl(BMAR_PRIORD_02, SYSCON_BMAR);
+
+	/*
+	 * Get the hostname from the SPI FLASH if it has been programmed.
+	 */
+	SSP_Handle = SSPDriver->Open(SERIAL_FLASH, 0);
+	if(SSP_Handle != -1) {
+		SSPDriver->Read( SSP_Handle, 0x1000, &uiTemp );
+		if (uiTemp == 0x43414d45) {
+			SSPDriver->Read( SSP_Handle, 0x1010, &uiTemp );
+			system_utsname.nodename[0] = uiTemp & 255;
+			system_utsname.nodename[1] = (uiTemp >> 8) & 255;
+			system_utsname.nodename[2] = (uiTemp >> 16) & 255;
+			system_utsname.nodename[3] = uiTemp >> 24;
+			SSPDriver->Read( SSP_Handle, 0x1014, &uiTemp );
+			system_utsname.nodename[4] = uiTemp & 255;
+			system_utsname.nodename[5] = (uiTemp >> 8) & 255;
+			system_utsname.nodename[6] = (uiTemp >> 16) & 255;
+			system_utsname.nodename[7] = uiTemp >> 24;
+			SSPDriver->Read( SSP_Handle, 0x1018, &uiTemp );
+			system_utsname.nodename[8] = uiTemp & 255;
+			system_utsname.nodename[9] = (uiTemp >> 8) & 255;
+			system_utsname.nodename[10] = (uiTemp >> 16) & 255;
+			system_utsname.nodename[11] = uiTemp >> 24;
+			SSPDriver->Read( SSP_Handle, 0x101c, &uiTemp );
+			system_utsname.nodename[12] = uiTemp & 255;
+			system_utsname.nodename[13] = (uiTemp >> 8) & 255;
+			system_utsname.nodename[14] = (uiTemp >> 16) & 255;
+			system_utsname.nodename[15] = uiTemp >> 24;
+			system_utsname.nodename[16] = 0;
+		}
+		SSPDriver->Close( SSP_Handle );
+	}
+
+#ifdef CONFIG_EP93XX_FPU
+    crunch_enable();
+    crunch_init();
+    crunch_is_enabled=1;
+#endif
+
+}
+
+/* Machine Descriptor created by macros in asm-arm/mach/arch.h
+    bootmem: phys ram base, phys io base, virt io base
+    bootpara: phys param base  */
+
+#ifdef CONFIG_ARCH_EDB9301
+MACHINE_START(EDB9301, "edb9301")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
+
+#ifdef CONFIG_ARCH_EDB9302
+MACHINE_START(EDB9302, "edb9302")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
+
+#ifdef CONFIG_ARCH_EDB9302A
+MACHINE_START(EDB9302A, "edb9302A")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
+
+#ifdef CONFIG_ARCH_EDB9307
+MACHINE_START(EDB9307, "edb9307")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
+
+#ifdef CONFIG_ARCH_EDB9307A
+MACHINE_START(EDB9307A, "edb9307A")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
+
+#ifdef CONFIG_ARCH_EDB9312
+MACHINE_START(EDB9312, "edb9312")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
+
+#ifdef CONFIG_ARCH_EDB9315
+MACHINE_START(EDB9315, "edb9315")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
+
+#ifdef CONFIG_ARCH_EDB9315A
+MACHINE_START(EDB9315A, "edb9315A")
+    MAINTAINER("Cirrus Logic")
+    BOOT_MEM( CONFIG_EP93XX_PHYS_ADDR, 0x80000000, 0xff000000 )
+    BOOT_PARAMS( CONFIG_EP93XX_PARAMS_PHYS )
+    MAPIO(ep93xx_map_io)
+    INITIRQ(ep93xx_init_irq)
+    INITTIME(ep93xx_init_time)
+    INIT_MACHINE(ep93xx_init)
+MACHINE_END
+#endif
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/crunch.c linux-2.6.8.1/arch/arm/mach-ep93xx/crunch.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/crunch.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/crunch.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,342 @@
+/*
+ *	Cirrus MaverickCrunch support
+ *
+ *	Copyright (c) 2003 Petko Manolov <petkan@nucleusys.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	version 2 as published by the Free Software Foundation;
+ */
+
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/arch/crunch.h>
+
+
+unsigned int read_dspsc_low(void)
+{
+	int res;
+
+	asm volatile (
+	"cdp        p4, 1, c15, c0, c0, 7\n\t"	// "cfmv32sc      mvdx15, dspsc\n\t"
+	"mrc        p5, 0, %0, c15, c0, 0"	// "cfmvr64l  %0, mvdx15"
+	:"=r" (res)
+	:
+	:"memory");
+
+	return res;
+}
+
+unsigned int read_dspsc_high(void)
+{
+	int res;
+
+	asm volatile (
+	"cdp        p4, 1, c15, c0, c0, 7\n\t"	// "cfmv32sc   mvdx15, dspsc\n\t"
+	"mrc        p5, 0, %0, c15, c0, 1"	// "cfmvr64h   %0, mvdx15"
+	:"=r" (res)
+	:
+	:"memory");
+
+	return res;
+}
+
+void write_dspsc(unsigned int dspsc)
+{
+	asm volatile (
+	"mcr        p5, 0, %0, c15, c0, 0\n\t"	// "cfmv64lr     mvdx15, %0\n\t"
+	"cdp        p4, 2, c15, c0, c0, 7"	// "cfmvsc32     dspsc, mvdx15"
+	:
+	:"r" (dspsc), "rN"(-1)
+	:"memory");
+}
+
+void crunch_init(void)
+{
+	write_dspsc(CRUNCH_INIT);
+//	current->flags |= PF_USEDCRUNCH;
+}
+
+
+/*
+ * had to do it this way since "clf(); cli();" takes longer
+ */
+static inline void clear_fiq_irq(void)
+{
+	int cpsr;
+
+	asm volatile (
+	"mrs	%0, CPSR\n\t"
+	"orr	%0, %0, #192\n\t"
+	"msr	CPSR_c, %0"
+	:"=r" (cpsr)
+	:
+	:"memory");
+}
+
+/*
+ * had to do it this way since "stf(); sti();" takes (twice) longer
+ */
+
+static inline void restore_fiq_irq(void)
+{
+	int cpsr;
+
+	asm volatile (
+	"mrs	%0, CPSR\n\t"
+	"bic	%0, %0, #192\n\t"
+	"msr	CPSR_c, %0"
+	:"=r" (cpsr)
+	:
+	:"memory");
+}
+
+#ifdef CONFIG_EP93XX_FPU_ACC
+
+static inline void save_accumulators(struct task_struct *tsk)
+{
+	int tmp;
+	struct thread_info *ti = tsk->thread_info; /* current_thread_info(); */
+	struct fp_crunch_struct *fp = &ti->fpstate.crunch;
+
+	/*
+	 * clear the IRQ & FIQ to avoid some of the bugs in the errata
+	 */
+	clear_fiq_irq();
+
+	asm volatile (
+	"cdp        p4, 1, c0, c0, c0, 2\n\t"	// "cfmv32al      mvfx0, mvax0\n\t"
+	"stc        p5, c0, [%0], #4\n\t"	// "cfstr32      mvfx0, [%0], 4\n\t"
+	"cdp        p4, 1, c1, c0, c0, 3\n\t"	// "cfmv32am      mvfx1, mvax0\n\t"
+	"stc        p5, c1, [%0], #4\n\t"	// "cfstr32      mvfx1, [%0], 4\n\t"
+	"cdp        p4, 1, c2, c0, c0, 4\n\t"	// "cfmv32ah      mvfx2, mvax0\n\t"
+	"stc        p5, c2, [%0], #4\n\t"	// "cfstr32      mvfx2, [%0], 4\n\t"
+	"cdp        p4, 1, c3, c1, c0, 2\n\t"	// "cfmv32al      mvfx3, mvax1\n\t"
+	"stc        p5, c3, [%0], #4\n\t"	// "cfstr32      mvfx3, [%0], 4\n\t"
+	"cdp        p4, 1, c4, c1, c0, 3\n\t"	// "cfmv32am      mvfx4, mvax1\n\t"
+	"stc        p5, c4, [%0], #4\n\t"	// "cfstr32      mvfx4, [%0], 4\n\t"
+	"cdp        p4, 1, c5, c1, c0, 4\n\t"	// "cfmv32ah      mvfx5, mvax1\n\t"
+	"stc        p5, c5, [%0], #4\n\t"	// "cfstr32      mvfx5, [%0], 4\n\t"
+	"cdp        p4, 1, c6, c2, c0, 2\n\t"	// "cfmv32al      mvfx6, mvax2\n\t"
+	"stc        p5, c6, [%0], #4\n\t"	// "cfstr32      mvfx6, [%0], 4\n\t"
+	"cdp        p4, 1, c7, c2, c0, 3\n\t"	// "cfmv32am      mvfx7, mvax2\n\t"
+	"stc        p5, c7, [%0], #4\n\t"	// "cfstr32      mvfx7, [%0], 4\n\t"
+	"cdp        p4, 1, c8, c2, c0, 4\n\t"	// "cfmv32ah      mvfx8, mvax2\n\t"
+	"stc        p5, c8, [%0], #4\n\t"	// "cfstr32      mvfx8, [%0], 4\n\t"
+	"cdp        p4, 1, c9, c3, c0, 2\n\t"	// "cfmv32al      mvfx9, mvax3\n\t"
+	"stc        p5, c9, [%0], #4\n\t"	// "cfstr32      mvfx9, [%0], 4\n\t"
+	"cdp        p4, 1, c10, c3, c0, 3\n\t"	// "cfmv32am     mvfx10, mvax3\n\t"
+	"stc        p5,c10, [%0], #4\n\t"	// "cfstr32      mvfx10, [%0], 4\n\t"
+	"cdp        p4, 1, c11, c3, c0, 4\n\t"	// "cfmv32ah     mvfx11, mvax3\n\t"
+	"stc        p5, c11, [%0, #0]"		// "cfstr32      mvfx11, [%0, #0]"
+	:"=&r" (tmp)
+	:"0" (&fp->acc0[0])
+	:"memory");
+
+	restore_fiq_irq();
+}
+
+static inline void restore_accumulators(struct task_struct *tsk)
+{
+	int tmp;
+	struct thread_info *ti = tsk->thread_info; /* current_thread_info(); */
+	struct fp_crunch_struct *fp = &ti->fpstate.crunch;
+
+	/*
+	 * clear the IRQ & FIQ to avoid some of the bugs in the errata
+	 */
+	clear_fiq_irq();
+
+	asm volatile (
+	"ldc        p5, c0, [%0],#4\n\t"	// "cfldr32        mvfx0, [%0], 4\n\t"
+	"cdp        p4, 2, c0, c0, c0, 2\n\t"	// "cfmval32       mvax0, mvfx0\n\t"
+	"ldc        p5, c1, [%0],#4\n\t"	// "cfldr32        mvfx1, [%0], 4\n\t"
+	"cdp        p4, 2, c0, c1, c0, 3\n\t"	// "cfmvam32       mvax0, mvfx1\n\t"
+	"ldc        p5, c2, [%0],#4\n\t"	// "cfldr32        mvfx2, [%0], 4\n\t"
+	"cdp        p4, 2, c0, c2, c0, 4\n\t"	// "cfmvah32       mvax0, mvfx2\n\t"
+	"ldc        p5, c3, [%0],#4\n\t"	// "cfldr32        mvfx3, [%0], 4\n\t"
+	"cdp        p4, 2, c1, c3, c0, 2\n\t"	// "cfmval32       mvax1, mvfx3\n\t"
+	"ldc        p5, c4, [%0],#4\n\t"	// "cfldr32        mvfx4, [%0], 4\n\t"
+	"cdp        p4, 2, c1, c4, c0, 3\n\t"	// "cfmvam32       mvax1, mvfx4\n\t"
+	"ldc        p5, c5, [%0],#4\n\t"	// "cfldr32        mvfx5, [%0], 4\n\t"
+	"cdp        p4, 2, c1, c5, c0, 4\n\t"	// "cfmvah32       mvax1, mvfx5\n\t"
+	"ldc        p5, c6, [%0],#4\n\t"	// "cfldr32        mvfx6, [%0], 4\n\t"
+	"cdp        p4, 2, c2, c6, c0, 2\n\t"	// "cfmval32       mvax2, mvfx6\n\t"
+	"ldc        p5, c7, [%0],#4\n\t"	// "cfldr32        mvfx7, [%0], 4\n\t"
+	"cdp        p4, 2, c2, c7, c0, 3\n\t"	// "cfmvam32       mvax2, mvfx7\n\t"
+	"ldc        p5, c8, [%0],#4\n\t"	// "cfldr32        mvfx8, [%0], 4\n\t"
+	"cdp        p4, 2, c2, c8, c0, 4\n\t"	// "cfmvah32       mvax2, mvfx8\n\t"
+	"ldc        p5, c9, [%0],#4\n\t"	// "cfldr32        mvfx9, [%0], 4\n\t"
+	"cdp        p4, 2, c3, c9, c0, 2\n\t"	// "cfmval32       mvax3, mvfx9\n\t"
+	"ldc        p5, c10, [%0],#4\n\t"	// "cfldr32        mvfx10, [%0], 4\n\t"
+	"cdp        p4, 2, c3, c10, c0, 3\n\t"	// "cfmvam32       mvax3, mvfx10\n\t"
+	"ldc        p5, c11, [%0, #0]\n\t"	// "cfldr32        mvfx11, [%0, #0]\n\t"
+	"cdp        p4, 2, c3, c11, c0, 4"	// "cfmvah32       mvax3, mvfx11"
+	:"=&r" (tmp)
+	:"0" (&fp->acc0[0])
+	:"memory");
+
+	restore_fiq_irq();
+}
+
+#endif
+
+
+
+#ifdef CONFIG_EP93XX_FPU
+void save_crunch(struct task_struct *tsk)
+{
+	int tmp;
+	struct thread_info *ti = tsk->thread_info; /* current_thread_info(); */
+	struct fp_crunch_struct *fp = &ti->fpstate.crunch;
+
+
+	asm volatile (
+	"stcl       p5, c0, [%0],#8\n\t"	// "cfstr64        mvdx0, [%0], 8\n\t"
+	"stcl       p5, c1, [%0],#8\n\t"	// "cfstr64        mvdx1, [%0], 8\n\t"
+	"stcl       p5, c2, [%0],#8\n\t"	// "cfstr64        mvdx2, [%0], 8\n\t"
+	"stcl       p5, c3, [%0],#8\n\t"	// "cfstr64        mvdx3, [%0], 8\n\t"
+	"stcl       p5, c4, [%0],#8\n\t"	// "cfstr64        mvdx4, [%0], 8\n\t"
+	"stcl       p5, c5, [%0],#8\n\t"	// "cfstr64        mvdx5, [%0], 8\n\t"
+	"stcl       p5, c6, [%0],#8\n\t"	// "cfstr64        mvdx6, [%0], 8\n\t"
+	"stcl       p5, c7, [%0],#8\n\t"	// "cfstr64        mvdx7, [%0], 8\n\t"
+	"stcl       p5, c8, [%0],#8\n\t"	// "cfstr64        mvdx8, [%0], 8\n\t"
+	"stcl       p5, c9, [%0],#8\n\t"	// "cfstr64        mvdx9, [%0], 8\n\t"
+	"stcl       p5, c10, [%0],#8\n\t"	// "cfstr64        mvdx10, [%0], 8\n\t"
+	"stcl       p5, c11, [%0],#8\n\t"	// "cfstr64        mvdx11, [%0], 8\n\t"
+	"stcl       p5, c12, [%0],#8\n\t"	// "cfstr64        mvdx12, [%0], 8\n\t"
+	"stcl       p5, c13, [%0],#8\n\t"	// "cfstr64        mvdx13, [%0], 8\n\t"
+	"stcl       p5, c14, [%0],#8\n\t"	// "cfstr64        mvdx14, [%0], 8\n\t"
+	"stcl       p5, c15, [%0, #0]\n\t"	// "cfstr64        mvdx15, [%0, #0]\n\t"
+	"cdp        p4, 1, c15, c0, c0, 7\n\t"	// "cfmv32sc       mvdx15, dspsc\n\t"
+	"stc        p5, c15, [%2, #0]"		// "cfstr32        mvfx15, [%2, #0]"
+	:"=&r" (tmp)
+	:"0" (&fp->regs[0]), "r" (&fp->dspsc)
+	:"memory");
+#ifdef CONFIG_EP93XX_CRUNCH_ACC
+	/*
+	 * this call should be made exactly here since it's corrupting
+	 * the contents of most crunch registers ;-)
+	 */
+	save_accumulators(tsk);
+#endif
+}
+
+void restore_crunch(struct task_struct *tsk)
+{
+	int tmp;
+	struct thread_info *ti = tsk->thread_info; /* current_thread_info(); */
+	struct fp_crunch_struct *fp = &ti->fpstate.crunch;
+
+#ifdef CONFIG_EP93XX_CRUNCH_ACC
+	/*
+	 * same as above, but reversed.  if you put the call below the 'asm'
+	 * code then you'll corrupt the 
+	 */
+	restore_accumulators(tsk);
+#endif
+	asm volatile (
+	"ldc        p5, c15, [%2, #0]\n\t"	// "cfldr32   mvfx15, [%2, #0]\n\t"
+	"cdp        p4, 2, c15, c0, c0, 7\n\t"	// "cfmvsc32  dspsc, mvdx15\n\t"
+	"ldcl       p5, c0, [%0],#8\n\t"	// "cfldr64   mvdx0, [%0], 8\n\t"
+	"ldcl       p5, c1, [%0],#8\n\t"	// "cfldr64   mvdx1, [%0], 8\n\t"
+	"ldcl       p5, c2, [%0],#8\n\t"	// "cfldr64   mvdx2, [%0], 8\n\t"
+	"ldcl       p5, c3, [%0],#8\n\t"	// "cfldr64   mvdx3, [%0], 8\n\t"
+	"ldcl       p5, c4, [%0],#8\n\t"	// "cfldr64   mvdx4, [%0], 8\n\t"
+	"ldcl       p5, c5, [%0],#8\n\t"	// "cfldr64   mvdx5, [%0], 8\n\t"
+	"ldcl       p5, c6, [%0],#8\n\t"	// "cfldr64   mvdx6, [%0], 8\n\t"
+	"ldcl       p5, c7, [%0],#8\n\t"	// "cfldr64   mvdx7, [%0], 8\n\t"
+	"ldcl       p5, c8, [%0],#8\n\t"	// "cfldr64   mvdx8, [%0], 8\n\t"
+	"ldcl       p5, c9, [%0],#8\n\t"	// "cfldr64   mvdx9, [%0], 8\n\t"
+	"ldcl       p5, c10, [%0],#8\n\t"	// "cfldr64   mvdx10, [%0], 8\n\t"
+	"ldcl       p5, c11, [%0],#8\n\t"	// "cfldr64   mvdx11, [%0], 8\n\t"
+	"ldcl       p5, c12, [%0],#8\n\t"	// "cfldr64   mvdx12, [%0], 8\n\t"
+	"ldcl       p5, c13, [%0],#8\n\t"	// "cfldr64   mvdx13, [%0], 8\n\t"
+	"ldcl       p5, c14, [%0],#8\n\t"	// "cfldr64   mvdx14, [%0], 8\n\t"
+	"ldcl       p5, c15, [%0, #0]"		// "cfldr64   mvdx15, [%0, #0]"
+	:"=&r" (tmp)
+	:"0" (&fp->regs[0]), "r" (&fp->dspsc)
+	:"memory");
+}
+#endif
+
+#if 0
+
+void crunch_exception(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int sc, opc;
+
+	send_sig(SIGFPE, current, 1);
+	opc = read_dspsc_high();
+	sc = read_dspsc_low();
+	printk("%s: DSPSC_high=%08x, DSPSC_low=%08x\n", __FUNCTION__, opc, sc);
+	sc &= ~(1 << 21);	/* we recure without this */
+	write_dspsc(sc);
+}
+
+/*
+ * only register ep9312 default FPU handler...
+ */
+__init int setup_crunch(void)
+{
+	int res;
+
+	res = request_irq(CRUNCH_IRQ, crunch_exception, SA_INTERRUPT, "FPU", NULL);
+	if (res) {
+		printk("Crunch IRQ (%d) allocation failure\n", CRUNCH_IRQ);
+		return res;
+	}
+
+	return res;
+}
+
+static inline int insn_is_crunch(long insn)
+{
+	long tmp;
+
+	tmp = (insn >> 24) & 0x0e;
+	/* cdp, mcr, mrc */
+	if (tmp == 0x0e || tmp == 0x0c) {
+		tmp = (insn >> 8) & 0x0f;
+		if (tmp == 4)
+			return 1;
+		if (tmp == 5)
+			return 1;
+		if (tmp == 6)
+			return 1;
+	}
+
+	return 0;
+}
+
+int crunch_opcode(struct pt_regs *regs)
+{
+	int *insn;
+	struct task_struct *tsk = current;
+
+	insn = (int *) (instruction_pointer(regs) - 4);
+	if (!insn_is_crunch(*insn)) {
+		/*
+		 * not a crunch instruction, but might be another
+		 * (FPA/VFP) floating point one
+		 */
+		return 0;
+	}
+
+	crunch_enable();
+	regs->ARM_pc -= 4;	/* restart the Crunch instruction */
+	if (tsk->flags & PF_USEDCRUNCH) {
+		restore_crunch(tsk);
+	} else {
+		crunch_init();
+	}
+	tsk->flags |= PF_USEDFPU;
+
+	return 1;
+}
+
+__initcall(setup_crunch);
+#endif
+
+
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/dma.c linux-2.6.8.1/arch/arm/mach-ep93xx/dma.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/dma.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/dma.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,28 @@
+/*
+ *  linux/arch/arm/mach-ep93xx/dma.c
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+
+void __init arch_dma_init(dma_t *dma)
+{
+}
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/dma_ep93xx.c linux-2.6.8.1/arch/arm/mach-ep93xx/dma_ep93xx.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/dma_ep93xx.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/dma_ep93xx.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,2929 @@
+/******************************************************************************
+ * arch/arm/mach-ep9312/dma_ep93xx.c
+ *
+ * Support functions for the ep93xx internal DMA channels.
+ * (see also Documentation/arm/ep93xx/dma.txt)
+ *
+ * Copyright (C) 2003  Cirrus Logic
+ *
+ * A large portion of this file is based on the dma api implemented by
+ * Nicolas Pitre, dma-sa1100.c, copyrighted 2000.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/mach/dma.h>
+#include "dma_ep93xx.h"
+
+/*****************************************************************************
+ *
+ * Debugging macros
+ *
+ ****************************************************************************/
+#undef DEBUG
+//#define DEBUG   1
+#ifdef DEBUG
+#define DPRINTK( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DPRINTK( fmt, arg... )
+#endif
+
+/*****************************************************************************
+ *
+ * static global variables
+ *
+ ****************************************************************************/
+ep93xx_dma_t dma_chan[MAX_EP93XX_DMA_CHANNELS];
+
+/*
+ *  lock used to protect the list of dma channels while searching for a free
+ *  channel during dma_request.
+ */
+static spinlock_t dma_list_lock;
+
+/*****************************************************************************
+ *
+ *  Internal DMA processing functions.
+ *
+ ****************************************************************************/
+/*****************************************************************************
+ *
+ *  get_dma_channel_from_handle()
+ *
+ *  If Handle is valid, returns the DMA channel # (0 to 9 for channels 1-10)
+ *  If Handle is not valid, returns -1.
+ *
+ ****************************************************************************/
+static int
+dma_get_channel_from_handle(int handle)
+{
+	int channel;
+
+	/*
+	 *  Get the DMA channel # from the handle.
+	 */
+	channel = ((int)handle & DMA_HANDLE_SPECIFIER_MASK) >> 28;
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (dma_chan[channel].last_valid_handle != (int)handle) {
+		DPRINTK("DMA ERROR - invalid handle 0x%x \n", handle);
+		return(-1);
+	}
+
+	/*
+	 *  See if this instance is still open
+	 */
+	if (!dma_chan[channel].ref_count )
+		return(-1);
+
+	return(channel);
+}
+
+static void dma_m2m_transfer_done(ep93xx_dma_t *dma)
+{
+	unsigned int uiCONTROL;
+	unsigned int M2M_reg_base = dma->reg_base;
+	unsigned int read_back;
+
+	DPRINTK("1  ");
+
+	outl( 0, M2M_reg_base+M2M_OFFSET_INTERRUPT );
+
+	if (dma->total_buffers) {
+		/*
+		 * The current_buffer has already been tranfered, so add the
+		 * byte count to the total_bytes field.
+		 */
+		dma->total_bytes = dma->total_bytes +
+			dma->buffer_queue[dma->current_buffer].size;
+
+		/*
+		 * Mark the current_buffer as used.
+		 */
+		dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+		/*
+		 * Increment the used buffer counter
+		 */
+		dma->used_buffers++;
+
+		DPRINTK("#%d", dma->current_buffer);
+
+		/*
+		 * Increment the current_buffer
+		 */
+		dma->current_buffer = (dma->current_buffer + 1) %
+				      MAX_EP93XX_DMA_BUFFERS;
+
+		/*
+		 * check if there's a new buffer to transfer.
+		 */
+		if (dma->new_buffers && dma->xfer_enable) {
+			/*
+			 * We have a new buffer to transfer so program in the
+			 * buffer values.  Since a STALL interrupt was
+			 * triggered, we program the buffer descriptor 0
+			 *
+			 * Set the SAR_BASE/DAR_BASE/BCR registers with values
+			 * from the next buffer in the queue.
+			 */
+			outl( dma->buffer_queue[dma->current_buffer].source,
+			      M2M_reg_base + M2M_OFFSET_SAR_BASE0 );
+
+			outl( dma->buffer_queue[dma->current_buffer].dest,
+			      M2M_reg_base + M2M_OFFSET_DAR_BASE0 );
+
+			outl( dma->buffer_queue[dma->current_buffer].size,
+			      M2M_reg_base + M2M_OFFSET_BCR0 );
+
+			DPRINTK("SAR_BASE0 - 0x%x\n", dma->buffer_queue[dma->current_buffer].source);
+			DPRINTK("DAR_BASE0 - 0x%x\n", dma->buffer_queue[dma->current_buffer].dest);
+			DPRINTK("BCR0 - 0x%x\n", dma->buffer_queue[dma->current_buffer].size);
+
+			/*
+			 * Decrement the new buffer counter
+			 */
+			dma->new_buffers--;
+
+			/*
+			 * If there's a second new buffer, we program the
+			 * second buffer descriptor.
+			 */
+			if (dma->new_buffers) {
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].source,
+				      M2M_reg_base+M2M_OFFSET_SAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].dest,
+				      M2M_reg_base+M2M_OFFSET_DAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].size,
+				      M2M_reg_base+M2M_OFFSET_BCR1 );
+
+				uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+				uiCONTROL |= CONTROL_M2M_NFBINTEN;
+				outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+				dma->new_buffers--;
+			}
+		} else {
+			DPRINTK("2 \n");
+			/*
+			 * There's a chance we setup both buffer descriptors,
+			 * but didn't service the NFB quickly enough, causing
+			 * the channel to transfer both buffers, then enter the
+			 * stall state.  So, we need to be able to process the
+			 * second buffer.
+			 */
+			if ((dma->used_buffers + dma->new_buffers) < dma->total_buffers)
+			{
+				DPRINTK("3 ");
+
+				/*
+				 * The current_buffer has already been
+				 * tranferred, so add the byte count to the
+				 * total_bytes field.
+				 */
+				dma->total_bytes = dma->total_bytes +
+					dma->buffer_queue[dma->current_buffer].size;
+
+				/*
+				 * Mark the current_buffer as used.
+				 */
+				dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+				/*
+				 * Increment the used buffer counter
+				 */
+				dma->used_buffers++;
+
+				DPRINTK("#%d", dma->current_buffer);
+
+				/*
+				 * Increment the current buffer pointer.
+				 */
+				dma->current_buffer = (dma->current_buffer + 1) %
+						      MAX_EP93XX_DMA_BUFFERS;
+
+			}
+
+			/*
+			 * No new buffers to transfer, so disable the channel.
+			 */
+			uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2M_ENABLE;
+			outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+			/*
+			 * Indicate that this channel is in the pause by
+			 * starvation state by setting the pause bit to true.
+			 */
+			dma->pause = TRUE;
+		}
+	} else {
+		/*
+		 * No buffers to transfer, or old buffers to mark as used,
+		 * so disable the channel
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+		/*
+		 * Must read the control register back after a write.
+		 */
+		read_back = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+
+		/*
+		 * Indicate that this channel is in the pause by
+		 * starvation state by setting the pause bit to true.
+		 */
+		dma->pause = TRUE;
+	}
+}
+
+static void dma_m2m_next_frame_buffer(ep93xx_dma_t *dma)
+{
+	int loop;
+	unsigned int uiCONTROL;
+	unsigned int M2M_reg_base = dma->reg_base;
+
+	DPRINTK("5  ");
+
+	if (dma->total_buffers) {
+		DPRINTK("6  ");
+		/*
+		 * The iCurrentBuffer has already been transfered.  so add the
+		 * byte count from the current buffer to the total byte count.
+		 */
+		dma->total_bytes = dma->total_bytes +
+			dma->buffer_queue[dma->current_buffer].size;
+
+		/*
+		 * Mark the Current Buffer as used.
+		 */
+		dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+		/*
+		 * Increment the used buffer counter
+		 */
+		dma->used_buffers++;
+
+		DPRINTK("#%d", dma->current_buffer);
+
+		if ((dma->buffer_queue[
+		    (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].last) ||
+		    (dma->new_buffers == 0) || (dma->xfer_enable == FALSE)) {
+			DPRINTK("7  ");
+
+			/*
+			 * This is the last Buffer in this transaction, so
+			 * disable the NFB interrupt.  We shouldn't get an NFB
+			 * int when the FSM moves to the ON state where it
+			 * would typically get the NFB int indicating a new
+			 * buffer can be programmed.  Instead, once in the ON
+			 * state, the DMA will just proceed to complete the
+			 * transfer of the current buffer, move the FSB
+			 * directly to the STALL state where a STALL interrupt
+			 * will be generated.
+			 */
+			uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2M_NFBINTEN ;
+			outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+			/*
+			 * The current buffer has been transferred, so
+			 * increment the current buffer counter to reflect
+			 * this.
+			 */
+			dma->current_buffer = (dma->current_buffer + 1) %
+					      MAX_EP93XX_DMA_BUFFERS;
+
+			DPRINTK("End of NFB handling. \n");
+			DPRINTK("CONTROL - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_CONTROL) );
+			DPRINTK("STATUS - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_STATUS) );
+			DPRINTK("SAR_BASE0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_SAR_BASE0) );
+			DPRINTK("SAR_CUR0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_SAR_CURRENT0) );
+			DPRINTK("DAR_BASE0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_DAR_BASE0) );
+			DPRINTK("DAR_CUR0 - 0x%x \n",
+                                inl(M2M_reg_base+M2M_OFFSET_DAR_CURRENT0) );
+
+			DPRINTK("Buffer	buf_id	 source	   size	   last	   used \n");
+			for (loop = 0; loop < 32; loop ++)
+				DPRINTK("%d		0x%x		0x%x		 0x%x		%d		 %d \n",
+					loop, dma->buffer_queue[loop].buf_id,
+					dma->buffer_queue[loop].source,
+					dma->buffer_queue[loop].size,
+					dma->buffer_queue[loop].last,
+					dma->buffer_queue[loop].used);
+			DPRINTK("pause	 0x%x		0x%x		 0x%x		%d		 %d \n",
+				dma->pause_buf.buf_id, dma->pause_buf.source,
+				dma->pause_buf.size, dma->pause_buf.last,
+				dma->pause_buf.used);
+
+			DPRINTK("Pause - %d \n", dma->pause);
+			DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+			DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+			DPRINTK("total buffer - %d \n", dma->total_buffers);
+			DPRINTK("new buffers - %d \n", dma->new_buffers);
+			DPRINTK("current buffer - %d \n", dma->current_buffer);
+			DPRINTK("last buffer - %d \n", dma->last_buffer);
+			DPRINTK("used buffers - %d \n", dma->used_buffers);
+			DPRINTK("callback addr - 0x%p \n", dma->callback);
+
+		} else if (dma->new_buffers) {
+			DPRINTK("8  ");
+			/*
+			 * We have a new buffer, so increment the current
+			 * buffer to point to the next buffer, which is already
+			 * programmed into the DMA. Next time around, it'll be
+			 * pointing to the current buffer.
+			 */
+			dma->current_buffer = (dma->current_buffer + 1) %
+					      MAX_EP93XX_DMA_BUFFERS;
+
+			/*
+			 * We know we have a new buffer to program as the next
+			 * buffer, so check which set of SAR_BASE/DAR_BASE/BCR
+			 * registers to program.
+			 */
+			if ( inl(M2M_reg_base+M2M_OFFSET_STATUS) & STATUS_M2M_NB ) {
+				/*
+				 * Set the SAR_BASE1/DAR_BASE1/BCR1 registers
+				 * with values from the next buffer in the
+				 * queue.
+				 */
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].source,
+				      M2M_reg_base+M2M_OFFSET_SAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].dest,
+				      M2M_reg_base+M2M_OFFSET_DAR_BASE1 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].size,
+				      M2M_reg_base+M2M_OFFSET_BCR1 );
+			} else {
+				/*
+				 * Set the SAR_BASE0/DAR_BASE0/BCR0 registers
+				 * with values from the next buffer in the
+				 * queue.
+				 */
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].source,
+				      M2M_reg_base+M2M_OFFSET_SAR_BASE0 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].dest,
+				      M2M_reg_base+M2M_OFFSET_DAR_BASE0 );
+
+				outl( dma->buffer_queue[(dma->current_buffer + 1) %
+							MAX_EP93XX_DMA_BUFFERS].size,
+				      M2M_reg_base+M2M_OFFSET_BCR0 );
+			}
+
+			/*
+			 *  Decrement the new buffers counter
+			 */
+			dma->new_buffers--;
+		}
+	} else {
+		/*
+		 * Total number of buffers is 0 - really we should never get
+		 * here, but just in case.
+		 */
+		DPRINTK("9 \n");
+
+		/*
+		 *  No new buffers to transfer, so Disable the channel
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+		/*
+		 *  Indicate that the channel is paused by starvation.
+		 */
+		dma->pause = 1;
+	}
+}
+
+/*****************************************************************************
+ *
+ * dma_m2m_irq_handler
+ *
+ ****************************************************************************/
+static irqreturn_t
+dma_m2m_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	ep93xx_dma_t *dma = (ep93xx_dma_t *)dev_id;
+	unsigned int M2M_reg_base = dma->reg_base;
+	ep93xx_dma_dev_t dma_int = UNDEF_INT;
+	int status;
+
+//	printk("+m2m irq=%d\n", irq);
+
+	/*
+	 *  Determine what kind of dma interrupt this is.
+	 */
+	status = inl(M2M_reg_base + M2M_OFFSET_INTERRUPT);
+	if ( status & INTERRUPT_M2M_DONEINT )
+		dma_int = DONE; // we're done with a requested dma
+	else if ( status & INTERRUPT_M2M_NFBINT )
+		dma_int = NFB;  // we're done with one dma buffer
+
+	DPRINTK("IRQ: b=%#x st=%#x\n", (int)dma->current_buffer, dma_int);
+
+	switch (dma_int) {
+	/*
+	 *  Next Frame Buffer Interrupt.  If there's a new buffer program it
+	 *  Check if this is the last buffer in the transfer,
+	 *  and if it is, disable the NFB int to prevent being
+	 *  interrupted for another buffer when we know there won't be
+	 *  another.
+	 */
+	case NFB:
+		dma_m2m_next_frame_buffer(dma);
+		break;
+	/*
+	 *  Done interrupt generated, indicating that the transfer is complete.
+	 */
+	case DONE:
+		dma_m2m_transfer_done(dma);
+		break;
+
+	default:
+		break;
+	}
+
+	if ((dma_int != UNDEF_INT) && dma->callback)
+		dma->callback(dma_int, dma->device, dma->user_data);
+
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************
+ *
+ * dma_m2p_irq_handler
+ *
+ *
+ *
+ ****************************************************************************/
+static irqreturn_t
+dma_m2p_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	ep93xx_dma_t *dma = (ep93xx_dma_t *) dev_id;
+	unsigned int M2P_reg_base = dma->reg_base;
+	unsigned int read_back;
+	ep93xx_dma_dev_t dma_int = UNDEF_INT;
+	unsigned int loop, uiCONTROL, uiINTERRUPT;
+
+	/*
+	 *  Determine what kind of dma interrupt this is.
+	 */
+	if ( inl(M2P_reg_base+M2P_OFFSET_INTERRUPT) & INTERRUPT_M2P_STALLINT )
+		dma_int = STALL;
+	else if ( inl(M2P_reg_base+M2P_OFFSET_INTERRUPT) & INTERRUPT_M2P_NFBINT )
+		dma_int = NFB;
+	else if ( inl(M2P_reg_base+M2P_OFFSET_INTERRUPT) & INTERRUPT_M2P_CHERRORINT )
+		dma_int = CHERROR;
+
+	/*
+	 *  Stall Interrupt: The Channel is stalled, meaning nothing is
+	 *  programmed to transfer right now.  So, we're back to the
+	 *  beginnning.  If there's a buffer to transfer, program it into
+	 *  max and base 0 registers.
+	 */
+	if (dma_int == STALL) {
+		DPRINTK("1  ");
+
+		if (dma->total_buffers) {
+			/*
+			 * The current_buffer has already been tranfered, so
+			 * add the byte count to the total_bytes field.
+			 */
+			dma->total_bytes = dma->total_bytes +
+				dma->buffer_queue[dma->current_buffer].size;
+
+			/*
+			 *  Mark the current_buffer as used.
+			 */
+			dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+			/*
+			 *  Increment the used buffer counter
+			 */
+			dma->used_buffers++;
+
+			DPRINTK("#%d", dma->current_buffer);
+
+			/*
+			 *  Increment the current_buffer
+			 */
+			dma->current_buffer = (dma->current_buffer + 1) %
+					      MAX_EP93XX_DMA_BUFFERS;
+
+			/*
+			 *  check if there's a new buffer to transfer.
+			 */
+			if (dma->new_buffers && dma->xfer_enable) {
+				/*
+				 * We have a new buffer to transfer so program
+				 * in the buffer values.  Since a STALL
+				 * interrupt was triggered, we program the
+				 * base0 and maxcnt0
+				 *
+				 * Set the MAXCNT0 register with the buffer
+				 * size
+				 */
+				outl( dma->buffer_queue[dma->current_buffer].size,
+					  M2P_reg_base+M2P_OFFSET_MAXCNT0 );
+
+				/*
+				 * Set the BASE0 register with the buffer base
+				 * address
+				 */
+				outl( dma->buffer_queue[dma->current_buffer].source,
+					  M2P_reg_base+M2P_OFFSET_BASE0 );
+
+				/*
+				 *  Decrement the new buffer counter
+				 */
+				dma->new_buffers--;
+
+				if (dma->new_buffers) {
+					DPRINTK("A  ");
+					/*
+					 * Set the MAXCNT1 register with the
+					 * buffer size
+					 */
+					outl( dma->buffer_queue[(dma->current_buffer + 1) %
+											MAX_EP93XX_DMA_BUFFERS].size,
+						  M2P_reg_base+M2P_OFFSET_MAXCNT1 );
+
+					/*
+					 * Set the BASE1 register with the
+					 * buffer base address
+					 */
+					outl( dma->buffer_queue[dma->current_buffer + 1 %
+											MAX_EP93XX_DMA_BUFFERS].source,
+						  M2P_reg_base+M2P_OFFSET_BASE1 );
+
+					/*
+					 *  Decrement the new buffer counter
+					 */
+					dma->new_buffers--;
+
+					/*
+					 *  Enable the NFB Interrupt.
+					 */
+					uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+					uiCONTROL |= CONTROL_M2P_NFBINTEN;
+					outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+				}
+			} else {
+				/*
+				 *  No new buffers.
+				 */
+				DPRINTK("2 \n");
+
+				/*
+				 *  There's a chance we setup both buffer descriptors, but
+				 *  didn't service the NFB quickly enough, causing the channel
+				 *  to transfer both buffers, then enter the stall state.
+				 *  So, we need to be able to process the second buffer.
+				 */
+				if ((dma->used_buffers + dma->new_buffers) < dma->total_buffers) {
+					DPRINTK("3 ");
+
+					/*
+					 *  The current_buffer has already been tranfered, so add the
+					 *  byte count to the total_bytes field.
+					 */
+					dma->total_bytes = dma->total_bytes +
+						dma->buffer_queue[dma->current_buffer].size;
+
+					/*
+					 *  Mark the current_buffer as used.
+					 */
+					dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+					/*
+					 *  Increment the used buffer counter
+					 */
+					dma->used_buffers++;
+
+					DPRINTK("#%d", dma->current_buffer);
+
+					/*
+					 *  Increment the current buffer pointer.
+					 */
+					dma->current_buffer = (dma->current_buffer + 1) %
+						MAX_EP93XX_DMA_BUFFERS;
+
+				}
+
+				/*
+				 *  No new buffers to transfer, so disable the channel.
+				 */
+				uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+				uiCONTROL &= ~CONTROL_M2P_ENABLE;
+				outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+				/*
+				 *  Indicate that this channel is in the pause by starvation
+				 *  state by setting the pause bit to true.
+				 */
+				dma->pause = TRUE;
+
+				DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+				DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+				DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+				DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+				DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+				DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+				DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+				DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+				DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+				DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+				DPRINTK("Buffer	buf_id	 source	   size	   last	   used \n");
+				for (loop = 0; loop < 32; loop ++)
+					DPRINTK("%d		0x%x		0x%x		 0x%x		%d		 %d \n",
+							loop, dma->buffer_queue[loop].buf_id, dma->buffer_queue[loop].source,
+							dma->buffer_queue[loop].size,
+							dma->buffer_queue[loop].last, dma->buffer_queue[loop].used);
+				DPRINTK("pause	 0x%x		0x%x		 0x%x		%d		 %d \n",
+						dma->pause_buf.buf_id, dma->pause_buf.source, dma->pause_buf.size,
+						dma->pause_buf.last, dma->pause_buf.used);
+
+				DPRINTK("Pause - %d \n", dma->pause);
+				DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+				DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+				DPRINTK("total buffer - %d \n", dma->total_buffers);
+				DPRINTK("new buffers - %d \n", dma->new_buffers);
+				DPRINTK("current buffer - %d \n", dma->current_buffer);
+				DPRINTK("last buffer - %d \n", dma->last_buffer);
+				DPRINTK("used buffers - %d \n", dma->used_buffers);
+				DPRINTK("callback addr - 0x%p \n", dma->callback);
+			}
+		} else {
+			/*
+			 *  No buffers to transfer, or old buffers to mark as used,
+			 *  so Disable the channel
+			 */
+			uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2P_ENABLE;
+			outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+			/*
+			 *  Must read the control register back after a write.
+			 */
+			read_back = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+
+			/*
+			 *  Indicate that this channel is in the pause by
+			 *  starvation state by setting the pause bit to true.
+			 */
+			dma->pause = TRUE;
+		}
+	}
+
+	/*
+	 *  Next Frame Buffer Interrupt.  If there's a new buffer program it
+	 *  Check if this is the last buffer in the transfer,
+	 *  and if it is, disable the NFB int to prevent being
+	 *  interrupted for another buffer when we know there won't be
+	 *  another.
+	 */
+	if (dma_int == NFB) {
+		DPRINTK("5  ");
+
+		if (dma->total_buffers) {
+			DPRINTK("6  ");
+			/*
+			 *  The iCurrentBuffer has already been transfered.  so add the
+			 *  byte count from the current buffer to the total byte count.
+			 */
+			dma->total_bytes = dma->total_bytes +
+				dma->buffer_queue[dma->current_buffer].size;
+
+			/*
+			 *  Mark the Current Buffer as used.
+			 */
+			dma->buffer_queue[dma->current_buffer].used = TRUE;
+
+			/*
+			 *  Increment the used buffer counter
+			 */
+			dma->used_buffers++;
+
+			DPRINTK("#%d", dma->current_buffer);
+
+			if ((dma->buffer_queue[
+			    (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].last) ||
+			    (dma->new_buffers == 0) || (dma->xfer_enable == FALSE)) {
+				DPRINTK("7  ");
+
+				/*
+				 *  This is the last Buffer in this transaction, so disable
+				 *  the NFB interrupt.  We shouldn't get an NFB int when the
+				 *  FSM moves to the ON state where it would typically get the
+				 *  NFB int indicating a new buffer can be programmed.
+				 *  Instead, once in the ON state, the DMA will just proceed
+				 *  to complet the transfer of the current buffer, move the
+				 *  FSB directly to the STALL state where a STALL interrupt
+				 *  will be generated.
+				 */
+				uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+				uiCONTROL &= ~CONTROL_M2P_NFBINTEN;
+				outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+				/*
+				 *  The current buffer has been transferred, so increment
+				 *  the current buffer counter to reflect this.
+				 */
+				dma->current_buffer = (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS;
+
+				DPRINTK("End of NFB handling. \n");
+				DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+				DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+				DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+				DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+				DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+				DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+				DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+				DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+				DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+				DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+				DPRINTK("Buffer	buf_id	 source	   size	   last	   used \n");
+				for (loop = 0; loop < 32; loop ++)
+					DPRINTK("%d		0x%x		0x%x		 0x%x		%d		 %d \n",
+							loop, dma->buffer_queue[loop].buf_id, dma->buffer_queue[loop].source,
+							dma->buffer_queue[loop].size,
+							dma->buffer_queue[loop].last, dma->buffer_queue[loop].used);
+				DPRINTK("pause	 0x%x		0x%x		 0x%x		%d		 %d \n",
+						dma->pause_buf.buf_id, dma->pause_buf.source, dma->pause_buf.size,
+						dma->pause_buf.last, dma->pause_buf.used);
+
+				DPRINTK("Pause - %d \n", dma->pause);
+				DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+				DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+				DPRINTK("total buffer - %d \n", dma->total_buffers);
+				DPRINTK("new buffers - %d \n", dma->new_buffers);
+				DPRINTK("current buffer - %d \n", dma->current_buffer);
+				DPRINTK("last buffer - %d \n", dma->last_buffer);
+				DPRINTK("used buffers - %d \n", dma->used_buffers);
+				DPRINTK("callback addr - 0x%p \n", dma->callback);
+
+			} else if (dma->new_buffers) {
+				DPRINTK("8  ");
+				/*
+				 *  we have a new buffer, so increment the current buffer to
+				 *  point to the next buffer, which is already programmed into
+				 *  the DMA. Next time around, it'll be pointing to the
+				 *  current buffer.
+				 */
+				dma->current_buffer = (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS;
+
+				/*
+				 *  we know we have a new buffer to program as the next
+				 *  buffer, so check which set of MAXCNT and BASE registers
+				 *  to program.
+				 */
+				if ( inl(M2P_reg_base+M2P_OFFSET_STATUS) & STATUS_M2P_NEXTBUFFER ) {
+					/*
+					 *  Set the MAXCNT1 register with the buffer size
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].size,
+					      M2P_reg_base+M2P_OFFSET_MAXCNT1 );
+
+					/*
+					 *  Set the BASE1 register with the buffer base address
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].source,
+					      M2P_reg_base+M2P_OFFSET_BASE1 );
+				} else {
+					/*
+					 *  Set the MAXCNT0 register with the buffer size
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].size,
+					       M2P_reg_base+M2P_OFFSET_MAXCNT0 );
+
+					/*
+					 *  Set the BASE0 register with the buffer base address
+					 */
+					outl( dma->buffer_queue[
+					      (dma->current_buffer + 1) % MAX_EP93XX_DMA_BUFFERS].source,
+					      M2P_reg_base+M2P_OFFSET_BASE0 );
+				}
+
+				/*
+				 *  Decrement the new buffers counter
+				 */
+				dma->new_buffers--;
+			}
+		} else {
+			/*
+			 *  Total number of buffers is 0 - really we should never get here,
+			 *  but just in case.
+			 */
+			DPRINTK("9 \n");
+
+			/*
+			 *  No new buffers to transfer, so Disable the channel
+			 */
+			uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+			uiCONTROL &= ~CONTROL_M2P_ENABLE;
+			outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+		}
+	}
+
+	/*
+	 *  Channel Error Interrupt, or perhipheral interrupt, specific to the
+	 *  memory to/from peripheral channels.
+	 */
+	if (dma_int == CHERROR) {
+		/*
+		 *  just clear the interrupt, it's really up to the peripheral
+		 *  driver to determine if any further action is necessary.
+		 */
+		uiINTERRUPT = inl(M2P_reg_base+M2P_OFFSET_INTERRUPT);
+		uiINTERRUPT &= ~INTERRUPT_M2P_CHERRORINT;
+		outl( uiINTERRUPT, M2P_reg_base+M2P_OFFSET_INTERRUPT );
+	}
+
+	/*
+	 *  Make sure the interrupt was valid, and if it was, then check
+	 *  if a callback function was installed for this DMA channel.  If a
+	 *  callback was installed call it.
+	 */
+	if ((dma_int != UNDEF_INT) && dma->callback)
+		dma->callback(dma_int, dma->device, dma->user_data);
+
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************
+ *
+ * ep9312_dma_open_m2p(int device)
+ *
+ * Description: This function will attempt to open a M2P/P2M DMA channel.
+ *			  If the open is successful, the channel number is returned,
+ *			  otherwise a negative number is returned.
+ *
+ * Parameters:
+ *  device:	 device for which the dma channel is requested.
+ *
+ ****************************************************************************/
+static int
+dma_open_m2p(int device)
+{
+	int channel = -1;
+	unsigned int loop;
+	unsigned int M2P_reg_base;
+	unsigned int uiPWRCNT;
+	unsigned long flags;
+
+	DPRINTK("DMA Open M2P with hw dev %d\n", device);
+
+	/*
+	 *  Lock the dma channel list.
+	 */
+	spin_lock_irqsave(&dma_list_lock, flags);
+
+	DPRINTK("1\n");
+	/*
+	 * Verify that the device requesting DMA isn't already using a DMA channel
+	 */
+	if (device >= 10)
+		loop = 1;		 // Rx transfer requested
+	else
+		loop = 0;		 // Tx transfer requested
+
+	for (; loop < 10; loop = loop + 2)
+		/*
+		 *  Before checking for a matching device, check that the
+		 *  channel is in use, otherwise the device field is
+		 *  invalid.
+		 */
+		if (dma_chan[loop].ref_count)
+			if (device == dma_chan[loop].device) {
+				DPRINTK("DMA Open M2P - Error\n");
+				return(-1);
+			}
+
+	/*
+	 *  Get a DMA channel instance for the given hardware device.
+	 *  If this is a TX look for even numbered channels, else look for
+	 *  odd numbered channels
+	 */
+	if (device >= 10)
+		loop = 1;		 /* Rx transfer requested */
+	else
+		loop = 0;		 /* Tx transfer requested */
+
+	for (; loop < 10; loop = loop + 2)
+		if (!dma_chan[loop].ref_count) {
+			/*
+			 *  Capture the channel and increment the reference count.
+			 */
+			channel = loop;
+			dma_chan[channel].ref_count++;
+			break;
+		}
+
+	/*
+	 *  Unlock the dma channel list.
+	 */
+	spin_unlock_irqrestore(&dma_list_lock, flags);
+
+	/*
+	 *  See if we got a valid channel.
+	 */
+	if (channel < 0)
+		return(-1);
+
+	/*
+	 *  Point regs to the correct dma channel register base.
+	 */
+	M2P_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  Turn on the clock for the specified DMA channel
+	 *  TODO: need to use the correct register name for the
+	 *  power control register.
+	 */
+	uiPWRCNT = inl(SYSCON_PWRCNT);
+	switch (channel) {
+	case 0:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH0;
+		break;
+
+	case 1:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH1;
+		break;
+
+	case 2:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH2;
+		break;
+
+	case 3:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH3;
+		break;
+
+	case 4:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH4;
+		break;
+
+	case 5:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH5;
+		break;
+
+	case 6:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH6;
+		break;
+
+	case 7:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH7;
+		break;
+
+	case 8:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH8;
+		break;
+
+	case 9:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2PCH9;
+		break;
+
+	default:
+		return(-1);
+	}
+	outl( uiPWRCNT, SYSCON_PWRCNT );
+
+	/*
+	 *  Clear out the control register before any further setup.
+	 */
+	outl( 0, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	/*
+	 *  Setup the peripheral port value in the DMA channel registers.
+	 */
+	if (device < 10)
+		outl( (unsigned int)device, M2P_reg_base+M2P_OFFSET_PPALLOC );
+	else
+		outl( (unsigned int)(device - 10), M2P_reg_base+M2P_OFFSET_PPALLOC );
+
+	/*
+	 *  Let's hold on to the value of the Hw device for comparison later.
+	 */
+	dma_chan[channel].device = device;
+
+	/*
+	 *  Success.
+	 */
+	return(channel);
+}
+
+/*****************************************************************************
+ *
+ * dma_open_m2m(int device)
+ *
+ * Description: This function will attempt to open a M2M DMA channel.
+ *			  If the open is successful, the channel number is returned,
+ *			  otherwise a negative number is returned.
+ *
+ * Parameters:
+ *  device:	 device for which the dma channel is requested.
+ *
+ ****************************************************************************/
+static int
+dma_open_m2m(int device)
+{
+	int channel = -1;
+	unsigned int loop;
+	unsigned int M2M_reg_base;
+	unsigned int uiPWRCNT, uiCONTROL;
+	unsigned long flags;
+
+	DPRINTK("DMA Open M2M with hw dev %d\n", device);
+
+	/*
+	 *  Lock the dma channel list.
+	 */
+	spin_lock_irqsave(&dma_list_lock, flags);
+
+	DPRINTK("1\n");
+
+	/*
+	 *  Check if this device is already allocated a channel.
+	 *  TODO: can one M2M device be allocated multiple channels?
+	 */
+	for (loop = DMA_MEMORY; loop < UNDEF; loop++)
+		/*
+		 *  Before checking for a matching device, check that the
+		 *  channel is in use, otherwise the device field is
+		 *  invalid.
+		 */
+		if (dma_chan[loop].ref_count)
+			if (device == dma_chan[loop].device) {
+				DPRINTK("Error - dma_open_m2m - already allocated channel\n");
+
+				/*
+				 *  Unlock the dma channel list.
+				 */
+				spin_unlock_irqrestore(&dma_list_lock, flags);
+
+				/*
+				 *  Fail.
+				 */
+				return(-1);
+			}
+
+	/*
+	 *  Get a DMA channel instance for the given hardware device.
+	 */
+	for (loop = 10; loop < 12; loop++)
+		if (!dma_chan[loop].ref_count) {
+			/*
+			 *  Capture the channel and increment the reference count.
+			 */
+			channel = loop;
+			dma_chan[channel].ref_count++;
+			break;
+		}
+
+	/*
+	 *  Unlock the dma channel list.
+	 */
+	spin_unlock(dma_list_lock);
+
+	/*
+	 *  See if we got a valid channel.
+	 */
+	if (channel < 0)
+		return(-1);
+
+	/*
+	 *  Point regs to the correct dma channel register base.
+	 */
+	M2M_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  Turn on the clock for the specified DMA channel
+	 *  TODO: need to use the correct register name for the
+	 *  power control register.
+	 */
+	uiPWRCNT = inl(SYSCON_PWRCNT);
+	switch (channel) {
+	case 10:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2MCH0;
+		break;
+
+	case 11:
+		uiPWRCNT |= SYSCON_PWRCNT_DMA_M2MCH1;
+		break;
+
+	default:
+		return(-1);
+	}
+	outl( uiPWRCNT, SYSCON_PWRCNT );
+
+	DPRINTK("DMA Open - power control: 0x%x \n", inl(SYSCON_PWRCNT) );
+
+	/*
+	 *  Clear out the control register before any further setup.
+	 */
+	outl( 0, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  Setup the transfer mode and the request source selection within
+	 *  the DMA M2M channel registers.
+	 */
+	switch (device) {
+	case DMA_MEMORY:
+		/*
+		 * Clear TM field, set RSS field to 0
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_TM_MASK | CONTROL_M2M_RSS_MASK);
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMA_IDE:
+		/*
+		 * Set RSS field to 3, Set NO_HDSK, Set PW field to 1
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_PW_MASK);
+		uiCONTROL |= (3<<CONTROL_M2M_RSS_SHIFT) |
+			CONTROL_M2M_NO_HDSK |
+			(2<<CONTROL_M2M_PW_SHIFT);
+
+		uiCONTROL &= ~(CONTROL_M2M_ETDP_MASK);
+		uiCONTROL &= ~(CONTROL_M2M_DACKP);
+		uiCONTROL &= ~(CONTROL_M2M_DREQP_MASK);
+
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		break;
+
+	case DMARx_SSP:
+		/*
+		 * Set RSS field to 1, Set NO_HDSK, Set TM field to 2
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= (1<<CONTROL_M2M_RSS_SHIFT) |
+			CONTROL_M2M_NO_HDSK |
+			(2<<CONTROL_M2M_TM_SHIFT);
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMATx_SSP:
+		/*
+		 * Set RSS field to 2, Set NO_HDSK, Set TM field to 1
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= (2<<CONTROL_M2M_RSS_SHIFT) |
+			CONTROL_M2M_NO_HDSK |
+			(1<<CONTROL_M2M_TM_SHIFT);
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMATx_EXT_DREQ:
+		/*
+		 * Set TM field to 2, set RSS field to 0
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= 1<<CONTROL_M2M_TM_SHIFT;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	case DMARx_EXT_DREQ:
+		/*
+		 * Set TM field to 2, set RSS field to 0
+		 */
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~(CONTROL_M2M_RSS_MASK|CONTROL_M2M_TM_MASK);
+		uiCONTROL |= 2<<CONTROL_M2M_TM_SHIFT;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+		break;
+
+	default:
+		return -1;
+	}
+
+	/*
+	 *  Let's hold on to the value of the Hw device for comparison later.
+	 */
+	dma_chan[channel].device = device;
+
+	/*
+	 *  Success.
+	 */
+	return(channel);
+}
+
+/*****************************************************************************
+ *
+ *  int dma_config_m2m(ep93xx_dma_t * dma, unsigned int flags_m2m,
+ *			   dma_callback callback, unsigned int user_data)
+ *
+ *  Description: Configure the DMA channel and install a callback function.
+ *			   This function will have to be called for every transfer
+ *
+ *  dma:		Pointer to the dma instance data for the M2M channel to
+ *			  configure.
+ *  flags_m2m   Flags used to configure an M2M dma channel and determine
+ *			  if a callback function and user_data information are included
+ *			  in this call.
+ *  callback	function pointer which is called near the end of the
+ *			  dma channel's irq handler.
+ *  user_data   defined by the calling driver.
+ *
+ ****************************************************************************/
+static int
+dma_config_m2m(ep93xx_dma_t * dma, unsigned int flags_m2m,
+			   dma_callback callback, unsigned int user_data)
+{
+	unsigned long flags;
+	unsigned int M2M_reg_base, uiCONTROL;
+
+	/*
+	 *  Make sure the channel is disabled before configuring the channel.
+	 *
+	 *  TODO: Is this correct??   Making a big change here...
+	 */
+	/* if (!dma->pause || (!dma->pause && dma->xfer_enable)) */
+	if (dma->xfer_enable) {
+		/*
+		 *  DMA channel is not paused, so we can't configure it.
+		 */
+		DPRINTK("DMA channel not paused, so can't configure! \n");
+		return(-1);
+	}
+
+	/*
+	 *  Mask interrupts.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Setup a pointer into the dma channel's register set.
+	 */
+	M2M_reg_base = dma->reg_base;
+
+	uiCONTROL = inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+	outl(0, M2M_reg_base + M2M_OFFSET_CONTROL);
+	inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+	outl(uiCONTROL, M2M_reg_base + M2M_OFFSET_CONTROL);
+
+	/*
+	 *  By default we disable the stall interrupt.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL &= ~CONTROL_M2M_STALLINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  By default we disable the done interrupt.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL &= ~CONTROL_M2M_DONEINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  Set up the transfer control fields based on values passed in
+	 *  the flags_m2m field.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+
+	if ( flags_m2m & DESTINATION_HOLD )
+		uiCONTROL |= CONTROL_M2M_DAH;
+	else
+		uiCONTROL &= ~CONTROL_M2M_DAH;
+
+	if ( flags_m2m & SOURCE_HOLD )
+		uiCONTROL |= CONTROL_M2M_SAH;
+	else
+		uiCONTROL &= ~CONTROL_M2M_SAH;
+
+	uiCONTROL &= ~CONTROL_M2M_TM_MASK;
+	uiCONTROL |= (((flags_m2m & TRANSFER_MODE_MASK) >> TRANSFER_MODE_SHIFT) <<
+				  CONTROL_M2M_TM_SHIFT) & CONTROL_M2M_TM_MASK;
+
+	uiCONTROL &= ~CONTROL_M2M_PWSC_MASK;
+	uiCONTROL |= (((flags_m2m & WAIT_STATES_MASK) >> WAIT_STATES_SHIFT) <<
+				  CONTROL_M2M_PWSC_SHIFT) & CONTROL_M2M_PWSC_MASK;
+
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+
+	/*
+	 *  Save the callback function in the dma instance for this channel.
+	 */
+	dma->callback = callback;
+
+	/*
+	 *  Save the user data in the the dma instance for this channel.
+	 */
+	dma->user_data = user_data;
+
+	/*
+	 *  Put the dma instance into the pause state by setting the
+	 *  pause bit to true.
+	 */
+	dma->pause = TRUE;
+
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int dma_start(int handle, unsigned int channels, unsigned int * handles)
+ *
+ *  Description: Initiate a transfer on up to 3 channels.
+ *
+ *  handle:	 handle for the channel to initiate transfer on.
+ *  channels:   number of channels to initiate transfers on.
+ *  handles:	pointer to an array of handles, one for each channel which
+ *			   is to be started.
+ *
+ ****************************************************************************/
+static int
+dma_start_m2m(int channel, ep93xx_dma_t * dma)
+{
+	unsigned long flags;
+	unsigned int M2M_reg_base = dma->reg_base;
+	unsigned int uiCONTROL;
+
+	/*
+	 *  Mask interrupts while we get this started.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Make sure the channel has at least one buffer in the queue.
+	 */
+	if (dma->new_buffers < 1) {
+		/*
+		 *  Unmask irqs
+		 */
+		local_irq_restore(flags);
+
+		DPRINTK("DMA Start: Channel starved.\n");
+
+		/*
+		 *  This channel does not have enough buffers queued up,
+		 *  so enter the pause by starvation state.
+		 */
+		dma->xfer_enable = TRUE;
+		dma->pause = TRUE;
+
+		/*
+		 *  Success.
+		 */
+		return(0);
+	}
+
+	/*
+	 *  Clear any pending interrupts.
+	 */
+	outl(0x0, M2M_reg_base+M2M_OFFSET_INTERRUPT);
+
+	/*
+	 *  Set up one or both buffer descriptors with values from the next one or
+	 *  two buffers in the queue.  By default disable the next frame buffer
+	 *  interrupt on the channel.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL &= ~CONTROL_M2M_NFBINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 * enable the done interrupt.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL |= CONTROL_M2M_DONEINTEN;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+	/*
+	 *  Update the dma channel instance transfer state.
+	 */
+	dma->xfer_enable = TRUE;
+	dma->pause = FALSE;
+
+	/*
+	 *  Program up the first buffer descriptor with a source and destination
+	 *  and a byte count.
+	 */
+	outl( dma->buffer_queue[dma->current_buffer].source,
+	      M2M_reg_base+M2M_OFFSET_SAR_BASE0 );
+
+	outl( dma->buffer_queue[dma->current_buffer].dest,
+	      M2M_reg_base+M2M_OFFSET_DAR_BASE0 );
+
+	outl( dma->buffer_queue[dma->current_buffer].size,
+	      M2M_reg_base+M2M_OFFSET_BCR0 );
+
+	/*
+	 *  Decrement the new buffers counter.
+	 */
+	dma->new_buffers--;
+
+	/*
+	 * Set up the second buffer descriptor with a second buffer if we have
+	 * a second buffer.
+	 */
+	if (dma->new_buffers) {
+		outl( dma->buffer_queue[(dma->current_buffer + 1) %
+					MAX_EP93XX_DMA_BUFFERS].source,
+		      M2M_reg_base+M2M_OFFSET_SAR_BASE1 );
+
+		outl( dma->buffer_queue[(dma->current_buffer + 1) %
+					MAX_EP93XX_DMA_BUFFERS].dest,
+		      M2M_reg_base+M2M_OFFSET_DAR_BASE1 );
+
+		outl( dma->buffer_queue[(dma->current_buffer + 1) %
+					MAX_EP93XX_DMA_BUFFERS].size,
+		      M2M_reg_base+M2M_OFFSET_BCR1 );
+
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL |= CONTROL_M2M_NFBINTEN;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+
+		dma->new_buffers--;
+	}
+
+	/*
+	 *  Now we enable the channel.  This initiates the transfer.
+	 */
+	uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+	uiCONTROL |= CONTROL_M2M_ENABLE;
+	outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	inl(M2M_reg_base + M2M_OFFSET_CONTROL);
+
+	/*
+	 *  If this is a memory to memory transfer, we need to s/w trigger the
+	 *  transfer by setting the start bit within the control register.
+	 */
+	if (dma->device == DMA_MEMORY) {
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL |= CONTROL_M2M_START;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	}
+
+	DPRINTK("DMA - It's been started!!");
+	DPRINTK("CONTROL - 0x%x \n",	inl(M2M_reg_base+M2M_OFFSET_CONTROL) );
+	DPRINTK("STATUS - 0x%x \n",	 inl(M2M_reg_base+M2M_OFFSET_STATUS) );
+	DPRINTK("BCR0 - 0x%x \n",	   dma->buffer_queue[dma->current_buffer].size);
+	DPRINTK("SAR_BASE0 - 0x%x \n",  inl(M2M_reg_base+M2M_OFFSET_SAR_BASE0) );
+	DPRINTK("SAR_CUR0 - 0x%x \n",   inl(M2M_reg_base+M2M_OFFSET_SAR_CURRENT0) );
+	DPRINTK("DAR_BASE0 - 0x%x \n",  inl(M2M_reg_base+M2M_OFFSET_DAR_BASE0) );
+	DPRINTK("DAR_CUR0 - 0x%x \n",   inl(M2M_reg_base+M2M_OFFSET_DAR_CURRENT0) );
+
+	/*
+	 *  Unmask irqs
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  DMA interface functions
+ *
+ ****************************************************************************/
+
+/*****************************************************************************
+ *
+ *  int dma_init(int handle, unsigned int flags_m2p, unsigned int flags_m2m,
+ *			   dma_callback callback, unsigned int user_data)
+ *
+ *  Description: Configure the DMA channel and install a callback function.
+ *
+ *  handle:	 Handle unique the each instance of the dma interface, used
+ *			  to verify this call.
+ *  flags_m2p   Flags used to configure an M2P/P2M dma channel and determine
+ *			  if a callback function and user_data information are included
+ *			  in this call. This field should be NULL if handle represents
+ *			  an M2M channel.
+ *  flags_m2m   Flags used to configure an M2M dma channel and determine
+ *			  if a callback function and user_data information are included
+ *			  in this call. This field should be NULL if handle represents
+ *			  an M2P/P2M channel.
+ *  callback	function pointer which is called near the end of the
+ *			  dma channel's irq handler.
+ *  user_data   defined by the calling driver.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_config(int handle, unsigned int flags_m2p, unsigned int flags_m2m,
+		  dma_callback callback, unsigned int user_data)
+{
+	int  channel;
+	ep93xx_dma_t * dma;
+	unsigned long flags;
+	unsigned int M2P_reg_base, uiCONTROL;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR
+			   "DMA Config: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA Config \n");
+
+	dma = &dma_chan[channel];
+
+	local_irq_save(flags);
+
+	/*
+	 *  Check if the channel is currently transferring.
+	 */
+	if (dma->xfer_enable) {
+		local_irq_restore(flags);
+		return(-EINVAL);
+	}
+
+	/*
+	 *  Check if this is an m2m function.
+	 */
+	if (channel >= 10) {
+		local_irq_restore(flags);
+
+		/*
+		 *  Call another function to handle m2m config.
+		 */
+		return(dma_config_m2m(dma, flags_m2m, callback, user_data));
+	}
+
+	/*
+	 *  Setup a pointer into the dma channel's register set.
+	 */
+	M2P_reg_base = dma->reg_base;
+
+	/*
+	 *  By default we enable the stall interrupt.
+	 */
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	uiCONTROL |= CONTROL_M2P_STALLINTEN;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	/*
+	 *  Configure the channel for an error from the peripheral.
+	 */
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	if ( flags_m2p && CHANNEL_ERROR_INT_ENABLE )
+		uiCONTROL |= CONTROL_M2P_CHERRORINTEN;
+	else
+		uiCONTROL &= ~CONTROL_M2P_CHERRORINTEN;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	if ( flags_m2p && CHANNEL_ABORT )
+		uiCONTROL |= CONTROL_M2P_ABRT;
+	else
+		uiCONTROL &= ~CONTROL_M2P_ABRT;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+	if ( flags_m2p && IGNORE_CHANNEL_ERROR )
+		uiCONTROL |= CONTROL_M2P_ICE;
+	else
+		uiCONTROL &= ~CONTROL_M2P_ICE;
+	outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+
+	/*
+	 *  Save the callback function in the dma instance for this channel.
+	 */
+	dma->callback = callback;
+
+	/*
+	 *  Save the user data in the the dma instance for this channel.
+	 */
+	dma->user_data = user_data;
+
+	/*
+	 *  Put the dma instance into the pause state by setting the
+	 *  pause bit to true.
+	 */
+	dma->pause = TRUE;
+
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int dma_start(int handle, unsigned int channels, unsigned int * handles)
+ *
+ *  Description: Initiate a transfer on up to 3 channels.
+ *
+ *  handle:	 handle for the channel to initiate transfer on.
+ *  channels:   number of channels to initiate transfers on.
+ *  handles:	pointer to an array of handles, one for each channel which
+ *			   is to be started.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_start(int handle, unsigned int channels, unsigned int * handles)
+{
+	ep93xx_dma_t * dma_pointers[3];
+	unsigned int M2P_reg_bases[3];
+	unsigned int loop, uiCONTROL;
+	unsigned long flags;
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Start: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	if (channels < 1) {
+		printk(KERN_ERR "DMA Start: Invalid parameter.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA Start \n");
+
+	/*
+	 *  Mask off registers.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Check if this is a start multiple.
+	 */
+	if (channels > 1) {
+		DPRINTK("DMA ERROR: Start, multiple start not supported yet \n");
+		return(-1);
+	} else {
+		/*
+		 *  Check if this channel is already transferring.
+		 */
+		if (dma_chan[channel].xfer_enable && !dma_chan[channel].pause) {
+			printk(KERN_ERR
+				   "DMA Start: Invalid command for channel %d.\n", channel);
+
+			/*
+			 *  Unmask irqs
+			 */
+			local_irq_restore(flags);
+
+			/*
+			 *  This channel is already transferring, so return an error.
+			 */
+			return(-EINVAL);
+		}
+
+		/*
+		 *  If this is an M2M channel, call a different function.
+		 */
+		if (channel >= 10) {
+			/*
+			 *  Unmask irqs
+			 */
+			local_irq_restore(flags);
+
+			/*
+			 *  Call the m2m start function.  Only start one channel.
+			 */
+			return(dma_start_m2m(channel, &dma_chan[channel]));
+		}
+
+		/*
+		 *  Make sure the channel has at least one buffer in the queue.
+		 */
+		if (dma_chan[channel].new_buffers < 1) {
+			DPRINTK("DMA Start: Channel starved.\n");
+
+			/*
+			 *  This channel does not have enough buffers queued up,
+			 *  so enter the pause by starvation state.
+			 */
+			dma_chan[channel].xfer_enable = TRUE;
+			dma_chan[channel].pause = TRUE;
+
+			/*
+			 *  Unmask irqs
+			 */
+			local_irq_restore(flags);
+
+			/*
+			 *  Success.
+			 */
+			return(0);
+		}
+
+		/*
+		 *  Set up a dma instance pointer for this dma channel.
+		 */
+		dma_pointers[0] = &dma_chan[channel];
+
+		/*
+		 * Set up a pointer to the register set for this channel.
+		 */
+		M2P_reg_bases[0] = dma_pointers[0]->reg_base;
+	}
+
+	/*
+	 *  Setup both MAXCNT registers with values from the next two buffers
+	 *  in the queue, and enable the next frame buffer interrupt on the channel.
+	 */
+	for (loop = 0; loop < channels; loop++) {
+		/*
+		 *  Check if we need to restore a paused transfer.
+		 */
+		if (dma_pointers[loop]->pause_buf.buf_id != -1)
+			outl( dma_pointers[loop]->pause_buf.size,
+			      M2P_reg_bases[loop]+M2P_OFFSET_MAXCNT0 );
+		else
+			outl( dma_pointers[loop]->buffer_queue[dma_pointers[loop]->current_buffer].size,
+			      M2P_reg_bases[loop]+M2P_OFFSET_MAXCNT0 );
+	}
+
+	for (loop = 0; loop < channels; loop++) {
+		/*
+		 *  Enable the specified dma channels.
+		 */
+		uiCONTROL = inl(M2P_reg_bases[loop]+M2P_OFFSET_CONTROL);
+		uiCONTROL |= CONTROL_M2P_ENABLE;
+		outl( uiCONTROL, M2P_reg_bases[loop]+M2P_OFFSET_CONTROL );
+
+		/*
+		 *  Update the dma channel instance transfer state.
+		 */
+		dma_pointers[loop]->xfer_enable = TRUE;
+		dma_pointers[loop]->pause = FALSE;
+	}
+
+	/*
+	 *  Program up the BASE0 registers for all specified channels, this
+	 *  will initiate transfers on all specified channels.
+	 */
+	for (loop = 0; loop < channels; loop++)
+		/*
+		 *  Check if we need to restore a paused transfer.
+		 */
+		if (dma_pointers[loop]->pause_buf.buf_id != -1) {
+			outl( dma_pointers[loop]->pause_buf.source,
+			      M2P_reg_bases[loop]+M2P_OFFSET_BASE0 );
+
+			/*
+			 *  Set the pause buffer to NULL
+			 */
+			dma_pointers[loop]->pause_buf.buf_id = -1;
+			dma_pointers[loop]->pause_buf.size = 0;
+		} else if(dma_pointers[loop]->new_buffers){
+			outl( dma_pointers[loop]->buffer_queue[
+				  dma_pointers[loop]->current_buffer].source,
+			      M2P_reg_bases[loop]+M2P_OFFSET_BASE0 );
+            dma_pointers[loop]->new_buffers--;
+            
+          }
+
+	/*
+	 *  Before restoring irqs setup the second MAXCNT/BASE
+	 *  register with a second buffer.
+	 */
+	for (loop = 0; loop < channels; loop++)
+		if (dma_pointers[loop]->new_buffers) {
+        	/*
+        	 *  By default we enable the next frame buffer interrupt.
+        	 */
+        	uiCONTROL = inl(M2P_reg_bases[loop]+M2P_OFFSET_CONTROL);
+        	uiCONTROL |= CONTROL_M2P_NFBINTEN;
+        	outl( uiCONTROL, M2P_reg_bases[loop]+M2P_OFFSET_CONTROL );
+
+			outl( dma_pointers[loop]->buffer_queue[
+				  (dma_pointers[loop]->current_buffer + 1) %
+				  MAX_EP93XX_DMA_BUFFERS].size,
+			      M2P_reg_bases[loop]+M2P_OFFSET_MAXCNT1 );
+
+			outl( dma_pointers[loop]->buffer_queue[
+				  (dma_pointers[loop]->current_buffer + 1) %
+				  MAX_EP93XX_DMA_BUFFERS].source,
+			      M2P_reg_bases[loop]+M2P_OFFSET_BASE1 );
+            dma_pointers[loop]->new_buffers--;
+		}
+
+	/*
+	  DPRINTK("DMA - It's been started!!");
+	  DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+	  DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+	  DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+	  DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+	  DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+	  DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+	  DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+	  DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+	  DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+	  DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+	  DPRINTK("Pause - %d \n", dma_pointers[0]->pause);
+	  DPRINTK("xfer_enable - %d \n", dma_pointers[0]->xfer_enable);
+	  DPRINTK("total bytes - 0x%x \n", dma_pointers[0]->total_bytes);
+	  DPRINTK("total buffer - %d \n", dma_pointers[0]->total_buffers);
+	  DPRINTK("new buffers - %d \n", dma_pointers[0]->new_buffers);
+	  DPRINTK("current buffer - %d \n", dma_pointers[0]->current_buffer);
+	  DPRINTK("last buffer - %d \n", dma_pointers[0]->last_buffer);
+	  DPRINTK("used buffers - %d \n", dma_pointers[0]->used_buffers);
+	*/
+	/*
+	 *  Unmask irqs
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_add_buffer(int handle, unsigned int * address,
+ *						 unsigned int size, unsigned int last)
+ *
+ *  Description: Add a buffer entry to the DMA buffer queue.
+ *
+ *  handle:	 handle for the channel to add this buffer to.
+ *  address:	Pointer to an integer which is the start address of the
+ *			  buffer which is to be added to the queue.
+ *  size:	   size of the buffer in bytes.
+ *  last:	   1 if this is the last buffer in this stream, 0 otherwise.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_add_buffer(int handle, unsigned int source, unsigned int dest,
+		      unsigned int size, unsigned int last,
+		      unsigned int buf_id)
+{
+	unsigned long flags;
+	ep93xx_dma_t * dma;
+	int  channel;
+#if 0
+	static int peak_total_buffers=0;
+#endif
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR
+			   "DMA Add Buffer: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	/*
+	 *  Get a pointer to the dma instance.
+	 */
+	dma = &dma_chan[channel];
+
+#if 0	
+	if( dma->total_buffers > peak_total_buffers )
+	{
+	    peak_total_buffers=dma->total_buffers;
+	    printk("peak_total_buffers=%d\n", peak_total_buffers );
+	}
+#endif
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  If the buffer queue is full, last_buffer is the same as current_buffer and
+	 *  we're not tranfering, or last_buffer is pointing to a used buffer, then exit.
+	 *  TODO: do I need to do any more checks?
+	 */
+	if (dma->total_buffers >= MAX_EP93XX_DMA_BUFFERS) 
+	{
+		DPRINTK("too many dma buffers: MAX_EP93XX_DMA_BUFFERS set to low ?\n");
+		/*
+		 *  Restore the state of the irqs
+		 */
+		local_irq_restore(flags);
+
+		/*
+		 *  Fail.
+		 */
+		return(-1);
+	}
+
+	/*
+	 *  Add this buffer to the queue
+	 */
+	dma->buffer_queue[dma->last_buffer].source = source;
+	dma->buffer_queue[dma->last_buffer].dest = dest;
+	dma->buffer_queue[dma->last_buffer].size = size;
+	dma->buffer_queue[dma->last_buffer].last = last;
+	dma->buffer_queue[dma->last_buffer].buf_id = buf_id;
+
+	/*
+	 *  Reset the used field of the buffer structure.
+	 */
+	dma->buffer_queue[dma->last_buffer].used = FALSE;
+
+	/*
+	 *  Increment the End Item Pointer.
+	 */
+	dma->last_buffer = (dma->last_buffer + 1) % MAX_EP93XX_DMA_BUFFERS;
+
+	/*
+	 *  Increment the new buffers counter and the total buffers counter
+	 */
+	dma->new_buffers++;
+	dma->total_buffers++;
+
+	/*
+	 *  restore the interrupt state.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Check if the channel was starved into a stopped state.
+	 */
+	if (dma->pause && dma->xfer_enable) {
+		if (dma->new_buffers >= 1) {
+			DPRINTK("DMA - calling start from add after starve. \n");
+
+			/*
+			 *  The channel was starved into a stopped state, and we've got
+			 *  2 new buffers, so start tranferring again.
+			 */
+			ep93xx_dma_start(handle, 1, 0);
+		}
+	}
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_remove_buffer(int handle, unsigned int * address,
+ *								unsigned int * size)
+ *
+ *  Description: Remove a buffer entry from the DMA buffer queue. If
+ *			   buffer was removed successfully, return 0, otherwise
+ *			   return -1.
+ *
+ *  handle:	 handle for the channel to remove a buffer from.
+ *  address:	Pointer to an integer which is filled in with the start
+ *			  address of the removed buffer.
+ *  size:	   Pointer to an integer which is filled in with the size in
+ *			  bytes of the removed buffer.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_remove_buffer(int handle, unsigned int * buf_id)
+{
+	unsigned int test;
+	unsigned int loop;
+	int return_val = -1;
+	unsigned long flags;
+	ep93xx_dma_t *dma;
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR
+			   "DMA Remove Buffer: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Make sure there are used buffers to be returned.
+	 */
+	if (dma->used_buffers) {
+		test = dma->last_buffer;
+
+		for (loop = 0; loop < MAX_EP93XX_DMA_BUFFERS; loop++) {
+			if (dma->buffer_queue[test].used && (dma->buffer_queue[test].buf_id != -1)) {
+				/*DPRINTK("buffer %d used \n", test); */
+
+				/*
+				 *  This is a used buffer, fill in the buf_id pointer
+				 *  with the buf_id for this buffer.
+				 */
+				*buf_id = dma->buffer_queue[test].buf_id;
+
+				/*
+				 *  Reset this buffer structure
+				 */
+				dma->buffer_queue[test].buf_id = -1;
+
+				/*
+				 *  Decrement the used buffer counter, and the total buffer counter.
+				 */
+				dma->used_buffers--;
+				dma->total_buffers--;
+
+				/*
+				 *  Successful removal of a buffer, so set the return
+				 *  value to 0, then exit this loop.
+				 */
+				return_val = 0;
+				break;
+			}
+
+			/*
+			 *  This buffer isn't used, let's see if the next one is.
+			 */
+			test = (test + 1) % MAX_EP93XX_DMA_BUFFERS;
+		}
+	}
+
+	/*
+	 *  Restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(return_val);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_pause(int handle, unsigned int channels,
+ *					   unsigned int * handles)
+ *
+ *  Description: Disable any ongoing transfer for the given channel, retaining
+ *			   the state of the current buffer transaction so that upon
+ *			   resume, the dma will continue where it left off.
+ *
+ *  handle:	 Handle for the channel to be paused.  If this is a pause for
+ *			  for multiple channels, handle is a valid handle for one of
+ *			  the channels to be paused.
+ *  channels:   number of channel to pause transfers on.
+ *  handles:	Pointer to an array of handles, one for each channel which
+ *			  to be paused.  If this pause is intended only for one
+ *			  channel, this field should be set to NULL.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_pause(int handle, unsigned int channels, unsigned int * handles)
+{
+	unsigned long flags;
+	ep93xx_dma_t * dma;
+	int channel;
+
+	DPRINTK("ep93xx_dma_pause \n");
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		/*
+		 *  restore interrupts.
+		 */
+		local_irq_restore(flags);
+
+		printk(KERN_ERR
+			   "DMA Pause: Invalid dma handle.\n");
+
+		/*
+		 *  Fail.
+		 */
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: pause \n", channel);
+
+	/*
+	 *  Set up a pointer to the dma instance data.
+	 */
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Check if we're already paused.
+	 */
+	if (dma->pause) {
+		/*
+		 *  We're paused, but are we stopped?
+		 */
+		if (dma->xfer_enable)
+			/*
+			 *  Put the channel in the stopped state.
+			 */
+			dma->xfer_enable = FALSE;
+
+		DPRINTK("DMA Pause - already paused.");
+	} else {
+		/*
+		 *  Put the channel into the stopped state.
+		 */
+		dma->xfer_enable = FALSE;
+		dma->pause = TRUE;
+	}
+
+	/*
+	 *  restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Already paused, so exit.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  void ep93xx_dma_flush(int handle)
+ *
+ *  Description: Flushes all queued buffers and transfers in progress
+ *			   for the given channel.  Return the buffer entries
+ *			   to the calling function.
+ *
+ *  handle:	 handle for the channel for which the flush is intended.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_flush(int handle)
+{
+	unsigned int loop;
+	unsigned long flags;
+	ep93xx_dma_t * dma;
+	int  channel;
+	unsigned int M2P_reg_base,uiCONTROL;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Flush: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: flush \n", channel);
+
+	/*
+	 *  Set up a pointer to the dma instance data for this channel
+	 */
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  Disable the dma channel
+	 */
+	if (channel < 10) {
+		/*
+		 *  M2P channel
+		 */
+		uiCONTROL = inl(dma->reg_base+M2P_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2P_ENABLE;
+		outl( uiCONTROL, dma->reg_base+M2P_OFFSET_CONTROL );
+	} else {
+		/*
+		 *  M2M channel
+		 */
+		uiCONTROL = inl(dma->reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, dma->reg_base+M2M_OFFSET_CONTROL );
+	}
+
+	for (loop = 0; loop < MAX_EP93XX_DMA_BUFFERS; loop++)
+	{
+		dma->buffer_queue[loop].buf_id = -1;
+		dma->buffer_queue[loop].last = 0;
+	}
+
+	/*
+	 *  Set the Current and Last item to zero.
+	 */
+	dma->current_buffer = 0;
+	dma->last_buffer = 0;
+
+	/*
+	 *  Reset the Buffer counters
+	 */
+	dma->used_buffers = 0;
+	dma->new_buffers = 0;
+	dma->total_buffers = 0;
+
+	/*
+	 *  reset the Total bytes counter.
+	 */
+	dma->total_bytes = 0;
+
+    /*
+     * Reset the paused buffer.
+     */
+     dma->pause_buf.last = 0;
+     dma->pause_buf.buf_id = -1;
+
+	M2P_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_queue_full(int handle)
+ *
+ *  Description: Query to determine if the DMA queue of buffers for
+ *			  a given channel is full.
+ *			  0 = queue is full
+ *			  1 = queue is not full
+ *
+ *  handle:	 handle for the channel to query.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_queue_full(int handle)
+{
+	int list_full = 0;
+	unsigned long flags;
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Queue Full: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: queue full \n", channel);
+
+	/*
+	 *  Mask interrupts and hold on to the original state.
+	 */
+	local_irq_save(flags);
+
+	/*
+	 *  If the last item is equal to the used item then
+	 *  the queue is full.
+	 */
+	if (dma_chan[channel].total_buffers < MAX_EP93XX_DMA_BUFFERS)
+		list_full =  FALSE;
+	else
+		list_full = TRUE;
+
+	/*
+	 *  restore interrupts.
+	 */
+	local_irq_restore(flags);
+
+	return(list_full);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_get_position()
+ *
+ *  Description:  Takes two integer pointers and fills them with the start
+ *                and current address of the buffer currently transferring
+ *                on the specified DMA channel.
+ *
+ *  handle         handle for the channel to query.
+ *  *buf_id        buffer id for the current buffer transferring on the
+ *                 dma channel.
+ *  *total         total bytes transferred on the channel.  Only counts  
+ *                 whole buffers transferred.
+ *  *current_frac  number of bytes transferred so far in the current buffer.
+ ****************************************************************************/
+int
+ep93xx_dma_get_position(int handle, unsigned int * buf_id,
+                        unsigned int * total, unsigned int * current_frac )
+{
+	int  channel;
+	ep93xx_dma_t * dma;
+	unsigned int buf_id1, total1, current_frac1, buf_id2, total2;
+	unsigned int Status, NextBuffer, StateIsBufNext, M2P_reg_base=0;
+	unsigned int pause1, pause2;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.  See if this is a 
+	 *  valid handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Get Position: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	dma = &dma_chan[channel];
+
+	/*
+	 * If DMA moves to a new buffer in the middle of us grabbing the 
+	 * buffer info, then do it over again.
+	 */
+	do{
+		buf_id1 = dma->buffer_queue[dma->current_buffer].buf_id;
+		total1  = dma->total_bytes;
+		pause1  = dma->pause;
+
+		if (channel < 10) {
+			// M2P
+			M2P_reg_base = dma->reg_base;
+
+			Status = inl(M2P_reg_base+M2P_OFFSET_STATUS);
+
+			NextBuffer = ((Status & STATUS_M2P_NEXTBUFFER) != 0);
+
+			StateIsBufNext = ((Status & STATUS_M2P_CURRENT_MASK) == 
+			                  STATUS_M2P_DMA_BUF_NEXT);
+			
+			if( NextBuffer ^ StateIsBufNext )
+				current_frac1 = inl(M2P_reg_base+M2P_OFFSET_CURRENT1) -
+				                inl(M2P_reg_base+M2P_OFFSET_BASE1);	
+			else
+				current_frac1 = inl(M2P_reg_base+M2P_OFFSET_CURRENT0) -
+				                inl(M2P_reg_base+M2P_OFFSET_BASE0);	
+			
+		} else { 
+			// M2M - TODO implement this for M2M
+			current_frac1 = 0;
+		}
+		
+		buf_id2 = dma->buffer_queue[dma->current_buffer].buf_id;
+		total2 = dma->total_bytes;
+		pause2  = dma->pause;
+
+	} while ( (buf_id1 != buf_id2) || (total1 != total2) || (pause1 != pause2) );
+
+	if (pause1)
+		current_frac1 = 0;
+
+	if (buf_id)
+		*buf_id = buf_id1;
+
+	if (total)
+		*total  = total1;
+
+	if (current_frac)
+		*current_frac = current_frac1;
+	
+//	DPRINTK("DMA buf_id %d, total %d, frac %d\n", buf_id1, total1, current_frac1);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_get_total(int handle)
+ *
+ *  Description:	Returns the total number of bytes transferred on the
+ *			specified channel since the channel was requested.
+ *
+ *  handle:	 handle for the channel to query.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_get_total(int handle)
+{
+	int  channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Get Total: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	DPRINTK("DMA %d: total: %d \n", channel, dma_chan[channel].total_bytes);
+
+	/*
+	 *  Return the total number of bytes transferred on this channel since
+	 *  it was requested.
+	 */
+	return(dma_chan[channel].total_bytes);
+}
+
+/*****************************************************************************
+ *
+ *  int ep93xx_dma_is_done(int handle)
+ *
+ *  Description:	Determines if the specified channel is done
+ *			transferring the requested data.
+ *
+ *  handle:	 handle for the channel to query.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_is_done(int handle)
+{
+	ep93xx_dma_t *dma;
+	int channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "ep93xx_dma_is_done: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+        /*
+         * Get a pointer to the DMA channel state structure.
+         */
+        dma = &dma_chan[channel];
+
+        /*
+         * See if there are any buffers remaining to be provided to the HW.
+         */
+        if (dma->new_buffers)
+            return 0;
+
+        /*
+         * See if this is a M2P or M2M channel.
+         */
+        if (channel < 10) {
+            /*
+             * If the bytes remaining register of the HW is not zero, then
+             * there is more work to be done.
+             */
+            if (inl(dma->reg_base + M2P_OFFSET_REMAIN) != 0)
+                return 0;
+        } else {
+            /*
+             * If either byte count register in the HW is not zero, then there
+             * is more work to be done.
+             */
+            if ((inl(dma->reg_base + M2M_OFFSET_BCR0) != 0) ||
+                (inl(dma->reg_base + M2M_OFFSET_BCR1) != 0))
+                return 0;
+        }
+
+        /*
+         * The DMA is complete.
+         */
+        return 1;
+}
+
+/*****************************************************************************
+ * ep93xx_dma_request
+ *
+ * Description: This function will allocate a DMA channel for a particular
+ * hardware peripheral.  Before initiating a transfer on the allocated
+ * channel, the channel must be set up and buffers have to queued up.
+ *
+ *  handle:	 pointer to an integer which is filled in with a unique
+ *			  handle for this instance of the dma interface.
+ *  device_id   string with the device name, primarily used by /proc.
+ *  device	  hardware device ID for which the requested dma channel will
+ *			  transfer data.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_request(int * handle, const char *device_id,
+				   ep93xx_dma_dev_t device)
+{
+	ep93xx_dma_t *dma = NULL;
+	int channel;
+	unsigned int error = 0;
+	unsigned int loop;
+	unsigned int M2P_reg_base;
+
+	/*
+	 *  Check if the device requesting a DMA channel is a valid device.
+	 */
+	if ((device >= UNDEF) || (device < 0))
+		return(-ENODEV);
+
+	/*
+	 *  We've got a valid hardware device requesting a DMA channel.
+	 *  Now check if the device should open an M2P or M2M channel
+	 */
+	if (device < 20)
+		channel = dma_open_m2p(device);
+	else
+		channel = dma_open_m2m(device);
+
+	/*
+	 *  Check if we successfully opened a DMA channel
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "%s: Could not open dma channel for this device.\n",
+			   device_id);
+		return(-EBUSY);
+	}
+
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Request the appropriate IRQ for the specified channel
+	 */
+	if (channel < 10)
+		error = request_irq(dma->irq, dma_m2p_irq_handler,
+				    SA_INTERRUPT, device_id, (void *) dma);
+	else
+		error = request_irq(dma->irq, &dma_m2m_irq_handler,
+				    SA_INTERRUPT, device_id, (void *) dma);
+	/*
+	 *  Check for any errors during the irq request
+	 */
+	if (error) {
+		printk(KERN_ERR "%s: unable to request IRQ %d for DMA channel\n",
+			   device_id, dma->irq);
+		return(error);
+	}
+
+	/*
+	 *  Generate a valid handle and exit.
+	 *
+	 *  Increment the last valid handle.
+	 *  Check for wraparound (unlikely, but we like to be complete).
+	 */
+	dma->last_valid_handle++;
+
+	if ( (dma->last_valid_handle & DMA_HANDLE_SPECIFIER_MASK) !=
+	     (channel << 28) )
+		dma->last_valid_handle = (channel << 28) + 1;
+
+	/*
+	 *  Fill in the handle pointer with a valid handle for
+	 *  this dma channel instance.
+	 */
+	*handle = dma->last_valid_handle;
+
+	DPRINTK("Handle for channel %d: 0x%x\n", channel, *handle);
+
+	/*
+	 * Save the device ID and device name.
+	 */
+	dma->device = device;
+	dma->device_id = device_id;
+
+	/*
+	 *  Init all fields within the dma instance.
+	 */
+	for (loop = 0; loop < MAX_EP93XX_DMA_BUFFERS; loop++)
+		dma->buffer_queue[loop].buf_id = -1;
+
+	/*
+	 *  Initialize all buffer queue variables.
+	 */
+	dma->current_buffer = 0;
+	dma->last_buffer = 0;
+
+	dma->new_buffers = 0;
+	dma->used_buffers = 0;
+	dma->total_buffers = 0;
+
+	/*
+	 *  Initialize the total bytes variable
+	 */
+	dma->total_bytes = 0;
+
+	/*
+	 *  Initialize the transfer and pause state variables to 0.
+	 */
+	dma->xfer_enable = 0;
+
+	dma->pause = 0;
+
+	/*
+	 *  Initialize the pause buffer structure.
+	 */
+	dma->pause_buf.buf_id = -1;
+
+	/*
+	 *  Initialize the callback function and user data fields.
+	 */
+	dma->callback = NULL;
+
+	/*
+	 * User data used as a parameter for the Callback function.  The user
+	 * sets up the data and sends it with the callback function.
+	 */
+	dma->user_data = 0;
+
+	M2P_reg_base = dma_chan[channel].reg_base;
+
+	/*
+	 *  Debugging message.
+	 */
+	DPRINTK("Successfully requested dma channel %d\n", channel);
+	DPRINTK("STATUS - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_STATUS) );
+	DPRINTK("CONTROL - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_CONTROL) );
+	DPRINTK("REMAIN - 0x%x \n",	 inl(M2P_reg_base+M2P_OFFSET_REMAIN) );
+	DPRINTK("PPALLOC - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_PPALLOC) );
+	DPRINTK("BASE0 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE0) );
+	DPRINTK("MAXCNT0 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT0) );
+	DPRINTK("CURRENT0 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT0) );
+	DPRINTK("BASE1 - 0x%x \n",	  inl(M2P_reg_base+M2P_OFFSET_BASE1) );
+	DPRINTK("MAXCNT1 - 0x%x \n",	inl(M2P_reg_base+M2P_OFFSET_MAXCNT1) );
+	DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+
+	DPRINTK("Buffer	source	   size	   last	   used \n");
+	for (loop = 0; loop < 5; loop ++)
+		DPRINTK("%d		0x%x		 0x%x		%d		 %d \n",
+			loop, dma->buffer_queue[loop].source, dma->buffer_queue[loop].size,
+			dma->buffer_queue[loop].last, dma->buffer_queue[loop].used);
+	DPRINTK("pause	 0x%x		 0x%x		%d		 %d \n",
+		dma->pause_buf.source, dma->pause_buf.size,
+		dma->pause_buf.last, dma->pause_buf.used);
+
+	DPRINTK("Pause - %d \n", dma->pause);
+	DPRINTK("xfer_enable - %d \n", dma->xfer_enable);
+	DPRINTK("total bytes - 0x%x \n", dma->total_bytes);
+	DPRINTK("total buffer - %d \n", dma->total_buffers);
+	DPRINTK("new buffers - %d \n", dma->new_buffers);
+	DPRINTK("current buffer - %d \n", dma->current_buffer);
+	DPRINTK("last buffer - %d \n", dma->last_buffer);
+	DPRINTK("used buffers - %d \n", dma->used_buffers);
+
+	DPRINTK("CURRENT1 - 0x%x \n",   inl(M2P_reg_base+M2P_OFFSET_CURRENT1) );
+	DPRINTK("VIC0IRQSTATUS - 0x%x, VIC0INTENABLE - 0x%x \n",
+		*(unsigned int *)(VIC0IRQSTATUS),
+		*(unsigned int *)(VIC0INTENABLE));
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ * ep93xx_dma_free
+ *
+ * Description: This function will free the dma channel for future requests.
+ *
+ *  handle:	 handle for the channel to be freed.
+ *
+ ****************************************************************************/
+int
+ep93xx_dma_free(int handle)
+{
+	ep93xx_dma_t *dma;
+	unsigned int M2M_reg_base, M2P_reg_base, uiCONTROL;
+	int channel;
+
+	/*
+	 *  Get the DMA hw channel # from the handle.
+	 */
+	channel = dma_get_channel_from_handle(handle);
+
+	/*
+	 *  See if this is a valid handle.
+	 */
+	if (channel < 0) {
+		printk(KERN_ERR "DMA Free: Invalid dma handle.\n");
+		return(-EINVAL);
+	}
+
+	/*
+	 *  Get a pointer to the dma instance.
+	 */
+	dma = &dma_chan[channel];
+
+	/*
+	 *  Disable the dma channel
+	 */
+	if (channel < 10) {
+		/*
+		 *  M2P channel
+		 */
+		M2P_reg_base = dma->reg_base;
+
+		uiCONTROL = inl(M2P_reg_base+M2P_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2P_ENABLE;
+		outl( uiCONTROL, M2P_reg_base+M2P_OFFSET_CONTROL );
+	} else {
+		/*
+		 *  M2M channel
+		 */
+		M2M_reg_base = dma->reg_base;
+
+		uiCONTROL = inl(M2M_reg_base+M2M_OFFSET_CONTROL);
+		uiCONTROL &= ~CONTROL_M2M_ENABLE;
+		outl( uiCONTROL, M2M_reg_base+M2M_OFFSET_CONTROL );
+	}
+
+	/*
+	 *  Free the interrupt servicing this dma channel
+	 */
+	free_irq(dma->irq, (void *) dma);
+
+	/*
+	 *  Decrement the reference count for this instance of the dma interface
+	 */
+	dma->ref_count--;
+
+	/*
+	 *  Set the transfer and pause state variables to 0
+	 *  (unititialized state).
+	 */
+	dma->xfer_enable = 0;
+	dma->pause = 0;
+
+	/*
+	 *  Debugging message.
+	 */
+	DPRINTK("Successfully freed dma channel %d\n", channel);
+
+	/*
+	 *  Success.
+	 */
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ * ep93xx_dma_init(void)
+ *
+ * Description: This function is called during system initialization to
+ * setup the interrupt number and register set base address for each DMA
+ * channel.
+ *
+ ****************************************************************************/
+static int __init
+ep93xx_dma_init(void)
+{
+	int channel;
+
+	/*
+	 * Init some values in each dma instance.
+	 */
+	for (channel = 0; channel < MAX_EP93XX_DMA_CHANNELS; channel++) {
+		/*
+		 *  IRQ for the specified dma channel.
+		 */
+		dma_chan[channel].irq = IRQ_DMAM2P0 + channel;
+
+		/*
+		 *  Initial value of the dma channel handle.
+		 */
+		dma_chan[channel].last_valid_handle = channel << 28;
+
+		/*
+		 *  Give the instance a pointer to the dma channel register
+		 *  base.
+		 */
+		if (channel < 10)
+			dma_chan[channel].reg_base = DMAM2PChannelBase[channel];
+		else
+			dma_chan[channel].reg_base = DMAM2MChannelBase[channel - 10];
+
+		/*
+		 *  Initialize the reference count for this channel.
+		 */
+		dma_chan[channel].ref_count = 0;
+	}
+
+	DPRINTK("DMA Interface intitialization complete\n");
+
+	/*
+	 * Success
+	 */
+	return 0;
+}
+
+arch_initcall(ep93xx_dma_init);
+
+EXPORT_SYMBOL(ep93xx_dma_free);
+EXPORT_SYMBOL(ep93xx_dma_request);
+EXPORT_SYMBOL(ep93xx_dma_flush);
+EXPORT_SYMBOL(ep93xx_dma_pause);
+EXPORT_SYMBOL(ep93xx_dma_remove_buffer);
+EXPORT_SYMBOL(ep93xx_dma_add_buffer);
+EXPORT_SYMBOL(ep93xx_dma_start);
+EXPORT_SYMBOL(ep93xx_dma_config);
+
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/dma_ep93xx.h linux-2.6.8.1/arch/arm/mach-ep93xx/dma_ep93xx.h
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/dma_ep93xx.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/dma_ep93xx.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,199 @@
+/*****************************************************************************
+ *
+ * arch/arm/mach-ep93xx/dma_ep93xx.h
+ *
+ * DESCRIPTION:    93XX DMA controller API private defintions.
+ *
+ * Copyright Cirrus Logic Corporation, 2003.  All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#ifndef _EP93XX_DMA_H_
+#define _EP93XX_DMA_H_
+
+// as it turns out the ide dma is the biggest dma buffer hog so far
+// in case the HDD is "thinking" (seek/buffer flush)
+// the continueing r/w DMAs to the HDD will be queued up to up to PRD_ENTRIES entries...
+#include <linux/ide.h>
+#define MAX_EP93XX_DMA_BUFFERS      PRD_ENTRIES
+
+#ifndef TRUE
+#define TRUE                        1
+#endif
+
+#ifndef FALSE
+#define FALSE                       0
+#endif
+
+#ifndef NULL
+#define NULL                        0
+#endif
+
+/*****************************************************************************
+ *
+ * DMA buffer structure type.
+ *
+ ****************************************************************************/
+typedef struct ep93xx_dma_buffer_s
+{
+    unsigned int    source;     /* buffer physical source address.          */
+    unsigned int    dest;       /* buffer physical destination address,     */
+                                /* only used with the 2 M2M channels.       */
+    unsigned int    size;       /* buffer size in bytes                     */
+    unsigned int    last;       /* 1 if this is the last buffer             */
+                                /* in this transaction.  If 1,              */
+                                /* disable the NFBint so we aren't          */
+                                /* interrupted for another buffer           */
+                                /* when we know there won't be another.     */
+    unsigned int    used;       /* This field is set to 1 by the DMA        */
+                                /* interface after the buffer is transferred*/
+    int    buf_id;              /* unique identifyer specified by the       */
+                                /* the driver which requested the dma       */
+} ep93xx_dma_buffer_t;
+
+typedef ep93xx_dma_buffer_t * ep93xx_dma_buffer_p;
+
+/*****************************************************************************
+ *
+ * Instance definition for the DMA interface.
+ *
+ ****************************************************************************/
+typedef struct ep9312_dma_s
+{
+    /*
+     *  This 1 when the instance is in use, and 0 when it's not.
+     */
+    unsigned int ref_count;
+
+    /*
+     * This is the last valid handle for this instance.  When giving out a
+     * new handle this will be incremented and given out.
+     */
+    int last_valid_handle;
+
+    /*
+     * device specifies one of the 20 DMA hardware ports this 
+     * DMA channel will service.
+     */
+    ep93xx_dma_dev_t device;
+
+    /*
+     * DMABufferQueue is the queue of buffer structure pointers which the
+     * dma channel will use to setup transfers.
+     */
+    ep93xx_dma_buffer_t buffer_queue[MAX_EP93XX_DMA_BUFFERS];
+
+    /*
+     * currnt_buffer : This is the buffer currently being transfered on 
+     *                 this channel.
+     * last_buffer : This is the last buffer for this transfer.
+     * Note: current_buffer + 1 is already programmed into the dma
+     *       channel as the next buffer to transfer. Don't write
+     *       over either entry.
+     */
+    int current_buffer;
+    int last_buffer;
+
+    /*
+     * The following 3 fields are buffer counters.
+     *
+     * iNewBuffers: Buffers in the queue which have not been transfered.
+     * iUsedBuffers: Buffers in the queue which have have been tranferred,
+     *               and are waiting to be returned.
+     * iTotalBuffers: Total number of buffers in the queue.
+     */  
+    int new_buffers;
+    int used_buffers;
+    int total_buffers;
+
+    /*
+     * uiTotalBytes has the total bytes transfered on the channel since the
+     * last flush.  This value does not include the bytes tranfered in the
+     * current buffer.  A byte count is only added after a complete buffer
+     * is tranfered. 
+     */
+    unsigned int total_bytes;
+
+    /*
+     *  Interrupt number for this channel
+     */
+    unsigned int irq;
+
+    /*
+     * Indicates whether or not the channel is currently enabled to transfer
+     * data.
+     */
+    unsigned int xfer_enable;
+    
+    /*
+     * pause indicates if the dma channel was paused by calling the pause
+     * ioctl.
+     */
+    unsigned int pause;
+    
+    /*
+     *  buffer structure used during a pause to capture the current
+     *  address and remaining bytes for the buffer actively being transferred
+     *  on the channel. This buffer will be used to reprogram the dma 
+     *  channel upon a resume.
+     */
+    ep93xx_dma_buffer_t pause_buf;
+    
+    /*
+     * DMACallback is a function pointer which the calling application can 
+     * use install a function to.  this fuction can be used to notify the 
+     * calling application of an interrupt.
+     */
+    dma_callback callback;
+
+    /*
+     * User data used as a parameter for the Callback function.  The user
+     * sets up the data and sends it with the callback function.
+     */
+    unsigned int user_data;
+    
+    /*
+     * A string representation of the device attached to the channel.
+     */
+    const char * device_id;
+    
+    /*
+     * The register base address for this dma channel.
+     */
+    unsigned int reg_base;
+    
+} ep93xx_dma_t;
+
+/*****************************************************************************
+ *
+ * DMA macros
+ *
+ ****************************************************************************/
+#define DMA_HANDLE_SPECIFIER_MASK   0xF0000000
+#define DMA_CH0_HANDLE_SPECIFIER    0x00000000
+#define DMA_CH1_HANDLE_SPECIFIER    0x10000000
+#define DMA_CH2_HANDLE_SPECIFIER    0x20000000
+#define DMA_CH3_HANDLE_SPECIFIER    0x30000000
+#define DMA_CH4_HANDLE_SPECIFIER    0x40000000
+#define DMA_CH5_HANDLE_SPECIFIER    0x50000000
+#define DMA_CH6_HANDLE_SPECIFIER    0x60000000
+#define DMA_CH7_HANDLE_SPECIFIER    0x70000000
+#define DMA_CH8_HANDLE_SPECIFIER    0x80000000
+#define DMA_CH9_HANDLE_SPECIFIER    0x90000000
+#define DMA_CH10_HANDLE_SPECIFIER   0xA0000000
+#define DMA_CH11_HANDLE_SPECIFIER   0xB0000000
+
+#endif // _DMADRV_H_
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/ee.c linux-2.6.8.1/arch/arm/mach-ep93xx/ee.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/ee.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/ee.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,21 @@
+/*
+ *  linux/arch/arm/mach-ep93xx/ee.c
+ *
+ *  Copyright (C) 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+/* This file intentionally left blank */
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/irq.c linux-2.6.8.1/arch/arm/mach-ep93xx/irq.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/irq.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,102 @@
+/*
+ *  linux/arch/arm/mach-ep93xx/irq.c
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * (c) Copyright 2001 LynuxWorks, Inc., San Jose, CA.  All rights reserved.
+ *
+ *  Copyright (C) 2002-2003 Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+/********************************************************************
+ *	Interrupt functions are defined as machine specific here.
+ *
+ *	Note:
+ *		1.  Only normal interrupts are defined here.
+ *		FIQs are a separate class of interrupts and would
+ *		be slowed down if handled like normal interrupts.
+ *
+ *		2.  TBD Invalid interrupt numbers are not checked.
+ *		Some interrupt inputs are tied to GND, which means 
+ *		they will immediately activate when unmasked.
+ *		Which may be useful for some devices.
+ *
+ *		3.  TBD Edge triggered interrupts are not specially
+ *		handled.  The architecture should provide a way to
+ *		set up the edge trigger features and then a way to
+ *		control the acknowledge to the interrupt.
+ *
+ ************************************************************************/
+
+static void int1_mask(unsigned int irq)
+{
+	outl( (1 << irq), VIC0INTENCLEAR );
+}
+
+static void int1_unmask(unsigned int irq)
+{
+	outl( (1 << irq), VIC0INTENABLE );
+}
+
+static struct irqchip int1_chip = {
+	.ack	= int1_mask,
+	.mask	= int1_mask,
+	.unmask	= int1_unmask,
+};
+ 
+static void int2_mask(unsigned int irq)
+{
+	outl( (1 << (irq - 32)), VIC1INTENCLEAR );
+}
+
+static void int2_unmask(unsigned int irq)
+{
+	outl( (1 << (irq - 32)), VIC1INTENABLE );
+}
+
+static struct irqchip int2_chip = {
+	.ack	= int2_mask,
+	.mask	= int2_mask,
+	.unmask	= int2_unmask,
+};
+ 
+void __init ep93xx_init_irq(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		if ((i < 32) && (INT1_IRQS & (1 << i))) {
+			set_irq_handler(i, do_level_IRQ);
+			set_irq_chip(i, &int1_chip);
+			set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+		}
+		if ((i >= 32) && (INT2_IRQS & (1 << (i - 32)))) {
+			set_irq_handler(i, do_level_IRQ);
+			set_irq_chip(i, &int2_chip);
+			set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+		}
+	}
+}
+
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/kgdb-serial.c linux-2.6.8.1/arch/arm/mach-ep93xx/kgdb-serial.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/kgdb-serial.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/kgdb-serial.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,64 @@
+/*
+ * tiny serial helper routines for kgdb
+ *
+ * Based on George G. Davis <gdavis@mvista.com> work.
+ */
+
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/hardware/serial_amba.h>
+#include <asm/arch/regmap.h>
+#include <asm/arch/regs_syscon.h>
+
+#if defined(CONFIG_KGDB_UART0)
+#define KGDB_UART_BASE UART1_BASE
+#define KGDB_UART_ENABLE 0x00040000
+#elif defined(CONFIG_KGDB_UART1)
+#define KGDB_UART_BASE UART2_BASE
+#define KGDB_UART_ENABLE 0x00100000
+#elif defined(CONFIG_KGDB_UART2)
+#define KGDB_UART_BASE UART3_BASE
+#define KGDB_UART_ENABLE 0x01000000
+#else
+#error "No kgdb serial port UART has been selected."
+#endif
+
+#if defined(CONFIG_KGDB_9600BAUD)
+#define KGDB_SERIAL_BAUD_RATE ARM_BAUD_9600
+#elif defined(CONFIG_KGDB_19200BAUD)
+#define KGDB_SERIAL_BAUD_RATE ARM_BAUD_19200
+#elif defined(CONFIG_KGDB_38400BAUD)
+#define KGDB_SERIAL_BAUD_RATE ARM_BAUD_38400
+#elif defined(CONFIG_KGDB_57600BAUD)
+#define KGDB_SERIAL_BAUD_RATE ARM_BAUD_57600
+#elif defined(CONFIG_KGDB_115200BAUD)
+#define KGDB_SERIAL_BAUD_RATE ARM_BAUD_115200
+#else
+#error "kgdb serial baud rate has not been specified."
+#endif
+
+void kgdb_serial_init(void)
+{
+	unsigned int uiTemp;
+
+	uiTemp = inl(SYSCON_DEVCFG) | KGDB_UART_ENABLE;
+	outl(0xaa, SYSCON_SWLOCK);
+	outl(uiTemp, SYSCON_DEVCFG);
+	outl(KGDB_SERIAL_BAUD_RATE, KGDB_UART_BASE + AMBA_UARTLCR_L);
+	outl(0, KGDB_UART_BASE + AMBA_UARTLCR_M);
+	outl(AMBA_UARTLCR_H_WLEN_8 | AMBA_UARTLCR_H_FEN,
+	     KGDB_UART_BASE + AMBA_UARTLCR_H);
+	outl(AMBA_UARTCR_UARTEN, KGDB_UART_BASE + AMBA_UARTCR);
+}
+
+void kgdb_serial_putchar(unsigned char ch)
+{
+	while(inl(KGDB_UART_BASE + AMBA_UARTFR) & AMBA_UARTFR_TXFF);
+	outl(ch, KGDB_UART_BASE + AMBA_UARTDR);
+}
+
+unsigned char kgdb_serial_getchar(void)
+{
+	while(inl(KGDB_UART_BASE + AMBA_UARTFR) & AMBA_UARTFR_RXFE);
+	return(inl(KGDB_UART_BASE + AMBA_UARTDR) & 0xff);
+}
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/mm.c linux-2.6.8.1/arch/arm/mach-ep93xx/mm.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/mm.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/mm.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,55 @@
+/*
+ *  linux/arch/arm/mach-ep93xx/mm.c
+ *
+ *  Extra MM routines for the Cirrus EP93xx
+ *
+ *  Copyright (C) 1999,2000 Arm Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2002-2003 Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/bootmem.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/arch/bits.h> 
+#include <asm/sizes.h> 
+#include <asm/arch/platform.h> 
+ 
+#include <asm/mach/map.h>
+
+/*
+ *  IO Map for EP93xx:
+ *
+ *  8000 0000 - 807f ffff = AHB peripherals  (8 Meg)
+ *  8080 0000 - 809f ffff = APB peripherals  (2 Meg)
+ *  a000 0000 - b000 0000 = PCMCIA space
+ */ 
+static struct map_desc ep93xx_io_desc[] __initdata = 
+{
+    { IO_BASE_VIRT,      IO_BASE_PHYS,      IO_SIZE,      MT_DEVICE },
+    { PCMCIA_BASE_VIRT,  PCMCIA_BASE_PHYS,  PCMCIA_SIZE,  MT_DEVICE }
+};
+
+void __init ep93xx_map_io(void)
+{
+	iotable_init(ep93xx_io_desc, ARRAY_SIZE(ep93xx_io_desc));
+}
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/pcmcia_io.c linux-2.6.8.1/arch/arm/mach-ep93xx/pcmcia_io.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/pcmcia_io.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/pcmcia_io.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,99 @@
+/*
+ *  linux/arch/arm/mach-ep93xx/pcmcia_io.c
+ *
+ * (c) Copyright 2004 Cirrus Logic, Inc., Austin, Tx 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/utsname.h>
+
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/memory.h>
+#include <asm/arch/platform.h>
+
+#include <asm/mach/arch.h>
+
+#ifndef __EP93XX_PCMCIA_IDE_HACK__
+#define __EP93XX_PCMCIA_IDE_HACK__
+
+/*
+ * These routines are used to hack the default ide i/o routines in
+ * drivers/ide/ide-iops.h so they work with PCMCIA IDE.  Sad, but
+ * necessary.
+ */
+#define SET_PCMCIA_WIDTH_16_BIT \
+	unsigned long ulSMC_PCIO = inl( SMC_PCIO );	 \
+	if ( (ulSMC_PCIO & PCCONFIG_MW_16BIT)	== 0 ) {   \
+		outl( ulSMC_PCIO | PCCONFIG_MW_16BIT, SMC_PCIO ); \
+		ulSMC_PCIO = inl( SMC_PCIO ); \
+	}
+	
+#define SET_PCMCIA_WIDTH_8_BIT \
+	unsigned long ulSMC_PCIO = inl( SMC_PCIO );	\
+	if ( ulSMC_PCIO & PCCONFIG_MW_16BIT ) {		\
+		outl( ulSMC_PCIO & ~PCCONFIG_MW_16BIT, SMC_PCIO ); \
+		ulSMC_PCIO = inl( SMC_PCIO ); \
+	}
+
+
+inline u8 ep93xx_pcmcia_ide_inb (unsigned long port)
+{
+	SET_PCMCIA_WIDTH_8_BIT
+	return (u8) inb(port);
+}
+
+inline u16 ep93xx_pcmcia_ide_inw (unsigned long port)
+{
+	SET_PCMCIA_WIDTH_16_BIT
+	return (u16) inw(port);
+}
+
+inline void ep93xx_pcmcia_ide_insw (unsigned long port, void *addr, u32 count)
+{
+	SET_PCMCIA_WIDTH_16_BIT
+	return insw(port, addr, count);
+}
+
+inline void ep93xx_pcmcia_ide_outb (u8 addr, unsigned long port)
+{
+	SET_PCMCIA_WIDTH_8_BIT
+	outb(addr, port);
+	ulSMC_PCIO = inl( SMC_PCIO );
+}
+
+inline void ep93xx_pcmcia_ide_outw (u16 addr, unsigned long port)
+{
+	SET_PCMCIA_WIDTH_16_BIT
+	outw(addr, port);
+	ulSMC_PCIO = inl( SMC_PCIO );
+}
+
+inline void ep93xx_pcmcia_ide_outsw (unsigned long port, void *addr, u32 count)
+{
+	SET_PCMCIA_WIDTH_16_BIT
+	outsw(port, addr, count);
+	ulSMC_PCIO = inl( SMC_PCIO );
+}
+#endif /* __EP93XX_PCMCIA_IDE_HACK__ */
+
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/ssp.c linux-2.6.8.1/arch/arm/mach-ep93xx/ssp.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/ssp.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/ssp.c	2007-01-15 12:17:44.000000000 +0900
@@ -0,0 +1,988 @@
+/*
+ *  FILE:			ssp.c
+ *
+ *  DESCRIPTION:	SSP Interface Driver Module implementation
+ *
+ *  Copyright Cirrus Logic Corporation, 2001-2003.  All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ *  This driver provides a way to read and write devices on the SSP
+ *  interface.
+ *
+ *  For Tx devices, EGPIO7 is used as an address pin:
+ *  I2S Codec CS4228        = EGPIO7 == 1
+ *  Serial Flash AT25F1024  = EGPIO7 == 0
+ */
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/ssp.h>
+
+#undef DEBUG
+// #define DEBUG 1
+#ifdef DEBUG
+#define DPRINTK( x... )  printk( ##x )
+#else
+#define DPRINTK( x... )
+#endif
+
+
+#define EP93XX_KEY_TIMER_PERIOD_MSEC 20
+
+static int SSP_Open(SSPDeviceType Device, SSPDataCallback Callback);
+static int SSP_Close(int Handle);
+static int SSP_Read(int Handle, unsigned int Addr, unsigned int *pValue);
+static int SSP_Write(int Handle, unsigned int Addr, unsigned int Value);
+static int CheckHandle(int Handle);
+
+static void  SetSSPtoPS2(void);
+static void  SetSSPtoI2S(void);
+static void  SetSSPtoFLASH(void);
+static int  ReadIntoBuffer(void);
+
+static int SSP_Write_I2SCodec(int Handle, unsigned int RegAddr,unsigned int RegValue);
+
+/*
+ * Key buffer...
+ */
+#define KEYBUF_SIZE 256
+static unsigned int uiKeyBuffer[KEYBUF_SIZE];
+static spinlock_t ssp_spinlock = SPIN_LOCK_UNLOCKED;
+
+
+typedef enum{
+	SSP_MODE_UNKNOWN = 0,
+	SSP_MODE_PS2,
+	SSP_MODE_I2S,
+	SSP_MODE_FLASH,
+} SSPmodes_t;
+
+static struct timer_list g_KbdTimer;
+static SSPmodes_t gSSPmode = SSP_MODE_UNKNOWN;
+static SSPDataCallback gKeyCallback = 0;
+static int gHookedInterrupt = 0;
+
+/*
+ * Keep the last valid handle for SSP for kbd, i2s, and flash
+ */
+static int iLastValidHandle = -1;
+static int KeyboardHandle = 0;
+static int I2SHandle = 0;
+static int FlashHandle = 0;
+
+#define SSP_DEVICE_MASK    0xf0000000
+#define SSP_DEVICE_SHIFT	 28
+
+SSP_DRIVER_API SSPinstance =
+{
+	SSP_Open,
+	SSP_Read,
+	SSP_Write,
+	SSP_Close,
+};
+
+/*
+ * The only instance of this driver.
+ */
+SSP_DRIVER_API *SSPDriver = &SSPinstance;
+
+//=============================================================================
+// SSPIrqHandler
+//=============================================================================
+// This routine will get all of the keys out of the SPI FIFO.
+//=============================================================================
+static irqreturn_t SSPIrqHandler( int irq, void *dev_id, struct pt_regs *regs)
+{
+	//
+	// Get key codes from SSP and send them to the keyboard callback.
+	//
+	ReadIntoBuffer();
+	
+	//
+	// Clear the interrupt.
+	//
+	outl( 0, SSPIIR );
+
+	return IRQ_HANDLED;
+}
+
+//=============================================================================
+// TimerRoutine
+//=============================================================================
+// This function is called periodically to make sure that no keys are stuck in
+// the SPI FIFO.  This is necessary because the SPI only interrupts on half
+// full FIFO which can leave up to one keyboard event in the FIFO until another
+// key is pressed.
+//=============================================================================
+static void TimerRoutine(unsigned long Data)
+{
+	int keycount;
+
+	//
+	// Get key codes from SSP and send them to the keyboard callback.
+	//
+	keycount = ReadIntoBuffer();
+	
+	//
+	// If no keys were received, call the Data callback anyway so it can
+	// check for stuck keys.
+	//
+	if( (keycount==0) && gKeyCallback )
+	{
+		gKeyCallback(-1);
+	}
+	
+	//
+	// Reschedule our timer in another 20 mSec.
+	//
+	g_KbdTimer.expires = jiffies + MSECS_TO_JIFFIES( EP93XX_KEY_TIMER_PERIOD_MSEC );
+	add_timer(&g_KbdTimer);
+}
+
+/*
+ * HookInterrupt
+ *
+ * Requests SSP interrupt, sets up interrupt handler, sets up keyboard polling
+ * timer.
+ */
+static int HookInterrupt(void)
+{
+	if (gHookedInterrupt)
+	{
+		printk( KERN_ERR "SSP driver interrupt already hooked\n");
+		return(-1);
+	}
+
+
+	if (request_irq(IRQ_SSPRX, SSPIrqHandler, SA_INTERRUPT, "ep93xxsspd", 0))
+	{
+		printk( KERN_ERR "SSP driver failed to get IRQ handler\n");
+		return(-1);
+	}
+	
+	gHookedInterrupt = 1;
+
+	//
+	// Initialize the timer that we will use to poll the SPI.
+	//
+	init_timer(&g_KbdTimer);
+	g_KbdTimer.function = TimerRoutine;
+	g_KbdTimer.data = 1;
+	g_KbdTimer.expires = jiffies + MSECS_TO_JIFFIES( EP93XX_KEY_TIMER_PERIOD_MSEC );
+
+	add_timer(&g_KbdTimer);
+	
+	return(0);
+}
+
+static int SSP_Open(SSPDeviceType Device, SSPDataCallback Callback)
+{
+#ifdef CONFIG_CODEC_KENWOOD
+	return 0;		/* Pseudosuccess */
+#endif
+
+	int Handle;
+	
+	/*
+	 * Generate a handle and pass it back.
+	 *
+	 * Increment the last valid handle.
+	 * Check for wraparound (unlikely, but we like to be complete).
+	 */
+	iLastValidHandle++;
+	
+	if((iLastValidHandle & ~SSP_DEVICE_MASK) == 0)
+	{
+		/*
+		 * If we wrapped around start over.  Unlikely.
+		 */
+		iLastValidHandle = 1;
+	}
+	
+	Handle = iLastValidHandle | (Device << SSP_DEVICE_SHIFT);
+
+	switch (Device)
+	{
+		case PS2_KEYBOARD:
+		{
+			DPRINTK("SSP_Open - PS2_KEYBOARD\n");
+			if (KeyboardHandle)
+			{
+				return(-1);
+			}
+			else
+			{
+				DPRINTK("Handle:%08x  Callback:%08x  -- Success\n",
+					Handle, (unsigned int)Callback);
+
+				KeyboardHandle = Handle;
+				//
+				// Hook the interrupt if we have not yet.
+				//
+				HookInterrupt();
+				SetSSPtoPS2();
+				gKeyCallback = Callback;
+			}
+			break;
+		}
+		case I2S_CODEC:
+		{
+			DPRINTK("SSP_Open - I2S_CODEC\n");
+			if (I2SHandle)
+			{
+				return(-1);
+			}
+			else
+			{
+				DPRINTK("Handle:%08x  Callback:%08x  -- Success\n",
+					Handle, (unsigned int)Callback);
+
+				I2SHandle = Handle;
+			}
+			break;
+		}
+		case SERIAL_FLASH:
+		{
+			DPRINTK("SSP_Open - SERIAL_FLASH\n");
+			if (FlashHandle)
+			{
+				return(-1);
+			}
+			else
+			{
+				DPRINTK("Handle:%08x  Callback:%08x  -- Success\n",
+					Handle, (unsigned int)Callback);
+				FlashHandle = Handle;
+			}
+			break;
+		}
+		default:
+		{
+			return(-1);
+		}
+	}
+	
+	/*
+	 * Return the handle.
+	 */
+	return(Handle );
+}
+
+/*
+ * Release that Handle!
+ */
+static int SSP_Close(int Handle)
+{
+#ifdef CONFIG_CODEC_KENWOOD
+	return 0;
+#endif
+
+
+	//
+	// Find out which device this API was called for.
+	//
+	switch( CheckHandle(Handle) )
+	{
+		case PS2_KEYBOARD:
+		{
+			DPRINTK("SSP_Open - PS2_KEYBOARD\n");
+			del_timer(&g_KbdTimer);
+			free_irq(IRQ_SSPRX, 0);
+			gKeyCallback = 0;
+			KeyboardHandle = 0;
+			gHookedInterrupt = 0;
+			break;
+		}
+		case I2S_CODEC:
+		{
+			DPRINTK("SSP_Open - I2S_CODEC\n");
+			I2SHandle = 0;
+			break;
+		}
+		case SERIAL_FLASH:
+		{
+			DPRINTK("SSP_Open - SERIAL_FLASH\n");
+			FlashHandle = 0;
+			break;
+		}
+		default:
+		{
+			return(-1);
+		}
+	}
+	return 0;
+}
+
+static int SSP_Read_FLASH
+(
+	int Handle,
+	unsigned int RegAddr,
+	unsigned int *pValue
+)
+{
+	SSPmodes_t saved_mode;
+
+	DPRINTK("SSP_Read_FLASH\n");
+
+	spin_lock(&ssp_spinlock);
+
+	/*
+	 * Save the SSP mode.  Switch to FLASH mode if we're not
+	 * already in FLASH mode.
+	 */
+	saved_mode = gSSPmode;
+	SetSSPtoFLASH();
+
+	/*
+	 * Let TX fifo clear out.  Poll the Transmit Fifo Empty bit.
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) )
+		barrier();
+
+	/*
+	 * Write the SPI read command.
+	 */
+	outl( 0x03, SSPDR );
+	outl( (RegAddr >> 16) & 255, SSPDR );
+	outl( (RegAddr >> 8) & 255, SSPDR );
+	outl( RegAddr & 255, SSPDR );
+
+	/*
+	 * Delay long enough for one byte to be transmitted.  It takes 7.6uS to
+	 * write a single byte.
+	 */
+	udelay(10);
+
+	/*
+	 * Read a byte to make sure the FIFO doesn't overrun.
+	 */
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+
+	/*
+	 * Write four more bytes so that we can read four bytes.
+	 */
+	outl( 0, SSPDR );
+	outl( 0, SSPDR );
+	outl( 0, SSPDR );
+	outl( 0, SSPDR );
+
+	/*
+	 * Delay long enough for three bytes to be transmitted.  It takes 7.6uS
+	 * to write a single byte.
+	 */
+	udelay(25);
+
+	/*
+	 * Read three and throw away the next tree bytes.
+	 */
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	inl( SSPDR );
+
+	/*
+	 * Delay long enough for four bytes to be transmitted.  It takes 7.6uS
+	 * to write a single byte.
+	 */
+	udelay(30);
+
+	/*
+	 * Read the data word.
+	 */
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue = inl( SSPDR );
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue |= inl( SSPDR ) << 8;
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue |= inl( SSPDR ) << 16;
+	while( !( inl(SSPSR) & SSPSR_RNE ) )
+		barrier();
+	*pValue |= inl( SSPDR ) << 24;
+
+	/*
+	 * Wait until the transmit buffer is empty (it should be...).
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) )
+		barrier();
+
+	/*
+	 * Read any residual bytes in the receive buffer.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+		inl( SSPDR );
+	
+	/*
+	 * If we were in PS2 mode, switch back to PS2 mode.
+	 * If we weren't in PS2 mode, that means we didn't compile in
+	 * the PS2 keyboard support, so no need to switch to PS2 mode.
+	 */
+	if( saved_mode == SSP_MODE_PS2 )
+		SetSSPtoPS2();
+
+	spin_unlock(&ssp_spinlock);
+
+	/*
+	 * Return success.
+	 */
+	return 0;
+}
+
+static int SSP_Read(int Handle, unsigned int Addr, unsigned int *pValue)
+{
+#ifdef CONFIG_CODEC_KENWOOD
+	return 0;
+#endif
+
+	DPRINTK("SSP_Read\n");
+
+	/*
+	 * Find out which device this API was called for.
+	 */
+	switch( CheckHandle(Handle) )
+	{
+		case SERIAL_FLASH:
+		{
+			return SSP_Read_FLASH(Handle, Addr, pValue);
+		}
+		default:
+		{
+			return -1;
+		}
+	}
+}
+
+static int SSP_Write(int Handle, unsigned int Addr, unsigned int Value)
+{
+	int iRet = 0;
+
+#ifdef	CONFIG_CODEC_KENWOOD
+	return 0;
+#endif
+
+	// DPRINTK("SSP_Write - Handle:0x%08x  Addr:0x%08x  Value:0x%08x\n",
+	//    Handle, Addr, Value );
+	
+	//
+	// Find out which device this API was called for.
+	//
+	switch( CheckHandle(Handle) )
+	{
+		case PS2_KEYBOARD:
+		{
+			break;
+		}
+		case I2S_CODEC:
+		{
+			iRet = SSP_Write_I2SCodec( Handle, Addr, Value );
+			break;
+		}
+		case SERIAL_FLASH:
+		{
+			break;
+		}
+		default:
+		{
+			return(-1);
+		}
+	}
+
+	return iRet;
+}
+
+static void SetSSPtoPS2(void)
+{
+	unsigned int uiRegTemp;
+	
+	if( gSSPmode == SSP_MODE_PS2 )
+	{
+		return;
+	}
+
+	/*
+	 * Disable the SSP, disable interrupts
+	 */
+	outl( 0, SSPCR1 );
+
+	/*
+	 * It takes almost a millisecond for a key to come in so
+	 * make sure we have completed all transactions.
+	 */
+	mdelay(1);
+
+	//
+	// Set EGPIO7 to disable EEPROM device on EDB9301, EDB9312, and EDB9315.
+	//
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x80, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x80, GPIO_PADR );
+
+	/*
+	 * Disable SFRM1 to I2S codec by setting EGPIO8 (port B, bit 0).
+	 * The EDB9315 board needs this but is harmless on the EDB9312 board.
+	 */
+#if defined(CONFIG_ARCH_EDB9307) || defined(CONFIG_ARCH_EDB9312) || defined(CONFIG_ARCH_EDB9315)
+	uiRegTemp = inl(GPIO_PBDDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDR );
+	
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Disable SFRM1 to I2S codec I2S by setting EGPIO6 (port A, bit 6).
+	 * The EDB9301 board needs this
+	 */
+#if defined(CONFIG_ARCH_EDB9301) || defined(CONFIG_ARCH_EDB9302)|| \
+   defined(CONFIG_ARCH_EDB9302A) || defined(CONFIG_ARCH_EDB9307A) || defined(CONFIG_ARCH_EDB9315A) 
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x40, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x40, GPIO_PADR );
+
+	uiRegTemp = inl(GPIO_PADR);
+#endif
+
+	/*
+	 * Still haven't enabled the keyboard.  So anything in
+	 * the rx fifo is garbage.  Time to take out the trash.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+	{
+		uiRegTemp = inl(SSPDR);
+	}
+
+	/*
+	 * SPICR0_SPO - SCLKOUT Polarity
+	 * SPICR0_SPH - SCLKOUT Phase
+	 * Motorola format, 11 bit, one start, 8 data, one bit for
+	 * parity, one stop bit.
+	 */
+	outl( (SSPCR0_FRF_MOTOROLA | SSPCR0_SPH | SSPCR0_SPO | SSPCR0_DSS_11BIT),
+	      SSPCR0 );
+	/*
+	 * Configure the device as a slave, Clear FIFO overrun interrupts,
+	 * enable interrupts and reset the device.
+	 */
+	outl( (SSPC1_MS | SSPC1_RIE | SSPC1_SOD), SSPCR1 );
+	outl( 0, SSPIIR );
+	outl( (SSPC1_MS | SSPC1_RIE | SSPC1_SOD | SSPC1_SSE), SSPCR1 );
+
+	/*
+	 * Configure EGPIO pins 12 and 14 as outputs because they are used
+	 * as buffer enables for the SPI interface to the ps2 keyboard.
+	 * Clear EGPIO pins 12 and 14, this will enable the SPI keyboard.
+	 */
+	uiRegTemp = inl(GPIO_PBDDR);
+	outl( uiRegTemp | 0x50, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR);
+	outl( uiRegTemp & ~0x50, GPIO_PBDR );
+
+	gSSPmode = SSP_MODE_PS2;
+}
+
+static void SetSSPtoI2S(void)
+{
+	unsigned int uiRegTemp;
+
+	if( gSSPmode == SSP_MODE_I2S )
+	{
+		return;
+	}
+	
+	/*
+	 * Disable recieve interrupts.
+	 */
+	outl( (SSPC1_MS | SSPC1_SSE), SSPCR1 );
+
+	/*
+	 * Set GPIO pins 12 and 14, this will bring the clock line low
+	 * which signals to the keyboard to buffer keystrokes.
+	 * Note that EGPIO 14 is the clock line and EGPIO 12 is data line.
+	 */
+	uiRegTemp = inl(GPIO_PBDR);
+	outl( 0x50 | uiRegTemp, GPIO_PBDR );
+
+	/*
+	 * It takes almost a millisecond for an partial keystrokes to come in.
+	 * Delay to make sure we have completed all transactions.
+	 */
+	mdelay(1);
+
+	/*
+	 * Anything we just recieved is garbage.  Time to take out the trash.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+	{
+		uiRegTemp = inl(SSPDR);
+	}
+	
+	/*
+	 * Disable the SSP and disable interrupts
+	 */
+	outl( 0, SSPCR1 );
+
+	/*
+	 * Clock will be 14.7 MHz divided by 4.
+	 */
+	outl( 2, SSPCPSR );
+
+	/*
+	 * Configure EGPIO7 as an output and set it.  This selects
+	 * I2S codec as the device on the SSP output instead of
+	 * the serial flash on EDB9312.  On EDB9301 and EDB9315 it
+	 * disables EEPROM but doesn't select anything.
+	 */
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x80, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x80, GPIO_PADR );
+
+	/*
+	 * Enable SFRM1 to I2S codec by clearing EGPIO8 (port B, bit 0).
+	 * The EDB9315 board needs this but is harmless on the EDB9312 board.
+	 */
+#if defined(CONFIG_ARCH_EDB9307) || defined(CONFIG_ARCH_EDB9312) || defined(CONFIG_ARCH_EDB9315)
+	uiRegTemp = inl(GPIO_PBDDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR) & 0xfe;
+	outl( uiRegTemp, GPIO_PBDR );
+	
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Enable SFRM1 to I2S codec I2S by clearing EGPIO6 (port A, bit 6).
+	 * The EDB9301 board needs this
+	 */
+#if defined(CONFIG_ARCH_EDB9301) || defined(CONFIG_ARCH_EDB9302) || \
+    defined(CONFIG_ARCH_EDB9302A) || defined(CONFIG_ARCH_EDB9307A) || defined(CONFIG_ARCH_EDB9315A)
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x40, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp & ~0x40, GPIO_PADR );
+
+	uiRegTemp = inl(GPIO_PADR);
+#endif
+
+	/*
+	 * Motorola format, 8 bit.
+	 */
+	outl( (SSPCR0_SPO | SSPCR0_SPH | SSPCR0_FRF_MOTOROLA | SSPCR0_DSS_8BIT),
+	      SSPCR0 );
+
+	/*
+	 * Configure the device as master, reenable the device.
+	 */
+	outl( SSPC1_SSE, SSPCR1 );
+
+	gSSPmode = SSP_MODE_I2S;
+
+	udelay(10);
+}
+
+static void SetSSPtoFLASH(void)
+{
+	unsigned int uiRegTemp;
+
+	if( gSSPmode == SSP_MODE_FLASH)
+		return;
+
+	/*
+	 * Disable recieve interrupts.
+	 */
+	outl( (SSPC1_MS | SSPC1_SSE), SSPCR1 );
+
+	/*
+	 * Set GPIO pins 12 and 14, this will bring the clock line low
+	 * which signals to the keyboard to buffer keystrokes.
+	 * Note that EGPIO 14 is the clock line and EGPIO 12 is data line.
+	 */
+	outl( inl(GPIO_PBDR) | 0x50, GPIO_PBDR );
+
+	/*
+	 * It takes almost a millisecond for an partial keystrokes to come in.
+	 * Delay to make sure we have completed all transactions.
+	 */
+	mdelay(1);
+
+	/*
+	 * Anything we just recieved is garbage.  Time to take out the trash.
+	 */
+	while( inl(SSPSR) & SSPSR_RNE )
+		inl(SSPDR);
+	
+	/*
+	 * Disable the SSP and disable interrupts
+	 */
+	outl( 0, SSPCR1 );
+
+	/*
+	 * Clock will be 14.7 MHz divided by 14.
+	 */
+	outl( 2, SSPCPSR );
+
+	/*
+	 * Configure EGPIO7 as an output and clear it.  This selects
+	 * serial flash as the device on the SSP output instead of
+	 * the I2S codec and is valid for EDB9301, EDB9312, and EDB9315.
+	 */
+	outl( inl(GPIO_PADDR) | 0x80, GPIO_PADDR );
+	outl( inl(GPIO_PADR) & ~0x80, GPIO_PADR );
+
+	/*
+	 * Disable SFRM1 to I2S codec by setting EGPIO8 (port B, bit 0).
+	 * The EDB9315 board needs this but is harmless on the EDB9312 board.
+	 */
+#if defined(CONFIG_ARCH_EDB9307) || defined(CONFIG_ARCH_EDB9312) || defined(CONFIG_ARCH_EDB9315)
+	uiRegTemp = inl(GPIO_PBDDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDDR );
+
+	uiRegTemp = inl(GPIO_PBDR) | 0x01;
+	outl( uiRegTemp, GPIO_PBDR );
+	
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Disable SFRM1 to I2S codec I2S by setting EGPIO6 (port A, bit 6).
+	 * The EDB9301 board needs this
+	 */
+#if defined(CONFIG_ARCH_EDB9301) || defined(CONFIG_ARCH_EDB9302) || \
+    defined(CONFIG_ARCH_EDB9302A) || defined(CONFIG_ARCH_EDB9307A) || defined(CONFIG_ARCH_EDB9315A)
+	uiRegTemp = inl(GPIO_PADDR);
+	outl( uiRegTemp | 0x40, GPIO_PADDR );
+
+	uiRegTemp = inl(GPIO_PADR);
+	outl( uiRegTemp | 0x40, GPIO_PADR );
+
+	uiRegTemp = inl(GPIO_PBDR);
+#endif
+
+	/*
+	 * Motorola format, 8 bit.
+	 */
+	outl( ((6 << SSPCR0_SCR_SHIFT) | SSPCR0_SPO | SSPCR0_SPH |
+	       SSPCR0_FRF_MOTOROLA | SSPCR0_DSS_8BIT),
+	      SSPCR0 );
+
+	/*
+	 * Configure the device as master, reenable the device.
+	 */
+	outl( SSPC1_SSE, SSPCR1 );
+
+	gSSPmode = SSP_MODE_FLASH;
+
+	udelay(10);
+}
+
+/*
+ *  CheckHandle
+ *
+ *  If Handle is valid, returns 0.  Otherwise it returns -1.
+ */
+static int CheckHandle(int Handle)
+{
+	int iRet;
+
+	if ((Handle != KeyboardHandle) &&
+	    (Handle != I2SHandle) &&
+	    (Handle != FlashHandle))
+	{
+		DPRINTK("OOPS! Invalid SSP Handle!\n");
+		return(-1);
+	}
+
+	/*
+	 * Get the SSP driver instance number from the handle.
+	 */
+	iRet = (((int)Handle & SSP_DEVICE_MASK) >> SSP_DEVICE_SHIFT);
+
+	return iRet;
+}
+
+/*
+ * ReadIntoBuffer
+ *
+ * Drains the SSP rx fifo into a buffer here.  If we overflow this buffer
+ * then something's wrong.
+ */
+static int ReadIntoBuffer(void)
+{
+	unsigned int count, index, saved_count, uiRegTemp;
+	
+	count = 0;
+	index = 0;
+
+
+	if( gSSPmode != SSP_MODE_PS2 )
+	{
+		return 0;
+	}
+	
+	/*
+	 * This spinlock will prevent I2S from grabbing the SSP to do a
+	 * write while we are using the SSP for PS2.
+	 *
+	 * There is a slight chance that we are in the beginning phase
+	 * of doing an I2S write but the mode flag hadn't yet switched
+	 * to I2S.  If that happens we will end up waiting on I2S to
+	 * finish a write.  Not great.
+	 */
+	spin_lock(&ssp_spinlock);
+
+	while( inl(SSPSR) & SSPSR_RNE)
+	{
+		/*
+		 * Read in the value from the SPI controller into
+		 * the partial key buffer.
+		 */
+		uiKeyBuffer[count] = inl(SSPDR);
+		if (((uiKeyBuffer[count] & 0x3fc) != 0x3e0) &&
+			((uiKeyBuffer[count] & 0x3fc) != 0x3c0))
+		{
+			/*
+			 * Set GPIO pins 12 and 14, this will bring the clock line low
+			 * which signals to the keyboard to buffer keystrokes.
+			 * Note that EGPIO 14 is the clock line and EGPIO 12 is data line.
+			 */
+			uiRegTemp = inl(GPIO_PBDR);
+			outl( 0x50 | uiRegTemp, GPIO_PBDR );
+
+			outl( 0, SSPCR1 );
+			outl( (SSPC1_MS | SSPC1_RIE | SSPC1_SSE), SSPCR1 );
+
+			/*
+			 * Clear EGPIO pins 12 and 14, this will enable the SPI keyboard.
+			 */
+			uiRegTemp = inl(GPIO_PBDR);
+			outl( uiRegTemp & ~0x50, GPIO_PBDR );
+
+			count++;
+			break;
+		}
+		count++;
+	}
+
+	saved_count = count;
+	index = 0;
+	while (count)
+	{
+		//
+		// No callback, dump data.
+		//
+		if (gKeyCallback)
+		{
+			gKeyCallback(uiKeyBuffer[index++]);
+		}
+		count--;
+	}
+
+	spin_unlock(&ssp_spinlock);
+
+	return saved_count;
+}
+
+/*
+ * SSP_Write_I2SCodec
+ *
+ */
+static int SSP_Write_I2SCodec
+(
+	int Handle,
+	unsigned int RegAddr,
+	unsigned int RegValue
+)
+{
+	SSPmodes_t saved_mode;
+
+	DPRINTK("SSP_Write_I2SCodec\n");
+
+	spin_lock(&ssp_spinlock);
+
+	/*
+	 * Save the SSP mode.  Switch to I2S mode if we're not
+	 * already in I2S mode.
+	 */
+	saved_mode = gSSPmode;
+	SetSSPtoI2S();
+
+	/*
+	 * Let TX fifo clear out.  Poll the Transmit Fifo Empty bit.
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) );
+	
+	/*
+	 * Write the data out to the tx fifo.
+	 */
+	outl( 0x20, SSPDR ); /* chip address for CS4228 */
+	outl( (RegAddr & 0xff), SSPDR );
+	outl( (RegValue & 0xff), SSPDR );
+
+	/*
+	 * Let TX fifo clear out.  Poll the Transmit Fifo Empty bit.
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) );
+
+	/*
+	 * Delay to let stuff make it out of the SR before doing
+	 * anthing else to the SSP.  It takes 6.8 uSec to do a
+	 * I2S codec register write.
+	 */
+	udelay(10);
+
+	/*
+	 * If we were in PS2 mode, switch back to PS2 mode.
+	 * If we weren't in PS2 mode, that means we didn't compile in
+	 * the PS2 keyboard support, so no need to switch to PS2 mode.
+	 */
+	if( saved_mode == SSP_MODE_PS2 )
+	{
+		SetSSPtoPS2();
+	}
+
+	spin_unlock(&ssp_spinlock);
+
+	/*
+	 * Return success.
+	 */
+	return 0;
+}
diff -burN linux-2.6.8.1-orig/arch/arm/mach-ep93xx/time.c linux-2.6.8.1/arch/arm/mach-ep93xx/time.c
--- linux-2.6.8.1-orig/arch/arm/mach-ep93xx/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mach-ep93xx/time.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,68 @@
+/*
+ *  linux/arch/arm/mach-ep93xx/time.c
+ *
+ *  Copyright (C) 2000-2001 Deep Blue Solutions
+ *
+ * (c) Copyright 2001 LynuxWorks, Inc., San Jose, CA.  All rights reserved.
+ *  Copyright (C) 2002-2003 Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/timex.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <asm/mach/time.h>
+
+/*
+ * gettimeoffset() returns time since last timer tick, in usecs.
+ *
+ * 'LATCH' is hwclock ticks (see CLOCK_TICK_RATE in timex.h) per jiffy.
+ * 'tick' is usecs per jiffy.
+ */
+static unsigned long ep93xx_gettimeoffset(void)
+{
+	unsigned long hwticks;
+	hwticks = LATCH - (inl(TIMER1VALUE) & 0xffff);
+	return (hwticks * (tick_nsec / 1000)) / LATCH;
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+ep93xx_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	outl(1, TIMER1CLEAR);
+	timer_tick(regs);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction ep93xx_timer_irq = {
+	.name		= "timer tick",
+	.flags		= SA_INTERRUPT,
+	.handler	= ep93xx_timer_interrupt
+};
+
+void __init ep93xx_init_time(void)
+{
+	struct timespec tv;
+
+	outl(0, TIMER1CONTROL);
+	outl(LATCH - 1, TIMER1LOAD);
+	outl(0xc8, TIMER1CONTROL);
+
+	setup_irq(IRQ_TIMER1, &ep93xx_timer_irq);
+	gettimeoffset = ep93xx_gettimeoffset;
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = inl(RTCDR);
+	do_settimeofday(&tv);
+}
diff -burN linux-2.6.8.1-orig/arch/arm/mm/Kconfig linux-2.6.8.1/arch/arm/mm/Kconfig
--- linux-2.6.8.1-orig/arch/arm/mm/Kconfig	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mm/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -58,9 +58,9 @@
 
 # ARM920T
 config CPU_ARM920T
-	bool "Support ARM920T processor" if !ARCH_S3C2410
-	depends on ARCH_INTEGRATOR || ARCH_S3C2410
-	default y if ARCH_S3C2410
+	bool "Support ARM920T processor" if !ARCH_S3C2410 && !ARCH_EP93XX
+	depends on ARCH_INTEGRATOR || ARCH_S3C2410 || ARCH_EP93XX
+	default y if ARCH_S3C2410 || ARCH_EP93XX
 	select CPU_32v4
 	select CPU_ABRT_EV4T
 	select CPU_CACHE_V4WT
diff -burN linux-2.6.8.1-orig/arch/arm/mm/mm-armv.c linux-2.6.8.1/arch/arm/mm/mm-armv.c
--- linux-2.6.8.1-orig/arch/arm/mm/mm-armv.c	2004-08-14 19:55:35.000000000 +0900
+++ linux-2.6.8.1/arch/arm/mm/mm-armv.c	2007-01-15 12:17:44.000000000 +0900
@@ -303,10 +303,10 @@
 static struct mem_types mem_types[] __initdata = {
 	[MT_DEVICE] = {
 		.prot_pte  = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY |
-				L_PTE_WRITE,
+				L_PTE_USER | L_PTE_WRITE,
 		.prot_l1   = PMD_TYPE_TABLE,
 		.prot_sect = PMD_TYPE_SECT | PMD_SECT_UNCACHED |
-				PMD_SECT_AP_WRITE,
+				PMD_SECT_AP_READ | PMD_SECT_AP_WRITE,
 		.domain    = DOMAIN_IO,
 	},
 	[MT_CACHECLEAN] = {
@@ -531,6 +531,12 @@
 		p->virtual    = __phys_to_virt(p->physical);
 		p->length     = mi->bank[i].size;
 		p->type       = MT_MEMORY;
+		
+		printk("	bank %d start at 0x%08x, length 0x%08x, mapped to 0x%08x\n", i
+											   , (int) p->physical
+											   , (int) p->length
+											   , (int) p->virtual);
+				
 		p ++;
 	}
 
diff -burN linux-2.6.8.1-orig/arch/arm/tools/mach-types linux-2.6.8.1/arch/arm/tools/mach-types
--- linux-2.6.8.1-orig/arch/arm/tools/mach-types	2004-08-14 19:55:32.000000000 +0900
+++ linux-2.6.8.1/arch/arm/tools/mach-types	2007-01-24 13:03:31.000000000 +0900
@@ -559,3 +559,7 @@
 switchgrass		MACH_SWITCHGRASS	SWITCHGRASS		549
 ens_cmu			MACH_ENS_CMU		ENS_CMU			550
 mm6_sdb			MACH_MM6_SDB		MM6_SDB			551
+edb9315a		MACH_EDB9315A		EDB9315A		772
+edb9307                 MACH_EDB9307            EDB9307                 607
+edb9302a                MACH_EDB9302A           EDB9302A                1127
+edb9307a                MACH_EDB9307A           EDB9307A                1128
diff -burN linux-2.6.8.1-orig/drivers/char/Kconfig linux-2.6.8.1/drivers/char/Kconfig
--- linux-2.6.8.1-orig/drivers/char/Kconfig	2004-08-14 19:54:47.000000000 +0900
+++ linux-2.6.8.1/drivers/char/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -754,6 +754,16 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rtc.
 
+config EP93XX_RTC
+	bool "RTC for Intersil 1208 device on Cirrus Logic EP93xx boards"
+	depends on ARCH_EP93XX
+	help
+	If you say Y here and create a character special file /dev/rtc with
+	major number 10 and minor number 135 using mknod ("man mknod"), you
+	will get access to the external Intersil 1208 RTC on the Cirrus Logic Lowcost Boards
+       	via the file /proc/rtc and its behaviour is set by various ioctls on
+	/dev/rtc.
+
 config SGI_DS1286
 	tristate "SGI DS1286 RTC support"
 	depends on SGI_IP22
diff -burN linux-2.6.8.1-orig/drivers/char/Makefile linux-2.6.8.1/drivers/char/Makefile
--- linux-2.6.8.1-orig/drivers/char/Makefile	2004-08-14 19:56:22.000000000 +0900
+++ linux-2.6.8.1/drivers/char/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -44,7 +44,8 @@
 obj-$(CONFIG_VIOCONS) += viocons.o
 obj-$(CONFIG_VIOTAPE)		+= viotape.o
 obj-$(CONFIG_HVCS)		+= hvcs.o
-
+obj-$(CONFIG_EP93XX_RTC)	+= ep93xx_rtc.o
+obj-$(CONFIG_EP93XX_KEYPAD)	+= ep93xx_keypad.o
 obj-$(CONFIG_PRINTER) += lp.o
 obj-$(CONFIG_TIPAR) += tipar.o
 
diff -burN linux-2.6.8.1-orig/drivers/char/ep93xx_keypad.c linux-2.6.8.1/drivers/char/ep93xx_keypad.c
--- linux-2.6.8.1-orig/drivers/char/ep93xx_keypad.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/char/ep93xx_keypad.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,422 @@
+/******************************************************************************
+ * 
+ *  File:   linux/drivers/input/keyboard/ep93xx_keypad.c
+ *
+ *  Purpose:    Support for 8x8 keypad (With Scroll Wheel) for a Cirrus Logic EP93xx
+ *
+ *  History:    
+ *              For Sirius (Internet Radio) Project.
+ *
+ * Copyright 2006 Cirrus Logic Inc.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *   
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/compiler.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/syscalls.h>
+#include <linux/input.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include "ep93xx_keypad.h"
+
+static struct ep93xx_keypad_dev dev;
+static char *name = "Cirrus EP93xx 8x8 keypad driver";
+
+static void handle_scancode(struct ep93xx_keypad_dev* pdev, unsigned char scancode, int down)
+{   
+#ifdef FIX_FOR_EC12E2424404
+    int i, wheel1_count=0, wheel2_count=0;
+    if(down && ((scancode == KEY_WHEEL_1) || (scancode == KEY_WHEEL_2)) )
+    {
+        pdev->wheelkey_count &= 0x03;
+        pdev->wheelkey_buffer[pdev->wheelkey_count] = scancode;
+        pdev->wheelkey_count ++;
+
+        if(pdev->wheelkey_hit)
+        {
+            for(i=0;i<=pdev->wheelkey_count;i++)
+            {
+                if(pdev->wheelkey_buffer[i]==KEY_WHEEL_1) wheel1_count++;
+                if(pdev->wheelkey_buffer[i]==KEY_WHEEL_2) wheel2_count++;
+            }
+            if(wheel1_count >=3)
+            {
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_1, 1);
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_1, 0);
+                input_sync((struct input_dev*)&dev);
+            }
+            else if(wheel2_count >=3)
+            {
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_2, 1);
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_2, 0);
+                input_sync((struct input_dev*)&dev);
+            }
+            pdev->wheelkey_hit = 0;
+            pdev->wheelkey_count = 0;
+        }
+    }
+    else
+#endif
+    if(scancode > 0)
+    {
+        input_report_key((struct input_dev*)&dev, scancode, down);
+        input_sync((struct input_dev*)&dev);
+    }
+}
+
+static irqreturn_t ep93xx_keypad_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+    int nkey1,nkey2;
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    int phase,step;
+#endif
+    unsigned long status;
+    struct ep93xx_keypad_dev* pdev = (struct ep93xx_keypad_dev*)dev_id;
+    
+    status = inl(KEY_REG);
+    
+    status &= 0x3fff;
+
+/*  printk("status = %08x\n", (int)status);
+    printk("%d\n",wheel_phase_table[pdev->wheelkey]);
+*/
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    phase = wheel_phase_table[pdev->wheelkey&0x3];
+#endif
+
+    if(status & KEYREG_KEY2)
+    {
+        nkey1 = KeyPadTable[ (status & KEYREG_KEY1_MASK)>>KEYREG_KEY1_SHIFT ];
+        nkey2 = KeyPadTable[ (status & KEYREG_KEY2_MASK)>>KEYREG_KEY2_SHIFT ];
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+        if( (nkey1 == KEY_WHEEL_1) || (nkey2 == KEY_WHEEL_1) )
+        {
+            pdev->wheelkey |= WHEEL_FLAG1;
+        }
+        if( (nkey1 == KEY_WHEEL_2) || (nkey2 == KEY_WHEEL_2) )
+        {
+            pdev->wheelkey |= WHEEL_FLAG2;
+        }
+        if(pdev->last_key1 >0 || pdev->last_key2 >0)
+        {
+            if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) && (nkey2 != pdev->last_key1) )
+            {
+                handle_scancode(pdev, pdev->last_key1, 0);
+                pdev->last_key1 = 0;
+            }
+            if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) && (nkey2 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, pdev->last_key2, 0);
+                pdev->last_key2 = 0;
+            }
+        }
+
+        if( (nkey1 != KEY_WHEEL_1) && (nkey1 != KEY_WHEEL_2) )
+        {
+            if( (nkey1 != pdev->last_key1) && (nkey1 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, nkey1, 1);
+                pdev->last_key1 = nkey1;
+            }
+        }
+
+        if( (nkey2 != KEY_WHEEL_1) && (nkey2 != KEY_WHEEL_2) )
+        {
+            if( (nkey2 != pdev->last_key1) && (nkey2 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, nkey2, 1);
+                pdev->last_key2 = nkey2;
+            }
+        }
+#else
+        if(pdev->last_key1 >0 || pdev->last_key2 >0)
+        {
+            if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) && (nkey2 != pdev->last_key1) )
+            {
+                handle_scancode(pdev, pdev->last_key1, 0);
+                pdev->last_key1 = 0;
+            }
+            if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) && (nkey2 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, pdev->last_key2, 0);
+                pdev->last_key2 = 0;
+            }
+        }
+
+        if( (nkey1 != pdev->last_key1) && (nkey1 != pdev->last_key2) )
+        {
+            handle_scancode(pdev, nkey1, 1);
+            pdev->last_key1 = nkey1;
+        }
+        if( (nkey2 != pdev->last_key1) && (nkey2 != pdev->last_key2) )
+        {
+            handle_scancode(pdev, nkey2, 1);
+            pdev->last_key2 = nkey2;
+        }
+#endif
+    }
+    else if(status & KEYREG_KEY1)
+    {
+        nkey1 = KeyPadTable[ (status & KEYREG_KEY1_MASK)>>KEYREG_KEY1_SHIFT ];
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+        if(nkey1 == KEY_WHEEL_1)
+        {
+            pdev->wheelkey |= WHEEL_FLAG1;
+            if(pdev->wheelkey & WHEEL_FLAG2)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG2;
+            }
+            if(pdev->last_key1 >0 || pdev->last_key2 >0)
+            {
+                if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+                {
+                    handle_scancode(pdev, pdev->last_key1, 0);
+                    pdev->last_key1 = 0;
+                }
+                if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+                {
+                    handle_scancode(pdev, pdev->last_key2, 0);
+                    pdev->last_key2 = 0;
+                }
+            }
+        }
+        else if(nkey1 == KEY_WHEEL_2)
+        {
+            pdev->wheelkey |= WHEEL_FLAG2;
+            if(pdev->wheelkey & WHEEL_FLAG1)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG1;
+            }
+            if(pdev->last_key1 >0 || pdev->last_key2 >0)
+            {
+                if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+                {
+                    handle_scancode(pdev, pdev->last_key1, 0);
+                    pdev->last_key1 = 0;
+                }
+                if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+                {
+                    handle_scancode(pdev, pdev->last_key2, 0);
+                    pdev->last_key2 = 0;
+                }
+            }
+        }
+        else
+        {
+            if(pdev->wheelkey & WHEEL_FLAG2)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG2;
+            }
+            if(pdev->wheelkey & WHEEL_FLAG1)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG1;
+            }
+            if(pdev->last_key1 >0 || pdev->last_key2 >0)
+            {
+                if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+                {
+                    handle_scancode(pdev, pdev->last_key1, 0);
+                    pdev->last_key1 = 0;
+                }
+                if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+                {
+                    handle_scancode(pdev, pdev->last_key2, 0);
+                    pdev->last_key2 = 0;
+                }
+            }
+            handle_scancode(pdev, nkey1, 1);
+            pdev->last_key1 = nkey1;
+        }
+#else
+        if(pdev->last_key1 >0 || pdev->last_key2 >0)
+        {
+            if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+            {
+                handle_scancode(pdev, pdev->last_key1, 0);
+                pdev->last_key1 = 0;
+            }
+            if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, pdev->last_key2, 0);
+                pdev->last_key2 = 0;
+            }
+        }
+        handle_scancode(pdev, nkey1, 1);
+        pdev->last_key1 = nkey1;
+#endif
+    }
+    else
+    {
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+        if(pdev->wheelkey & WHEEL_FLAG2)
+        {
+            pdev->wheelkey &= ~WHEEL_FLAG2;
+        }
+        if(pdev->wheelkey & WHEEL_FLAG1)
+        {
+            pdev->wheelkey &= ~WHEEL_FLAG1;
+        }
+#ifdef FIX_FOR_EC12E2424404
+        pdev->wheelkey_hit = 1;
+#endif
+
+#endif
+        if(pdev->last_key1)
+        {
+            handle_scancode(pdev, pdev->last_key1, 0);
+            pdev->last_key1 = 0;
+        }
+        if(pdev->last_key2)
+        {
+            handle_scancode(pdev, pdev->last_key2, 0);
+            pdev->last_key2 = 0;
+        }
+    }
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    if(phase != wheel_phase_table[pdev->wheelkey&0x3])
+    {
+        step = ((wheel_phase_table[pdev->wheelkey&0x3] - phase + 4 ) % 4 );
+        if(step == 2)
+            step = pdev->last_wheel_step;
+        else
+            pdev->last_wheel_step = step;
+        
+        /*printk("step %d\n",step);*/
+        switch(step)
+        {
+        case 1:
+            handle_scancode(pdev, KEY_WHEEL_1, 1);
+            handle_scancode(pdev, KEY_WHEEL_1, 0);
+            break;
+        case 3:
+            handle_scancode(pdev, KEY_WHEEL_2, 1);
+            handle_scancode(pdev, KEY_WHEEL_2, 0);
+            break;
+        default:
+            break;
+        }
+    }
+#endif
+    return(IRQ_HANDLED);
+}
+ 
+unsigned long setprescale (unsigned short nScale)
+{
+    unsigned long nValue;
+
+    nValue = inl(SCANINIT);
+    nValue = ( nValue & (~SCANINIT_PRSCL_MASK) ) | (nScale & SCANINIT_PRSCL_MASK);
+    outl(nValue, SCANINIT);
+    return nValue;
+}
+
+unsigned long setdebounce (unsigned char nDebounce)
+{
+    unsigned long nValue;
+
+    nValue = inl(SCANINIT);
+    nValue = ( nValue & (~SCANINIT_DBNC_MASK) ) | ((nDebounce<<16) & SCANINIT_DBNC_MASK);
+    outl(nValue, SCANINIT);
+    return nValue;
+}
+
+void keypad_enable ( unsigned char bState )
+{
+    unsigned long nreg;
+    if( bState ) 
+    {
+        nreg = inl(SYSCON_KTDIV);
+        nreg |= SYSCON_KTDIV_KEN;
+        SysconSetLocked( SYSCON_KTDIV, nreg );    
+    }
+    else
+    {
+        nreg = inl(SYSCON_KTDIV);
+        nreg &= (~SYSCON_KTDIV_KEN);
+        SysconSetLocked( SYSCON_KTDIV, nreg );    
+    }
+    return;
+}
+
+//=============================================================================
+// ep93xx_keypad_init
+//=============================================================================
+int __init ep93xx_keypad_init(void)
+{
+    int i;
+    int retval;
+
+    printk("%s\n", name);
+
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    dev.wheelkey = 0;
+    dev.last_wheel_step = 0;
+#ifdef FIX_FOR_EC12E2424404
+    dev.wheelkey_count = 0;
+    dev.wheelkey_hit = 0;
+#endif
+
+#endif
+
+    dev.last_key1 = 0;
+    dev.last_key2 = 0;
+    dev.input.name = name;
+    dev.input.evbit[0] = BIT(EV_KEY);
+
+    for (i = 0; i < KeyPad_SIZE; i++)
+        set_bit(KeyPadTable[i], dev.input.keybit);
+
+#ifdef FIX_FOR_EC12E2424404
+    setdebounce(0xfe);
+    setprescale(0x8);
+#else
+    setdebounce(0xfe);
+    setprescale(0x80);
+#endif
+    retval = request_irq( IRQ_KEY, ep93xx_keypad_isr, SA_INTERRUPT, "ep93xx_keypad", (void*)&dev);
+    if( retval )
+    {
+        printk(KERN_WARNING "ep93xx_keypad: failed to get keypad IRQ\n");
+        return retval;
+    }
+    
+    input_register_device((struct input_dev*)&dev);
+
+    keypad_enable(1);
+
+    return 0;
+}
+
+void __exit ep93xx_keypad_cleanup(void)
+{
+    input_unregister_device((struct input_dev*)&dev);
+}
+
+module_init(ep93xx_keypad_init);
+module_exit(ep93xx_keypad_cleanup);
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/drivers/char/ep93xx_keypad.h linux-2.6.8.1/drivers/char/ep93xx_keypad.h
--- linux-2.6.8.1-orig/drivers/char/ep93xx_keypad.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/char/ep93xx_keypad.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,93 @@
+/*
+ * ep93xx_keypad.h Keymap definitions
+ */
+#define SCROLL_WHEEL_KEY_SUPPORT
+
+
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+
+/*
+ *  Support for a scroll wheel key:
+ *      ALPS 12mm Size Insulated Shaft Type Encoder.
+ *  Part NO. :      EC12E2424404
+ *  Connect TO:     Col1/2-Row3
+ */
+#define FIX_FOR_EC12E2424404 1
+
+
+#define KEY_WHEEL_1      KEY_UP
+#define KEY_WHEEL_2      KEY_DOWN
+
+static int wheel_phase_table[16] = {1,0,2,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
+
+
+#endif
+
+
+//
+// This table is used to map the scan code to the Linux default keymap.
+//
+#define KeyPad_SIZE         (8*8)
+static unsigned int const KeyPadTable[KeyPad_SIZE] = 
+{
+/*             COL0        COL1        CLO2        COL3       COL4       COL5       COL6       COL7   */
+/*ROW0*/       KEY_ESC,    KEY_1 ,     KEY_2 ,     0,         0,         0,         0,         0, 
+/*ROW1*/       KEY_3 ,     KEY_4 ,     KEY_5 ,     0,         0,         0,         0,         0, 
+/*ROW2*/       KEY_6 ,     KEY_7 ,     KEY_ENTER,  0,         0,         0,         0,         0, 
+/*ROW3*/       0,          KEY_UP,     KEY_DOWN,   0,         0,         0,         0,         0, 
+/*ROW4*/       0,          0,          0,          0,         0,         0,         0,         0, 
+/*ROW5*/       0,          0,          0,          0,         0,         0,         0,         0, 
+/*ROW6*/       0,          0,          0,          0,         0,         0,         0,         0, 
+/*ROW7*/       0,          0,          0,          0,         0,         0,         0,         0
+};
+
+struct ep93xx_keypad_dev
+{
+    struct input_dev input;
+
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+
+#define WHEEL_FLAG1   1
+#define WHEEL_FLAG2  2
+    int wheelkey;
+    int last_wheel_step;
+
+#ifdef FIX_FOR_EC12E2424404
+    int wheelkey_buffer[4];
+    int wheelkey_count;
+    int wheelkey_hit;
+#endif
+
+#endif
+
+    int last_key1;
+    int last_key2;
+
+};
+
+#define SCANINIT_PRSCL_MASK         0x000003FF
+#define SCANINIT_PRSCL_SHIFT        0L
+#define SCANINIT_T2                 0x00001000
+#define SCANINIT_BACK               0x00002000
+#define SCANINIT_DIAG               0x00004000
+#define SCANINIT_DIS3KY             0x00008000
+#define SCANINIT_DBNC_MASK          0x00FF0000
+#define SCANINIT_DBNC_SHIFT         16L
+
+#define KEYREG_KEY1_MASK            0x0000003F
+#define KEYREG_KEY1_SHIFT           0L
+#define KEYREG_KEY2_MASK            0x00000Fc0
+#define KEYREG_KEY2_SHIFT           6L
+#define KEYREG_KEY1ROW_MASK         0x00000007
+#define KEYREG_KEY1ROW_SHIFT        0L
+#define KEYREG_KEY1COL_MASK         0x00000038
+#define KEYREG_KEY1COL_SHIFT        3L
+#define KEYREG_KEY2ROW_MASK         0x000001c0
+#define KEYREG_KEY2ROW_SHIFT        6L
+#define KEYREG_KEY2COL_MASK         0x00000E00
+#define KEYREG_KEY2COL_SHIFT        9L
+
+#define KEYREG_KEY1                 0x00001000
+#define KEYREG_KEY2                 0x00002000
+#define KEYREG_INT                  0x00004000
+#define KEYREG_K                    0x00008000
diff -burN linux-2.6.8.1-orig/drivers/char/ep93xx_rtc.c linux-2.6.8.1/drivers/char/ep93xx_rtc.c
--- linux-2.6.8.1-orig/drivers/char/ep93xx_rtc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/char/ep93xx_rtc.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,359 @@
+/*
+ *	Driver for the EP93xx I2C bus RTC device interface
+ *
+ *	Copyright (C) 2006 Cirrus Logic, Co.
+ *	Written by Shrek Wu
+ *	Real Time Clock interface for Linux
+ *
+ *	TODO: Implement periodic interrupts.
+ *	based on /driver/char/ip-rtc.c
+ *	Copyright (C) 2000 Silicon Graphics, Inc.
+ *	Written by Ulf Carlsson (ulfc@engr.sgi.com)
+ *
+ *	Based on code written by Paul Gortmaker.
+ *
+ *	This driver allows use of the real time clock (built into
+ *	nearly all computers) from user space. It exports the /dev/rtc
+ *	interface supporting various ioctl() and also the /proc/rtc
+ *	pseudo-file for status information.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ */
+
+#define RTC_VERSION		"1.09b"
+
+#include <linux/bcd.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+
+#include <linux/rtc_isl1208.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+spinlock_t ep93xx_rtc_lock;
+
+static int rtc_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg);
+
+static int rtc_read_proc(char *page, char **start, off_t off,
+                         int count, int *eof, void *data);
+
+static void get_rtc_time(struct rtc_time *rtc_tm);
+
+/*
+ *	Bits in rtc_status. (6 bits of room for future expansion)
+ */
+
+#define RTC_IS_OPEN		0x01	/* means /dev/rtc is in use	*/
+#define RTC_TIMER_ON		0x02	/* missed irq timer active	*/
+
+static unsigned char rtc_status;	/* bitmapped status byte.	*/
+static unsigned long rtc_freq;	/* Current periodic IRQ rate	*/
+
+
+/*
+ *	If this driver ever becomes modularised, it will be really nice
+ *	to make the epoch retain its value across module reload...
+ */
+
+static unsigned long epoch = 1970;	/* year corresponding to 0x00	*/
+
+static const unsigned char days_in_mo[] =
+{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+
+
+
+static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+
+	struct rtc_time wtime;
+#ifdef EP93xx_RTC_debug
+	printk("ioctol %x\n",cmd);
+#endif
+	switch (cmd) {
+	case RTC_RD_TIME:	/* Read the time/date from RTC	*/
+	{
+		get_rtc_time(&wtime);
+		break;
+	}
+	case RTC_SET_TIME:	/* Set the RTC */
+	{
+		int err=0;
+		struct rtc_time rtc_tm;
+		unsigned char mon, day, hrs, min, sec, leap_yr;
+		unsigned int yrs;
+
+		if (!capable(CAP_SYS_TIME)){
+			printk("%s: line %d ",__FUNCTION__,__LINE__);
+			return -EACCES;
+			}
+
+		if (copy_from_user(&rtc_tm, (struct rtc_time*)arg,
+				   sizeof(struct rtc_time))){
+			printk("%s line %d:copy from user fail ",__FUNCTION__,__LINE__);
+			return -EFAULT;
+			}
+			
+#ifdef EP93xx_RTC_debug			
+		printk("rtc_time: %02d:%02d:%02d\n rtc_date: %04d-%02d-%02d\n",
+		     rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec,
+		     rtc_tm.tm_year + 1900, rtc_tm.tm_mon + 1, rtc_tm.tm_mday);
+#endif		     
+		yrs = rtc_tm.tm_year + 1900;
+		mon = rtc_tm.tm_mon + 1;   /* tm_mon starts at zero */
+		day = rtc_tm.tm_mday;
+		hrs = rtc_tm.tm_hour;
+		min = rtc_tm.tm_min;
+		sec = rtc_tm.tm_sec;
+
+		if (yrs < 1970){
+			printk("yrs < 1970\n");
+			return -EINVAL;
+			}
+
+		leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+
+		if ((mon > 12) || (day == 0)){
+			printk("(mon > 12) || (day == 0)\n");
+			return -EINVAL;
+			}
+
+		if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr))){
+			printk("day > (days_in_mo[mon] + ((mon == 2) && leap_yr)\n");
+			return -EINVAL;
+			}
+
+		if ((hrs >= 24) || (min >= 60) || (sec >= 60)){
+			printk("((hrs >= 24) || (min >= 60) || (sec >= 60))\n");
+			return -EINVAL;
+			}
+
+		if ((yrs -= epoch) > 255){    /* They are unsigned */
+			printk("(yrs -= epoch) > 255\n");
+			return -EINVAL;
+			}
+
+		/*if (yrs > 169)
+			return -EINVAL;
+
+		if (yrs >= 100)
+			yrs -= 100;
+		*/
+		//sec = BIN2BCD(sec);
+		//min = BIN2BCD(min);
+		//hrs = BIN2BCD(hrs);
+		//day = BIN2BCD(day);
+		//mon = BIN2BCD(mon);
+		//yrs = BIN2BCD(yrs);
+
+		spin_lock_irq(&ep93xx_rtc_lock);
+		/*
+		rtc_tm.tm_year = yrs;
+		rtc_tm.tm_mon  = mon;   
+		rtc_tm.tm_mday = day;
+		rtc_tm.tm_hour = hrs;
+		rtc_tm.tm_min = min;
+		rtc_tm.tm_sec = sec;
+		*/
+		err = isl1208_do_command(RTC_SETDATETIME, (void *)&rtc_tm);
+		if(err!=0){
+			printk("%s: do command error:%d\n",__FUNCTION__,err);
+		}
+
+		spin_unlock_irq(&ep93xx_rtc_lock);
+
+		return 0;
+	}
+	default:{
+		printk("the command do not support now\n");
+		return -EINVAL;
+		}
+	}
+	return copy_to_user((void *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+}
+
+/*
+ *	We enforce only one user at a time here with the open/close.
+ *	Also clear the previous interrupt data on an open, and clean
+ *	up things on a close.
+ */
+
+static int rtc_open(struct inode *inode, struct file *file)
+{
+#ifdef EP93xx_RTC_debug
+	printk("%s\n",__FUNCTION__);
+#endif
+	spin_lock_irq(&ep93xx_rtc_lock);
+
+	if (rtc_status & RTC_IS_OPEN) {
+		spin_unlock_irq(&ep93xx_rtc_lock);
+		return -EBUSY;
+	}
+
+	rtc_status |= RTC_IS_OPEN;
+	spin_unlock_irq(&ep93xx_rtc_lock);
+
+	return 0;
+}
+
+static int rtc_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * Turn off all interrupts once the device is no longer
+	 * in use, and clear the data.
+	 */
+
+	spin_lock_irq(&ep93xx_rtc_lock);
+	rtc_status &= ~RTC_IS_OPEN;
+	spin_unlock_irq(&ep93xx_rtc_lock);
+
+	return 0;
+}
+
+/*
+ *	The various file operations we support.
+ */
+
+static struct file_operations rtc_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= rtc_ioctl,
+	.open		= rtc_open,
+	.release	= rtc_release,
+};
+
+static struct miscdevice rtc_dev=
+{
+	RTC_MINOR,
+	"rtc",
+	&rtc_fops
+};
+
+static int __init rtc_init(void)
+{
+
+#ifdef EP93xx_RTC_debug
+	printk("Real Time Clock Driver v%s\n", RTC_VERSION);
+#endif	
+	if (misc_register(&rtc_dev)) {
+		printk(KERN_ERR "rtc: cannot register misc device.\n");
+		return -ENODEV;
+	}
+	if (!create_proc_read_entry("driver/rtc", 0, NULL, rtc_read_proc, NULL)) {
+		printk(KERN_ERR "rtc: cannot create /proc/rtc.\n");
+		misc_deregister(&rtc_dev);
+		return -ENOENT;
+	}
+
+	printk("EP93xx RTC file system driver\n");
+
+	rtc_freq = 1024;
+
+	return 0;
+}
+
+static void __exit rtc_exit (void)
+{
+	/* interrupts and timer disabled at this point by rtc_release */
+
+	remove_proc_entry ("rtc", NULL);
+	misc_deregister(&rtc_dev);
+}
+
+module_init(rtc_init);
+module_exit(rtc_exit);
+
+/*
+ *	Info exported via "/proc/rtc".
+ */
+
+static int rtc_get_status(char *buf)
+{
+	char *p;
+	struct rtc_time tm;
+
+	/*
+	 * Just emulate the standard /proc/rtc
+	 */
+
+	p = buf;
+
+	get_rtc_time(&tm);
+
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p,
+		     "rtc_time\t: %02d:%02d:%02d\n"
+		     "rtc_date\t: %04d-%02d-%02d\n"
+	 	     "rtc_epoch\t: %04lu\n"
+		     "24hr\t\t: yes\n",
+		     tm.tm_hour, tm.tm_min, tm.tm_sec,
+		     tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, epoch);
+
+	return  p - buf;
+}
+
+static int rtc_read_proc(char *page, char **start, off_t off,
+                                 int count, int *eof, void *data)
+{
+        int len = rtc_get_status(page);
+        if (len <= off+count) *eof = 1;
+        *start = page + off;
+        len -= off;
+        if (len>count) len = count;
+        if (len<0) len = 0;
+        return len;
+}
+
+static void get_rtc_time(struct rtc_time *rtc_tm)
+{
+	/*
+	 * Do we need to wait for the last update to finish?
+	 */
+	int err=0;
+	/*
+	 * Only the values that we read from the RTC are set. We leave
+	 * tm_wday, tm_yday and tm_isdst untouched. Even though the
+	 * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated
+	 * by the RTC when initially set to a non-zero value.
+	 */
+#ifdef EP93xx_RTC_debug	 
+	printk("%s:\n",__FUNCTION__);
+#endif	
+	spin_lock_irq(&ep93xx_rtc_lock);
+	
+	err = isl1208_do_command(RTC_GETDATETIME, (void *)rtc_tm);
+	if(err!=0){
+		printk("%s: do command error:%d\n",__FUNCTION__,err);
+	}
+	spin_unlock_irq(&ep93xx_rtc_lock);
+
+
+
+	/*
+	 * Account for differences between how the RTC uses the values
+	 * and how they are defined in a struct rtc_time;
+	 */
+	//if ((rtc_tm->tm_year += (epoch - 1900)) <= 69)
+	//	rtc_tm->tm_year += 100;
+
+	//rtc_tm->tm_mon--;
+}
diff -burN linux-2.6.8.1-orig/drivers/char/keyboard.c linux-2.6.8.1/drivers/char/keyboard.c
--- linux-2.6.8.1-orig/drivers/char/keyboard.c	2004-08-14 19:56:26.000000000 +0900
+++ linux-2.6.8.1/drivers/char/keyboard.c	2007-01-24 13:19:57.000000000 +0900
@@ -1058,6 +1058,14 @@
 			if (keycode < BTN_MISC)
 				printk(KERN_WARNING "keyboard.c: can't emulate rawmode for keycode %d\n", keycode);
 
+#ifdef CONFIG_BOOTSPLASH
+	/* This code has to be redone for some non-x86 platforms */
+	if (down == 1 && (keycode == 0x3c || keycode == 0x01)) {	/* F2 and ESC on PC keyboard */
+		extern int splash_verbose(void);
+		if (splash_verbose())
+			return;
+	}
+#endif
 #ifdef CONFIG_MAGIC_SYSRQ	       /* Handle the SysRq Hack */
 	if (keycode == KEY_SYSRQ && (sysrq_down || (down == 1 && sysrq_alt))) {
 		sysrq_down = down;
diff -burN linux-2.6.8.1-orig/drivers/char/n_tty.c linux-2.6.8.1/drivers/char/n_tty.c
--- linux-2.6.8.1-orig/drivers/char/n_tty.c	2004-08-14 19:54:47.000000000 +0900
+++ linux-2.6.8.1/drivers/char/n_tty.c	2007-01-24 13:19:57.000000000 +0900
@@ -988,7 +988,6 @@
 		printk("n_tty_read_chan: called with read_buf == NULL?!?\n");
 		return -EIO;
 	}
-
 	/* Job control check -- must be done at start and after
 	   every sleep (POSIX.1 7.1.1.4). */
 	/* NOTE: not yet done after every sleep pending a thorough
@@ -1081,6 +1080,15 @@
 				retval = -ERESTARTSYS;
 				break;
 			}
+			#ifdef CONFIG_BOOTSPLASH
+				if (file->f_dentry->d_inode->i_rdev == MKDEV(TTY_MAJOR,0) ||
+					file->f_dentry->d_inode->i_rdev == MKDEV(TTY_MAJOR,1) ||
+					file->f_dentry->d_inode->i_rdev == MKDEV(TTYAUX_MAJOR,0) ||
+					file->f_dentry->d_inode->i_rdev == MKDEV(TTYAUX_MAJOR,1)) {
+						extern int splash_verbose(void);
+						(void)splash_verbose();
+				}               
+			#endif
 			clear_bit(TTY_DONT_FLIP, &tty->flags);
 			timeout = schedule_timeout(timeout);
 			set_bit(TTY_DONT_FLIP, &tty->flags);
diff -burN linux-2.6.8.1-orig/drivers/char/vt.c linux-2.6.8.1/drivers/char/vt.c
--- linux-2.6.8.1-orig/drivers/char/vt.c	2004-08-14 19:56:00.000000000 +0900
+++ linux-2.6.8.1/drivers/char/vt.c	2007-01-24 13:19:57.000000000 +0900
@@ -778,10 +778,6 @@
 	old_screen_size = screenbuf_size;
 
 	err = resize_screen(currcons, new_cols, new_rows);
-	if (err) {
-		kfree(newscreen);
-		return err;
-	}
 
 	video_num_lines = new_rows;
 	video_num_columns = new_cols;
@@ -3267,6 +3263,31 @@
 	return 0;
 }
 
+#ifdef CONFIG_BOOTSPLASH
+void con_remap_def_color(int currcons, int new_color)
+{
+       unsigned short *sbuf = screenbuf;
+       unsigned c, len = screenbuf_size >> 1;
+       int old_color;
+
+       if (sbuf) {
+	       old_color = def_color << 8;
+	       new_color <<= 8;
+	       while(len--) {
+		       c = *sbuf;
+		       if (((c ^ old_color) & 0xf000) == 0)
+			       *sbuf ^= (old_color ^ new_color) & 0xf000;
+		       if (((c ^ old_color) & 0x0f00) == 0)
+			       *sbuf ^= (old_color ^ new_color) & 0x0f00;
+		       sbuf++;
+	       }
+	       new_color >>= 8;
+       }
+       def_color = color = new_color;
+       update_attr(currcons);
+}
+#endif
+
 /*
  *	Visible symbols for modules
  */
diff -burN linux-2.6.8.1-orig/drivers/i2c/busses/Kconfig linux-2.6.8.1/drivers/i2c/busses/Kconfig
--- linux-2.6.8.1-orig/drivers/i2c/busses/Kconfig	2004-08-14 19:56:00.000000000 +0900
+++ linux-2.6.8.1/drivers/i2c/busses/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -5,6 +5,10 @@
 menu "I2C Hardware Bus support"
 	depends on I2C
 
+config I2C_EP93XX
+	tristate "EP93XX I2C"
+	depends on I2C && ARCH_EP93XX
+
 config I2C_ALI1535
 	tristate "ALI 1535"
 	depends on I2C && PCI && EXPERIMENTAL
diff -burN linux-2.6.8.1-orig/drivers/i2c/busses/Makefile linux-2.6.8.1/drivers/i2c/busses/Makefile
--- linux-2.6.8.1-orig/drivers/i2c/busses/Makefile	2004-08-14 19:54:48.000000000 +0900
+++ linux-2.6.8.1/drivers/i2c/busses/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -32,7 +32,7 @@
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
-
+obj-$(CONFIG_I2C_EP93XX)	+= i2c-ep93xx.o
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
diff -burN linux-2.6.8.1-orig/drivers/i2c/busses/i2c-ep93xx.c linux-2.6.8.1/drivers/i2c/busses/i2c-ep93xx.c
--- linux-2.6.8.1-orig/drivers/i2c/busses/i2c-ep93xx.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/i2c/busses/i2c-ep93xx.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,192 @@
+/* ------------------------------------------------------------------------ *
+ * i2c-ep933xx.c I2C bus glue for Cirrus EP93xx                             *
+ * ------------------------------------------------------------------------ *
+
+   Copyright (C) 2004 Michael Burian
+   
+   Based on i2c-parport-light.c
+   Copyright (C) 2003-2004 Jean Delvare <khali@linux-fr.org>
+  
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ------------------------------------------------------------------------ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <asm/io.h>
+
+//1/(2*clockfrequency)
+#define EE_DELAY_USEC       50
+#define GPIOG_EECLK 1
+#define GPIOG_EEDAT 2
+
+/* ----- I2C algorithm call-back functions and structures ----------------- */
+
+// TODO: optimize
+static void ep93xx_setscl(void *data, int state)
+{
+	unsigned int uiPGDR, uiPGDDR;
+
+	uiPGDR = inl(GPIO_PGDR);
+	uiPGDDR = inl(GPIO_PGDDR);
+
+	/* Configure the clock line as output. */
+	uiPGDDR |= GPIOG_EECLK;
+	outl(uiPGDDR, GPIO_PGDDR);
+
+	/* Set clock line to state */
+	if(state)
+		uiPGDR |= GPIOG_EECLK;
+	else
+		uiPGDR &= ~GPIOG_EECLK;
+	
+	outl(uiPGDR, GPIO_PGDR);
+}
+
+static void ep93xx_setsda(void *data, int state)
+{
+	unsigned int uiPGDR, uiPGDDR;
+	
+	uiPGDR = inl(GPIO_PGDR);
+	uiPGDDR = inl(GPIO_PGDDR);
+
+	/* Configure the data line as output. */
+	uiPGDDR |= GPIOG_EEDAT;
+	outl(uiPGDDR, GPIO_PGDDR);
+
+	/* Set data line to state */
+	if(state)
+		uiPGDR |= GPIOG_EEDAT;
+	else
+		uiPGDR &= ~GPIOG_EEDAT;
+	
+	outl(uiPGDR, GPIO_PGDR);
+}
+
+static int ep93xx_getscl(void *data)
+{
+	unsigned int uiPGDR, uiPGDDR;
+	
+	uiPGDR = inl(GPIO_PGDR);
+	uiPGDDR = inl(GPIO_PGDDR);
+
+	/* Configure the clock line as input */
+	uiPGDDR &= ~GPIOG_EECLK;
+	outl(uiPGDDR, GPIO_PGDDR);
+	
+	/* Return state of the clock line */
+	return (inl(GPIO_PGDR) & GPIOG_EECLK) ? 1 : 0;
+}
+
+static int ep93xx_getsda(void *data)
+{
+	unsigned int uiPGDR, uiPGDDR;
+	uiPGDR = inl(GPIO_PGDR);
+	uiPGDDR = inl(GPIO_PGDDR);
+
+	/* Configure the data line as input */
+	uiPGDDR &= ~GPIOG_EEDAT;
+	outl(uiPGDDR, GPIO_PGDDR);
+
+	/* Return state of the data line */
+	return (inl(GPIO_PGDR) & GPIOG_EEDAT) ? 1 : 0;
+}
+
+/* ------------------------------------------------------------------------
+ * Encapsulate the above functions in the correct operations structure.
+ * This is only done when more than one hardware adapter is supported.
+ */
+
+/* last line (us, ms, timeout)
+ * us dominates the bit rate: 10us  means: 100Kbit/sec(25 means 40kbps)
+ *                            10ms  not known
+ *                            100ms timeout
+ */
+static struct i2c_algo_bit_data ep93xx_data = {
+	.setsda		= ep93xx_setsda,
+	.setscl		= ep93xx_setscl,
+	.getsda		= ep93xx_getsda,
+	.getscl		= ep93xx_getscl,
+	.udelay		= 10,
+	.mdelay		= 10,
+	.timeout	= HZ,
+};
+
+/* ----- I2c structure ---------------------------------------------------- */
+static struct i2c_adapter ep93xx_adapter = {
+	.owner		= THIS_MODULE,
+	.class		= I2C_CLASS_HWMON,
+	.id		= I2C_HW_B_LP,
+	.algo_data	= &ep93xx_data,
+	.name		= "EP93XX I2C bit-bang interface",
+};
+
+/* ----- Module loading, unloading and information ------------------------ */
+
+static int __init i2c_ep93xx_init(void)
+{
+	unsigned long uiPGDR, uiPGDDR;
+	
+	/* Read the current value of the GPIO data and data direction registers. */
+	uiPGDR = inl(GPIO_PGDR);
+	uiPGDDR = inl(GPIO_PGDDR);
+	
+	/* If the GPIO pins have not been configured since reset, the data 
+	 * and clock lines will be set as inputs and with data value of 0.
+	 * External pullup resisters are pulling them high.
+	 * Set them both high before configuring them as outputs. */
+	uiPGDR |= (GPIOG_EEDAT | GPIOG_EECLK);
+	outl(uiPGDR, GPIO_PGDR);
+
+	/* Delay to meet the EE Interface timing specification. */
+	udelay(EE_DELAY_USEC);
+
+	
+	/* Configure the EE data and clock lines as outputs. */
+	uiPGDDR |= (GPIOG_EEDAT | GPIOG_EECLK);
+	outl(uiPGDDR, GPIO_PGDDR);
+
+	/* Delay to meet the EE Interface timing specification. */
+	udelay(EE_DELAY_USEC);
+
+	/* Reset hardware to a sane state (SCL and SDA high) */
+	ep93xx_setsda(NULL, 1);
+	ep93xx_setscl(NULL, 1);
+
+	if (i2c_bit_add_bus(&ep93xx_adapter) > 0) {
+		printk(KERN_ERR "i2c-ep93xx: Unable to register with I2C\n");
+		return -ENODEV;
+	}
+	
+	return 0;
+}
+
+static void __exit i2c_ep93xx_exit(void)
+{
+	i2c_bit_del_bus(&ep93xx_adapter);
+}
+
+MODULE_AUTHOR("Michael Burian");
+MODULE_DESCRIPTION("I2C bus glue for Cirrus EP93xx processors");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_ep93xx_init);
+module_exit(i2c_ep93xx_exit);
diff -burN linux-2.6.8.1-orig/drivers/i2c/chips/Kconfig linux-2.6.8.1/drivers/i2c/chips/Kconfig
--- linux-2.6.8.1-orig/drivers/i2c/chips/Kconfig	2004-08-14 19:55:33.000000000 +0900
+++ linux-2.6.8.1/drivers/i2c/chips/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -286,4 +286,16 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-rtc8564.
 
+config SENSORS_RTC_ISL1208
+        tristate "ISL 1208 RTC chip"
+        depends on I2C && EXPERIMENTAL
+        select I2C_SENSOR
+        help
+          If you say yes here you get support for the ISL 1208 RTC chip.
+
+          This driver can also be built as a module.  If so, the module
+          will be called i2c-isl1208.
+
+
+
 endmenu
diff -burN linux-2.6.8.1-orig/drivers/i2c/chips/Makefile linux-2.6.8.1/drivers/i2c/chips/Makefile
--- linux-2.6.8.1-orig/drivers/i2c/chips/Makefile	2004-08-14 19:56:25.000000000 +0900
+++ linux-2.6.8.1/drivers/i2c/chips/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -26,6 +26,7 @@
 obj-$(CONFIG_SENSORS_PCF8574)	+= pcf8574.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_SENSORS_RTC8564)	+= rtc8564.o
+obj-$(CONFIG_SENSORS_RTC_ISL1208)   += rtc_isl1208.o
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
 obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l785ts.o
 
diff -burN linux-2.6.8.1-orig/drivers/i2c/chips/rtc_isl1208.c linux-2.6.8.1/drivers/i2c/chips/rtc_isl1208.c
--- linux-2.6.8.1-orig/drivers/i2c/chips/rtc_isl1208.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/i2c/chips/rtc_isl1208.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,594 @@
+/*
+ *  linux/drivers/i2c/chips/rtc_isl1208.c
+ *  Copyright (C) 2006 Shrek Wu
+ *
+ *	based on based on linux/drivers/i2c/chips/rtc8289.c
+ *  Copyright (C) 2002-2004 Stefan Eletzhofer
+ *
+ *	based on linux/drivers/acron/char/pcf8583.c
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Driver for isl RTC 1208 chip
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/rtc.h>		/* get the user-level API */
+#include <linux/init.h>
+#include <linux/bcd.h>
+
+#include <linux/rtc_isl1208.h>
+
+#define DRV_NAME "isl1208"
+#define DRV_VERSION "0.1"
+
+//#define ISL1208_DEBUG
+
+#ifdef ISL1208_DEBUG
+#define _DBG(x, fmt, args...) do{ printk("%s: " fmt "\n", __FUNCTION__, ##args); } while(0);
+#else
+#define _DBG(x, fmt, args...) do { } while(0);
+#endif
+
+
+
+struct isl1208_data {
+	struct i2c_client client;
+	u16 ctrl;
+	struct list_head list;
+	unsigned int epoch;
+};
+
+
+
+static struct i2c_driver isl1208_driver;
+
+static unsigned short ignore[] = { I2C_CLIENT_END };
+static unsigned short normal_addr[] = {
+	ISL1208_I2C_ADDR>>1, I2C_CLIENT_END};
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c		= normal_addr,
+	.normal_i2c_range	= ignore,
+	.probe			= ignore,
+	.probe_range		= ignore,
+	.ignore			= ignore,
+	.ignore_range		= ignore,
+	.force			= ignore,
+};
+
+
+
+static LIST_HEAD(isl1208_RTC_clients);
+
+/* block read */
+static int isl1208_read(struct i2c_client *client, unsigned char adr,
+			unsigned char *buf, unsigned char len)
+{
+	int ret = -EIO;
+	unsigned char addr[1] = { adr };
+	struct i2c_msg msgs[2] = {
+		{client->addr, client->flags, sizeof(addr), addr},
+		{client->addr, client->flags|I2C_M_RD, len, buf}
+	};
+
+	_DBG(1, "client=%p, adr=%d, buf=%p, len=%d", client, adr, buf, len);
+
+	/*check the param is or no valid*/
+	if (!buf || !client) {
+		ret = -1;
+		goto done;
+	}
+	
+	if(len == 0){
+		ret = -2;
+		goto done;
+	}
+	
+	if(adr > ISL1208_REG_USR2){
+		ret = -3;
+		goto done;		
+	}
+	
+	if(adr + len > ISL1208_REG_USR2 + 1){
+		ret = -4;
+		goto done;		
+	}
+	
+	/*transfer data based on I2C bus*/
+	ret = i2c_transfer(client->adapter, msgs, 2);
+	if (ret == 2) {
+		ret = 0;
+	}
+	
+	if (ret < 0 ){
+		ret = -5;
+	}
+
+
+done:
+	_DBG(1, "function %s line %d: ret=%d", __FUNCTION__,__LINE__,ret);
+	return ret;
+}
+
+/* block write */
+static int isl1208_write(struct i2c_client *client, unsigned char adr,
+			 unsigned char *data, unsigned char len)
+{
+	int ret = 0;
+	int i;
+	unsigned char i2c_buf[ISL1208_REG_USR2 + 2];/*address + data*/
+	struct i2c_msg msgs[1] = {
+		{ client->addr, client->flags, len + 1, i2c_buf }
+	};
+
+	/*check the param is or no valid*/
+	if (!client || !data || len > 15) {
+		ret = -1;
+		goto done;
+	}
+
+	if(len == 0){
+		ret = -2;
+		goto done;
+	}
+	
+	if(adr > ISL1208_REG_USR2){
+		ret = -3;
+		goto done;		
+	}
+	
+	if(adr + len > ISL1208_REG_USR2 + 1){
+		ret = -4;
+		goto done;		
+	}	
+	_DBG(1, "client=%p, adr=%d, buf=%p, len=%d", client, adr, data, len);	
+	
+	/**/
+	i2c_buf[0] = adr;
+	memcpy(&i2c_buf[1], data, len);
+
+	/*transfer data based on I2C bus*/
+	ret = i2c_transfer(client->adapter, msgs, 1);
+	if (ret == 1) {
+		ret = 0;
+	}
+	
+	if(ret < 0){
+		ret = -5;
+	}
+	
+done:
+	_DBG(1, "function %s line %d: ret=%d", __FUNCTION__,__LINE__,ret);
+	return ret;
+}
+
+static int isl1208_i2c_get_sr(struct i2c_client *client)
+{
+	return i2c_smbus_read_byte_data (client, ISL1208_REG_SR);
+}
+
+static int isl1208_get_datetime(struct i2c_client *client, struct rtc_time *tm)
+{
+	int ret = -EIO;
+	unsigned char  regs[ISL1208_RTC_SECTION_LEN] = { 0, };
+	
+	/*check the param is or no valid*/	
+	if (!tm || !client){
+		_DBG(1, "function %s line %d: ret=%d", __FUNCTION__,__LINE__,ret);
+		return -EINVAL;
+	}
+
+	memset(regs, 0, sizeof(regs));
+		
+	/*check read status register */
+	if ((ret = isl1208_i2c_get_sr(client)) < 0) {
+		dev_err(&client->dev, "%s: reading SR failed %x \n", __func__,ret);
+		return -EIO;
+	}
+	
+	if (ret & ISL1208_REG_SR_RTCF){
+		dev_warn(&client->dev, "rtc power failure detected, "
+			 "please set clock.\n");
+	}
+	
+	/* read RTC date registers */
+	if (ret = isl1208_read(client, 0, regs, ISL1208_RTC_SECTION_LEN))
+	{
+		dev_err(&client->dev, "%s: reading RTC section failed %x\n",
+			__func__,ret);
+		return -EIO;
+	}
+
+	_DBG(1, "client=%p, tm=%p", client, tm);
+
+	/* century stored in minute alarm reg */
+	tm->tm_sec = BCD2BIN(regs[ISL1208_REG_SC]);
+	tm->tm_min = BCD2BIN(regs[ISL1208_REG_MN]);
+	{ 
+		/* HR field has a more complex interpretation */
+		const unsigned char _hr = regs[ISL1208_REG_HR];
+		if (_hr & ISL1208_REG_HR_MIL){ 
+			/* 24h format */
+			tm->tm_hour = BCD2BIN(_hr & 0x3f);
+		}
+		else { 
+			/* 12h format*/
+			tm->tm_hour = BCD2BIN(_hr & 0x1f);
+			if (_hr & ISL1208_REG_HR_PM){ 
+				/* PM flag set */
+				tm->tm_hour += 12;
+			}
+		}
+	}
+
+	tm->tm_mday = BCD2BIN(regs[ISL1208_REG_DT]);
+	tm->tm_mon = BCD2BIN(regs[ISL1208_REG_MO]) - 1; /* rtc starts at 1 */
+	tm->tm_year = BCD2BIN(regs[ISL1208_REG_YR]) + 100;
+	tm->tm_wday = BCD2BIN(regs[ISL1208_REG_DW]);
+
+	_DBG(1,"%s: tm is secs=%d, mins=%d, hours=%d, "
+		"mday=%d, mon=%d, year=%d, wday=%d\n",
+		__FUNCTION__,
+		tm->tm_sec, tm->tm_min, tm->tm_hour,
+		tm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);
+	return 0;
+}
+
+static int
+isl1208_set_datetime(struct i2c_client *client, struct rtc_time *tm,int datetoo)
+{
+	int ret, len = 5;
+	unsigned char regs[ISL1208_RTC_SECTION_LEN] = { 0, };
+
+
+	/*check the param is or no valid*/	
+	if (!tm || !client){
+		_DBG(1, "function %s line %d: ret=%d", __FUNCTION__,__LINE__,ret);
+		return -EINVAL;
+	}
+
+	//_DBGRTCTM(2, *tm);
+
+	/*set the RTC register value*/
+	regs[ISL1208_REG_SC] = BIN2BCD(tm->tm_sec);
+	regs[ISL1208_REG_MN] = BIN2BCD(tm->tm_min);
+	regs[ISL1208_REG_HR] = BIN2BCD(tm->tm_hour) | ISL1208_REG_HR_MIL;
+
+	if (datetoo) {
+		regs[ISL1208_REG_DT] = BIN2BCD(tm->tm_mday);
+		regs[ISL1208_REG_MO] = BIN2BCD(tm->tm_mon + 1);
+		regs[ISL1208_REG_YR] = BIN2BCD(tm->tm_year - 100);
+
+		regs[ISL1208_REG_DW] = BIN2BCD(tm->tm_wday & 7);
+	}
+	
+	/*check read status register */
+	if ((ret = isl1208_i2c_get_sr(client)) < 0) {
+		dev_err(&client->dev, "%s: reading SR failed %x\n", __func__,ret);
+		return -EIO;
+	}
+
+	/* set WRTC */
+	if ( (ret=i2c_smbus_write_byte_data (client, ISL1208_REG_SR,
+				       ret | ISL1208_REG_SR_WRTC) ) < 0) {
+		dev_err(&client->dev, "%s: writing SR failed %x\n", __func__,ret);
+		return -EIO;
+	}
+
+	/* write RTC registers */
+	if (ret = isl1208_write(client, 0, regs, ISL1208_RTC_SECTION_LEN)) {
+		dev_err(&client->dev, "%s: writing RTC section failed %x\n",
+			__func__,ret);
+		return -EIO;
+	}
+
+	/* clear WRTC again */
+	if ( (ret = i2c_smbus_write_byte_data (client, ISL1208_REG_SR,
+				       ret & ~ISL1208_REG_SR_WRTC) ) < 0) {
+		dev_err(&client->dev, "%s: writing SR failed %x\n", __func__,ret);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int isl1208_i2c_read_alarm(struct i2c_client *client,
+				  struct rtc_wkalrm *alarm)
+{
+	struct rtc_time *const tm = &alarm->time;
+	unsigned char  regs[ISL1208_ALARM_SECTION_LEN] = { 0, };
+	int sr,ret = 0;
+	
+	/*check the param is or no valid*/	
+	if (!alarm || !client){
+		_DBG(1, "function %s line %d: ret=%d", __FUNCTION__,__LINE__,ret);
+		return -EINVAL;
+	}
+
+	memset(regs, 0, sizeof(regs));
+
+	/*check read status register */	
+	if ((sr = isl1208_i2c_get_sr(client)) < 0) {
+		dev_err(&client->dev, "%s: reading SR failed %x\n", __func__,sr);
+		return -EIO;
+	}
+	if (sr & ISL1208_REG_SR_RTCF){
+		dev_warn(&client->dev, "rtc power failure detected, "
+			 "please set clock.\n");
+	}
+	
+	/* read ALARM date registers */
+	if (sr = isl1208_read(client, ISL1208_REG_SCA, regs,
+				  ISL1208_ALARM_SECTION_LEN))
+	{
+		dev_err(&client->dev, "%s: reading alarm section failed %x\n",
+			__func__,sr);
+		return -EIO;
+	}
+
+	/* MSB of each alarm register is an enable bit */
+	tm->tm_sec  = BCD2BIN(regs[ISL1208_REG_SCA-ISL1208_REG_SCA] & 0x7f);
+	tm->tm_min  = BCD2BIN(regs[ISL1208_REG_MNA-ISL1208_REG_SCA] & 0x7f);
+	tm->tm_hour = BCD2BIN(regs[ISL1208_REG_HRA-ISL1208_REG_SCA] & 0x3f);
+	tm->tm_mday = BCD2BIN(regs[ISL1208_REG_DTA-ISL1208_REG_SCA] & 0x3f);
+	tm->tm_mon  = BCD2BIN(regs[ISL1208_REG_MOA-ISL1208_REG_SCA] & 0x1f)-1;
+	tm->tm_wday = BCD2BIN(regs[ISL1208_REG_DWA-ISL1208_REG_SCA] & 0x03);
+
+	_DBG(1, "%s: tm is secs=%d, mins=%d, hours=%d, "
+		"mday=%d, mon=%d, wday=%d\n",
+		__FUNCTION__,
+		tm->tm_sec, tm->tm_min, tm->tm_hour,
+		tm->tm_mday, tm->tm_mon, tm->tm_wday);
+		
+	return 0;
+}
+
+
+
+static int
+isl1208_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+
+	_DBG(1,"cmd=%d", cmd);
+
+	switch (cmd) {
+	case RTC_GETDATETIME:
+		return isl1208_get_datetime(client, arg);
+
+	case RTC_SETTIME:
+		return isl1208_set_datetime(client, arg, 0);
+
+	case RTC_SETDATETIME:
+		return isl1208_set_datetime(client, arg, 1);
+		
+	case RTC_GETALARM:
+		return isl1208_i2c_read_alarm(client, arg);
+	//case RTC_GETCTRL:
+	//	return rtc8564_get_ctrl(client, arg);
+
+	//case RTC_SETCTRL:
+	//	return rtc8564_set_ctrl(client, arg);
+
+	//case MEM_READ:
+	//	return rtc8564_read_mem(client, arg);
+
+	//case MEM_WRITE:
+	//	return rtc8564_write_mem(client, arg);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+/* Workaround until the I2C subsytem will allow to send
+ * commands to a specific client. This function will send the command
+ * to the first client.
+ */
+int isl1208_do_command(unsigned int cmd, void *arg)
+{
+	struct list_head *walk;
+	struct list_head *tmp;
+	struct isl1208_data *data;
+	
+	_DBG(1,"%s: start\n",__FUNCTION__);
+	list_for_each_safe(walk, tmp, &isl1208_RTC_clients) {
+		data = list_entry(walk, struct isl1208_data, list);
+		return isl1208_command(&data->client, cmd, arg);
+	}
+	_DBG(1,"%s:isl1208_RTC_clients failes\n",__FUNCTION__);
+	return -ENODEV;
+}
+
+
+
+/* simple check to see wether we have a isl1208 */
+static int isl1208_i2c_validate_client(struct i2c_client *client)
+{
+	u8 regs[ISL1208_RTC_SECTION_LEN] = { 0, };
+	u8 zero_mask[ISL1208_RTC_SECTION_LEN] = {
+		0x80, 0x80, 0x40, 0xc0, 0xe0, 0x00, 0xf8
+	};
+	int i,ret;
+
+	_DBG(1,"%s\n",__FUNCTION__);
+
+	if (ret = isl1208_read(client, 0, regs, ISL1208_RTC_SECTION_LEN)){
+		printk("function %s line %d: ret=%d", __FUNCTION__,__LINE__,ret);
+		return -EIO;
+	}
+
+	for (i = 0; i < ISL1208_RTC_SECTION_LEN; ++i) {
+		if (regs[i] & zero_mask[i]) {/* check if bits are cleared */
+			printk("function %s line %d: regs[i]=%d", __FUNCTION__,__LINE__,regs[i]);
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+static int isl1208_attach(struct i2c_adapter *adap, int addr, int kind)
+{
+	int ret = 0;
+	int err = 0;
+	struct i2c_client *new_client;
+	struct isl1208_data *new_data;
+
+	struct rtc_time tm;
+
+
+	/**/
+	/*if (!i2c_check_functionality(adap, I2C_FUNC_I2C)) {
+		ret = -ENODEV;
+		printk("function %s line %d: ret=%d\n", __FUNCTION__,__LINE__,ret);
+		goto exit;
+	}*/
+	
+	/**/
+	new_data = kmalloc(sizeof(struct isl1208_data), GFP_KERNEL);
+	if (!new_data) {
+		ret = -ENOMEM;
+		printk("function %s line %d: ret=%d\n", __FUNCTION__,__LINE__,ret);
+		goto exit;
+	}
+	memset(new_data, 0, sizeof(struct isl1208_data));
+	
+	
+	/* 
+	 * The common I2C client data is placed right before the
+	 * specific RTC chip data. 
+	 */
+	new_client = &new_data->client;
+	i2c_set_clientdata(new_client, new_data);
+	
+	new_client->addr = addr;
+	new_client->adapter = adap;
+	new_client->driver = &isl1208_driver;
+	
+	new_client->id = isl1208_driver.id;
+	new_client->flags = 0;//I2C_CLIENT_ALLOW_USE | I2C_DF_NOTIFY;
+		
+
+	/* Verify the chip is really an ISL1208 */
+	if (kind < 0) {
+		if ((isl1208_i2c_validate_client(new_client)) < 0){
+			ret = -ENODEV;
+			printk("function %s line %d: ret=%d", __FUNCTION__,__LINE__,ret);
+			goto done;
+		}
+	}
+	
+	/* We can fill in the remaining client fields */
+	strlcpy(new_client->name, DRV_NAME, I2C_NAME_SIZE);
+
+	_DBG(1,"client=%p\n", new_client);
+	_DBG(1,"client.id=%d\n", new_client->id);	
+	
+	/* Inform the i2c layer */
+	if ((ret = i2c_attach_client(new_client)))
+		goto done;
+	/*add the data struct into list */	
+	list_add(&new_data->list, &isl1208_RTC_clients);
+
+	_DBG(1,"chip found, driver name %s,driver version %s\n",DRV_NAME,DRV_VERSION);
+	
+	/* Check the status of RTC.If requested, set the system time */
+	if ((ret = isl1208_i2c_get_sr (new_client)) < 0) {
+		dev_err(&new_client->dev, "reading status failed\n");
+		goto failout_detach;
+	}
+
+	if (ret & ISL1208_REG_SR_RTCF){
+		dev_warn(&new_client->dev, "rtc power failure detected, "
+			 "please set clock.\n");
+	}
+
+
+/*
+	tm.tm_sec = 0;//BCD2BIN(00);
+	tm.tm_min = 12;//BCD2BIN(20);
+	tm.tm_hour = 13;//BCD2BIN(13 & 0x3f);
+	tm.tm_mday = 6;//BCD2BIN(6);
+	tm.tm_mon = 9-1;//BCD2BIN(9) - 1; 
+	tm.tm_year = 106;//BCD2BIN(106);
+	tm.tm_wday = 2;//BCD2BIN(2);
+
+	isl1208_set_datetime(new_client, &tm,1);
+	isl1208_get_datetime(new_client, &tm);
+*/
+	
+	return 0;
+	
+failout_detach:
+	i2c_detach_client(new_client);	
+done:
+	kfree(new_data);
+exit:
+	return ret;
+}
+
+static int isl1208_attach_adapter(struct i2c_adapter *adap)
+{
+	_DBG(1,"%s\n",__FUNCTION__);
+	return i2c_probe(adap, &addr_data, isl1208_attach);
+}
+
+static int isl1208_detach_client(struct i2c_client *client)
+{
+	int err;
+	struct isl1208_data *data = i2c_get_clientdata(client);
+
+	_DBG(1,"%s\n",__FUNCTION__);
+
+	if ((err = i2c_detach_client(client)))
+	{
+		printk("function %s line %d:client=%p, err=%d", __FUNCTION__,__LINE__,client, err);
+		return err;	
+	}
+		
+	list_del(&data->list);
+	kfree(data);
+	
+	return 0;
+}
+
+static struct i2c_driver isl1208_driver = {
+	.owner		= THIS_MODULE,
+	.name		= DRV_NAME,
+	.id		= I2C_DRIVERID_ISL1208,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter = isl1208_attach_adapter,
+	.detach_client	= isl1208_detach_client,
+	.command	= isl1208_command
+};
+
+static __init int isl1208_init(void)
+{
+	int ret = 0;
+	ret = i2c_add_driver(&isl1208_driver);
+	_DBG(1,"%s over %d\n",__FUNCTION__,ret);
+	return ret;
+}
+
+static __exit void isl1208_exit(void)
+{
+	_DBG(1,"%s\n",__FUNCTION__);
+	i2c_del_driver(&isl1208_driver);
+}
+
+MODULE_AUTHOR("Shrek Wu");
+MODULE_DESCRIPTION("Intersil ISL1208 RTC driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+EXPORT_SYMBOL_GPL(isl1208_do_command);
+
+module_init(isl1208_init);
+module_exit(isl1208_exit);
diff -burN linux-2.6.8.1-orig/drivers/ide/Kconfig linux-2.6.8.1/drivers/ide/Kconfig
--- linux-2.6.8.1-orig/drivers/ide/Kconfig	2004-08-14 19:55:32.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -324,6 +324,19 @@
 	  and your BIOS does not already do this for you, then say Y here.
 	  Otherwise say N.
 
+config BLK_DEV_IDE_EP93XX
+        bool "EP93xx support"
+        depends on (ARCH_EP9312 || ARCH_EP9315 || ARCH_EP9315A )
+        help
+          If you want IDE support for EP9312&EP9315&EP9315A, say Y here.
+
+config BLK_DEV_IDE_DMA_EP93XX
+        bool "EP93xx IDE DMA support"
+       depends on (ARCH_EP9312 || ARCH_EP9315 || ARCH_EP9315A )
+        help
+          If you want IDE DMA support for your EP9312&EP9315&EP9315A, say Y here.
+
+                                                                                                                     
 config BLK_DEV_IDEPNP
 	bool "PNP EIDE support"
 	depends on PNP
@@ -798,7 +811,7 @@
 	  Apple machines.
 
 config IDE_ARM
-	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
+	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK || ARCH_EP9312 || ARCH_EP9315 || ARCH_EP9315A )
 
 config BLK_DEV_IDE_ICSIDE
 	tristate "ICS IDE interface support"
@@ -1038,7 +1051,7 @@
 endif
 
 config BLK_DEV_IDEDMA
-	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_DMA_EP93XX
 
 config IDEDMA_IVB
 	bool "IGNORE word93 Validation BITS"
diff -burN linux-2.6.8.1-orig/drivers/ide/arm/Makefile linux-2.6.8.1/drivers/ide/arm/Makefile
--- linux-2.6.8.1-orig/drivers/ide/arm/Makefile	2004-08-14 19:54:46.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/arm/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -1,5 +1,7 @@
 
 obj-$(CONFIG_BLK_DEV_IDE_ICSIDE)	+= icside.o
 obj-$(CONFIG_BLK_DEV_IDE_RAPIDE)	+= rapide.o
+obj-$(CONFIG_BLK_DEV_IDE_EP93XX)	+= ide-ep93xx.o
+obj-$(CONFIG_BLK_DEV_IDE_DMA_EP93XX)	+= ide-dma-ep93xx.o
 
 EXTRA_CFLAGS	:= -Idrivers/ide
diff -burN linux-2.6.8.1-orig/drivers/ide/arm/ide-dma-ep93xx.c linux-2.6.8.1/drivers/ide/arm/ide-dma-ep93xx.c
--- linux-2.6.8.1-orig/drivers/ide/arm/ide-dma-ep93xx.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/arm/ide-dma-ep93xx.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1360 @@
+/******************************************************************************
+ * drivers/ide/arm/ide-dma-ep93xx.c
+ *
+ * Support for IDE UDMA
+ * Version 1.0 for EP93XX-E1
+ *
+ * Copyright (C) 2005  Cirrus Logic
+ *
+ * A large portion of this file is based on the ide-dma.c
+ * and the respective pmac version of it
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#include <linux/ide.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+#include <asm/ide.h>
+#include <asm/irq.h>
+#include <asm/arch/ide.h>
+#include <asm/arch/dma.h>
+#include <asm/hardware.h>
+
+//#define EP93XX_IDE_DMA_DEBUG
+//#define DEBUG_VADDR
+
+#ifdef EP93XX_IDE_DMA_DEBUG
+#define DPRINTK( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DPRINTK( fmt, arg... )
+#endif
+
+static void
+ep93xx_set_pio(void);
+
+
+#define ep93xx_ide_dma_intr ide_dma_intr
+
+//this functions comes from PCI PC land
+ide_startstop_t ide_dma_intr (ide_drive_t *drive)
+{
+	u8 stat = 0, dma_stat = 0;
+	
+	DPRINTK("%s\n", __FUNCTION__);
+
+	dma_stat = HWIF(drive)->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);	/* get drive status */
+	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
+		if (!dma_stat) {
+			struct request *rq = HWGROUP(drive)->rq;
+
+			DRIVER(drive)->end_request(drive, 1, rq->nr_sectors);
+			return ide_stopped;
+		}
+		printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n", 
+		       drive->name, dma_stat);
+	}
+	return DRIVER(drive)->error(drive, "dma_intr", stat);
+}
+
+
+/*****************************************************************************
+ *
+ * ep93xx_config_ide_device()
+ *
+ * This function sets up the ep93xx ide device for a dma transfer by first
+ * probing to find the best dma mode supported by the device.
+ *
+ * Returns a 0 for success, and a 1 otherwise.
+ *
+ ****************************************************************************/
+static unsigned int
+ep93xx_config_ide_device(ide_drive_t *drive)
+{
+        unsigned int   ulChipID;
+	byte transfer = 0;
+
+	DPRINTK("%s: ep93xx_config_ide_device\n", drive->name);
+
+	/*
+	 * Determine the best transfer speed supported.  On Rev D1/E0
+     * the maximum DMA mode is 2.  On Rev E1 the maximum UDMA mode is 3.
+	 */
+	transfer = ide_dma_speed(drive, 1); //mode1=udma0..2, mode2=udma2..4
+  	
+	/*
+	 * Do nothing if a DMA mode is not supported or if the drive supports
+         * MDMA.
+	 */
+	if(transfer == XFER_MW_DMA_2 || transfer == XFER_MW_DMA_1 || 
+		transfer == XFER_MW_DMA_0 || transfer == 0) {
+printk("	device only supports MDMA ? (we're hosed)\n");
+                return 1;  
+	}
+
+	ulChipID = inl(SYSCON_CHIPID);
+	if(transfer == XFER_UDMA_3 && ((ulChipID &  SYSCON_CHIPID_REV_MASK)>>SYSCON_CHIPID_REV_SHIFT) != 0x6)
+	{
+		transfer = XFER_UDMA_2; 
+        }
+
+	DPRINTK("configuring the HDD for this transfer: ");
+	/*
+	 * Configure the drive.
+	 */
+	if (ide_config_drive_speed(drive, transfer) == 0) {
+		/*
+		 * Hold on to this value for use later.
+		 */
+printk("	device configured for speed X%d\n", transfer ); 
+		drive->current_speed = transfer;
+
+		/*
+		 * Success, so turn on DMA.
+		 */
+		return HWIF(drive)->ide_dma_on(drive);
+	} 
+	else
+		return 1;  
+}
+
+
+
+
+static int g_prd_count=0;
+static int g_pwr_count=0;
+
+
+
+//from include/asm/dma-mapping.h
+//static inline int
+//dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+//	   enum dma_data_direction dir)
+
+//#define MAP_SG(a,b,c,d)		dma_map_sg( (struct device *) (a), (b), (c), (d) )
+//#define UNMAP_SG(a,b,c,d)	dma_unmap_sg( (struct device *) (a), (b), (c), (d) )
+
+#define MAP_SG(a,b,c,d)		dma_map_sg( NULL, (b), (c), (d) )
+#define UNMAP_SG(a,b,c,d)	dma_unmap_sg( NULL, (b), (c), (d) )
+
+/*
+ * Needed for allowing full modular support of ide-driver
+ */
+static int ep93xx_ide_release_dma_engine (ide_hwif_t *hwif)
+{
+	if (hwif->dmatable_cpu) 
+	{
+	    kfree(hwif->dmatable_cpu);
+	    hwif->dmatable_cpu = NULL;
+	}
+	if (hwif->sg_table) 
+	{
+	    kfree(hwif->sg_table);
+	    hwif->sg_table = NULL;
+	}
+
+
+	return 1;
+}
+
+
+int ep93xx_ide_allocate_dma_engine (ide_hwif_t *hwif)
+{
+	
+	/*
+	 * Allocate memory for the DMA table.
+	 */
+	hwif->dmatable_cpu = kmalloc(PRD_ENTRIES * PRD_BYTES, GFP_KERNEL);
+
+	/*
+	 * Check if we allocated memory for dma
+	 */
+	if (hwif->dmatable_cpu == NULL) 
+	{
+		printk("%s: SG-DMA disabled, UNABLE TO ALLOCATE DMA TABLES\n", hwif->name);
+		return 1;
+	}
+
+	/*
+	 * Allocate memory for the scatterlist structures.
+	 */
+	hwif->sg_table = kmalloc(sizeof(struct scatterlist) * PRD_ENTRIES, GFP_KERNEL);
+
+	/*
+	 * Check if we allocated the memory we expected to.
+	 */
+	if (hwif->sg_table == NULL) 
+	{
+		/*
+		 *  Fail, so clean up.
+		 */
+		kfree(hwif->dmatable_cpu );
+		printk("%s: SG-DMA disabled, UNABLE TO ALLOCATE DMA TABLES\n", hwif->name);
+		return 1;
+	}
+
+    return 0;
+}
+
+
+/**
+ *	config_drive_for_dma	-	attempt to activate IDE DMA
+ *	@drive: the drive to place in DMA mode
+ *
+ *	If the drive supports at least mode 2 DMA or UDMA of any kind
+ *	then attempt to place it into DMA mode. Drives that are known to
+ *	support DMA but predate the DMA properties or that are known
+ *	to have DMA handling bugs are also set up appropriately based
+ *	on the good/bad drive lists.
+ */
+ 
+static int config_drive_for_dma (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = HWIF(drive);
+
+        DPRINTK("%s\n", __FUNCTION__ );
+
+	if ((id->capability & 1) && hwif->autodma) 
+	{
+		/* Consult the list of known "bad" drives */
+		if (__ide_dma_bad_drive(drive))
+			return __ide_dma_off(drive);
+
+		DPRINTK("	drive seems ok\n");
+
+#ifdef EP93XX_IDE_DMA_DEBUG
+		if (id->field_valid & 4)
+		{
+		    printk("	supports UDMA : 0x%08x\n", id->dma_ultra );
+		}
+#endif
+
+		/*
+		 * Enable DMA on any drive that has
+		 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
+		 * ep93xx supports up to udma2 
+		 */
+		 
+		if ( (id->field_valid & 4) && ( id->dma_ultra & 0x7f) )
+		{
+			DPRINTK("enabling UDMA\n");
+			return hwif->ide_dma_on(drive);
+		}
+
+		// ep93xx can't do mdma/sdma
+	}
+
+	return hwif->ide_dma_off_quietly(drive);
+}
+
+
+
+/**
+ *	ep93xx_ide_dma_check		-	check DMA setup
+ *	@drive: drive to check
+ *
+ */
+ 
+static int ep93xx_ide_dma_check (ide_drive_t *drive)
+{
+        DPRINTK("%s\n", __FUNCTION__ );
+
+	config_drive_for_dma(drive);
+	return ep93xx_config_ide_device(drive);
+}
+
+
+/**
+ *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
+ *	@drive: the drive to build the DMA table for
+ *	@rq: the request holding the sg list
+ *
+ *	Perform the PCI mapping magic necessary to access the source or
+ *	target buffers of a request via PCI DMA. The lower layers of the
+ *	kernel provide the necessary cache management so that we can
+ *	operate in a portable fashion
+ */
+
+static int ide_build_sglist(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg = hwif->sg_table;
+	int nents;
+#ifdef DEBUG_VADDR
+	u32 vaddr;
+	vaddr = (u32) rq->buffer;
+	printk("vaddr=0x%08x, paddr=0x%08x\n", (int) vaddr, (int) virt_to_dma(NULL,vaddr) );
+#endif	
+	if (hwif->sg_dma_active)
+		BUG();
+
+	nents = blk_rq_map_sg(drive->queue, rq, sg);
+		
+	if (rq_data_dir(rq) == READ)
+		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
+	else
+		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
+
+	return MAP_SG(hwif->pci_dev, sg, nents, hwif->sg_dma_direction);
+}
+
+
+//comes from PCI PC land
+/**
+ *	ide_raw_build_sglist	-	map IDE scatter gather for DMA
+ *	@drive: the drive to build the DMA table for
+ *	@rq: the request holding the sg list
+ *
+ *	Perform the PCI mapping magic necessary to access the source or
+ *	target buffers of a taskfile request via PCI DMA. The lower layers 
+ *	of the  kernel provide the necessary cache management so that we can
+ *	operate in a portable fashion
+ */
+
+static int ide_raw_build_sglist(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg = hwif->sg_table;
+	int nents = 0;
+	ide_task_t *args = rq->special;
+	u8 *virt_addr = rq->buffer;
+	int sector_count = rq->nr_sectors;
+#ifdef DEBUG_VADDR
+	u32 vaddr;
+	vaddr = (u32) rq->buffer;
+	printk("vaddr=0x%08x, paddr=0x%08x\n", (int) vaddr, (int) virt_to_dma(NULL, vaddr) );
+#endif	
+
+	if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
+		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
+	else
+		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
+
+#if 1
+	if (sector_count > 256)
+		BUG();
+
+	if (sector_count > 128) {
+#else
+	while (sector_count > 128) {
+#endif
+		memset(&sg[nents], 0, sizeof(*sg));
+		sg[nents].page = virt_to_page(virt_addr);
+		sg[nents].offset = offset_in_page(virt_addr);
+		sg[nents].length = 128  * SECTOR_SIZE;
+		nents++;
+		virt_addr = virt_addr + (128 * SECTOR_SIZE);
+		sector_count -= 128;
+	}
+	memset(&sg[nents], 0, sizeof(*sg));
+	sg[nents].page = virt_to_page(virt_addr);
+	sg[nents].offset = offset_in_page(virt_addr);
+	sg[nents].length =  sector_count  * SECTOR_SIZE;
+	nents++;
+
+	return MAP_SG(hwif->pci_dev, sg, nents, hwif->sg_dma_direction);
+}
+
+//comes from PCI PC land
+/**
+ *	ide_build_dmatable	-	build IDE DMA table
+ *
+ *	ide_build_dmatable() prepares a dma request. We map the command
+ *	to get the pci bus addresses of the buffers and then build up
+ *	the PRD table that the IDE layer wants to be fed. The code
+ *	knows about the 64K wrap bug in the CS5530.
+ *
+ *	Returns 0 if all went okay, returns 1 otherwise.
+ *	May also be invoked from trm290.c
+ */
+ 
+static int ep93xx_ide_build_dmatable (ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	unsigned int *table	= hwif->dmatable_cpu;
+	unsigned int count = 0;
+	int i;
+	struct scatterlist *sg;
+
+	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE)
+		hwif->sg_nents = i = ide_raw_build_sglist(drive, rq);
+	else
+		hwif->sg_nents = i = ide_build_sglist(drive, rq);
+
+	if (!i)
+		return 0;
+
+	sg = hwif->sg_table;
+	while (i) {
+		u32 cur_addr;
+		u32 cur_len;
+
+		cur_addr = sg_dma_address(sg);
+		cur_len = sg_dma_len(sg);
+
+		/*
+		 * Fill in the dma table, without crossing any 64kB boundaries.
+		 * Most hardware requires 16-bit alignment of all blocks,
+		 * but the trm290 requires 32-bit alignment.
+		 */
+
+		while (cur_len) {
+			if (count++ >= PRD_ENTRIES) {
+				printk(KERN_ERR "%s: DMA table too small\n", drive->name);
+				goto use_pio_instead;
+			} else {
+				u32 xcount, bcount = 0x10000 - (cur_addr & 0xffff);
+
+				if (bcount > cur_len)
+					bcount = cur_len;
+				*table++ = cpu_to_le32(cur_addr);
+				xcount = bcount & 0xffff;
+
+				if (xcount == 0x0000) {
+	/* 
+	 * Most chipsets correctly interpret a length of 0x0000 as 64KB,
+	 * but at least one (e.g. CS5530) misinterprets it as zero (!).
+	 * So here we break the 64KB entry into two 32KB entries instead.
+	 */
+					if (count++ >= PRD_ENTRIES) {
+						printk(KERN_ERR "%s: DMA table too small\n", drive->name);
+						goto use_pio_instead;
+					}
+					*table++ = cpu_to_le32(0x8000);
+					*table++ = cpu_to_le32(cur_addr + 0x8000);
+					xcount = 0x8000;
+				}
+				*table++ = cpu_to_le32(xcount);
+				cur_addr += bcount;
+				cur_len -= bcount;
+			}
+		}
+
+		sg++;
+		i--;
+	}
+
+	if (count) {
+			*--table |= cpu_to_le32(0x80000000);
+		return count;
+	}
+
+	printk(KERN_ERR "%s: empty DMA table?\n", drive->name);
+
+use_pio_instead:
+
+	UNMAP_SG(hwif->pci_dev,
+		     hwif->sg_table,
+		     hwif->sg_nents,
+		     hwif->sg_dma_direction);
+
+	hwif->sg_dma_active = 0;
+
+	return 0; /* revert to PIO for this request */
+}
+
+
+/* Teardown mappings after DMA has completed.  */
+static void
+ep93xx_ide_destroy_dmatable (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg;  
+	
+	sg = hwif->sg_table;
+
+	if (hwif->sg_nents) {
+		UNMAP_SG(NULL, sg, hwif->sg_nents, hwif->sg_dma_direction);
+		hwif->sg_dma_active = 0;
+	}
+}
+
+
+static int __ide_dma_lostirq (ide_drive_t *drive)
+{
+	printk("%s: DMA interrupt recovery\n", drive->name);
+	return 1;
+}
+
+// from PCI PC land
+/**
+ *	__ide_dma_on		-	Enable DMA on a device
+ *	@drive: drive to enable DMA on
+ *
+ *	Enable IDE DMA for a device on this IDE controller.
+ */
+ 
+int __ide_dma_on (ide_drive_t *drive)
+{
+        DPRINTK("%s\n", __FUNCTION__ );
+
+	drive->using_dma = 1;	
+	ide_toggle_bounce(drive, 1);
+
+	if (HWIF(drive)->ide_dma_host_on(drive))
+		return 1;
+
+	return 0;
+}
+
+
+/*				
+ * this is supposed to enable the host side (PC) host controller
+ * on the ep93xx it is already running, so nothing really happening here
+ *
+ */
+static int
+ep93xx_ide_dma_host_on(ide_drive_t *drive)
+{
+	DPRINTK("%s\n", __FUNCTION__ );
+
+	return 0;
+}
+
+static int
+ep93xx_ide_dma_host_off (ide_drive_t *drive)
+{
+	return 0;
+}
+
+/*****************************************************************************
+ *
+ *  ep93xx_rwproc()
+ *
+ *  Initializes the ep93xx IDE controller interface with the transfer type,
+ *  transfer mode, and transfer direction.
+ *
+ ****************************************************************************/
+static void
+ep93xx_rwproc(ide_drive_t *drive, int action)
+{
+	int speed;
+
+
+        DPRINTK("%s\n", __FUNCTION__ );
+
+	/*
+	 * Insure that neither device is selected. -wlg
+	 */
+	ep93xx_set_pio();
+
+
+	DPRINTK("rwproc in udma mode (udma starts at 64): %d\n", drive->current_speed);
+
+	/*
+	 * Configure the IDE controller for the specified transfer mode.
+	 */
+	switch (drive->current_speed)
+	{
+		/*
+		 * Configure for an MDMA operation.
+		 */
+		case XFER_MW_DMA_0:
+		case XFER_MW_DMA_1:
+		case XFER_MW_DMA_2:
+		printk("ep93xx ide dma: BAAAAADDD ! someone tries to use MDMA: not supported !!\n");
+		
+		break;
+
+		/*
+		 * Configure for a UDMA operation.
+		 */
+		case XFER_UDMA_0:
+		case XFER_UDMA_1:
+		case XFER_UDMA_2:
+		case XFER_UDMA_3:
+		case XFER_UDMA_4:
+		
+		    speed = drive->current_speed;
+		    speed -=64; //udma 0
+		    if(speed >= 3)
+			speed = 3; //max udma 3
+
+		    DPRINTK("rwproc in udma %d, action is %d\n", speed, action);
+		    outl( (speed << IDECfg_MODE_SHIFT) | IDECfg_UDMA | IDECfg_IDEEN, IDECFG );
+
+		    //action == 0 for read, action == 1 for write
+
+		    if(action)
+			action=0x2; //IDEUDMAOp_RWOP
+		    else
+			action=0;
+		        
+		    outl( action , IDEUDMAOP );    
+		    outl( action | IDEUDMAOp_UEN, IDEUDMAOP );
+		
+		break;
+
+		default:
+			break;
+	}
+}
+
+
+/*****************************************************************************
+ *
+ * ep93xx_ide_dma_begin()
+ *
+ * This function initiates a dma transfer.
+ *
+ ****************************************************************************/
+static int
+ep93xx_ide_dma_begin(ide_drive_t *drive)
+{
+	int rv;
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq = HWGROUP(drive)->rq;
+
+
+	DPRINTK("%s\n", __FUNCTION__ );
+	
+	/*
+	 * Configure the ep93xx ide controller for a dma operation.
+	 */
+	if (rq_data_dir(rq) == READ)
+	    ep93xx_rwproc(drive, 0);
+	else
+	    ep93xx_rwproc(drive, 1);
+
+	/*
+	 * Start the dma transfer.
+	 */
+	rv=ep93xx_dma_start(hwif->hw.dma, 1, NULL);
+	DPRINTK("	starting dma on handle 0x%08x, rv=%d\n", (int)  hwif->hw.dma, rv );
+	DPRINTK(" 	DMAMM_0_CONTROL=0x%08x\n", inl(DMAMM_0_CONTROL) );
+	return rv;
+}
+
+
+/*****************************************************************************
+ *
+ * ep93xx_ide_callback()
+ *
+ * Registered with the ep93xx dma driver and called at the end of the dma
+ * interrupt handler, this function should process the dma buffers.
+ *
+ ****************************************************************************/
+static void
+ep93xx_ide_callback(ep93xx_dma_int_t dma_int, ep93xx_dma_dev_t device,
+                    unsigned int user_data)
+{
+	ide_drive_t *drive = (ide_drive_t *)user_data;
+	ide_hwif_t *hwif = HWIF(drive);
+	unsigned int temp;
+	int rv;
+
+	DPRINTK("ep93xx_ide_callback %d\n", dma_int);
+	DPRINTK("	IDEUDMARdBufSts=0x%08x\n", inl(IDEUDMARFST) );
+
+#ifdef EP93XX_IDE_DMA_DEBUG
+
+    if( ep93xx_dma_is_done(hwif->hw.dma) == 1 )
+    {
+	printk("dma is done\n");
+    }
+    else
+    {
+	printk("dma is NOT DONE\n");
+    }
+
+    printk("DMAMM_0_SAR_CURRENT0  =0x%08x\n", inl(DMAMM_0_SAR_CURRENT0)   );
+    printk("DMAMM_0_DAR_CURRENT0  =0x%08x\n", inl(DMAMM_0_DAR_CURRENT0)   );
+
+#endif
+	/*
+	 * Retrieve from the dma interface as many used buffers as are
+	 * available.
+	 */
+	while (1)
+	{
+	    rv = ep93xx_dma_remove_buffer(hwif->hw.dma, &temp);
+	    if(rv<0)
+		break;
+	}
+	DPRINTK("buffers removed\n");
+
+    DPRINTK("	return from callback\n");
+}
+
+/*****************************************************************************
+ *
+ *  ep93xx_dma_timer_expiry()
+ *
+ *
+ *	dma_timer_expiry	-	handle a DMA timeout
+ *	@drive: Drive that timed out
+ *
+ *	An IDE DMA transfer timed out. In the event of an error we ask
+ *	the driver to resolve the problem, if a DMA transfer is still
+ *	in progress we continue to wait (arguably we need to add a
+ *	secondary 'I dont care what the drive thinks' timeout here)
+ *	Finally if we have an interrupt we let it complete the I/O.
+ *	But only one time - we clear expiry and if it's still not
+ *	completed after WAIT_CMD, we error and retry in PIO.
+ *	This can occur if an interrupt is lost or due to hang or bugs.
+ *
+ *
+ ****************************************************************************/
+static int
+ep93xx_idedma_timer_expiry(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dev_stat	 = hwif->INB(IDE_ALTSTATUS_REG);
+	u8 irq_stat	 = inl(IDECR) & IDECtrl_INTRQ;
+
+	DPRINTK(KERN_WARNING "%s: dma_timer_expiry: dev status == 0x%02x,irq= %d\n",
+		drive->name, dev_stat, irq_stat);
+
+	/*
+	 * Clear the expiry handler in case we decide to wait more,
+	 * next time timer expires it is an error
+	 */
+	HWGROUP(drive)->expiry = NULL;
+
+	/*
+	 * If the interrupt is asserted, call the handler.
+	 */
+	if (irq_stat)
+		HWGROUP(drive)->handler(drive);
+
+	/*
+	 * Check if the busy bit or the drq bit is set, indicating that
+	 * a dma transfer is still active, or the IDE interrupt is asserted.
+	 */
+	if ( (dev_stat & 0x80) || (dev_stat & 0x08) || irq_stat)
+		return WAIT_CMD;
+
+	/*
+	 * the device is not busy and the interrupt is not asserted, so check
+	 * if there's an error.
+	 */
+	if (dev_stat & 0x01)	/* ERROR */
+		return -1;
+
+	return 0;	/* Unknown status -- reset the bus */
+}
+
+
+
+
+/*****************************************************************************
+ *
+ * ep93xx_ide_dma_read()
+ *
+ * This function sets up a dma read operation.
+ *
+ ****************************************************************************/
+static int
+ep93xx_ide_dma_read(ide_drive_t *drive)
+{
+	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int flags;
+	ide_hwif_t *hwif = HWIF(drive);
+	task_ioreg_t command = WIN_NOP;
+	unsigned int *table	= hwif->dmatable_cpu;
+
+	DPRINTK("%s\n", __FUNCTION__ );
+//printk("r sector %u, count=%u\n", (unsigned) HWGROUP(drive)->rq->sector, HWGROUP(drive)->rq->nr_sectors );
+
+	/*
+	 * Check if we are already transferring on this dma channel.
+	 */
+	if (hwif->sg_dma_active || drive->waiting_for_dma) {
+		DPRINTK("%s: dma_read: dma already active \n", drive->name);
+		return 1;
+	}
+
+
+	/*
+	 * Indicate that we're waiting for dma.
+	 */
+	drive->waiting_for_dma = 1;
+
+	/*
+	 * Configure DMA M2M channel flags for a source address hold, h/w
+	 * initiated P2M transfer.
+	 */
+	flags = (SOURCE_HOLD | TRANSFER_MODE_HW_P2M);
+
+	if (drive->current_speed & 0x20) 
+	{
+	    printk("ep93xx_ide_dma_read: been asked to to MDMA: refusing categorically!!!\n");
+	} 
+	else 
+	{
+		flags |= (WS_IDE_UDMA_READ << WAIT_STATES_SHIFT);
+		/*
+		 * UDMA data register address.
+		 */
+		hwif->dma_base = IDEUDMADATAIN - IO_BASE_VIRT + IO_BASE_PHYS;
+	}
+
+	/*
+	 * Configure the dma interface for this IDE operation.
+	 */
+	if (ep93xx_dma_config(hwif->hw.dma, 0, flags, ep93xx_ide_callback,
+			      (unsigned int)drive) != 0) {
+		DPRINTK("%s: ep93xx_ide_dma_read: ERROR- dma config failed",
+				drive->name);
+		drive->waiting_for_dma = 0;
+		/*
+		 * Fail.
+		 */
+		return 1;
+	}
+
+	/*
+	 * Build the table of dma-able buffers.
+	 */
+	if (!(g_prd_count=ep93xx_ide_build_dmatable(drive, rq)) ) 
+	{
+		DPRINTK("%s: ep93xx_ide_dma_read: ERROR- failed to build dma table",
+			drive->name);
+		drive->waiting_for_dma = 0;
+		/*
+		 * Fail, try PIO instead of DMA
+		 */
+		return 1;
+	}
+
+	DPRINTK("	%d dmas pending\n", g_prd_count);
+	/*
+	 * Indicate that the scatter gather is active.
+	 */
+	hwif->sg_dma_active = 1;
+
+	/*
+	 * Prepare the dma interface with some buffers from the
+	 * dma_table.
+	 */
+	do {
+		DPRINTK("	add buf: handle=0x%08x, base=0x%08x, dest=0x%08x, len=0x%08x, g_prd_count=%d\n",
+			     hwif->hw.dma,
+			     hwif->dma_base,
+			     table[0],
+			     table[1],
+			     g_prd_count);
+
+	
+		/*
+		 * Add a buffer to the dma interface.
+		 */
+//		printk("rrd b=0x%08x, len=%d\n",  hwif->dmatable_cpu[0], (int) (hwif->dmatable_cpu[1] & 0x0fffffff) );
+		if (ep93xx_dma_add_buffer(hwif->hw.dma, hwif->dma_base,
+					  table[0],
+					  table[1], 0,
+					  g_prd_count) != 0)
+			break;
+		table += 2;
+
+		/*
+		 * Decrement the count of dmatable entries
+		 */
+		g_prd_count--;
+	} while (g_prd_count);
+
+	/*
+	 * Nothing further is required if this is not a ide_disk (i.e. an ATAPI
+	 * device).
+	 */
+	if (drive->media != ide_disk)
+	{
+		return 0;
+	}
+
+	command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
+	
+	if (drive->vdma)
+		command = (lba48) ? WIN_READ_EXT: WIN_READ;
+		
+	if (rq->flags & REQ_DRIVE_TASKFILE) {
+		ide_task_t *args = rq->special;
+		command = args->tfRegister[IDE_COMMAND_OFFSET];
+	}
+
+	DPRINTK("command=0x%02x\n", (u8) command );
+
+	/*
+	 * Enable PIO mode on the IDE interface.
+	 */
+	ep93xx_set_pio();
+
+	/*
+	 * Send the read command to the device.
+	 */
+	ide_execute_command(drive, command, &ep93xx_ide_dma_intr, 2*WAIT_CMD,
+			    &ep93xx_idedma_timer_expiry);
+
+	/*
+	 * initiate the dma transfer.
+	 */	 
+	return hwif->ide_dma_begin(drive);
+}
+
+
+/*****************************************************************************
+ *
+ * ep93xx_ide_dma_write()
+ *
+ * This function sets up a dma write operation.
+ *
+ ****************************************************************************/
+static int
+ep93xx_ide_dma_write(ide_drive_t *drive)
+{
+	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int flags;
+	ide_hwif_t *hwif = HWIF(drive);
+	task_ioreg_t command = WIN_NOP;
+	unsigned int *table	= hwif->dmatable_cpu;
+
+	DPRINTK("%s: ep93xx_ide_dma_write\n", drive->name);
+	
+//printk("w sector %u, count=%u\n", (unsigned) HWGROUP(drive)->rq->sector, HWGROUP(drive)->rq->nr_sectors );
+
+	/*
+	 * Check if we are already transferring on this dma channel.
+	 */
+	if (hwif->sg_dma_active || drive->waiting_for_dma) {
+		DPRINTK("%s: dma_write - dma is already active \n",
+			drive->name);
+		return 1;
+	}
+
+	/*
+	 * Indicate that we're waiting for dma.
+	 */
+	drive->waiting_for_dma = 1;
+
+	/*
+	 * Configure DMA M2M channel flags for a destination address
+	 * hold, h/w initiated M2P transfer.
+	 */
+	flags = (DESTINATION_HOLD | TRANSFER_MODE_HW_M2P);
+
+	/*
+	 * Determine if we need the MDMA or UDMA data register.
+	 */
+	if (drive->current_speed & 0x20) 
+	{
+	
+		printk("EP93xx cannot do MDMA !!\n");
+	} 
+	else 
+	{
+		flags |= (WS_IDE_UDMA_WRITE << WAIT_STATES_SHIFT);
+
+		/*
+		 * UDMA data register address.
+		 */
+		hwif->dma_base = IDEUDMADATAOUT - IO_BASE_VIRT + IO_BASE_PHYS;
+	}
+
+	/*
+	 * Configure the dma interface for this IDE operation.
+	 */
+	if (ep93xx_dma_config(hwif->hw.dma, 0, flags, ep93xx_ide_callback,
+			      (unsigned int)drive) != 0) {
+		drive->waiting_for_dma = 0;
+		return 1;
+	}
+
+	/*
+	 * Build the table of dma-able buffers.
+	 */
+	if (!(g_pwr_count = ep93xx_ide_build_dmatable(drive, rq)) ) {
+		drive->waiting_for_dma = 0;
+		/*
+		 * Fail, try PIO instead of DMA
+		 */
+		return 1;
+	}
+
+	/*
+	 * Indicate that we're waiting for dma.
+	 */
+	hwif->sg_dma_active = 1;
+
+
+	/*
+	 * Prepare the dma interface with some buffers from the
+	 * dma_table.
+	 */
+	do {
+		/*
+		 * Add a buffer to the dma interface.
+		 */
+		 
+		if (ep93xx_dma_add_buffer(hwif->hw.dma,
+					  table[0],
+					  hwif->dma_base,
+					  table[1], 0,
+					  g_pwr_count) != 0)
+		{
+		    break;
+		}
+		table += 2;
+
+		/*
+		 * Decrement the count of dmatable entries
+		 */
+		g_pwr_count--;
+	} while (g_pwr_count);
+
+	/*
+	 * Nothing further is required if this is not a ide_disk (i.e. an ATAPI
+	 * device).
+	 */
+	if (drive->media != ide_disk)
+		return 0;
+
+	/*
+	 * Determine the command to be sent to the device.
+	 */
+
+
+	command = (lba48) ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
+
+	if (drive->vdma)
+		command = (lba48) ? WIN_WRITE_EXT: WIN_WRITE;
+		
+	if (rq->flags & REQ_DRIVE_TASKFILE) 
+	{
+		ide_task_t *args = rq->special;
+		command = args->tfRegister[IDE_COMMAND_OFFSET];
+	}
+
+	/*
+	 * Enable PIO mode on the IDE interface.
+	 */
+	ep93xx_set_pio();
+
+	/*
+	 * Send the write dma command to the device.
+	 */
+	ide_execute_command(drive, command, &ep93xx_ide_dma_intr, 4*WAIT_CMD,
+			    &ep93xx_idedma_timer_expiry);
+
+	/*
+	 * initiate the dma transfer.
+	 */
+	return hwif->ide_dma_begin(drive);
+}
+
+
+/*****************************************************************************
+ *
+ *  ep93xx_set_pio()
+ *
+ *  Configures the ep93xx controller for a PIO mode transfer.
+ *
+ ****************************************************************************/
+static void
+ep93xx_set_pio(void)
+{
+	DPRINTK("ep93xx_set_pio\n");
+
+	/*
+	 * Insure that neither device is selected -wlg
+	 */
+        outl(inl(IDECR) | (IDECtrl_CS0n | IDECtrl_CS1n), IDECR);
+	/*
+	 * Clear the MDMA and UDMA operation registers.
+	 */
+	outl(0, IDEMDMAOP);
+	outl(0, IDEUDMAOP);
+
+	/*
+	 * Enable PIO mode of operation.
+	 */
+	outl(IDECfg_PIO | IDECfg_IDEEN | (4 << IDECfg_MODE_SHIFT) |
+	     (1 << IDECfg_WST_SHIFT), IDECFG);
+}
+
+
+static int
+ep93xx_ide_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t * hwif = HWIF(drive);
+	int rv;
+	int i;
+	
+	rv = 0;
+
+	DPRINTK("%s\n", __FUNCTION__ );
+
+	while(1)
+	{
+	/*
+	 * See if there is any data left in UDMA FIFOs.  For a read, first wait
+	 * until either the DMA is done or the FIFO is empty.  If there is any
+	 * residual data in the FIFO, there was an error in the transfer.
+	 */
+	    i = inl(IDEUDMARFST);
+	    if( ep93xx_dma_is_done(hwif->hw.dma) )
+		break;
+	    if ( (i & 15) == ((i >> 4) & 15) )
+		break;
+	    udelay(1);
+	}
+	udelay(1);
+
+	/*
+	 * Put the dma interface into pause mode.
+	 */
+	ep93xx_dma_pause(hwif->hw.dma, 1, 0);
+	ep93xx_dma_flush(hwif->hw.dma);
+
+	/*
+	 * Enable PIO mode on the IDE interface.
+	 */
+	ep93xx_set_pio();
+
+	/*
+	 * Indicate there's no dma transfer currently in progress.
+	 */
+	hwif->sg_dma_active = 0;
+	drive->waiting_for_dma = 0;
+
+	DPRINTK("IDEUDMARdBufSts=0x%08x\n", inl(IDEUDMARFST) );
+
+	if ( (i & 15) != ((i >> 4) & 15) )
+	{
+	    printk("dma_end: udma fifo ptr mismatch !\n");
+	    rv=-1;
+	    goto end;
+	}
+
+	if( ep93xx_dma_is_done(hwif->hw.dma) != 1)
+	{
+	    printk("dma_end: dma not done !\n");
+	    rv=-1;
+	    goto end;
+	}
+//this doesn't really do anthing right now, but might be necessary in the future
+	ep93xx_ide_destroy_dmatable(drive); 
+//negative value if DMA engine failed	
+end:
+	return rv;
+}
+
+
+//from PCi PC land
+/**
+ *	__ide_dma_host_off_quietly	-	Generic DMA kill
+ *	@drive: drive to control
+ *
+ *	Turn off the current DMA on this IDE controller. 
+ */
+
+static int ep93xx_ide_dma_off_quietly (ide_drive_t *drive)
+{
+        DPRINTK("%s\n", __FUNCTION__ );
+
+	drive->using_dma = 0;
+	ide_toggle_bounce(drive, 0);
+
+	if (HWIF(drive)->ide_dma_host_off(drive))
+		return 1;
+
+	return 0;
+}
+
+
+/*****************************************************************************
+ *
+ * ep93xx_ide_dma_bad_timeout()
+ *
+ ****************************************************************************/
+static int
+ep93xx_ide_dma_timeout(ide_drive_t *drive)
+{
+	printk("%s: ep93xx_ide_dma_timeout\n", drive->name);
+
+	printk("	IDEUDMARdBufSts=0x%08x\n", inl(IDEUDMARFST) );
+	printk("	DMAMM_0_SAR_CURRENT0  =0x%08x\n", inl(DMAMM_0_SAR_CURRENT0)   );
+	printk("	DMAMM_0_DAR_CURRENT0  =0x%08x\n", inl(DMAMM_0_DAR_CURRENT0)   );
+
+	if (HWIF(drive)->ide_dma_test_irq(drive))
+		return 0;
+
+	return HWIF(drive)->ide_dma_end(drive);
+}
+
+/*****************************************************************************
+ *
+ * ep93xx_ide_dma_test_irq()
+ *
+ * This function checks if the IDE interrupt is asserted and returns a
+ * 1 if it is, and 0 otherwise..
+ *
+ ****************************************************************************/
+static int
+ep93xx_ide_dma_test_irq(ide_drive_t *drive)
+{
+	DPRINTK("%s: ep93xx_ide_dma_test_irq\n", drive->name);
+
+	if (!drive->waiting_for_dma)
+		printk(KERN_WARNING "%s: %s called while not waiting\n",
+		       drive->name, __FUNCTION__);
+	/*
+	 * Return the value of the IDE interrupt bit.
+	 */
+	if( inl(IDECR) & IDECtrl_INTRQ )
+	    return 1;
+	    
+	return 0;
+}
+
+
+static int
+ep93xx_ide_dma_verbose(ide_drive_t *drive)
+{
+        DPRINTK("%s\n", __FUNCTION__ );
+	return 1;
+}
+
+
+void ep93xx_dma_init(ide_hwif_t *hwif)
+{
+    int dma_handle;
+    u32 uiTemp;
+    unsigned long flags;
+    
+    DPRINTK("%s\n", __FUNCTION__ );
+
+        local_irq_save(flags);
+        
+    	if( ep93xx_ide_allocate_dma_engine(hwif) )
+	    return;
+
+
+	/*
+	 * Init the ep93xx dma handle to 0.  This field is used to hold a
+	 * handle to the dma instance.
+	 */
+	hwif->hw.dma = 0; 
+
+	/*
+	 * Make sure the GPIO on IDE bits in the DEVCFG register are not set.
+	 */
+	uiTemp = inl(SYSCON_DEVCFG) & ~(SYSCON_DEVCFG_EonIDE |
+					SYSCON_DEVCFG_GonIDE |
+					SYSCON_DEVCFG_HonIDE);
+	SysconSetLocked( SYSCON_DEVCFG, uiTemp );
+
+	/*
+	 * Insure that neither device is selected. -wlg
+	 */
+        outl(inl(IDECR) | (IDECtrl_CS0n | IDECtrl_CS1n), IDECR);
+
+	/*
+        * Clear the MDMA and UDMA operation registers.
+        */
+	outl(0, IDEMDMAOP);
+	outl(0, IDEUDMAOP);
+
+	/*
+        * Reset the UDMA state machine.
+        */
+	outl(IDEUDMADebug_RWOE | IDEUDMADebug_RWPTR | IDEUDMADebug_RWDR | IDEUDMADebug_RROE | IDEUDMADebug_RRPTR | IDEUDMADebug_RRDR,
+	     IDEUDMADEBUG);
+	outl(0, IDEUDMADEBUG);
+
+	/*
+	 * Set up the IDE interface for PIO transfers, using the default PIO
+	 * mode.
+	 */
+	outl(IDECfg_IDEEN | IDECfg_PIO | (4 << IDECfg_MODE_SHIFT) |
+	     (1 << IDECfg_WST_SHIFT), IDECFG);
+
+	/*
+	 * Setup the ports.
+	 */
+	ide_init_hwif_ports(&hwif->hw, 0x800, 0x406, NULL);
+
+	
+            
+        /*
+	 * Get the interrupt.
+	 */
+	hwif->hw.irq = IRQ_EIDE;
+
+	/*
+	 * This is the dma channel number assigned to this IDE interface. Until
+	 * dma is enabled for this interface, we set it to NO_DMA.
+	 */
+	hwif->hw.dma = NO_DMA;
+ 
+ 	/*
+	 * Open an instance of the ep93xx dma interface.
+	 */
+
+	if ( ep93xx_dma_request(&dma_handle, hwif->name, DMA_IDE) != 0 ) 
+	{
+			/*
+			 * Fail, so clean up.
+			 */
+			 
+	    ep93xx_ide_release_dma_engine (hwif);
+	    return;
+	}
+
+	/*
+	 * Now that we've got a dma channel allocated, set up the rest
+	 * of the dma specific stuff.
+	 */
+	DPRINTK("\n ide init- dma channel allocated: 0x%x, %s  %d \n", dma_handle, hwif->name, DMA_IDE);
+
+	hwif->hw.dma = dma_handle;
+	/*
+	 * Enable dma support for atapi devices.
+	 */
+
+	hwif->atapi_dma			= 1;
+	hwif->ultra_mask		= 0x0f;  
+	hwif->mwdma_mask		= 0x00;
+	hwif->swdma_mask		= 0x00;
+	hwif->speedproc			= NULL;
+	hwif->autodma			= 1;
+
+	g_prd_count=0;
+  
+     	hwif->ide_dma_on 		= __ide_dma_on;
+	hwif->ide_dma_lostirq 		= __ide_dma_lostirq;
+	hwif->ide_dma_check 		= ep93xx_ide_dma_check;
+	hwif->ide_dma_host_on 		= ep93xx_ide_dma_host_on;
+
+	hwif->ide_dma_host_off 		= ep93xx_ide_dma_host_off;
+
+	hwif->ide_dma_begin 		= ep93xx_ide_dma_begin;
+	hwif->ide_dma_read 		= ep93xx_ide_dma_read;
+	hwif->ide_dma_write 		= ep93xx_ide_dma_write;
+	hwif->ide_dma_end 		= ep93xx_ide_dma_end;
+	hwif->ide_dma_off_quietly 	= ep93xx_ide_dma_off_quietly;
+	hwif->ide_dma_timeout 		= ep93xx_ide_dma_timeout;
+	hwif->ide_dma_test_irq 		= ep93xx_ide_dma_test_irq;
+	hwif->ide_dma_verbose 		= ep93xx_ide_dma_verbose;
+	
+        local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(ep93xx_dma_init);
diff -burN linux-2.6.8.1-orig/drivers/ide/arm/ide-ep93xx.c linux-2.6.8.1/drivers/ide/arm/ide-ep93xx.c
--- linux-2.6.8.1-orig/drivers/ide/arm/ide-ep93xx.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/arm/ide-ep93xx.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,304 @@
+/******************************************************************************
+ * drivers/ide/arm/ide-ep93xx.c
+ *
+ * Support for IDE PIO
+ * Version 1.0 for EP93XX-E1
+ *
+ * Copyright (C) 2005  Cirrus Logic
+ *
+ * A large portion of this file is based on the ide-io.c
+ * and the respective pmac version of it
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#include <linux/ide.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+#include <asm/ide.h>
+#include <asm/irq.h>
+#include <asm/arch/ide.h>
+#include <asm/arch/dma.h>
+#include <asm/hardware.h>
+
+extern void ep93xx_dma_init(ide_hwif_t *hwif);
+
+/*****************************************************************************
+ *
+ *  functions to set up the IDE control register and data register to read
+ *  or write a byte of data to/from the specified IDE device register.
+ *
+ ****************************************************************************/
+static void
+ep93xx_ide_outb(u8 b, unsigned long addr)
+{
+	unsigned int uiIDECR;
+	
+	/*
+	 * Write the address out.
+	 */
+	uiIDECR = IDECtrl_DIORn | IDECtrl_DIOWn | ((addr & 7) << 2) |
+		  (addr >> 10);
+	outl(uiIDECR, IDECR);
+
+	/*
+	 * Write the data out.
+	 */
+	outl(b, IDEDATAOUT);
+
+	/*
+	 * Toggle the write signal.
+	 */
+	outl(uiIDECR & ~IDECtrl_DIOWn, IDECR);
+
+	outl(uiIDECR, IDECR);
+}
+
+static void
+ep93xx_ide_outbsync(ide_drive_t *drive, u8 b, unsigned long addr)
+{
+	unsigned int uiIDECR;
+	/*
+	 * Write the address out.
+	 */
+	uiIDECR = IDECtrl_DIORn | IDECtrl_DIOWn | ((addr & 7) << 2) |
+		  (addr >> 10);
+	outl(uiIDECR, IDECR);
+
+	/*
+	 * Write the data out.p
+	 */
+	outl(b, IDEDATAOUT);
+	/*
+	 * Toggle the write signal.
+	 */
+	outl(uiIDECR & ~IDECtrl_DIOWn, IDECR);
+	outl(uiIDECR, IDECR);
+}
+
+static unsigned char
+ep93xx_ide_inb(unsigned long addr)
+{
+	unsigned int uiIDECR;
+
+	/*
+	 * Write the address out.
+	 */
+	uiIDECR = IDECtrl_DIORn | IDECtrl_DIOWn | ((addr & 7) << 2) |
+		  (addr >> 10);
+	outl(uiIDECR, IDECR);
+
+	/*
+	 * Toggle the read signal.
+	 */
+	outl(uiIDECR & ~IDECtrl_DIORn, IDECR);
+	outl(uiIDECR, IDECR);
+
+	/*
+	 * Read the data in.
+	 */
+	return(inl(IDEDATAIN) & 0xff);
+}
+
+/*****************************************************************************
+ *
+ *  functions to set up the IDE control register and data restister to read
+ *  or write 16 bits of data to/from the specified IDE device register.
+ *  These functions should only be used when reading/writing data to/from
+ *  the data register.
+ *
+ ****************************************************************************/
+static void
+ep93xx_ide_outw(u16 w, unsigned long addr)
+{
+	unsigned int uiIDECR;
+
+	/*
+	 * Write the address out.
+	 */
+	uiIDECR = IDECtrl_DIORn | IDECtrl_DIOWn | ((addr & 7) << 2) |
+		  (addr >> 10);
+	outl(uiIDECR, IDECR);
+
+	/*
+	 * Write the data out.
+	 */
+	outl(w, IDEDATAOUT);
+
+	/*
+	 * Toggle the write signal.
+	 */
+	outl(uiIDECR & ~IDECtrl_DIOWn, IDECR);	
+	outl(uiIDECR, IDECR);
+}
+
+static u16
+ep93xx_ide_inw(unsigned long addr)
+{
+	unsigned int uiIDECR;
+
+	/*
+	 * Write the address out.
+	 */
+	uiIDECR = IDECtrl_DIORn | IDECtrl_DIOWn | ((addr & 7) << 2) |
+		  (addr >> 10);
+	outl(uiIDECR, IDECR);
+
+	/*
+	 * Toggle the read signal.
+	 */
+	outl(uiIDECR & ~IDECtrl_DIORn, IDECR);
+	outl(uiIDECR, IDECR);
+
+	/*
+	 * Read the data in.
+	 */
+	return(inl(IDEDATAIN) & 0xffff);
+}
+
+/*****************************************************************************
+ *
+ *  functions to read/write a block of data to/from the ide device using
+ *  PIO mode.
+ *
+ ****************************************************************************/
+static void
+ep93xx_ide_insw(unsigned long addr, void *buf, u32 count)
+{
+	unsigned short *data = (unsigned short *)buf;
+
+	/*
+	 * Read in data from the data register 16 bits at a time.
+	 */
+	for (; count; count--)
+		*data++ = ep93xx_ide_inw(addr);
+}
+
+static void
+ep93xx_ide_outsw(unsigned long addr, void *buf, u32 count)
+{
+	unsigned short *data = (unsigned short *)buf;
+
+	/*
+	 * Write out data to the data register 16 bits at a time.
+	 */
+	for (; count; count--)
+		ep93xx_ide_outw(*data++, addr);
+}
+
+static void
+ep93xx_ata_input_data(ide_drive_t *drive, void *buffer, u32 count)
+{
+	/*
+	 * Read in the specified number of half words from the ide interface.
+	 */
+	ep93xx_ide_insw(IDE_DATA_REG, buffer, count << 1);
+}
+
+static void
+ep93xx_ata_output_data(ide_drive_t *drive, void *buffer, u32 count)
+{
+	/*
+	 * write the specified number of half words from the ide interface
+	 * to the ide device.
+	 */
+	ep93xx_ide_outsw(IDE_DATA_REG, buffer, count << 1);
+}
+
+static void
+ep93xx_atapi_input_bytes(ide_drive_t *drive, void *buffer, u32 count)
+{
+	/*
+	 * read in the specified number of bytes from the ide interface.
+	 */
+	ep93xx_ide_insw(IDE_DATA_REG, buffer, (count >> 1) + (count & 1));
+}
+
+static void
+ep93xx_atapi_output_bytes(ide_drive_t *drive, void *buffer, u32 count)
+{
+	/*
+	 * Write the specified number of bytes from the ide interface
+	 * to the ide device.
+	 */
+	ep93xx_ide_outsw(IDE_DATA_REG, buffer, (count >> 1) + (count & 1));
+}
+
+
+
+
+void
+ep93xx_ide_init(struct hwif_s *hwif)
+{
+      
+    u32 uiTemp;         
+	      
+	/*
+	 * Make sure the GPIO on IDE bits in the DEVCFG register are not set.
+	 */
+	uiTemp = inl(SYSCON_DEVCFG) & ~(SYSCON_DEVCFG_EonIDE |
+					SYSCON_DEVCFG_GonIDE |
+					SYSCON_DEVCFG_HonIDE);
+	SysconSetLocked( SYSCON_DEVCFG, uiTemp );
+
+	/*
+	 * Insure that neither device is selected. -wlg
+	 */
+        outl(inl(IDECR) | (IDECtrl_CS0n | IDECtrl_CS1n), IDECR);
+
+	/*
+	 * Make sure that MWDMA and UDMA are disabled.
+	 */
+	outl(0, IDEMDMAOP);
+	outl(0, IDEUDMAOP);
+
+	/*
+	 * Set up the IDE interface for PIO transfers, using the default PIO
+	 * mode.
+	 */
+	outl(IDECfg_IDEEN | IDECfg_PIO | (4 << IDECfg_MODE_SHIFT) |
+	     (1 << IDECfg_WST_SHIFT), IDECFG);
+
+	/*
+	 * Setup the ports.
+	 */
+	ide_init_hwif_ports(&(hwif->hw), 0x800, 0x406, NULL);
+	      
+	/*
+	 *  Set up the HW interface function pointers with the ep93xx specific
+	 *  function.
+	 */
+	hwif->ata_input_data = ep93xx_ata_input_data;
+	hwif->ata_output_data = ep93xx_ata_output_data;
+	hwif->atapi_input_bytes = ep93xx_atapi_input_bytes;
+	hwif->atapi_output_bytes = ep93xx_atapi_output_bytes;
+
+	hwif->OUTB = ep93xx_ide_outb;
+	hwif->OUTBSYNC = ep93xx_ide_outbsync;
+	hwif->OUTW = ep93xx_ide_outw;
+	hwif->OUTSW = ep93xx_ide_outsw;
+
+	hwif->INB = ep93xx_ide_inb;
+	hwif->INW = ep93xx_ide_inw;
+	hwif->INSW = ep93xx_ide_insw;
+
+
+	ep93xx_dma_init(hwif);
+}
+
+
+
diff -burN linux-2.6.8.1-orig/drivers/ide/arm/ide_arm.c linux-2.6.8.1/drivers/ide/arm/ide_arm.c
--- linux-2.6.8.1-orig/drivers/ide/arm/ide_arm.c	2004-08-14 19:55:09.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/arm/ide_arm.c	2007-01-24 13:03:31.000000000 +0900
@@ -36,8 +36,14 @@
 		hw_regs_t hw;
 
 		memset(&hw, 0, sizeof(hw));
+#ifdef CONFIG_BLK_DEV_IDE_EP93XX
+		#include <asm/arch/ide.h>
+		old_ide_init_default_hwifs();
+		//ide_init_default_hwifs();
+#else
 		ide_std_init_ports(&hw, IDE_ARM_IO, IDE_ARM_IO + 0x206);
 		hw.irq = IDE_ARM_IRQ;
 		ide_register_hw(&hw, NULL);
+#endif
 	}
 }
diff -burN linux-2.6.8.1-orig/drivers/ide/ide-cd.c linux-2.6.8.1/drivers/ide/ide-cd.c
--- linux-2.6.8.1-orig/drivers/ide/ide-cd.c	2004-08-14 19:55:22.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/ide-cd.c	2007-01-24 13:03:31.000000000 +0900
@@ -1057,8 +1057,13 @@
 	 */
 	if (dma) {
 		info->dma = 0;
+	#ifdef CONFIG_ARCH_EP93XX
+	         dma_error = HWIF(drive)->ide_dma_end(drive);
+        #else		 	
 		if ((dma_error = HWIF(drive)->ide_dma_end(drive)))
 			__ide_dma_off(drive);
+	#endif
+	
 	}
 
 	if (cdrom_decode_status(drive, 0, &stat))
@@ -1069,7 +1074,14 @@
 			ide_end_request(drive, 1, rq->nr_sectors);
 			return ide_stopped;
 		} else
+   #ifdef CONFIG_ARCH_EP93XX	
+           
+	    return  ide_stopped;
+   #else
 			return DRIVER(drive)->error(drive, "dma error", stat);
+	   
+    #endif
+	    
 	}
 
 	/* Read the interrupt reason and the transfer length. */
diff -burN linux-2.6.8.1-orig/drivers/ide/ide-io.c linux-2.6.8.1/drivers/ide/ide-io.c
--- linux-2.6.8.1-orig/drivers/ide/ide-io.c	2004-08-14 19:55:59.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/ide-io.c	2007-01-24 13:03:31.000000000 +0900
@@ -647,7 +647,7 @@
 
 	SELECT_DRIVE(drive);
 	if (ide_wait_stat(&startstop, drive, drive->ready_stat, BUSY_STAT|DRQ_STAT, WAIT_READY)) {
-		printk(KERN_ERR "%s: drive not ready for command\n", drive->name);
+	//	printk(KERN_ERR "%s: drive not ready for command\n", drive->name);
 		return startstop;
 	}
 	if (!drive->special.all) {
@@ -941,7 +941,7 @@
 		ret = DRIVER(drive)->error(drive, "dma timeout error",
 						hwif->INB(IDE_STATUS_REG));
 	} else {
-		printk(KERN_WARNING "%s: DMA timeout retry\n", drive->name);
+//		printk(KERN_WARNING "%s: DMA timeout retry\n", drive->name);
 		(void) hwif->ide_dma_timeout(drive);
 	}
 
diff -burN linux-2.6.8.1-orig/drivers/ide/ide-iops.c linux-2.6.8.1/drivers/ide/ide-iops.c
--- linux-2.6.8.1-orig/drivers/ide/ide-iops.c	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/ide-iops.c	2007-01-24 13:03:31.000000000 +0900
@@ -30,23 +30,46 @@
 #include <asm/io.h>
 #include <asm/bitops.h>
 
+//#undef DEBUG
+#define DEBUG 1
+#ifdef DEBUG
+#  define DPRINTK(fmt, args...)	printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#  define DPRINTK(fmt, args...)
+#endif
+
+
 /*
  *	Conventional PIO operations for ATA devices
  */
 
 static u8 ide_inb (unsigned long port)
 {
+#if defined( CONFIG_ARCH_EDB7312 )
+	return IN_BYTE(port);
+#elif defined( CONFIG_ARCH_EP93XX )
+	return (u8) ep93xx_pcmcia_ide_inb(port);
+#else
 	return (u8) inb(port);
+#endif
 }
 
 static u16 ide_inw (unsigned long port)
 {
+#ifdef CONFIG_ARCH_EP93XX
+	return (u16) ep93xx_pcmcia_ide_inw(port);
+#else
 	return (u16) inw(port);
+#endif
 }
 
 static void ide_insw (unsigned long port, void *addr, u32 count)
 {
-	insw(port, addr, count);
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_insw(port, addr, count);
+#else
+	return insw(port, addr, count);
+#endif
 }
 
 static u32 ide_inl (unsigned long port)
@@ -61,22 +84,43 @@
 
 static void ide_outb (u8 val, unsigned long port)
 {
-	outb(val, port);
+#if defined( CONFIG_ARCH_EDB7312 )
+	OUT_BYTE(val, port);
+#elif defined( CONFIG_ARCH_EP93XX )
+	ep93xx_pcmcia_ide_outb(val, port);
+#else
+	outb(addr, port);
+#endif
 }
 
 static void ide_outbsync (ide_drive_t *drive, u8 addr, unsigned long port)
 {
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
 	outb(addr, port);
+#endif
 }
 
 static void ide_outw (u16 val, unsigned long port)
 {
-	outw(val, port);
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outw(val, port);
+#else
+	outw(addr, port);
+#endif
 }
 
+
+
+
 static void ide_outsw (unsigned long port, void *addr, u32 count)
 {
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr, count);
+#else
 	outsw(port, addr, count);
+#endif	
 }
 
 static void ide_outl (u32 val, unsigned long port)
@@ -1002,7 +1046,9 @@
 	if(hwgroup->handler)
 		BUG();
 	hwgroup->handler	= handler;
+//	DPRINTK(" \n \n hwgroup->expiry begin \n \n ");
 	hwgroup->expiry		= expiry;
+//        DPRINTK(" \n \n hwgroup->expiry end \n \n ");
 	hwgroup->timer.expires	= jiffies + timeout;
 	add_timer(&hwgroup->timer);
 	hwif->OUTBSYNC(drive, cmd, IDE_COMMAND_REG);
@@ -1271,11 +1317,15 @@
 	u8 stat = 0;
 
 	while(timeout--) {
+	
+	
 		/*
 		 * Turn this into a schedule() sleep once I'm sure
 		 * about locking issues (2.5 work ?).
 		 */
+		// mdelay(1);
 		mdelay(1);
+		
 		stat = hwif->INB(hwif->io_ports[IDE_STATUS_OFFSET]);
 		if ((stat & BUSY_STAT) == 0)
 			return 0;
@@ -1290,5 +1340,8 @@
 	return -EBUSY;
 }
 
+
+
+
 EXPORT_SYMBOL_GPL(ide_wait_not_busy);
 
diff -burN linux-2.6.8.1-orig/drivers/ide/ide-lib.c linux-2.6.8.1/drivers/ide/ide-lib.c
--- linux-2.6.8.1-orig/drivers/ide/ide-lib.c	2004-08-14 19:56:23.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/ide-lib.c	2007-01-24 13:03:31.000000000 +0900
@@ -91,47 +91,47 @@
 	switch(mode) {
 		case 0x04:
 			if ((id->dma_ultra & 0x0040) &&
-			    (id->dma_ultra & hwif->ultra_mask))
+			    (id->dma_ultra & hwif->ultra_mask & 0x0040))
 				{ speed = XFER_UDMA_6; break; }
 		case 0x03:
 			if ((id->dma_ultra & 0x0020) &&
-			    (id->dma_ultra & hwif->ultra_mask))
+			    (id->dma_ultra & hwif->ultra_mask & 0x0020))
 				{ speed = XFER_UDMA_5; break; }
 		case 0x02:
 			if ((id->dma_ultra & 0x0010) &&
-			    (id->dma_ultra & hwif->ultra_mask))
+			    (id->dma_ultra & hwif->ultra_mask & 0x0010))
 				{ speed = XFER_UDMA_4; break; }
 			if ((id->dma_ultra & 0x0008) &&
-			    (id->dma_ultra & hwif->ultra_mask))
+			    (id->dma_ultra & hwif->ultra_mask & 0x0008))
 				{ speed = XFER_UDMA_3; break; }
 		case 0x01:
 			if ((id->dma_ultra & 0x0004) &&
-			    (id->dma_ultra & hwif->ultra_mask))
+			    (id->dma_ultra & hwif->ultra_mask & 0x0004))
 				{ speed = XFER_UDMA_2; break; }
 			if ((id->dma_ultra & 0x0002) &&
-			    (id->dma_ultra & hwif->ultra_mask))
+			    (id->dma_ultra & hwif->ultra_mask & 0x0002))
 				{ speed = XFER_UDMA_1; break; }
 			if ((id->dma_ultra & 0x0001) &&
-			    (id->dma_ultra & hwif->ultra_mask))
+			    (id->dma_ultra & hwif->ultra_mask & 0x0001))
 				{ speed = XFER_UDMA_0; break; }
 		case 0x00:
 			if ((id->dma_mword & 0x0004) &&
-			    (id->dma_mword & hwif->mwdma_mask))
+			    (id->dma_mword & hwif->mwdma_mask & 0x0004))
 				{ speed = XFER_MW_DMA_2; break; }
 			if ((id->dma_mword & 0x0002) &&
-			    (id->dma_mword & hwif->mwdma_mask))
+			    (id->dma_mword & hwif->mwdma_mask & 0x0002))
 				{ speed = XFER_MW_DMA_1; break; }
 			if ((id->dma_mword & 0x0001) &&
-			    (id->dma_mword & hwif->mwdma_mask))
+			    (id->dma_mword & hwif->mwdma_mask & 0x0001))
 				{ speed = XFER_MW_DMA_0; break; }
 			if ((id->dma_1word & 0x0004) &&
-			    (id->dma_1word & hwif->swdma_mask))
+			    (id->dma_1word & hwif->swdma_mask & 0x0004))
 				{ speed = XFER_SW_DMA_2; break; }
 			if ((id->dma_1word & 0x0002) &&
-			    (id->dma_1word & hwif->swdma_mask))
+			    (id->dma_1word & hwif->swdma_mask & 0x0002))
 				{ speed = XFER_SW_DMA_1; break; }
 			if ((id->dma_1word & 0x0001) &&
-			    (id->dma_1word & hwif->swdma_mask))
+			    (id->dma_1word & hwif->swdma_mask & 0x0001))
 				{ speed = XFER_SW_DMA_0; break; }
 	}
 
diff -burN linux-2.6.8.1-orig/drivers/ide/legacy/ide-cs.c linux-2.6.8.1/drivers/ide/legacy/ide-cs.c
--- linux-2.6.8.1-orig/drivers/ide/legacy/ide-cs.c	2004-08-14 19:55:47.000000000 +0900
+++ linux-2.6.8.1/drivers/ide/legacy/ide-cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -413,11 +413,14 @@
 	   -- need to investigate the required PCMCIA magic */
 	ide_unregister(info->hd);
 	/* deal with brain dead IDE resource management */
+#ifndef CONFIG_ARCH_EP93XX
 	request_region(link->io.BasePort1, link->io.NumPorts1,
 		       info->node.dev_name);
 	if (link->io.NumPorts2)
 	    request_region(link->io.BasePort2, link->io.NumPorts2,
 			   info->node.dev_name);
+#endif
+    
     }
     info->ndev = 0;
     link->dev = NULL;
diff -burN linux-2.6.8.1-orig/drivers/input/keyboard/Kconfig linux-2.6.8.1/drivers/input/keyboard/Kconfig
--- linux-2.6.8.1-orig/drivers/input/keyboard/Kconfig	2004-08-14 19:56:22.000000000 +0900
+++ linux-2.6.8.1/drivers/input/keyboard/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -96,3 +96,22 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called amikbd.
+
+config KEYBOARD_EP93XX_SPI
+	tristate "EP93xx PS2 Keyboard support"
+	depends on ARCH_EP93XX && INPUT && INPUT_KEYBOARD 
+	help
+	  Say Y here if you want support for a PS2 keyboard connected via SPI.
+
+config KEYBOARD_EP93XX_KEYPAD
+	tristate "EP93xx 8x8 Keypad support"
+	depends on ARCH_EP93XX && INPUT && INPUT_KEYBOARD
+	help
+	  Say Y here if you want support for an 8x8 keypad.
+
+config KEYBOARD_EP93XX_SCROLL_WHEEL
+	bool "EP93xx Scrollwheel support"
+	depends on KEYBOARD_EP93XX_KEYPAD
+	help
+	  Say Y here if you want support for a Scroll Wheel.
+
diff -burN linux-2.6.8.1-orig/drivers/input/keyboard/Makefile linux-2.6.8.1/drivers/input/keyboard/Makefile
--- linux-2.6.8.1-orig/drivers/input/keyboard/Makefile	2004-08-14 19:56:26.000000000 +0900
+++ linux-2.6.8.1/drivers/input/keyboard/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -12,3 +12,5 @@
 obj-$(CONFIG_KEYBOARD_AMIGA)		+= amikbd.o
 obj-$(CONFIG_KEYBOARD_NEWTON)		+= newtonkbd.o
 obj-$(CONFIG_KEYBOARD_98KBD)		+= 98kbd.o
+obj-$(CONFIG_KEYBOARD_EP93XX_SPI) 	+= ep93xx_spi_kbd.o
+obj-$(CONFIG_KEYBOARD_EP93XX_KEYPAD) 	+= ep93xx_keypad.o
diff -burN linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_keypad.c linux-2.6.8.1/drivers/input/keyboard/ep93xx_keypad.c
--- linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_keypad.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/input/keyboard/ep93xx_keypad.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,422 @@
+/******************************************************************************
+ * 
+ *  File:   linux/drivers/input/keyboard/ep93xx_keypad.c
+ *
+ *  Purpose:    Support for 8x8 keypad (With Scroll Wheel) for a Cirrus Logic EP93xx
+ *
+ *  History:    
+ *              For Sirius (Internet Radio) Project.
+ *
+ * Copyright 2006 Cirrus Logic Inc.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *   
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/compiler.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/syscalls.h>
+#include <linux/input.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include "ep93xx_keypad.h"
+
+static struct ep93xx_keypad_dev dev;
+static char *name = "Cirrus EP93xx 8x8 keypad driver";
+
+static void handle_scancode(struct ep93xx_keypad_dev* pdev, unsigned char scancode, int down)
+{   
+#ifdef FIX_FOR_EC12E2424404
+    int i, wheel1_count=0, wheel2_count=0;
+    if(down && ((scancode == KEY_WHEEL_1) || (scancode == KEY_WHEEL_2)) )
+    {
+        pdev->wheelkey_count &= 0x03;
+        pdev->wheelkey_buffer[pdev->wheelkey_count] = scancode;
+        pdev->wheelkey_count ++;
+
+        if(pdev->wheelkey_hit)
+        {
+            for(i=0;i<=pdev->wheelkey_count;i++)
+            {
+                if(pdev->wheelkey_buffer[i]==KEY_WHEEL_1) wheel1_count++;
+                if(pdev->wheelkey_buffer[i]==KEY_WHEEL_2) wheel2_count++;
+            }
+            if(wheel1_count >=3)
+            {
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_1, 1);
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_1, 0);
+                input_sync((struct input_dev*)&dev);
+            }
+            else if(wheel2_count >=3)
+            {
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_2, 1);
+                input_report_key((struct input_dev*)&dev, KEY_WHEEL_2, 0);
+                input_sync((struct input_dev*)&dev);
+            }
+            pdev->wheelkey_hit = 0;
+            pdev->wheelkey_count = 0;
+        }
+    }
+    else
+#endif
+    if(scancode > 0)
+    {
+        input_report_key((struct input_dev*)&dev, scancode, down);
+        input_sync((struct input_dev*)&dev);
+    }
+}
+
+static irqreturn_t ep93xx_keypad_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+    int nkey1,nkey2;
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    int phase,step;
+#endif
+    unsigned long status;
+    struct ep93xx_keypad_dev* pdev = (struct ep93xx_keypad_dev*)dev_id;
+    
+    status = inl(KEY_REG);
+    
+    status &= 0x3fff;
+
+/*  printk("status = %08x\n", (int)status);
+    printk("%d\n",wheel_phase_table[pdev->wheelkey]);
+*/
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    phase = wheel_phase_table[pdev->wheelkey&0x3];
+#endif
+
+    if(status & KEYREG_KEY2)
+    {
+        nkey1 = KeyPadTable[ (status & KEYREG_KEY1_MASK)>>KEYREG_KEY1_SHIFT ];
+        nkey2 = KeyPadTable[ (status & KEYREG_KEY2_MASK)>>KEYREG_KEY2_SHIFT ];
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+        if( (nkey1 == KEY_WHEEL_1) || (nkey2 == KEY_WHEEL_1) )
+        {
+            pdev->wheelkey |= WHEEL_FLAG1;
+        }
+        if( (nkey1 == KEY_WHEEL_2) || (nkey2 == KEY_WHEEL_2) )
+        {
+            pdev->wheelkey |= WHEEL_FLAG2;
+        }
+        if(pdev->last_key1 >0 || pdev->last_key2 >0)
+        {
+            if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) && (nkey2 != pdev->last_key1) )
+            {
+                handle_scancode(pdev, pdev->last_key1, 0);
+                pdev->last_key1 = 0;
+            }
+            if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) && (nkey2 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, pdev->last_key2, 0);
+                pdev->last_key2 = 0;
+            }
+        }
+
+        if( (nkey1 != KEY_WHEEL_1) && (nkey1 != KEY_WHEEL_2) )
+        {
+            if( (nkey1 != pdev->last_key1) && (nkey1 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, nkey1, 1);
+                pdev->last_key1 = nkey1;
+            }
+        }
+
+        if( (nkey2 != KEY_WHEEL_1) && (nkey2 != KEY_WHEEL_2) )
+        {
+            if( (nkey2 != pdev->last_key1) && (nkey2 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, nkey2, 1);
+                pdev->last_key2 = nkey2;
+            }
+        }
+#else
+        if(pdev->last_key1 >0 || pdev->last_key2 >0)
+        {
+            if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) && (nkey2 != pdev->last_key1) )
+            {
+                handle_scancode(pdev, pdev->last_key1, 0);
+                pdev->last_key1 = 0;
+            }
+            if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) && (nkey2 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, pdev->last_key2, 0);
+                pdev->last_key2 = 0;
+            }
+        }
+
+        if( (nkey1 != pdev->last_key1) && (nkey1 != pdev->last_key2) )
+        {
+            handle_scancode(pdev, nkey1, 1);
+            pdev->last_key1 = nkey1;
+        }
+        if( (nkey2 != pdev->last_key1) && (nkey2 != pdev->last_key2) )
+        {
+            handle_scancode(pdev, nkey2, 1);
+            pdev->last_key2 = nkey2;
+        }
+#endif
+    }
+    else if(status & KEYREG_KEY1)
+    {
+        nkey1 = KeyPadTable[ (status & KEYREG_KEY1_MASK)>>KEYREG_KEY1_SHIFT ];
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+        if(nkey1 == KEY_WHEEL_1)
+        {
+            pdev->wheelkey |= WHEEL_FLAG1;
+            if(pdev->wheelkey & WHEEL_FLAG2)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG2;
+            }
+            if(pdev->last_key1 >0 || pdev->last_key2 >0)
+            {
+                if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+                {
+                    handle_scancode(pdev, pdev->last_key1, 0);
+                    pdev->last_key1 = 0;
+                }
+                if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+                {
+                    handle_scancode(pdev, pdev->last_key2, 0);
+                    pdev->last_key2 = 0;
+                }
+            }
+        }
+        else if(nkey1 == KEY_WHEEL_2)
+        {
+            pdev->wheelkey |= WHEEL_FLAG2;
+            if(pdev->wheelkey & WHEEL_FLAG1)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG1;
+            }
+            if(pdev->last_key1 >0 || pdev->last_key2 >0)
+            {
+                if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+                {
+                    handle_scancode(pdev, pdev->last_key1, 0);
+                    pdev->last_key1 = 0;
+                }
+                if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+                {
+                    handle_scancode(pdev, pdev->last_key2, 0);
+                    pdev->last_key2 = 0;
+                }
+            }
+        }
+        else
+        {
+            if(pdev->wheelkey & WHEEL_FLAG2)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG2;
+            }
+            if(pdev->wheelkey & WHEEL_FLAG1)
+            {
+                pdev->wheelkey &= ~WHEEL_FLAG1;
+            }
+            if(pdev->last_key1 >0 || pdev->last_key2 >0)
+            {
+                if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+                {
+                    handle_scancode(pdev, pdev->last_key1, 0);
+                    pdev->last_key1 = 0;
+                }
+                if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+                {
+                    handle_scancode(pdev, pdev->last_key2, 0);
+                    pdev->last_key2 = 0;
+                }
+            }
+            handle_scancode(pdev, nkey1, 1);
+            pdev->last_key1 = nkey1;
+        }
+#else
+        if(pdev->last_key1 >0 || pdev->last_key2 >0)
+        {
+            if((pdev->last_key1 > 0) && (nkey1 != pdev->last_key1) )
+            {
+                handle_scancode(pdev, pdev->last_key1, 0);
+                pdev->last_key1 = 0;
+            }
+            if((pdev->last_key2 > 0) && (nkey1 != pdev->last_key2) )
+            {
+                handle_scancode(pdev, pdev->last_key2, 0);
+                pdev->last_key2 = 0;
+            }
+        }
+        handle_scancode(pdev, nkey1, 1);
+        pdev->last_key1 = nkey1;
+#endif
+    }
+    else
+    {
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+        if(pdev->wheelkey & WHEEL_FLAG2)
+        {
+            pdev->wheelkey &= ~WHEEL_FLAG2;
+        }
+        if(pdev->wheelkey & WHEEL_FLAG1)
+        {
+            pdev->wheelkey &= ~WHEEL_FLAG1;
+        }
+#ifdef FIX_FOR_EC12E2424404
+        pdev->wheelkey_hit = 1;
+#endif
+
+#endif
+        if(pdev->last_key1)
+        {
+            handle_scancode(pdev, pdev->last_key1, 0);
+            pdev->last_key1 = 0;
+        }
+        if(pdev->last_key2)
+        {
+            handle_scancode(pdev, pdev->last_key2, 0);
+            pdev->last_key2 = 0;
+        }
+    }
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    if(phase != wheel_phase_table[pdev->wheelkey&0x3])
+    {
+        step = ((wheel_phase_table[pdev->wheelkey&0x3] - phase + 4 ) % 4 );
+        if(step == 2)
+            step = pdev->last_wheel_step;
+        else
+            pdev->last_wheel_step = step;
+        
+        /*printk("step %d\n",step);*/
+        switch(step)
+        {
+        case 1:
+            handle_scancode(pdev, KEY_WHEEL_1, 1);
+            handle_scancode(pdev, KEY_WHEEL_1, 0);
+            break;
+        case 3:
+            handle_scancode(pdev, KEY_WHEEL_2, 1);
+            handle_scancode(pdev, KEY_WHEEL_2, 0);
+            break;
+        default:
+            break;
+        }
+    }
+#endif
+    return(IRQ_HANDLED);
+}
+ 
+unsigned long setprescale (unsigned short nScale)
+{
+    unsigned long nValue;
+
+    nValue = inl(SCANINIT);
+    nValue = ( nValue & (~SCANINIT_PRSCL_MASK) ) | (nScale & SCANINIT_PRSCL_MASK);
+    outl(nValue, SCANINIT);
+    return nValue;
+}
+
+unsigned long setdebounce (unsigned char nDebounce)
+{
+    unsigned long nValue;
+
+    nValue = inl(SCANINIT);
+    nValue = ( nValue & (~SCANINIT_DBNC_MASK) ) | ((nDebounce<<16) & SCANINIT_DBNC_MASK);
+    outl(nValue, SCANINIT);
+    return nValue;
+}
+
+void keypad_enable ( unsigned char bState )
+{
+    unsigned long nreg;
+    if( bState ) 
+    {
+        nreg = inl(SYSCON_KTDIV);
+        nreg |= SYSCON_KTDIV_KEN;
+        SysconSetLocked( SYSCON_KTDIV, nreg );    
+    }
+    else
+    {
+        nreg = inl(SYSCON_KTDIV);
+        nreg &= (~SYSCON_KTDIV_KEN);
+        SysconSetLocked( SYSCON_KTDIV, nreg );    
+    }
+    return;
+}
+
+//=============================================================================
+// ep93xx_keypad_init
+//=============================================================================
+int __init ep93xx_keypad_init(void)
+{
+    int i;
+    int retval;
+
+    printk("%s\n", name);
+
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+    dev.wheelkey = 0;
+    dev.last_wheel_step = 0;
+#ifdef FIX_FOR_EC12E2424404
+    dev.wheelkey_count = 0;
+    dev.wheelkey_hit = 0;
+#endif
+
+#endif
+
+    dev.last_key1 = 0;
+    dev.last_key2 = 0;
+    dev.input.name = name;
+    dev.input.evbit[0] = BIT(EV_KEY);
+
+    for (i = 0; i < KeyPad_SIZE; i++)
+        set_bit(KeyPadTable[i], dev.input.keybit);
+
+#ifdef FIX_FOR_EC12E2424404
+    setdebounce(0xfe);
+    setprescale(0x8);
+#else
+    setdebounce(0xfe);
+    setprescale(0x80);
+#endif
+    retval = request_irq( IRQ_KEY, ep93xx_keypad_isr, SA_INTERRUPT, "ep93xx_keypad", (void*)&dev);
+    if( retval )
+    {
+        printk(KERN_WARNING "ep93xx_keypad: failed to get keypad IRQ\n");
+        return retval;
+    }
+    
+    input_register_device((struct input_dev*)&dev);
+
+    keypad_enable(1);
+
+    return 0;
+}
+
+void __exit ep93xx_keypad_cleanup(void)
+{
+    input_unregister_device((struct input_dev*)&dev);
+}
+
+module_init(ep93xx_keypad_init);
+module_exit(ep93xx_keypad_cleanup);
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_keypad.h linux-2.6.8.1/drivers/input/keyboard/ep93xx_keypad.h
--- linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_keypad.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/input/keyboard/ep93xx_keypad.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,95 @@
+/*
+ * ep93xx_keypad.h Keymap definitions
+ */
+
+#if defined(CONFIG_KEYBOARD_EP93XX_SCROLL_WHEEL)
+#define SCROLL_WHEEL_KEY_SUPPORT
+#endif
+
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+
+/*
+ *  Support for a scroll wheel key:
+ *      ALPS 12mm Size Insulated Shaft Type Encoder.
+ *  Part NO. :      EC12E2424404
+ *  Connect TO:     Col1/2-Row3
+ */
+#define FIX_FOR_EC12E2424404 1
+
+
+#define KEY_WHEEL_1      KEY_UP
+#define KEY_WHEEL_2      KEY_DOWN
+
+static int wheel_phase_table[16] = {1,0,2,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
+
+
+#endif
+
+
+//
+// This table is used to map the scan code to the Linux default keymap.
+//
+#define KeyPad_SIZE         (8*8)
+static unsigned int const KeyPadTable[KeyPad_SIZE] = 
+{
+/*             COL0        COL1        CLO2        COL3       COL4       COL5       COL6       COL7   */
+/*ROW0*/       KEY_ESC,    KEY_1 ,     KEY_2 ,     0,         0,         0,         0,         0, 
+/*ROW1*/       KEY_3 ,     KEY_4 ,     KEY_5 ,     0,         0,         0,         0,         0, 
+/*ROW2*/       KEY_6 ,     KEY_7 ,     KEY_ENTER,  0,         0,         0,         0,         0, 
+/*ROW3*/       0,          KEY_UP,     KEY_DOWN,   0,         0,         0,         0,         0, 
+/*ROW4*/       0,          0,          0,          0,         0,         0,         0,         0, 
+/*ROW5*/       0,          0,          0,          0,         0,         0,         0,         0, 
+/*ROW6*/       0,          0,          0,          0,         0,         0,         0,         0, 
+/*ROW7*/       0,          0,          0,          0,         0,         0,         0,         0
+};
+
+struct ep93xx_keypad_dev
+{
+    struct input_dev input;
+
+#ifdef SCROLL_WHEEL_KEY_SUPPORT
+
+#define WHEEL_FLAG1   1
+#define WHEEL_FLAG2  2
+    int wheelkey;
+    int last_wheel_step;
+
+#ifdef FIX_FOR_EC12E2424404
+    int wheelkey_buffer[4];
+    int wheelkey_count;
+    int wheelkey_hit;
+#endif
+
+#endif
+
+    int last_key1;
+    int last_key2;
+
+};
+
+#define SCANINIT_PRSCL_MASK         0x000003FF
+#define SCANINIT_PRSCL_SHIFT        0L
+#define SCANINIT_T2                 0x00001000
+#define SCANINIT_BACK               0x00002000
+#define SCANINIT_DIAG               0x00004000
+#define SCANINIT_DIS3KY             0x00008000
+#define SCANINIT_DBNC_MASK          0x00FF0000
+#define SCANINIT_DBNC_SHIFT         16L
+
+#define KEYREG_KEY1_MASK            0x0000003F
+#define KEYREG_KEY1_SHIFT           0L
+#define KEYREG_KEY2_MASK            0x00000Fc0
+#define KEYREG_KEY2_SHIFT           6L
+#define KEYREG_KEY1ROW_MASK         0x00000007
+#define KEYREG_KEY1ROW_SHIFT        0L
+#define KEYREG_KEY1COL_MASK         0x00000038
+#define KEYREG_KEY1COL_SHIFT        3L
+#define KEYREG_KEY2ROW_MASK         0x000001c0
+#define KEYREG_KEY2ROW_SHIFT        6L
+#define KEYREG_KEY2COL_MASK         0x00000E00
+#define KEYREG_KEY2COL_SHIFT        9L
+
+#define KEYREG_KEY1                 0x00001000
+#define KEYREG_KEY2                 0x00002000
+#define KEYREG_INT                  0x00004000
+#define KEYREG_K                    0x00008000
diff -burN linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_spi_kbd.c linux-2.6.8.1/drivers/input/keyboard/ep93xx_spi_kbd.c
--- linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_spi_kbd.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/input/keyboard/ep93xx_spi_kbd.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,422 @@
+/******************************************************************************
+ * 
+ *  File:	linux/drivers/char/ep93xx_spi_kbd.c
+ *
+ *  Purpose:	Support for SPI Keyboard for a Cirrus Logic EP93xx
+ *
+ *  History:	
+ *
+ *  Limitations:
+ *  Break and Print Screen keys not handled yet!
+ *
+ *
+ *  Copyright 2003 Cirrus Logic Inc.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *   
+ ******************************************************************************/
+
+/*
+ * FIXME: There are more parity problems than there ought to be.
+ * TODO: Track down
+ * WHERE: grep for "BAD_PARITY" 
+ * WORKAROUND: Do not press too many keys and do not type too fast
+ *             type key another time if it got lost 
+ *
+ * FIXME2: Keymap should be done properly
+ */
+
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/arch/ssp.h>
+
+#include "ep93xx_spi_kbd.h"
+
+#define EP93XX_MAX_KEY_DOWN_COUNT 6
+
+void DataCallback(unsigned int Data);
+static int g_SSP_Handle;
+static struct input_dev ep93xxkbd_dev;
+static char *name = "Cirrus EP93xx PS/2 keyboard driver";
+
+//-----------------------------------------------------------------------------
+//  Debug stuff...
+//-----------------------------------------------------------------------------
+
+#undef UART_HACK_DEBUG
+//#define UART_HACK_DEBUG 1
+
+#if defined(UART_HACK_DEBUG) && defined(CONFIG_DEBUG_LL)
+char szBuf[256];
+#define DPRINTK( x... )   \
+	sprintf( szBuf, ##x ); \
+	printascii( szBuf );
+#else
+#define DPRINTK( x... )
+#endif
+
+typedef struct {
+	unsigned char scancode;
+	unsigned char count;
+} key_down_tracker_t;
+
+//
+// In the interest of efficiency, let's only allow 5 keys to be down
+// at a time, maximum.  So if anybody is having a temper tantrum on
+// their keyboard, they may get stuck keys, but that's to be expected.
+//
+
+#define MAX_KEYS_DOWN 8
+static key_down_tracker_t KeyTracker[MAX_KEYS_DOWN];
+
+static unsigned char SPI2KScan(unsigned int uiSPIValue, int *pValid);
+static void InitSniffer(void);
+static void KeySniffer(unsigned char scancode, int down);
+static void Check4StuckKeys(void);
+
+
+/* 
+ * wrapper: old style (2.4.x) to 2.6.x input subsystem 
+ */
+static void handle_scancode(unsigned char scancode, int down)
+{
+	DPRINTK("handle_scancode(scancode=%04X, down=%d); %02X ", scancode,
+		down, scancode & 0x7f);
+
+	if( scancode > KSCAN_TABLE_SIZE)
+		scancode &= ~EXTENDED_KEY;
+	
+	input_report_key(&ep93xxkbd_dev, KScanCodeToVKeyTable[scancode], down);
+	input_sync(&ep93xxkbd_dev);
+
+	DPRINTK("(virtual) scancode=%02X\n", scancode);
+}
+
+//=============================================================================
+// InitSniffer
+//=============================================================================
+static void InitSniffer(void)
+{
+	int i;
+
+	//
+	// Clear our struct to indicate that no keys are down now.
+	// If somebody boots this thing while holding down keys, then they'll
+	// get what they deserve.
+	//
+	for (i = 0; i < MAX_KEYS_DOWN; i++) {
+		KeyTracker[i].count = 0;
+		KeyTracker[i].scancode = 0;
+	}
+}
+
+//=============================================================================
+// KeySniffer
+//=============================================================================
+// To prevent stuck keys, keep track of what keys are down.  This information
+// is used by Check4StuckKeys().
+//=============================================================================
+static void KeySniffer(unsigned char scancode, int down)
+{
+	int i;
+
+	//
+	// There are certain keys that will definately get held down
+	// and we can't interfere with that.
+	//
+	switch (scancode) {
+	case 0x12:		/* left  shift */
+	case 0x59:		/* right shift */
+	case 0x14:		/* left  ctrl  */
+	case 0x94:		/* right ctrl  */
+	case 0x11:		/* left  alt   */
+	case 0x91:		/* right alt   */
+	case 0x58:		/* caps lock   */
+	case 0x77:		/* Num lock    */
+		//printk("Snuff - %02x, %d\n", scancode, down);
+		handle_scancode(scancode, down);
+		return;
+
+	default:
+		break;
+	}
+	
+	//printk("Sniff - %02x, %d\n", scancode, down );
+
+	//
+	// Go thru our array, looking for the key.  If it already
+	// is recorded, update its count.
+	// Also look for empty cells in the array in case we
+	// need one.
+	//
+	for (i = 0; i < MAX_KEYS_DOWN; i++) {
+		//
+		// If this is a key up in our list then we are done.
+		//
+		if (down == 0) {
+			if (KeyTracker[i].scancode == scancode) {
+				KeyTracker[i].count = 0;
+				KeyTracker[i].scancode = 0;
+				handle_scancode(scancode, down);
+				break;
+			}
+		}
+		//
+		// Hey here's an unused cell.  Save its index.
+		//
+		else if (KeyTracker[i].count == 0) {
+			KeyTracker[i].scancode = scancode;
+			KeyTracker[i].count = 1;
+			handle_scancode(scancode, down);
+			break;
+		}
+	}
+}
+
+//=============================================================================
+// Check4StuckKeys
+//=============================================================================
+// When a key is held down longer than 1/2 sec, it start repeating
+// 10 times a second.  What we do is watch how long each key is
+// held down.  If longer than X where X is less than 1/2 second
+// then we assume it is stuck and issue the key up.  If we were
+// wrong and the key really is being held down, no problem because
+// the keyboard is about to start sending it to us repeatedly
+// anyway.
+//=============================================================================
+static void Check4StuckKeys(void)
+{
+	int i;
+
+	for (i = 0; i < MAX_KEYS_DOWN; i++) {
+		if (KeyTracker[i].count) {
+			KeyTracker[i].count++;
+			if (KeyTracker[i].count >= EP93XX_MAX_KEY_DOWN_COUNT) {
+				handle_scancode(KeyTracker[i].scancode, 0);
+				KeyTracker[i].count = 0;
+				KeyTracker[i].scancode = 0;
+			}
+		}
+	}
+}
+
+
+//=============================================================================
+// HandleKeyPress
+//=============================================================================
+// Checks if there are any keys in the FIFO and processes them if there are.
+//=============================================================================
+void HandleKeyPress(unsigned int Data)
+{
+	static unsigned char ucKScan[4] = { 0, 0, 0, 0 };
+	static unsigned int ulNum = 0;
+	int bParityValid;
+
+	//
+	// No keys to decode, but the timer went off and is calling us
+	// to check for stuck keys.
+	//
+	if (Data == -1) {
+		Check4StuckKeys();
+		return;
+	}
+	//
+	// Read in the value from the SPI controller.
+	//
+	ucKScan[ulNum++] = SPI2KScan(Data, &bParityValid);
+
+	//
+	// Bad parity?  We should read the rest of the fifo and
+	// throw it away, because it will all be bad.  Then the
+	// SSP will be reset when we close the SSP driver and 
+	// all will be good again.
+	//
+	if (!bParityValid){
+		//	printk("_BAD_PARITY_");  
+		ulNum = 0;
+	}
+	//
+	// If we have one character in the array, do the following.
+	//
+	if (ulNum == 1) {
+		//
+		// If it is a simple key without the extended scan code perform 
+		// following.
+		//
+		if (ucKScan[0] < KSCAN_TABLE_SIZE) {
+			DPRINTK("1:Dn %02x\n", ucKScan[0]);
+			KeySniffer(ucKScan[0], 1);
+			ulNum = 0;
+		}
+		//
+		// I don't know what type of character this is so erase the 
+		// keys stored in the buffer and continue.
+		//
+		else if ((ucKScan[0] != 0xF0) && (ucKScan[0] != 0xE0)) {
+			DPRINTK("1:oops - %02x\n", ucKScan[0]);
+			ulNum = 0;
+		}
+	} else if (ulNum == 2) {
+		//
+		// 0xF0 means that a key has been released.
+		//
+		if (ucKScan[0] == 0xF0) {
+			//
+			// If it is a simple key without the extended scan code 
+			// perform the following.
+			//
+			if (ucKScan[1] < KSCAN_TABLE_SIZE) {
+				DPRINTK("2:Up %02x %02x\n", ucKScan[0],
+					ucKScan[1]);
+				KeySniffer(ucKScan[1], 0);
+				ulNum = 0;
+			}
+			//
+			// If it a extended kscan continue to get the next byte.
+			//
+			else if (ucKScan[1] != 0xE0) {
+				DPRINTK("2:oops - %02x %02x\n", ucKScan[0],
+					ucKScan[1]);
+				ulNum = 0;
+			}
+		}
+		//
+		// Find out what extended code it is.
+		//
+		else if (ucKScan[0] == 0xE0 && ucKScan[1] != 0xF0) {
+			DPRINTK("2:Dn %02x %02x\n", ucKScan[0], ucKScan[1]);
+			KeySniffer(EXTENDED_KEY | ucKScan[1], 1);
+			ulNum = 0;
+		}
+	}
+	//
+	// This means that an extended code key has been released.
+	//
+	else if (ulNum == 3) {
+		//
+		// 0xF0 means that a key has been released.
+		//
+		if (ucKScan[0] == 0xE0 && ucKScan[1] == 0xF0) {
+			DPRINTK("3:Up %02x %02x %02x",
+				ucKScan[0], ucKScan[1], ucKScan[2]);
+			KeySniffer(EXTENDED_KEY | ucKScan[2], 0);
+		} else {
+			DPRINTK("3:oops - %02x %02x %02x\n",
+				ucKScan[0], ucKScan[1], ucKScan[2]);
+		}
+		ulNum = 0;
+	}
+}
+
+//=============================================================================
+// SPI2KScan
+//=============================================================================
+// Get a character from the spi port if it is available.
+// 
+// Below is a picture of the spi signal from the PS2. 
+//
+//CK HHllllHHLLLHHHLLLHHHLLLHHHLLLHHHLLLHHHLLLHHHLLLHHHLLLHHHLLLHHHLLLHHHLLLHllll
+//DA HHHllllll000000111111222222333333444444555555666666777777ppppppssssssLLLLHHH
+//        ^                                                                ^
+//    start bit                                                   important bit
+// 
+//where:  l = 8042 driving the line 
+//        L = KEYBOARD driving the line
+//        1..7 data
+//         = Parity 8042 driving
+//        s = stop   8042 driving
+//         = PARITY KEYBOARD driving the line
+//        S = STOP   KEYBOARD driving the line
+//
+//  In our design the value comes high bit first and is inverted.  So we must
+//  convert it to low byte first and then inverted it back.
+//
+//=============================================================================
+static unsigned char SPI2KScan(unsigned int uiSPIValue, int *pValid)
+{
+	unsigned char ucKScan = 0;
+	unsigned int uiParity = 0;
+	unsigned int uiCount = 0;
+
+	for (uiCount = 1; uiCount < 10; uiCount++) {
+		uiParity += (uiSPIValue >> uiCount) & 0x1;
+	}
+
+	if (!(uiParity & 0x1) && (uiSPIValue & 0x401) == 0x400) {
+		*pValid = 1;
+
+		//
+		// Invert the pattern.
+		//
+		uiSPIValue = ~uiSPIValue;
+
+		//
+		// Read in the value from the motorola spi file
+		//
+		ucKScan = (unsigned char)((uiSPIValue & 0x004) << 5);
+		ucKScan |= (unsigned char)((uiSPIValue & 0x008) << 3);
+		ucKScan |= (unsigned char)((uiSPIValue & 0x010) << 1);
+		ucKScan |= (unsigned char)((uiSPIValue & 0x020) >> 1);
+		ucKScan |= (unsigned char)((uiSPIValue & 0x040) >> 3);
+		ucKScan |= (unsigned char)((uiSPIValue & 0x080) >> 5);
+		ucKScan |= (unsigned char)((uiSPIValue & 0x100) >> 7);
+		ucKScan |= (unsigned char)((uiSPIValue & 0x200) >> 9);
+	} else {
+		*pValid = 0;
+	}
+
+	return (ucKScan);
+}
+
+//=============================================================================
+// EP93XXSpiKbdInit
+//=============================================================================
+int __init EP93XXSpiKbdInit(void)
+{
+	int i;
+	printk("%s\n", name);
+
+	ep93xxkbd_dev.name = name;
+	ep93xxkbd_dev.evbit[0] = BIT(EV_KEY);
+
+	for (i = 0; i < KSCAN_TABLE_SIZE; i++)
+		set_bit(KScanCodeToVKeyTable[i], ep93xxkbd_dev.keybit);
+
+	input_register_device(&ep93xxkbd_dev);
+
+	/* Open SSP driver for Keyboard input. */
+	g_SSP_Handle = SSPDriver->Open(PS2_KEYBOARD, HandleKeyPress);
+
+	InitSniffer();
+
+	DPRINTK("Leaving EP93XXSpiKbdInit()\n");
+
+	return 0;
+}
+
+void __exit EP93XXSpiKbdCleanup(void)
+{
+	SSPDriver->Close(g_SSP_Handle);
+	input_unregister_device(&ep93xxkbd_dev);
+}
+
+module_init(EP93XXSpiKbdInit);
+module_exit(EP93XXSpiKbdCleanup);
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_spi_kbd.h linux-2.6.8.1/drivers/input/keyboard/ep93xx_spi_kbd.h
--- linux-2.6.8.1-orig/drivers/input/keyboard/ep93xx_spi_kbd.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/input/keyboard/ep93xx_spi_kbd.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,149 @@
+/*
+ * ep93xx_spi_kbd.h Keymap definitions (to be cleaned up)
+ */
+
+#define KSCAN_TABLE_SIZE    0x88
+
+#define EXTENDED_KEY     0x80
+
+//
+// This table is used to map the scan code to the Linux default keymap.
+//
+static unsigned int const KScanCodeToVKeyTable[KSCAN_TABLE_SIZE] = {
+	KEY_RESERVED,		// Scan Code 0x0
+	KEY_F9,			// Scan Code 0x1
+	KEY_RESERVED,		// Scan Code 0x2
+	KEY_F5,			// Scan Code 0x3
+	KEY_F3,			// Scan Code 0x4
+	KEY_F1,			// Scan Code 0x5
+	KEY_F2,			// Scan Code 0x6
+	KEY_F12,		// Scan Code 0x7
+	KEY_RESERVED,		// Scan Code 0x8
+	KEY_F10,		// Scan Code 0x9
+	KEY_F8,			// Scan Code 0xA
+	KEY_F6,			// Scan Code 0xB
+	KEY_F4,			// Scan Code 0xC
+	KEY_TAB,		// Scan Code 0xD Tab
+	KEY_GRAVE,		// Scan Code 0xE '
+	KEY_RESERVED,		// Scan Code 0xF
+	KEY_RESERVED,		// Scan Code 0x10
+	KEY_LEFTALT,		// Scan Code 0x11 Left Menu
+	KEY_LEFTSHIFT,		// Scan Code 0x12 Left Shift
+	KEY_RESERVED,		// Scan Code 0x13
+	KEY_LEFTCTRL,		// Scan Code 0x14
+	KEY_Q,			// Scan Code 0x15
+	KEY_1,			// Scan Code 0x16
+	KEY_RESERVED,		// Scan Code 0x17
+	KEY_RESERVED,		// Scan Code 0x18
+	KEY_RESERVED,		// Scan Code 0x19
+	KEY_Z,			// Scan Code 0x1A
+	KEY_S,			// Scan Code 0x1B
+	KEY_A,			// Scan Code 0x1C
+	KEY_W,			// Scan Code 0x1D
+	KEY_2,			// Scan Code 0x1E
+	KEY_RESERVED,		// Scan Code 0x1F
+	KEY_RESERVED,		// Scan Code 0x20
+	KEY_C,			// Scan Code 0x21
+	KEY_X,			// Scan Code 0x22
+	KEY_D,			// Scan Code 0x23
+	KEY_E,			// Scan Code 0x24
+	KEY_4,			// Scan Code 0x25
+	KEY_3,			// Scan Code 0x26
+	KEY_RESERVED,		// Scan Code 0x27
+	KEY_RESERVED,		// Scan Code 0x28
+	KEY_SPACE,		// Scan Code 0x29  Space
+	KEY_V,			// Scan Code 0x2A
+	KEY_F,			// Scan Code 0x2B
+	KEY_T,			// Scan Code 0x2C
+	KEY_R,			// Scan Code 0x2D
+	KEY_5,			// Scan Code 0x2E
+	KEY_RESERVED,		// Scan Code 0x2F
+	KEY_RESERVED,		// Scan Code 0x30
+	KEY_N,			// Scan Code 0x31
+	KEY_B,			// Scan Code 0x32 B
+	KEY_H,			// Scan Code 0x33
+	KEY_G,			// Scan Code 0x34
+	KEY_Y,			// Scan Code 0x35
+	KEY_6,			// Scan Code 0x36
+	KEY_RESERVED,		// Scan Code 0x37
+	KEY_RESERVED,		// Scan Code 0x38
+	KEY_RESERVED,		// Scan Code 0x39
+	KEY_M,			// Scan Code 0x3A
+	KEY_J,			// Scan Code 0x3B
+	KEY_U,			// Scan Code 0x3C
+	KEY_7,			// Scan Code 0x3D
+	KEY_8,			// Scan Code 0x3E
+	KEY_RESERVED,		// Scan Code 0x3F
+	KEY_RESERVED,		// Scan Code 0x40
+	KEY_COMMA,		// Scan Code 0x41
+	KEY_K,			// Scan Code 0x42
+	KEY_I,			// Scan Code 0x43       
+	KEY_O,			// Scan Code 0x44
+	KEY_0,			// Scan Code 0x45
+	KEY_9,			// Scan Code 0x46
+	KEY_RESERVED,		// Scan Code 0x47
+	KEY_RESERVED,		// Scan Code 0x48
+	KEY_DOT,		// Scan Code 0x49
+	KEY_SLASH,		// Scan Code 0x4A
+	KEY_L,			// Scan Code 0x4B
+	KEY_SEMICOLON,		// Scan Code 0x4C
+	KEY_P,			// Scan Code 0x4D
+	KEY_MINUS,		// Scan Code 0x4E
+	KEY_RESERVED,		// Scan Code 0x4F
+	KEY_RESERVED,		// Scan Code 0x50
+	KEY_RESERVED,		// Scan Code 0x51
+	KEY_APOSTROPHE,		// Scan Code 0x52
+	KEY_RESERVED,		// Scan Code 0x53
+	KEY_LEFTBRACE,		// Scan Code 0x54
+	KEY_EQUAL,		// Scan Code 0x55
+	KEY_BACKSPACE,		// Scan Code 0x56
+	KEY_RESERVED,		// Scan Code 0x57
+	KEY_CAPSLOCK,		// Scan Code 0x58 Caps Lock
+	KEY_RIGHTSHIFT,		// Scan Code 0x59 Right Shift
+	KEY_ENTER,		// Scan Code 0x5A
+	KEY_RIGHTBRACE,		// Scan Code 0x5B
+	KEY_RESERVED,		// Scan Code 0x5C
+	KEY_BACKSLASH,		// Scan Code 0x5D
+	KEY_RESERVED,		// Scan Code 0x5E
+	KEY_RESERVED,		// Scan Code 0x5F
+	KEY_RESERVED,		// Scan Code 0x60
+	KEY_BACKSLASH,		// Scan Code 0x61 ?? //VK_BSLH,            
+	KEY_RESERVED,		// Scan Code 0x62
+	KEY_RESERVED,		// Scan Code 0x63
+	KEY_RESERVED,		// Scan Code 0x64
+	KEY_RESERVED,		// Scan Code 0x65
+	KEY_BACKSPACE,		// Scan Code 0x66 ?? //VK_BKSP,            
+	KEY_RESERVED,		// Scan Code 0x67
+	KEY_RESERVED,		// Scan Code 0x68
+	KEY_KP1,		// Scan Code 0x69
+	KEY_RESERVED,		// Scan Code 0x6A
+	KEY_KP4,		// Scan Code 0x6B
+	KEY_KP7,		// Scan Code 0x6C
+	KEY_RESERVED,		// Scan Code 0x6D
+	KEY_RESERVED,		// Scan Code 0x6E
+	KEY_RESERVED,		// Scan Code 0x6F
+	KEY_KP0,		// Scan Code 0x70
+	KEY_KPDOT,		// Scan Code 0x71 DECIMAL??
+	KEY_KP2,		// Scan Code 0x72
+	KEY_KP5,		// Scan Code 0x73
+	KEY_KP6,		// Scan Code 0x74
+	KEY_KP8,		// Scan Code 0x75
+	KEY_ESC,		// Scan Code 0x76
+	KEY_NUMLOCK,		// Scan Code 0x77
+	KEY_F11,		// Scan Code 0x78
+	KEY_KPPLUS,		// Scan Code 0x79
+	KEY_KP3,		// Scan Code 0x7A
+	KEY_KPMINUS,		// Scan Code 0x7B
+	KEY_KPASTERISK,		// Scan Code 0x7C
+	KEY_KP9,		// Scan Code 0x7D
+	KEY_SCROLLLOCK,		// Scan Code 0x7E
+	KEY_RESERVED,		// Scan Code 0x7F
+	KEY_RESERVED,		// Scan Code 0x80      
+	KEY_RESERVED,		// Scan Code 0x81
+	KEY_RESERVED,		// Scan Code 0x82
+	KEY_F7,			// Scan Code 0x83
+	KEY_RESERVED,		// Scan Code 0x84
+	KEY_RESERVED,		// Scan Code 0x85
+	KEY_RESERVED,		// Scan Code 0x86
+	KEY_RESERVED		// Scan Code 0x87
+};
diff -burN linux-2.6.8.1-orig/drivers/input/touchscreen/Kconfig linux-2.6.8.1/drivers/input/touchscreen/Kconfig
--- linux-2.6.8.1-orig/drivers/input/touchscreen/Kconfig	2004-08-14 19:55:32.000000000 +0900
+++ linux-2.6.8.1/drivers/input/touchscreen/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -34,4 +34,7 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called gunze.
+config TOUCHSCREEN_EP93XX
+        tristate "EP93xx Touchscreen"
+ 	depends on ARM && INPUT && ARCH_EP93XX && INPUT_TOUCHSCREEN
 
diff -burN linux-2.6.8.1-orig/drivers/input/touchscreen/Makefile linux-2.6.8.1/drivers/input/touchscreen/Makefile
--- linux-2.6.8.1-orig/drivers/input/touchscreen/Makefile	2004-08-14 19:56:14.000000000 +0900
+++ linux-2.6.8.1/drivers/input/touchscreen/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -6,3 +6,4 @@
 
 obj-$(CONFIG_TOUCHSCREEN_BITSY)	+= h3600_ts_input.o
 obj-$(CONFIG_TOUCHSCREEN_GUNZE)	+= gunze.o
+obj-$(CONFIG_TOUCHSCREEN_EP93XX) += ep93xx_ts.o
diff -burN linux-2.6.8.1-orig/drivers/input/touchscreen/ep93xx_ts.c linux-2.6.8.1/drivers/input/touchscreen/ep93xx_ts.c
--- linux-2.6.8.1-orig/drivers/input/touchscreen/ep93xx_ts.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/input/touchscreen/ep93xx_ts.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1106 @@
+/*
+ *  linux/drivers/char/ep93xx_ts.c
+ *
+ *  Copyright (C) 2003-2004 Cirrus Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+ 
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/compiler.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/syscalls.h>
+#include <linux/input.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+
+//
+// To customize for a new touchscreen, there are various macros that
+// have to be set.  If you allow UART_HACK_DEBUG to be defined, you
+// will get real time ts data scrolling up your serial terminal
+// screen that will help you empirically determine good values for these.  
+//
+
+//
+// These are used as trigger levels to know when we have pen up/down
+//
+// The rules:
+// 1.  TS_HEAVY_INV_PRESSURE < TS_LIGHT_INV_PRESSURE because these
+//    are Inverse pressure.  
+// 2.  Any touch lighter than TS_LIGHT_INV_PRESSURE is a pen up.
+// 3.  Any touch heavier than TS_HEAVY_INV_PRESSURE is a pen down.
+//
+#define   TS_HEAVY_INV_PRESSURE 0xFE0 //C00
+#define   TS_LIGHT_INV_PRESSURE 0xFFF //e00
+
+//
+// If the x, y, or inverse pressure changes more than these values
+// between two succeeding points, the point is not reported.
+//
+#define   TS_MAX_VALID_XY_CHANGE 0x300
+#define   TS_MAX_VALID_PRESSURE_CHANGE  0x100
+
+//
+// This is the minimum Z1 Value that is valid.
+//
+#define     MIN_Z1_VALUE                    0x50
+
+//
+// Settling delay for taking each ADC measurement.  Increase this
+// if ts is jittery.
+//
+#define EP93XX_TS_ADC_DELAY_USEC 2000
+
+//
+// Delay between TS points.
+//
+#define EP93XX_TS_PER_POINT_DELAY_USEC 10000
+
+//-----------------------------------------------------------------------------
+// Debug messaging thru the UARTs
+//-----------------------------------------------------------------------------
+/*
+ *  Hello there!  Are you trying to get this driver to work with a new
+ *  touschscreen?  Turn this on and you will get useful info coming
+ *  out of your serial port.
+ */
+/* #define PRINT_CALIBRATION_FACTORS */
+#ifdef PRINT_CALIBRATION_FACTORS
+#define UART_HACK_DEBUG 1
+int iMaxX=0, iMaxY=0, iMinX = 0xfff, iMinY = 0xfff;
+#endif
+
+/*
+ * For debugging, let's spew messages out serial port 1 or 3 at 57,600 baud.
+ */
+/* #define UART_HACK_DEBUG 1 */
+#if 0
+#ifdef UART_HACK_DEBUG
+static char szBuf[256];
+void UARTWriteString(char * msg);
+#define DPRINTK( x... )   \
+    sprintf( szBuf, ##x ); \
+    UARTWriteString( szBuf );
+#else
+static char szBuf[256];
+#define DPRINTK( x... )  \
+    sprintf( szBuf, ##x ); \
+    printk( szBuf );
+#endif
+#endif // 0
+#define DPRINTK( x... ) 
+
+//-----------------------------------------------------------------------------
+// A few more macros...
+//-----------------------------------------------------------------------------
+#define TSSETUP_DEFAULT  ( TSSETUP_NSMP_32 | TSSETUP_DEV_64 |  \
+                           ((128<<TSSETUP_SDLY_SHIFT) & TSSETUP_SDLY_MASK) | \
+                           ((128<<TSSETUP_DLY_SHIFT)  & TSSETUP_DLY_MASK) )
+
+#define TSSETUP2_DEFAULT (TSSETUP2_NSIGND)
+
+//
+// For now, we use one of the minor numbers from the local/experimental
+// range.
+//
+#define EP93XX_TS_MINOR 240
+
+//-----------------------------------------------------------------------------
+// Static Declarations
+//-----------------------------------------------------------------------------
+static unsigned int   guiLastX, guiLastY;
+static unsigned int   guiLastInvPressure;
+
+struct TouchScreenSample
+{
+    int     currentX;
+    int     currentY;
+    int     currentButton;
+    int     currentPressure;
+    struct timeval currentTime;
+};
+
+//
+// This must match the structure in tslib.
+//
+struct ts_sample {
+    int     x;
+    int     y;
+    unsigned int    pressure;
+    struct timeval  tv;
+};
+
+
+static struct TouchScreenSample gSample;
+
+// static int currentX, currentY, currentButton;
+// static int gPressure;
+// static struct timeval  gtime;
+
+static int bFreshTouchData;
+static int bCurrentPenDown;
+
+
+
+static DECLARE_WAIT_QUEUE_HEAD(queue);
+static DECLARE_MUTEX(open_sem);
+static spinlock_t event_buffer_lock = SPIN_LOCK_UNLOCKED;
+static struct fasync_struct *fasync;
+
+//-----------------------------------------------------------------------------
+// Typedef Declarations
+//-----------------------------------------------------------------------------
+typedef enum {
+    TS_MODE_UN_INITIALIZED,
+    TS_MODE_HARDWARE_SCAN,
+    TS_MODE_SOFT_SCAN
+} ts_mode_t;
+
+static ts_mode_t      gScanningMode;
+
+typedef enum{
+    TS_STATE_STOPPED = 0,
+    TS_STATE_Z1,
+    TS_STATE_Z2,
+    TS_STATE_Y,
+    TS_STATE_X,
+    TS_STATE_DONE
+} ts_states_t;
+
+typedef struct 
+{
+    unsigned int   uiX;
+    unsigned int   uiY;
+    unsigned int   uiZ1;
+    unsigned int   uiZ2;
+    ts_states_t    state;
+} ts_struct_t;
+
+static ts_struct_t sTouch;
+
+/*
+ * From the spec, here's how to set up the touch screen's switch registers.
+ */
+typedef struct 
+{
+    unsigned int uiDetect;
+    unsigned int uiDischarge;
+    unsigned int uiXSample;
+    unsigned int uiYSample;
+    unsigned int uiSwitchZ1;
+    unsigned int uiSwitchZ2;
+}SwitchStructType;
+
+//
+// Here's the switch settings for a 4-wire touchscreen.  See the spec
+// for how to handle a 4, 7, or 8-wire.
+//
+const static SwitchStructType sSwitchSettings = 
+/*     s28en=0
+ *   TSDetect    TSDischarge  TSXSample  TSYSample    SwitchZ1   SwitchZ2
+ */
+    {0x00403604, 0x0007fe04, 0x00081604, 0x00104601, 0x00101601, 0x00101608};   
+
+
+//-----------------------------------------------------------------------------
+// Function Declarations
+//-----------------------------------------------------------------------------
+static void ep93xx_ts_set_direct( unsigned int uiADCSwitch );
+static irqreturn_t ep93xx_ts_isr(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t ep93xx_timer2_isr(int irq, void *dev_id, struct pt_regs *regs);
+static void ee93xx_ts_evt_add( int button, int dX, int dY, int Pressure );
+static ssize_t ep93xx_ts_read(struct file *filp, char *buf, 
+        size_t count, loff_t *l);
+static unsigned int ep93xx_ts_poll(struct file *filp, poll_table *wait);
+static int ep93xx_ts_open(struct inode *inode, struct file *filp);
+static int ep93xx_ts_fasync(int fd, struct file *filp, int on);
+static int ep93xx_ts_release(struct inode *inode, struct file *filp);
+static ssize_t ep93xx_ts_write(struct file *file, const char *buffer, 
+                size_t count, loff_t *ppos);
+static void ep93xx_hw_setup(void);
+static void ep93xx_hw_shutdown(void);
+int __init ep93xx_ts_init(void);
+void __exit ep93xx_ts_exit(void);
+static unsigned int CalculateInvPressure( void );
+static unsigned int ADCGetData( unsigned int uiSamples, unsigned int uiMaxDiff);
+static void TS_Soft_Scan_Mode(void);
+static void TS_Hardware_Scan_Mode(void);
+static void ProcessPointData(void);
+static void Set_Timer2_uSec( unsigned int Delay_mSec );
+static void Stop_Timer2(void);
+
+
+
+//-----------------------------------------------------------------------------
+//  Debug stuff...
+//-----------------------------------------------------------------------------
+
+#ifdef UART_HACK_DEBUG
+
+// This "array" is a cheap-n-easy way of getting access to the UART registers.
+static unsigned int * const pDebugUART=(unsigned int *)IO_ADDRESS(UART1_BASE);
+//static unsigned int * const pDebugUART=(unsigned int *)IO_ADDRESS(UART3_BASE);
+static int bUartInitialized = 0; 
+
+void SendChar(char value)
+{
+    // wait for Tx fifo full flag to clear.
+    while (pDebugUART[0x18>>2] & 0x20);
+
+    // send a char to the uart               
+    pDebugUART[0] = value;
+}
+
+void UARTWriteString(char * msg) 
+{
+    int index = 0;
+    unsigned int uiTemp;
+
+    //if((pDebugUART[0x14>>2] & 0x1) == 0)
+    if( bUartInitialized == 0 )
+    {
+        uiTemp = inl(SYSCON_DEVCFG);
+        uiTemp |= SYSCON_DEVCFG_U1EN;
+        //uiTemp |= SYSCON_DEVCFG_U3EN;
+        SysconSetLocked(SYSCON_DEVCFG, uiTemp);  
+        pDebugUART[0x10>>2] = 0xf;
+        pDebugUART[0xc>>2] = 0;
+        pDebugUART[0x8>>2] = 0x70;
+        pDebugUART[0x14>>2] = 0x1;
+        bUartInitialized = 1;
+    }
+    while (msg[index] != 0)
+    {
+        if (msg[index] == '\n')
+        {
+            SendChar('\r');
+            SendChar('\n');
+        }
+        else 
+        {
+            SendChar(msg[index]);
+        }
+        index++;
+    }
+}
+#endif // UART_HACK_DEBUG
+
+/*
+ *  ep93xx_ts_isr
+ */
+static irqreturn_t ep93xx_ts_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+    DPRINTK("isr\n");
+
+    // 
+    // Note that we don't clear the interrupt here.  The interrupt
+    // gets cleared in TS_Soft_Scan_Mode when the TS ENABLE
+    // bit is cleared.
+    //
+
+    //
+    // Set the ts to manual polling mode and schedule a callback.
+    // That way we can return from the isr in a reasonable amount of
+    // time and process the touch in the callback after a brief delay.
+    //
+    TS_Soft_Scan_Mode();
+    
+    return(IRQ_HANDLED);
+}
+ 
+/*
+ * Save the current ts 'event' in an atomic fashion.
+ */
+static void ee93xx_ts_evt_add( int buttons, int iX, int iY, int iPressure )
+{
+#ifdef PRINT_CALIBRATION_FACTORS
+    if( iX > iMaxX ) iMaxX = iX;
+    if( iX < iMinX ) iMinX = iX;
+    if( iY > iMaxY ) iMaxY = iY;
+    if( iY < iMinY ) iMinY = iY;
+#endif
+
+    
+    // printk("ee93xx_ts_evt_add\n");
+    //DPRINTK("cb\n");
+    /*
+     * Note the event, but use spinlocks to keep it from getting
+     * halfway read if we get interrupted.
+     */  
+    
+    spin_lock(&event_buffer_lock);
+    gSample.currentX        = iX;
+    gSample.currentY        = iY;
+    gSample.currentButton   = buttons;
+    gSample.currentPressure = iPressure;
+    bFreshTouchData         = 1;
+    do_gettimeofday(&gSample.currentTime);
+
+    
+    spin_unlock(&event_buffer_lock);
+
+    kill_fasync(&fasync, SIGIO, POLL_IN);
+    wake_up_interruptible(&queue);
+
+}
+
+
+static ssize_t ep93xx_ts_read(struct file *filp, char *buf, size_t count, loff_t *l)
+{
+
+    unsigned short data[3];
+    struct  ts_sample   ts_data;
+    int     iReturn;
+    // printk("ep93xx_ts_read\n");
+
+#ifdef PRINT_CALIBRATION_FACTORS
+    static int lala=0;
+    if( bFreshTouchData && (lala++ > 9) )
+    {
+        DPRINTK("%4d, %4d - range [%4d to %4d],[%4d to %4d]\n",
+            f, currentY, iMinX, iMaxX, iMinY, iMaxY );
+        lala = 0;
+    }
+#endif
+    if( !bFreshTouchData)
+    {
+        iReturn = 0;
+    }        
+    else if( (count == sizeof(data)) )
+    {
+        spin_lock_irq(&event_buffer_lock);
+        bFreshTouchData = 0;
+        data[0] = gSample.currentX;
+        data[1] = gSample.currentY;
+        data[2] = gSample.currentButton;
+        
+        spin_unlock_irq(&event_buffer_lock);
+
+        if (copy_to_user(buf, data, sizeof data))
+            return -EFAULT;
+
+        count -= sizeof(data);
+
+        /* return the # of bytes that got read */
+        iReturn = sizeof(data) ;
+    }
+    else if (count == sizeof(struct ts_sample) )
+    {
+        spin_lock_irq(&event_buffer_lock);
+        bFreshTouchData = 0;
+        ts_data.x           = gSample.currentX;
+        ts_data.y           = gSample.currentY;
+        ts_data.pressure    = gSample.currentPressure;
+        ts_data.tv          = gSample.currentTime;
+        spin_unlock_irq(&event_buffer_lock);
+        
+        if (copy_to_user(buf, &ts_data, sizeof(struct ts_sample)))
+        {
+            iReturn = -EFAULT;
+        }
+        else
+        {                
+            count -= sizeof(ts_data);
+            iReturn = sizeof(ts_data);
+        }            
+
+    }
+
+    return iReturn;
+}
+
+static unsigned int ep93xx_ts_poll(struct file *filp, poll_table *wait)
+{
+    // printk("ep93xx_ts_poll\n");
+    poll_wait(filp, &queue, wait);
+
+    if( bFreshTouchData )
+    {
+        return POLLIN | POLLRDNORM;
+    }
+    
+    return 0;
+}
+
+static int ep93xx_ts_open(struct inode *inode, struct file *filp)
+{
+    // printk("ep93xx_ts_open");
+
+    if( down_trylock(&open_sem) )
+    {
+        return -EBUSY;
+    }
+
+    ep93xx_hw_setup();
+
+    return 0;
+}
+
+/*
+ * Asynchronous I/O support.
+ */
+static int ep93xx_ts_fasync(int fd, struct file *filp, int on)
+{
+    int retval;
+
+    retval = fasync_helper(fd, filp, on, &fasync);
+    if (retval < 0)
+    {
+        return retval;
+    }
+    
+    return 0;
+}
+
+static int ep93xx_ts_release(struct inode *inode, struct file *filp)
+{
+    Stop_Timer2();
+
+    /*
+     * Call our async I/O support to request that this file 
+     * cease to be used for async I/O.
+     */
+    ep93xx_ts_fasync(-1, filp, 0);
+
+    ep93xx_hw_shutdown();
+    
+    up(&open_sem);
+    
+    return 0;
+}
+
+static ssize_t ep93xx_ts_write(struct file *file, const char *buffer, size_t count,
+               loff_t *ppos)
+{
+    return -EINVAL;
+}
+
+
+static int ep93xx_ts_ioctl(struct inode *inode, struct file *file, uint command, ulong u)
+{
+    static const int         version = EV_VERSION;   
+    static const u_int32_t   bit =(1 << EV_ABS);
+    static const u_int64_t   absbit = (1 << ABS_X) | (1 << ABS_Y) | (1 << ABS_PRESSURE);
+    int         iReturn ;
+    int         i;
+    
+    switch(command)
+    {
+        case EVIOCGVERSION:
+            DPRINTK("ep93xx_ts_ioctl command = EVIOCGVERSION\r\n");
+            i = copy_to_user((void __user *)u, (void *)version, sizeof(version));
+            iReturn = i ? -EFAULT : 0;
+            break;
+            
+        case EVIOCGBIT(0,sizeof(u_int32_t) * 8) :
+            DPRINTK("ep93xx_ts_ioctl command = EVIOCGBIT(0,sizeof(uint32) * 8)\r\n");
+            i = copy_to_user((void __user *)u, (void *)bit, sizeof(bit));
+            iReturn = i ? -EFAULT : 0;
+            break;
+            
+        case EVIOCGBIT(EV_ABS, sizeof(absbit) * 8):
+            DPRINTK("ep93xx_ts_ioctl command = EVIOCGBIT(0,sizeof(uint32) * 8)\r\n");
+            copy_to_user((void __user *)u, (void *)absbit, sizeof(absbit));
+            iReturn = i ? -EFAULT : 0;
+            break;
+        default:
+            DPRINTK(" ep93xx_ts_ioctl unknown command = %d\n",u);           
+            iReturn = -1;
+            break;
+    }            
+    
+    return iReturn;
+}
+
+static struct file_operations ep93xx_ts_fops = {
+    owner:      THIS_MODULE,
+    read:       ep93xx_ts_read,
+    write:      ep93xx_ts_write,
+    poll:       ep93xx_ts_poll,
+    open:       ep93xx_ts_open,
+//    ioctl:      ep93xx_ts_ioctl,
+    release:    ep93xx_ts_release,
+    fasync:     ep93xx_ts_fasync,
+};
+
+static struct miscdevice ep93xx_ts_miscdev = 
+{
+        EP93XX_TS_MINOR,
+        "ep93xx_ts",
+        &ep93xx_ts_fops
+};
+
+void ep93xx_hw_setup(void)
+{
+    unsigned int uiKTDIV, uiTSXYMaxMin;
+    // printk("ep93xx_hw_setup\n");
+    
+    /*
+     * Set the TSEN bit in KTDIV so that we are enabling the clock
+     * for the touchscreen.
+     */    
+    uiKTDIV = inl(SYSCON_KTDIV);
+    uiKTDIV |= SYSCON_KTDIV_TSEN;
+    SysconSetLocked( SYSCON_KTDIV, uiKTDIV );    
+
+    //
+    // Program the TSSetup and TSSetup2 registers.
+    //
+    outl( TSSETUP_DEFAULT, TSSetup );
+    outl( TSSETUP2_DEFAULT, TSSetup2 );
+
+    //
+    // Set the the touch settings. 
+    //
+    outl( 0xaa, TSSWLock );
+    outl( sSwitchSettings.uiDischarge, TSDirect );
+
+    outl( 0xaa, TSSWLock );
+    outl( sSwitchSettings.uiDischarge, TSDischarge );
+
+    outl( 0xaa, TSSWLock );
+    outl( sSwitchSettings.uiSwitchZ1, TSXSample );
+
+    outl( 0xaa, TSSWLock );
+    outl( sSwitchSettings.uiSwitchZ2, TSYSample );
+
+    outl( 0xaa, TSSWLock );
+    outl( sSwitchSettings.uiDetect, TSDetect );
+
+    //
+    // X,YMin set to 0x40 = have to drag that many pixels for a new irq.
+    // X,YMax set to 0x40 = 1024 pixels is the maximum movement within the
+    // time scan limit.
+    //
+    uiTSXYMaxMin =  (50   << TSMAXMIN_XMIN_SHIFT) & TSMAXMIN_XMIN_MASK;
+    uiTSXYMaxMin |= (50   << TSMAXMIN_YMIN_SHIFT) & TSMAXMIN_YMIN_MASK;
+    uiTSXYMaxMin |= (0xff << TSMAXMIN_XMAX_SHIFT) & TSMAXMIN_XMAX_MASK;
+    uiTSXYMaxMin |= (0xff << TSMAXMIN_YMAX_SHIFT) & TSMAXMIN_YMAX_MASK;
+    outl( uiTSXYMaxMin, TSXYMaxMin );
+    
+    bCurrentPenDown = 0;
+    bFreshTouchData = 0;
+    guiLastX = 0;
+    guiLastY = 0;
+    guiLastInvPressure = 0xffffff;
+    
+    //
+    // Enable the touch screen scanning engine.
+    //
+    TS_Hardware_Scan_Mode();
+}
+
+/*
+ * ep93xx_hw_shutdown
+ *
+ */
+static void
+ep93xx_hw_shutdown(void)
+{
+    unsigned int uiKTDIV;
+    
+    DPRINTK("ep93xx_hw_shutdown\n");
+    
+    sTouch.state = TS_STATE_STOPPED;
+    Stop_Timer2();
+
+    /*
+     * Disable the scanning engine.
+     */
+    outl( 0, TSSetup );
+    outl( 0, TSSetup2 );
+
+    /*
+     * Clear the TSEN bit in KTDIV so that we are disabling the clock
+     * for the touchscreen.
+     */    
+    uiKTDIV = inl(SYSCON_KTDIV);
+    uiKTDIV &= ~SYSCON_KTDIV_TSEN;
+    SysconSetLocked( SYSCON_KTDIV, uiKTDIV );    
+
+} /* ep93xx_hw_shutdown */
+
+static irqreturn_t ep93xx_timer2_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+    DPRINTK("%d", (int)sTouch.state );
+
+    switch( sTouch.state )
+    {
+        case TS_STATE_STOPPED:
+            TS_Hardware_Scan_Mode();
+            break;
+            
+        //
+        // Get the Z1 value for pressure measurement and set up
+        // the switch register for getting the Z2 measurement.
+        //
+        case TS_STATE_Z1:
+            Set_Timer2_uSec( EP93XX_TS_ADC_DELAY_USEC );
+            sTouch.uiZ1 = ADCGetData( 2, 200 );
+            ep93xx_ts_set_direct( sSwitchSettings.uiSwitchZ2 );
+            sTouch.state = TS_STATE_Z2;
+            break;
+        
+        //
+        // Get the Z2 value for pressure measurement and set up
+        // the switch register for getting the Y measurement.
+        //
+        case TS_STATE_Z2:
+            sTouch.uiZ2 = ADCGetData( 2, 200 );
+            ep93xx_ts_set_direct( sSwitchSettings.uiYSample );
+            sTouch.state = TS_STATE_Y;
+            break;
+        
+        //
+        // Get the Y value and set up the switch register for 
+        // getting the X measurement.
+        //
+        case TS_STATE_Y:
+            sTouch.uiY = ADCGetData( 4, 20 );
+            ep93xx_ts_set_direct( sSwitchSettings.uiXSample );
+            sTouch.state = TS_STATE_X;
+            break;
+        
+        //
+        // Read the X value.  This is the last of the 4 adc values
+        // we need so we continue on to process the data.
+        //
+        case TS_STATE_X:
+            Stop_Timer2();
+            
+            sTouch.uiX = ADCGetData( 4, 20 );
+            
+            outl( 0xaa, TSSWLock );
+            outl( sSwitchSettings.uiDischarge, TSDirect );
+            
+            sTouch.state = TS_STATE_DONE;
+        
+            /*
+             * Process this set of ADC readings.
+             */
+            ProcessPointData();
+            
+            break;
+
+
+        //
+        // Shouldn't get here.  But if we do, we can recover...
+        //
+        case TS_STATE_DONE:
+            TS_Hardware_Scan_Mode();
+            break;
+    } 
+
+    //
+    // Clear the timer2 interrupt.
+    //
+    outl( 1, TIMER2CLEAR );
+    return(IRQ_HANDLED);
+}
+
+/*---------------------------------------------------------------------
+ * ProcessPointData
+ *
+ * This routine processes the ADC data into usable point data and then
+ * puts the driver into hw or sw scanning mode before returning.
+ *
+ * We calculate inverse pressure (lower number = more pressure) then
+ * do a hystheresis with the two pressure values 'light' and 'heavy'.
+ *
+ * If we are above the light, we have pen up.
+ * If we are below the heavy we have pen down.
+ * As long as the pressure stays below the light, pen stays down.
+ * When we get above the light again, pen goes back up.
+ *
+ */
+static void ProcessPointData(void)
+{
+    int  bValidPoint = 0;
+    unsigned int   uiXDiff, uiYDiff, uiInvPressureDiff;
+    unsigned int   uiInvPressure;
+
+    //
+    // Calculate the current pressure.
+    //
+    uiInvPressure = CalculateInvPressure();
+
+    DPRINTK(" X=0x%x, Y=0x%x, Z1=0x%x, Z2=0x%x, InvPressure=0x%x",
+            sTouch.uiX, sTouch.uiY, sTouch.uiZ1, sTouch.uiZ2, uiInvPressure ); 
+
+    //
+    // If pen pressure is so light that it is greater than the 'max' setting
+    // then we consider this to be a pen up.
+    //
+    if( uiInvPressure >= TS_LIGHT_INV_PRESSURE )
+    {
+        DPRINTK(" -- up \n");
+        bCurrentPenDown = 0;
+                ee93xx_ts_evt_add( 0, guiLastX, guiLastY, 0 );
+        TS_Hardware_Scan_Mode();
+        return;
+    }
+
+    //
+    // Hystheresis:
+    // If the pen pressure is hard enough to be less than the 'min' OR
+    // the pen is already down and is still less than the 'max'...
+    //
+    if( (uiInvPressure < TS_HEAVY_INV_PRESSURE) ||
+        ( bCurrentPenDown && (uiInvPressure < TS_LIGHT_INV_PRESSURE) )  )
+    {
+        if( bCurrentPenDown )
+        {
+            //
+            // If pen was previously down, check the difference between
+            // the last sample and this one... if the difference between 
+            // samples is too great, ignore the sample.
+            //
+            uiXDiff = abs(guiLastX - sTouch.uiX);
+            uiYDiff = abs(guiLastY - sTouch.uiY);
+            uiInvPressureDiff = abs(guiLastInvPressure - uiInvPressure);
+            
+            if( (uiXDiff < TS_MAX_VALID_XY_CHANGE) && (uiYDiff < TS_MAX_VALID_XY_CHANGE) &&
+                (uiInvPressureDiff < TS_MAX_VALID_PRESSURE_CHANGE) )
+            {
+                DPRINTK(" -- valid(two) \n");
+                bValidPoint = 1;
+            }
+            else
+            {
+                DPRINTK(" -- INvalid(two) \n");
+            }
+        }
+        else
+        {
+            DPRINTK(" -- valid \n");
+            bValidPoint = 1;
+        }
+        
+        /*
+         * If either the pen was put down or dragged make a note of it.
+         */
+        if( bValidPoint )
+        {
+            guiLastX = sTouch.uiX;
+            guiLastY = sTouch.uiY;
+            guiLastInvPressure = uiInvPressure;
+            bCurrentPenDown = 1;
+            ee93xx_ts_evt_add( 1, sTouch.uiX, sTouch.uiY, (0x7000000 /uiInvPressure) );
+        }
+
+        TS_Soft_Scan_Mode();
+        return;
+    }
+
+    DPRINTK(" -- fallout \n");
+    TS_Hardware_Scan_Mode();
+}
+
+static void ep93xx_ts_set_direct( unsigned int uiADCSwitch )
+{
+    unsigned int uiResult;
+    
+    //
+    // Set the switch settings in the direct register.
+    //
+    outl( 0xaa, TSSWLock );
+    outl( uiADCSwitch, TSDirect );
+
+    //
+    // Read and throw away the first sample.
+    //
+    do {
+        uiResult = inl(TSXYResult);
+    } while( !(uiResult & TSXYRESULT_SDR) );
+    
+}
+
+static unsigned int ADCGetData
+( 
+    unsigned int uiSamples, 
+    unsigned int uiMaxDiff 
+)
+{
+    unsigned int   uiResult, uiValue, uiCount, uiLowest, uiHighest, uiSum, uiAve;
+
+    do
+    {
+        //
+        //Initialize our values.
+        //
+        uiLowest        = 0xfffffff;
+        uiHighest       = 0;
+        uiSum           = 0;
+        
+        for( uiCount = 0 ; uiCount < uiSamples ; uiCount++ )
+        {
+            //
+            // Read the touch screen four more times and average.
+            //
+            do {
+                uiResult = inl(TSXYResult);
+            } while( !(uiResult & TSXYRESULT_SDR) );
+            
+            uiValue = (uiResult & TSXYRESULT_AD_MASK) >> TSXYRESULT_AD_SHIFT;
+            uiValue = ((uiValue >> 4) + ((1 + TSXYRESULT_X_MASK)>>1))  & TSXYRESULT_X_MASK; 
+
+            //
+            // Add up the values.
+            //
+            uiSum += uiValue;
+
+            //
+            // Get the lowest and highest values.
+            //
+            if( uiValue < uiLowest )
+            {
+                uiLowest = uiValue;
+            }
+            if( uiValue > uiHighest )
+            {
+                uiHighest = uiValue;
+            }
+        }
+
+    } while( (uiHighest - uiLowest) > uiMaxDiff );
+
+    //
+    // Calculate the Average value.
+    //
+    uiAve = uiSum / uiSamples;
+
+    return uiAve;    
+}
+
+//****************************************************************************
+// CalculateInvPressure
+//****************************************************************************
+// Is the Touch Valid.  Touch is not valid if the X or Y value is not 
+// in range and the pressure is not  enough.
+// 
+// Touch resistance can be measured by the following formula:
+//
+//          Rx * X *     Z2
+// Rtouch = --------- * (-- - 1)
+//           4096        Z1
+//
+// This is simplified in the ration of Rtouch to Rx.  The lower the value, the
+// higher the pressure.
+//
+//                     Z2
+// InvPressure =  X * (-- - 1)
+//                     Z1
+//
+static unsigned int CalculateInvPressure(void)
+{
+    unsigned int   uiInvPressure;
+
+    //
+    // Check to see if the point is valid.
+    //
+    if( sTouch.uiZ1 < MIN_Z1_VALUE )
+    {
+        uiInvPressure = 0x10000;
+    }
+
+    //
+    // Can omit the pressure calculation if you need to get rid of the division.
+    //
+    else
+    {
+        uiInvPressure = ((sTouch.uiX * sTouch.uiZ2) / sTouch.uiZ1) - sTouch.uiX;
+    }    
+
+    return uiInvPressure;
+}
+
+
+
+//****************************************************************************
+// TS_Hardware_Scan_Mode
+//****************************************************************************
+// Enables the ep93xx ts scanning engine so that when the pen goes down
+// we will get an interrupt.
+// 
+//
+static void TS_Hardware_Scan_Mode(void)
+{
+    unsigned int   uiDevCfg;
+
+    DPRINTK("S\n");
+
+    //
+    // Disable the soft scanning engine.
+    //
+    sTouch.state = TS_STATE_STOPPED;
+    Stop_Timer2();
+    
+    //
+    // Clear the TIN (Touchscreen INactive) bit so we can go to
+    // automatic scanning mode.
+    //
+    uiDevCfg = inl( SYSCON_DEVCFG );
+    SysconSetLocked( SYSCON_DEVCFG, (uiDevCfg & ~SYSCON_DEVCFG_TIN) );    
+
+    //
+    // Enable the touch screen scanning state machine by setting
+    // the ENABLE bit.
+    //
+    outl( (TSSETUP_DEFAULT | TSSETUP_ENABLE), TSSetup );
+
+    //
+    // Set the flag to show that we are in interrupt mode.
+    //
+    gScanningMode = TS_MODE_HARDWARE_SCAN;
+
+    //
+    // Initialize TSSetup2 register.
+    //
+    outl( TSSETUP2_DEFAULT, TSSetup2 );
+
+}
+
+//****************************************************************************
+// TS_Soft_Scan_Mode
+//****************************************************************************
+// Sets the touch screen to manual polling mode.
+// 
+//
+static void TS_Soft_Scan_Mode(void)
+{
+    unsigned int   uiDevCfg;
+
+    DPRINTK("M\n");
+
+    if( gScanningMode != TS_MODE_SOFT_SCAN )
+    {
+        //
+        // Disable the touch screen scanning state machine by clearing
+        // the ENABLE bit.
+        //
+        outl( TSSETUP_DEFAULT, TSSetup );
+
+        //
+        // Set the TIN bit so we can do manual touchscreen polling.
+        //
+        uiDevCfg = inl( SYSCON_DEVCFG );
+        SysconSetLocked( SYSCON_DEVCFG, (uiDevCfg | SYSCON_DEVCFG_TIN) );    
+    }
+
+    //
+    // Set the switch register up for the first ADC reading
+    //
+    ep93xx_ts_set_direct( sSwitchSettings.uiSwitchZ1 );
+    
+    //
+    // Initialize our software state machine to know which ADC
+    // reading to take
+    //
+    sTouch.state = TS_STATE_Z1;
+    
+    //
+    // Set the timer so after a mSec or two settling delay it will 
+    // take the first ADC reading.
+    // 
+    Set_Timer2_uSec( EP93XX_TS_PER_POINT_DELAY_USEC );
+    
+    //
+    // Note that we are in sw scanning mode not hw scanning mode.
+    //
+    gScanningMode = TS_MODE_SOFT_SCAN;
+
+}
+
+static void Set_Timer2_uSec( unsigned int uiDelay_uSec )
+{
+    unsigned int uiClockTicks;
+
+    /*
+     * Stop timer 2
+     */
+    outl( 0, TIMER2CONTROL );
+
+    uiClockTicks = ((uiDelay_uSec * 508) + 999) / 1000;
+    outl( uiClockTicks, TIMER2LOAD );
+    outl( uiClockTicks, TIMER2VALUE );
+
+    /*
+     * Set up Timer 2 for 508 kHz clock and periodic mode.
+     */ 
+    outl( 0xC8, TIMER2CONTROL );
+
+}
+
+static void Stop_Timer2(void)
+{
+    outl( 0, TIMER2CONTROL );
+}
+
+/*
+ * Initialization and exit routines
+ */
+int __init ep93xx_ts_init(void)
+{
+    int retval;
+
+    // printk("ep93xx_ts_init\n");
+
+    // printk("request Touchscreen interrupt.\n");
+    retval = request_irq( IRQ_TOUCH, ep93xx_ts_isr, SA_INTERRUPT, "ep93xx_ts", 0);
+    if( retval )
+    {
+        // printk(KERN_WARNING "ep93xx_ts: failed to get touchscreen IRQ\n");
+        return retval;
+    }
+
+    // printk("Request Timer interrupt.\n");
+    retval = request_irq( IRQ_TIMER2, ep93xx_timer2_isr,
+                        SA_INTERRUPT, "ep93xx_timer2", 0);
+    if( retval )
+    {
+        // printk(KERN_WARNING "ep93xx_ts: failed to get timer2 IRQ\n");
+        return retval;
+    }
+
+    // printk("Register Touchscreen Driver\n");
+    misc_register(&ep93xx_ts_miscdev);
+
+    sTouch.state = TS_STATE_STOPPED;
+    gScanningMode = TS_MODE_UN_INITIALIZED;
+    
+    // printk(KERN_NOTICE "EP93xx touchscreen driver configured for 4-wire operation\n");
+
+    return 0;
+}
+
+void __exit
+ep93xx_ts_exit(void)
+{
+    DPRINTK("ep93xx_ts_exit\n");
+    
+    Stop_Timer2();
+
+    free_irq(IRQ_TOUCH, 0);
+    free_irq(IRQ_TIMER2, 0);
+    
+    misc_deregister(&ep93xx_ts_miscdev);
+}
+
+module_init(ep93xx_ts_init);
+module_exit(ep93xx_ts_exit);
+
+MODULE_DESCRIPTION("Cirrus EP93xx touchscreen driver");
+MODULE_SUPPORTED_DEVICE("touchscreen/ep93xx");
diff -burN linux-2.6.8.1-orig/drivers/mtd/chips/cfi_util.c linux-2.6.8.1/drivers/mtd/chips/cfi_util.c
--- linux-2.6.8.1-orig/drivers/mtd/chips/cfi_util.c	2004-08-14 19:55:34.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/chips/cfi_util.c	2007-01-24 13:03:31.000000000 +0900
@@ -55,7 +55,7 @@
 	}
 
 	if (extp->MajorVersion != '1' || 
-	    (extp->MinorVersion < '0' || extp->MinorVersion > '3')) {
+	    (extp->MinorVersion < '0' || extp->MinorVersion > '4')) {
 		printk(KERN_WARNING "  Unknown %s Extended Query "
 		       "version %c.%c.\n",  name, extp->MajorVersion,
 		       extp->MinorVersion);
diff -burN linux-2.6.8.1-orig/drivers/mtd/maps/Kconfig linux-2.6.8.1/drivers/mtd/maps/Kconfig
--- linux-2.6.8.1-orig/drivers/mtd/maps/Kconfig	2004-08-14 19:56:23.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/maps/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -502,6 +502,13 @@
 	  This enables access to the CFI Flash on the Cogent EDB7312 board.
 	  If you have such a board, say 'Y' here.
 
+config MTD_EDB93XX
+	tristate "CFI Flash device mapped on EDB93xx"
+	depends on ARM && MTD_CFI && ARCH_EP93XX
+	help
+	  This enables access ot the CFI FLASH on the EDB93xx boards.  If you
+	  have such a board, say 'Y' here.
+
 config MTD_IMPA7
 	tristate "JEDEC Flash device mapped on impA7"
 	depends on ARM && MTD_JEDECPROBE
diff -burN linux-2.6.8.1-orig/drivers/mtd/maps/Makefile linux-2.6.8.1/drivers/mtd/maps/Makefile
--- linux-2.6.8.1-orig/drivers/mtd/maps/Makefile	2004-08-14 19:54:46.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/maps/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -48,6 +48,7 @@
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
+obj-$(CONFIG_MTD_EDB93XX)	+= edb93xx.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
 obj-$(CONFIG_MTD_FORTUNET)	+= fortunet.o
 obj-$(CONFIG_MTD_REDWOOD)	+= redwood.o
diff -burN linux-2.6.8.1-orig/drivers/mtd/maps/edb93xx.c linux-2.6.8.1/drivers/mtd/maps/edb93xx.c
--- linux-2.6.8.1-orig/drivers/mtd/maps/edb93xx.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/maps/edb93xx.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,293 @@
+/*======================================================================
+
+    drivers/mtd/maps/edb93xx.c: EDB93xx flash map driver
+
+    Copyright (C) 2000 ARM Limited
+    Copyright (C) 2003 Deep Blue Solutions Ltd.
+    Copyright (C) 2004 Cirrus Logic, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+======================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/init.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+struct edb93xx_flash_info {
+	struct flash_platform_data *plat;
+	struct resource		*res;
+	struct mtd_partition	*parts;
+	struct mtd_info		*mtd;
+	struct map_info		map;
+};
+
+#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
+#define MUNG_ADDR(x) ((x & 0xfffe0000) | ((x & 0x00010000) >> 15) | ((x & 0x0000ffff) << 1))
+
+static map_word
+edb93xx_flash_read(struct map_info *map, unsigned long ofs)
+{
+	map_word ret;
+	if (ofs == 0x40)
+		ret.x[0] = 0;
+	else
+		ret.x[0] = __raw_readw(map->virt + MUNG_ADDR(ofs));
+	return ret;
+}
+
+static void
+edb93xx_flash_copy_from(struct map_info *map, void *to, unsigned long from,
+			ssize_t len)
+{
+	while (len) {
+		*(short *)to++ = __raw_readw(map->virt + MUNG_ADDR(from));
+		from += 2;
+		len -= 2;
+	}
+}
+
+static void
+edb93xx_flash_write(struct map_info *map, const map_word d, unsigned long adr)
+{
+	__raw_writew(d.x[0], map->virt + MUNG_ADDR(adr));
+}
+
+static void
+edb93xx_flash_copy_to(struct map_info *map, unsigned long to, const void *from,
+		      ssize_t len)
+{
+	while (len) {
+		__raw_writew(*(short *)from++, map->virt + MUNG_ADDR(to));
+		to += 2;
+		len -= 2;
+	}
+}
+#endif
+
+static void
+edb93xx_flash_set_vpp(struct map_info *map, int on)
+{
+	struct edb93xx_flash_info *info = container_of(map, struct edb93xx_flash_info, map);
+
+	if (info->plat && info->plat->set_vpp)
+		info->plat->set_vpp(on);
+}
+
+static const char *probes[] = { "cmdlinepart", "RedBoot", NULL };
+
+static int
+edb93xx_flash_probe(struct device *_dev)
+{
+	struct platform_device *dev = to_platform_device(_dev);
+	struct flash_platform_data *plat = dev->dev.platform_data;
+	struct resource *res = dev->resource;
+	unsigned int size = res->end - res->start + 1;
+	struct edb93xx_flash_info *info;
+	int err;
+	void *base;
+
+	info = kmalloc(sizeof(struct edb93xx_flash_info), GFP_KERNEL);
+	if (!info) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	memset(info, 0, sizeof(struct edb93xx_flash_info));
+
+	info->plat = plat;
+	if (plat && plat->init) {
+		err = plat->init();
+		if (err)
+			goto no_resource;
+	}
+
+	info->res = request_mem_region(res->start, size, "mtd");
+	if (!info->res) {
+		err = -EBUSY;
+		goto no_resource;
+	}
+
+	base = ioremap(res->start, size);
+	if (!base) {
+		err = -ENOMEM;
+		goto no_mem;
+	}
+
+	/*
+	 * look for CFI based flash parts fitted to this board
+	 */
+	info->map.size		= size;
+	info->map.bankwidth	= plat->width;
+	info->map.phys		= res->start;
+	info->map.virt		= (unsigned long) base;
+	info->map.name		= dev->dev.bus_id;
+	info->map.set_vpp	= edb93xx_flash_set_vpp;
+
+
+   /*  defined(CONFIG_ARCH_EDB9312) || \  */
+
+#if defined(CONFIG_MTD_COMPLEX_MAPPINGS) && \
+    (defined(CONFIG_ARCH_EDB9307) || \
+     defined(CONFIG_ARCH_EDB9315))
+
+#ifdef CONFIG_EP93XX_CS0
+#define CONFIG inl(SMCBCR0)
+#endif
+#ifdef CONFIG_EP93XX_CS1
+#define CONFIG inl(SMCBCR1)
+#endif
+#ifdef CONFIG_EP93XX_CS2
+#define CONFIG inl(SMCBCR2)
+#endif
+#ifdef CONFIG_EP93XX_CS3
+#define CONFIG inl(SMCBCR3)
+#endif
+#ifdef CONFIG_EP93XX_CS6
+#define CONFIG inl(SMCBCR6)
+#endif
+#ifdef CONFIG_EP93XX_CS7
+#define CONFIG inl(SMCBCR7)
+#endif
+
+	if ((CONFIG & SMCBCR_MW_MASK) == SMCBCR_MW_16) {
+		info->map.read = edb93xx_flash_read;
+		info->map.copy_from = edb93xx_flash_copy_from;
+		info->map.write = edb93xx_flash_write;
+		info->map.copy_to = edb93xx_flash_copy_to;
+	} else
+#endif
+	simple_map_init(&info->map);
+
+	/*
+	 * Also, the CFI layer automatically works out what size
+	 * of chips we have, and does the necessary identification
+	 * for us automatically.
+	 */
+	info->mtd = do_map_probe(plat->map_name, &info->map);
+	if (!info->mtd) {
+		err = -ENXIO;
+		goto no_device;
+	}
+
+#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
+	simple_map_init(&info->map);
+#endif
+
+	info->mtd->owner = THIS_MODULE;
+
+	err = parse_mtd_partitions(info->mtd, probes, &info->parts, 0);
+	if (err > 0) {
+		err = add_mtd_partitions(info->mtd, info->parts, err);
+		if (err)
+			printk(KERN_ERR
+			       "mtd partition registration failed: %d\n", err);
+	}
+
+	if (err == 0)
+		dev_set_drvdata(&dev->dev, info);
+
+	/*
+	 * If we got an error, free all resources.
+	 */
+	if (err < 0) {
+		if (info->mtd) {
+			del_mtd_partitions(info->mtd);
+			map_destroy(info->mtd);
+		}
+		if (info->parts)
+			kfree(info->parts);
+
+ no_device:
+		iounmap(base);
+ no_mem:
+		release_mem_region(res->start, size);
+ no_resource:
+		if (plat && plat->exit)
+			plat->exit();
+		kfree(info);
+	}
+ out:
+	return err;
+}
+
+static int
+edb93xx_flash_remove(struct device *_dev)
+{
+	struct platform_device *dev = to_platform_device(_dev);
+	struct edb93xx_flash_info *info = dev_get_drvdata(&dev->dev);
+
+	dev_set_drvdata(&dev->dev, NULL);
+
+	if (info) {
+		if (info->mtd) {
+			del_mtd_partitions(info->mtd);
+			map_destroy(info->mtd);
+		}
+		if (info->parts)
+			kfree(info->parts);
+
+		iounmap((void *)info->map.virt);
+		release_resource(info->res);
+		kfree(info->res);
+
+		if (info->plat && info->plat->exit)
+			info->plat->exit();
+
+		kfree(info);
+	}
+
+	return 0;
+}
+
+static struct device_driver edb93xx_flash_driver = {
+	.name		= "edb93xxflash",
+	.bus		= &platform_bus_type,
+	.probe		= edb93xx_flash_probe,
+	.remove		= edb93xx_flash_remove,
+};
+
+static int __init
+edb93xx_flash_init(void)
+{
+	return driver_register(&edb93xx_flash_driver);
+}
+
+static void __exit
+edb93xx_flash_exit(void)
+{
+	driver_unregister(&edb93xx_flash_driver);
+}
+
+module_init(edb93xx_flash_init);
+module_exit(edb93xx_flash_exit);
+
+MODULE_AUTHOR("Cirrus Logic, Inc.");
+MODULE_DESCRIPTION("EDB93xx CFI map driver");
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/drivers/mtd/nand/Kconfig linux-2.6.8.1/drivers/mtd/nand/Kconfig
--- linux-2.6.8.1-orig/drivers/mtd/nand/Kconfig	2004-08-14 19:55:59.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/nand/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -147,4 +147,12 @@
 	  Even if you leave this disabled, you can enable BBT writes at module
 	  load time (assuming you build diskonchip as a module) with the module
 	  parameter "inftl_bbt_write=1".
+config MTD_NAND_EDB93xx
+	tristate "EDB93xx NAND Flash Support"
+	depends on ARCH_EP93XX && MTD_NAND
+	help
+	  This enables the driver for the NAND flash support on the
+	  EDB93xx NAND Daughter Board.
+	  There are different ways of setting up the NAND device.
+	  Please consult the source code.
 endmenu
diff -burN linux-2.6.8.1-orig/drivers/mtd/nand/Makefile linux-2.6.8.1/drivers/mtd/nand/Makefile
--- linux-2.6.8.1-orig/drivers/mtd/nand/Makefile	2004-08-14 19:54:47.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/nand/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -15,5 +15,6 @@
 obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_DISKONCHIP)	+= diskonchip.o
+obj-$(CONFIG_MTD_NAND_EDB93xx)		+= ep93xx_nand.o
 
 nand-objs = nand_base.o nand_bbt.o
diff -burN linux-2.6.8.1-orig/drivers/mtd/nand/ep93xx_nand.c linux-2.6.8.1/drivers/mtd/nand/ep93xx_nand.c
--- linux-2.6.8.1-orig/drivers/mtd/nand/ep93xx_nand.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/nand/ep93xx_nand.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,451 @@
+/*======================================================================
+ 
+   drivers/mtd/nand/ep93xx_nand.c: EDB93xx NAND flash driver
+ 
+   Copyright (C) 2006 Cirrus Logic, Inc.
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ 
+======================================================================*/
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/sizes.h>
+
+
+/*
+ *  There is a jumper select the ALE connect to A24 or EGPIO4.
+ *  If ALE is connected to A24, define NAND_ALE_ON_A24.
+ *  If ALE is connected to EGPIO4, un-define NAND_ALE_ON_A24.
+ */
+#undef NAND_ALE_ON_A24
+
+/*
+ *  There is a jumper select the CLE connect to A25 or EGPIO5.
+ *  If CLE is connected to A25, define NAND_CLE_ON_A25.
+ *  If CLE is connected to EGPIO5, un-define NAND_CLE_ON_A25.
+ */
+#undef NAND_CLE_ON_A25
+
+/*
+ *  There is a jumper select the CE connect to CS3 or EGPIO8.
+ *  If CE is connected to CS3, define NAND_CE_DONNT_CARE.
+ *  If CE is connected to EGPIO8, un-define NAND_CE_DONNT_CARE.
+ *  
+ *  NOTICE: CE DON'T CARE mode doesn't work for all nand chips.
+ */
+#undef NAND_CE_DONNT_CARE
+
+/*
+ *  There is a jumper select the R/B connect to /WAIT or EGPIO9.
+ *  If CE is connected to /WAIT, define NAND_RB_ON_WAIT.
+ *  If CE is connected to EGPIO9, un-define NAND_RB_ON_WAIT.
+ *  
+ */
+#undef NAND_RB_ON_WAIT
+
+
+static struct mtd_info *ep93xx_mtd = NULL;
+
+/*
+ *  CS3 is used for NAND flash.
+ */
+#define EP93xx_FIO_PBASE 0x30000000
+
+
+#ifdef NAND_ALE_ON_A24
+
+    static int ale_status = 0;
+    static int ale_address_offset = 0;
+
+#endif
+
+#ifdef NAND_CLE_ON_A25
+
+    static int cle_status = 0;
+    static int cle_address_offset = 0;
+#endif
+
+static int ep93xx_fio_pbase = EP93xx_FIO_PBASE;
+
+#ifdef MODULE
+MODULE_PARM(ep93xx_fio_pbase, "i");
+
+__setup("ep93xx_fio_pbase=",ep93xx_fio_pbase);
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+#define BOOT_PARTITION_SIZE         (0x800000)
+/*
+ * Define static partitions for flash device
+ */
+static struct mtd_partition partition_info[] =
+{
+    {
+        .name = "EP93xx Nand Flash Boot Partition",
+        .offset = 0,
+        .size = BOOT_PARTITION_SIZE
+    },
+    {
+        .name = "EP93xx Nand Flash",
+        .offset = BOOT_PARTITION_SIZE,
+        .size = 32*1024*1024
+    }
+};
+
+#define NUM_PARTITIONS 2
+
+#endif
+
+int EGpio_out (int line, int value)
+{
+    unsigned long uTmp;
+    unsigned long PDR = GPIO_PADR;
+    unsigned long PDDR = GPIO_PADDR;
+
+    if(line&0xff00)
+    {
+        PDR = GPIO_PBDR;
+        PDDR = GPIO_PBDDR;
+        line = line>>8;
+    }
+
+    uTmp = inl(PDDR);
+    if( ( uTmp & line) == 0)
+    {
+        outl(uTmp|line, PDDR);
+    }
+
+
+    uTmp = inl(PDR);
+    if(value)
+        outl(uTmp|line, PDR);
+    else
+        outl(uTmp&(~line), PDR);
+
+    return value;
+}
+
+int EGpio_in (int line)
+{
+    unsigned long uTmp;
+    unsigned long PDR = GPIO_PADR;
+    unsigned long PDDR = GPIO_PADDR;
+
+    if(line&0xff00)
+    {
+        PDR = GPIO_PBDR;
+        PDDR = GPIO_PBDDR;
+        line = line>>8;
+    }
+
+    uTmp = inl(PDDR);
+    if( uTmp & line )
+    {
+        outl(uTmp&(~line), PDDR);
+    }
+
+    return (inl(PDR) & line)?1:0;
+}
+
+#ifndef NAND_RB_ON_WAIT
+int ep93xx_device_ready(struct mtd_info *mtd)
+{
+    return EGpio_in(1<<9);
+}
+#endif
+
+static void ep93xx_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+    int i;
+    struct nand_chip *this = mtd->priv;
+    
+    /*printk("readbuf of %d bytes: \n", len);*/
+    
+    for (i=0; i<len; i++)
+        buf[i] = readb(this->IO_ADDR_R);
+}
+
+#if defined(NAND_CLE_ON_A25) || defined(NAND_ALE_ON_A24)
+
+static void ep93xx_nand_write_byte(struct mtd_info *mtd, u_char byte)
+{
+    struct nand_chip *this = mtd->priv;
+
+#ifdef NAND_ALE_ON_A24
+    if(ale_status)
+    {
+        writeb(byte, ale_address_offset);
+        return;
+    }
+#endif
+
+#ifdef NAND_CLE_ON_A25
+    if(cle_status)
+    {
+        writeb(byte, cle_address_offset);
+        return;
+    }
+#endif
+    writeb(byte, this->IO_ADDR_W);
+}
+
+#endif
+
+/*
+ *      hardware specific access to control-lines
+ */
+static void ep93xx_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    switch(cmd)
+    {
+
+    case NAND_CTL_SETCLE:
+#ifdef NAND_CLE_ON_A25
+
+        cle_status = 1;
+#else
+
+        EGpio_out(1<<5, 1);
+#endif
+
+        break;
+    case NAND_CTL_CLRCLE:
+#ifdef NAND_CLE_ON_A25
+
+        cle_status = 0;
+#else
+
+        EGpio_out(1<<5, 0);
+#endif
+
+        break;
+
+    case NAND_CTL_SETALE:
+#ifdef NAND_ALE_ON_A24
+
+        ale_status = 1;
+#else
+
+        EGpio_out(1<<4, 1);
+#endif
+
+        break;
+    case NAND_CTL_CLRALE:
+#ifdef NAND_ALE_ON_A24
+
+        ale_status = 0;
+#else
+
+        EGpio_out(1<<4, 0);
+#endif
+
+        break;
+
+    case NAND_CTL_SETNCE:
+#ifndef NAND_CE_DONNT_CARE
+
+        EGpio_out(1<<8, 0);
+#endif
+
+        break;
+    case NAND_CTL_CLRNCE:
+#ifndef NAND_CE_DONNT_CARE
+
+        EGpio_out(1<<8, 1);
+#endif
+
+        break;
+    }
+}
+
+
+#ifdef CONFIG_MTD_PARTITIONS
+const char *part_probes[] =
+    { "cmdlinepart", NULL
+    };
+#endif
+
+/*
+ * Main initialization routine
+ */
+static int __init ep93xx_init (void)
+{
+    int ret=0;
+    struct nand_chip *chip;
+    const char *part_type = 0;
+    int mtd_parts_nb = 0;
+    struct mtd_partition *mtd_parts = 0;
+    int ep93xx_fio_base =0;
+
+    /* Allocate memory for MTD device structure and private data */
+    ep93xx_mtd = kmalloc(sizeof(struct mtd_info) +
+                         sizeof(struct nand_chip),
+                         GFP_KERNEL);
+    if (!ep93xx_mtd)
+    {
+        printk("Unable to allocate EDB93xx NAND MTD device structure.\n");
+        ret = -ENOMEM;
+        goto fail_return;
+    }
+
+    /* map physical adress */
+    ep93xx_fio_base = (unsigned long)ioremap(ep93xx_fio_pbase, SZ_1K);
+    if(!ep93xx_fio_base)
+    {
+        printk("ioremap EDB93xx NAND flash failed\n");
+        ret = -EIO;
+        goto fail_return;
+    }
+    
+#ifdef NAND_ALE_ON_A24
+    ale_address_offset = (unsigned long)ioremap(ep93xx_fio_pbase | 0x1000000, SZ_1K);
+    if(!ale_address_offset)
+    {
+        printk("ioremap EDB93xx NAND flash failed\n");
+        ret = -EIO;
+        goto fail_return;
+    }
+#endif
+
+#ifdef NAND_CLE_ON_A25
+
+    cle_address_offset = (unsigned long)ioremap(ep93xx_fio_pbase | 0x2000000, SZ_1K);
+    if(!cle_address_offset)
+    {
+        printk("ioremap EDB93xx NAND flash failed\n");
+        ret = -EIO;
+        goto fail_return;
+    }
+
+#endif
+
+    /* Get pointer to private data */
+    chip = (struct nand_chip *) (&ep93xx_mtd[1]);
+
+    /* Initialize structures */
+    memset((char *) ep93xx_mtd, 0, sizeof(struct mtd_info));
+    memset((char *) chip, 0, sizeof(struct nand_chip));
+
+    /* Link the private data with the MTD structure */
+    ep93xx_mtd->priv = chip;
+
+    /* insert callbacks */
+    chip->IO_ADDR_R = ep93xx_fio_base;
+    chip->IO_ADDR_W = ep93xx_fio_base;
+    chip->hwcontrol = ep93xx_hwcontrol;
+#ifdef NAND_RB_ON_WAIT
+    chip->dev_ready = NULL;
+#else
+    chip->dev_ready = ep93xx_device_ready;
+#endif
+    chip->read_buf = ep93xx_read_buf;
+    /* 15 us command delay time */
+    chip->chip_delay = 100;
+    chip->eccmode = NAND_ECC_SOFT;
+    
+
+#if defined(NAND_CLE_ON_A25) || defined(NAND_ALE_ON_A24)
+    chip->write_byte = ep93xx_nand_write_byte;
+#endif
+    /* Scan to find existence of the device */
+    printk("Scan the NAND device for EDB93xx.\n");
+    if (nand_scan (ep93xx_mtd, 1))
+    {
+        ret = -ENXIO;
+        goto fail_return;
+    }
+
+    /* Allocate memory for internal data buffer */
+    chip->data_buf = kmalloc (sizeof(u_char) * (ep93xx_mtd->oobblock + ep93xx_mtd->oobsize), GFP_KERNEL);
+    if (!chip->data_buf)
+    {
+        ret = -ENOMEM;
+        goto fail_return;
+    }
+
+#ifdef CONFIG_MTD_PARTITIONS
+    ep93xx_mtd->name = "ep93xx_nand";
+    mtd_parts_nb = parse_mtd_partitions(ep93xx_mtd, part_probes,
+                                        &mtd_parts, 0);
+    if (mtd_parts_nb > 0)
+        part_type = "command line";
+    else
+        mtd_parts_nb = 0;
+#endif
+
+    if (mtd_parts_nb == 0)
+    {
+        mtd_parts = partition_info;
+        mtd_parts_nb = NUM_PARTITIONS;
+        part_type = "static";
+    }
+
+    /* Register the partitions */
+    printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+    add_mtd_partitions(ep93xx_mtd, mtd_parts, mtd_parts_nb);
+
+    /* Return happy */
+    return ret;
+
+fail_return:
+
+#ifdef NAND_ALE_ON_A24
+    if(ale_address_offset)
+        iounmap((void *)ale_address_offset);
+#endif
+
+#ifdef NAND_CLE_ON_A25
+    if(cle_address_offset)
+        iounmap((void *)cle_address_offset);
+#endif
+    
+    if(ep93xx_fio_base)
+        iounmap((void *)ep93xx_fio_base);
+
+    if (ep93xx_mtd)
+        kfree (ep93xx_mtd);
+
+    return ret;
+}
+module_init(ep93xx_init);
+
+/*
+ * Clean up routine
+ */
+static void __exit ep93xx_cleanup (void)
+{
+    struct nand_chip *chip = (struct nand_chip *) &ep93xx_mtd[1];
+
+    /* Unregister the device */
+    del_mtd_device (ep93xx_mtd);
+
+    /* Free internal data buffer */
+    kfree (chip->data_buf);
+
+    /* Free the MTD device structure */
+    kfree (ep93xx_mtd);
+}
+module_exit(ep93xx_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for EDB93xx NAND daughter board");
diff -burN linux-2.6.8.1-orig/drivers/mtd/nand/nand_ids.c linux-2.6.8.1/drivers/mtd/nand/nand_ids.c
--- linux-2.6.8.1-orig/drivers/mtd/nand/nand_ids.c	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/drivers/mtd/nand/nand_ids.c	2007-01-24 13:03:31.000000000 +0900
@@ -62,7 +62,7 @@
 	
 	{"NAND 256MiB 3,3V 8-bit", 	0x71, 512, 256, 0x4000, 0},
 
-	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
+//	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
 	
 	/* These are the new chips with large page size. The pagesize
 	* and the erasesize is determined from the extended id bytes
@@ -118,6 +118,7 @@
 	{NAND_MFR_NATIONAL, "National"},
 	{NAND_MFR_RENESAS, "Renesas"},
 	{NAND_MFR_STMICRO, "ST Micro"},
+	{0x2c, "Micron"},
 	{0x0, "Unknown"}
 };
 
diff -burN linux-2.6.8.1-orig/drivers/net/Kconfig linux-2.6.8.1/drivers/net/Kconfig
--- linux-2.6.8.1-orig/drivers/net/Kconfig	2004-08-14 19:56:00.000000000 +0900
+++ linux-2.6.8.1/drivers/net/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -813,6 +813,15 @@
 	  <file:Documentation/networking/net-modules.txt>. The module
 	  will be called smc-ultra32.
 
+config EP93XX_ETHERNET
+	tristate "EP93xx ethernet support"
+	depends on NET_ETHERNET && ARM && ARCH_EP93XX
+	help
+	  The internal ethernet controller on the EP93xx parts.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ep93xx_eth.
+
 config SMC91X
 	tristate "SMC 91C9x/91C1xxx support"
 	select CRC32
diff -burN linux-2.6.8.1-orig/drivers/net/Makefile linux-2.6.8.1/drivers/net/Makefile
--- linux-2.6.8.1-orig/drivers/net/Makefile	2004-08-14 19:55:09.000000000 +0900
+++ linux-2.6.8.1/drivers/net/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -25,6 +25,8 @@
 obj-$(CONFIG_MYRI_SBUS) += myri_sbus.o
 obj-$(CONFIG_SUNGEM) += sungem.o sungem_phy.o
 
+obj-$(CONFIG_EP93XX_ETHERNET) += ep93xx_eth.o
+
 obj-$(CONFIG_MACE) += mace.o
 obj-$(CONFIG_BMAC) += bmac.o
 
diff -burN linux-2.6.8.1-orig/drivers/net/ep93xx_eth.c linux-2.6.8.1/drivers/net/ep93xx_eth.c
--- linux-2.6.8.1-orig/drivers/net/ep93xx_eth.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/net/ep93xx_eth.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1598 @@
+/*----------------------------------------------------------------------------
+ * ep93xx_eth.c
+ *  Ethernet Device Driver for Cirrus Logic EP93xx.
+ *
+ * Copyright (C) 2003 by Cirrus Logic www.cirrus.com
+ * This software may be used and distributed according to the terms
+ * of the GNU Public License.
+ *
+ *   This driver was written based on skeleton.c by Donald Becker and
+ * smc9194.c by Erik Stahlman.
+ *
+ * Theory of Operation
+ * Driver Configuration
+ *  - Getting MAC address from system
+ *     To setup identical MAC address for each target board, driver need
+ *      to get a MAC address from system.  Normally, system has a Serial
+ *      EEPROM or other media to store individual MAC address when
+ *      manufacturing.
+ *      The macro GET_MAC_ADDR is prepared to get the MAC address from
+ *      system and one should supply a routine for this purpose.
+ * Driver Initialization
+ * DMA Operation
+ * Cache Coherence
+ *
+ * History:
+ * 07/19/01 0.1  Sungwook Kim  initial release
+ * 10/16/01 0.2  Sungwook Kim  add workaround for ignorance of Tx request while sending frame
+ *                             add some error stuations handling
+ *
+ * 03/25/03 Melody Lee Modified for EP93xx
+ *--------------------------------------------------------------------------*/
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/ssp.h>
+
+#include "ep93xx_eth.h"
+
+/*----------------------------------------------------------------------------
+ * The name of the card.
+ * It is used for messages and in the requests for io regions, irqs and ...
+ * This device is not in a card but I used same name in skeleton.c file.
+ *--------------------------------------------------------------------------*/
+#define  cardname  "ep93xxethernet"
+
+/*----------------------------------------------------------------------------
+ * Macro to get MAC address from system
+ *
+ * Parameters:
+ *  - pD  : a pointer to the net device information, struct net_device.
+ *          one can get base address of device from pD->base_addr,
+ *          device instance ID (0 for 1st and so on) from *((int*)pD->priv).
+ *  - pMac: a pointer to a 6 bytes length buffer to return device MAC address.
+ *          this buffer will be initialized with default_mac[] value before
+ *          calling.
+ * Return: none
+ *--------------------------------------------------------------------------*/
+#define GET_MAC_ADDR(pD, pMac)						\
+	{								\
+		unsigned int uiTemp;					\
+		int SSP_Handle;						\
+									\
+		SSP_Handle = SSPDriver->Open( SERIAL_FLASH, 0 );	\
+		if (SSP_Handle != -1) {					\
+			SSPDriver->Read( SSP_Handle, 0x1000, &uiTemp );	\
+			if (uiTemp == 0x43414d45) {			\
+				SSPDriver->Read( SSP_Handle, 0x1004,	\
+						 &uiTemp );		\
+				pMac[0] = uiTemp & 255;			\
+				pMac[1] = (uiTemp >> 8) & 255;		\
+				pMac[2] = (uiTemp >> 16) & 255;		\
+				pMac[3] = uiTemp >> 24;			\
+				SSPDriver->Read( SSP_Handle, 0x1008,	\
+						 &uiTemp );		\
+				pMac[4] = uiTemp & 255;			\
+				pMac[5] = (uiTemp >> 8) & 255;		\
+			}						\
+			SSPDriver->Close( SSP_Handle );			\
+		}							\
+	}
+
+/****  default MAC address if GET_MAC_ADDR does not override  *************/
+static const U8  default_mac[6] = {0x00, 0xba, 0xd0, 0x0b, 0xad, 0x00};
+
+/*----------------------------------------------------------------------------
+ * Some definitions belong to the operation of this driver.
+ * You should understand how it affect to driver before any modification.
+ *--------------------------------------------------------------------------*/
+
+/****  Interrupt Sources in Use  *******************************************/
+/*#define  Default_IntSrc  (IntEn_RxMIE|IntEn_RxSQIE|IntEn_TxLEIE|IntEn_TIE|IntEn_TxSQIE|IntEn_RxEOFIE|IntEn_RxEOBIE|IntEn_RxHDRIE)
+*/
+#define  Default_IntSrc  (IntEn_TxSQIE|IntEn_RxEOFIE|IntEn_RxEOBIE|IntEn_RxHDRIE)
+
+/****  Length of Device Queue in number of entries
+       (must be less than or equal to 255)  ********************************/
+#define  LEN_QueRxDesc  64             /*length of Rx Descriptor Queue (4 or bigger) Must be power of 2.*/
+#define  LEN_QueRxSts   LEN_QueRxDesc  /*length of Rx Status Queue*/
+#define  LEN_QueTxDesc  8              /*length of Tx Descriptor Queue (4 or bigger) Must be power of 2.*/
+#define  LEN_QueTxSts   LEN_QueTxDesc  /*length of Tx Status Queue*/
+
+/****  Tx Queue fill-up level control  *************************************/
+#define  LVL_TxStop    LEN_QueTxDesc - 2    /*level to ask the stack to stop Tx*/
+#define  LVL_TxResume  2   /*level to ask the stack to resume Tx*/
+
+/****  Rx Buffer length in bytes  ******************************************/
+#define  LEN_RxBuf  (1518+2+16)  /*length of Rx buffer, must be 4-byte aligned*/
+#define  LEN_TxBuf   LEN_RxBuf
+
+/*----------------------------------------------------------------------------
+ * MACRO for ease
+ *--------------------------------------------------------------------------*/
+#define  Align32(a)  (((unsigned int)(a)+3)&~0x03)  /*32bit address alignment*/
+#define  IdxNext(idxCur,len)  (((idxCur)+1)%(len))  /*calc next array index number*/
+
+/****  malloc/free routine for DMA buffer  **********************************/
+ /*use non-cached DMA buffer*/
+#define  MALLOC_DMA(size, pPhyAddr)  dma_alloc_writecombine(NULL, (size), (dma_addr_t*)(pPhyAddr), GFP_KERNEL | GFP_DMA)
+//#define  FREE_DMA(size, vaddr, paddr)            dma_free_writecombine(NULL, (size), (vaddr), (paddr))
+
+/*----------------------------------------------------------------------------
+ * DEBUGGING LEVELS
+ *
+ * 0 for normal operation
+ * 1 for slightly more details
+ * >2 for various levels of increasingly useless information
+ *    2 for interrupt tracking, status flags
+ *    3 for packet dumps, etc.
+ *--------------------------------------------------------------------------*/
+//#define  _DBG  3
+
+#if (_DBG > 2 )
+#define PRINTK3(x) printk x
+#else
+#define PRINTK3(x)
+#endif
+
+#if _DBG > 1
+#define PRINTK2(x) printk x
+#else
+#define PRINTK2(x)
+#endif
+
+#if _DBG > 0
+#define PRINTK1(x) printk x
+#else
+#define PRINTK1(x)
+#endif
+
+#ifdef _DBG
+#define PRINTK(x) printk x
+#else
+#define PRINTK(x)
+#endif
+
+#define  _PRTK_ENTRY      PRINTK2   /*to trace function entries*/
+#define  _PRTK_SWERR      PRINTK    /*logical S/W error*/
+#define  _PRTK_SYSFAIL    PRINTK    /*system service failure*/
+#define  _PRTK_HWFAIL     PRINTK    /*H/W operation failure message*/
+#define  _PRTK_WARN       PRINTK1   /*warning information*/
+#define  _PRTK_INFO       PRINTK2   /*general information*/
+#define  _PRTK_ENTRY_ISR  PRINTK3   /*to trace function entries belong to ISR*/
+#define  _PRTK_WARN_ISR   PRINTK1   /*warning informations from ISR*/
+#define  _PRTK_INFO_ISR   PRINTK3   /*general informations from ISR*/
+#define  _PRTK_           PRINTK    /*for temporary print out*/
+
+#if 0
+# define  _PRTK_DUMP       PRINTK1   /*to dump large amount of debug info*/
+#endif
+
+/*----------------------------------------------------------------------------
+ * Custom Data Structures
+ *--------------------------------------------------------------------------*/
+
+/****  the information about the buffer passed to device.
+       there are matching bufferDescriptor informations
+       for each Tx/Rx Descriptor Queue entry to trace
+       the buffer within those queues.  ************************************/
+typedef  struct bufferDescriptor  {
+    void  *vaddr;                /*virtual address representing the buffer passed to device*/
+    int(*pFreeRtn)(void *pBuf);  /*free routine*/
+}  bufferDescriptor;
+
+/****  device privite informations
+       pointed by struct net_device::priv  *********************************/
+typedef  struct ep93xxEth_info  {
+    /****  static device informations  **********************************/
+    struct {
+        int                 id;            /*device instance ID (0 for 1st and so on)
+                                             must be first element of this structure*/
+        receiveDescriptor   *pQueRxDesc;   /*pointer to Rx Descriptor Queue*/
+        receiveStatus       *pQueRxSts;    /*pointer to Rx Status Queue*/
+        transmitDescriptor  *pQueTxDesc;   /*pointer to Tx Descriptor Queue*/
+        transmitStatus      *pQueTxSts;    /*pointer to Tx Status Queue*/
+        unsigned char       *pRxBuf;       /*base of Rx Buffer pool*/
+        unsigned char       *pTxBuf;       /*base of Tx Buffer pool*/
+        unsigned long       phyQueueBase;  /*physical address of device queues*/
+        unsigned long       phyQueRxDesc,  /*physical address of Rx Descriptor Queue*/
+                            phyQueRxSts,   /*physical address of Rx Status Queue*/
+                            phyQueTxDesc,  /*physical address of Tx Descriptor Queue*/
+                            phyQueTxSts,   /*physical address of Tx Status Queue*/
+                            phyRxBuf,      /*physical address of Rx Buffer pool*/
+                            phyTxBuf;      /*physical address of Tx Buffer pool*/
+        bufferDescriptor    *pRxBufDesc,   /*info of Rx Buffers*/
+                            *pTxBufDesc;   /*info of Tx Buffers*/
+        int                 miiIdPhy;      /*MII Bus ID of Ethernet PHY*/
+    }  s;
+    /****  dynamic information, subject to clear when device open  ******/
+    struct {
+        struct net_device_stats  stats;  /*statistic data*/
+        int  idxQueRxDesc,       /*next processing index of device queues*/
+             idxQueRxSts,
+             idxQueTxDescHead,
+             idxQueTxDescTail,
+             idxQueTxSts;
+        int  txStopped;          /*flag for Tx condition*/
+    }  d;
+}  ep93xxEth_info;
+
+/*----------------------------------------------------------------------------
+ * Global Variables
+ *--------------------------------------------------------------------------*/
+static int  numOfInstance = 0;  /*total number of device instance, 0 means the 1st instance.*/
+
+//static struct sk_buff gTxSkb;
+//static char gTxBuff[LEN_TxBuf];
+
+static char gTxDataBuff[LEN_QueTxDesc][LEN_TxBuf];
+
+// To know if PHY auto-negotiation has done?
+static int gPhyAutoNegoDone=0;
+
+/*============================================================================
+ *
+ * Internal Routines
+ *
+ *==========================================================================*/
+
+/*****************************************************************************
+* free_skb()
+*****************************************************************************/
+static int
+free_skb(void *pSkb)
+{
+	dev_kfree_skb_irq((struct sk_buff*)pSkb);
+	return 0;
+}
+
+/*****************************************************************************
+* waitOnReg32()
+*****************************************************************************/
+static int
+waitOnReg32(struct net_device *pD, int reg, unsigned long mask,
+	    unsigned long expect, int tout)
+{
+	int  i;
+	int  dt;
+
+	for (i = 0; i < 10000; ) {
+		dt = RegRd32(reg);
+		dt = (dt ^ expect) & mask;
+		if (dt == 0)
+			break;
+		if (tout)
+			i++;
+	}
+
+	return dt;
+}
+
+#define  phy_wr(reg,dt)  _phy_write(pD, ((ep93xxEth_info*)pD->priv)->s.miiIdPhy, (reg), (dt))
+#define  phy_rd(reg)     _phy_read(pD, ((ep93xxEth_info*)pD->priv)->s.miiIdPhy, (reg))
+#define  phy_waitRdy()  waitOnReg32(pD, REG_MIISts,MIISts_Busy, ~MIISts_Busy, 1)
+
+/*****************************************************************************
+* _phy_write()
+*****************************************************************************/
+static void
+_phy_write(struct net_device *pD, int idPhy, int reg, U16 dt)
+{
+	phy_waitRdy();
+	RegWr32(REG_MIIData, dt);
+	RegWr32(REG_MIICmd, MIICmd_OP_WR | ((idPhy & 0x1f) << 5) |
+		((reg & 0x1f) << 0));
+}
+
+/*****************************************************************************
+* _phy_read()
+*****************************************************************************/
+static U16
+_phy_read(struct net_device *pD,int idPhy,int reg)
+{
+	U16  dt;
+
+	phy_waitRdy();
+	RegWr32(REG_MIICmd, MIICmd_OP_RD | ((idPhy & 0x1f) << 5) |
+		((reg & 0x1f) << 0));
+	phy_waitRdy();
+	dt = (unsigned short)RegRd32(REG_MIIData);
+
+	return dt;
+}
+
+#ifndef _PRTK_DUMP
+#define _dbg_phy_dumpReg(pD)
+#else
+/*****************************************************************************
+* _dbg_phy_dumpReg()
+*****************************************************************************/
+static void
+_dbg_phy_dumpReg(struct net_device *pD)
+{
+	_PRTK_DUMP(("Dumping registers of Ethernet PHY\n"));
+	_PRTK_DUMP((" pD:0x%p, Eth Base Address:0x%x\n", pD,
+		    (unsigned int)pD->base_addr));
+
+	_PRTK_DUMP((" 0-3:0x%04x 0x%04x  0x%04x 0x%04x\n",
+		    phy_rd(0), phy_rd(1), phy_rd(2), phy_rd(3)));
+	_PRTK_DUMP((" 4-6:0x%04x 0x%04x  0x%04x\n",
+		    phy_rd(4), phy_rd(5), phy_rd(6)));
+	_PRTK_DUMP((" 16-19:0x%04x 0x%04x  0x%04x  0x%04x\n",
+		    phy_rd(16), phy_rd(17), phy_rd(18), phy_rd(19)));
+	_PRTK_DUMP((" 20:0x%04x\n", phy_rd(20)));
+}
+#endif
+
+/*****************************************************************************
+* phy_autoNegotiation()
+*****************************************************************************/
+static int
+phy_autoNegotiation(struct net_device *pD)
+{
+	U16 val;
+	U16 oldVal;
+	U16 count = 0;
+
+	phy_wr(4, 0x01e1);  /*Set 802.3, 100M/10M Full/Half ability*/
+	phy_wr(0, (1 << 12) | (1 << 9)); /* enable auto negotiation*/
+	while (1) {
+		val = phy_rd(1); /* read BM status Reg*/
+		if (val & 0x0020) /* if Auto_Neg_complete?*/
+			break;
+		else {
+			if (count >= 3)
+				return -1;
+			mdelay(1000);//delay 1 second.
+			count++;
+		}
+	}
+
+	//CS8952 PHY needs the delay.  Otherwise it won't send the 1st frame.
+	mdelay(1000);//delay 1 second.
+
+	val = phy_rd(5); /* read ANLPAR Reg*/
+	if (val & 0x0140) { /* if 100M_FDX or 10M_FDX?*/
+		oldVal = RegRd16(REG_TestCTL);
+		/*Enable MAC's Full Duplex mode.*/
+		RegWr16(REG_TestCTL, oldVal | TestCTL_MFDX);
+	}
+
+	gPhyAutoNegoDone = 1;
+
+	return 0;
+}
+
+/*****************************************************************************
+* phy_init()
+*****************************************************************************/
+static int
+phy_init(struct net_device *pD)
+{
+	U32 oldVal;
+	int status = -1;
+	U16 val;
+
+	oldVal = RegRd32(REG_SelfCTL);
+
+	/*
+	 * Set MDC clock to be divided by 8 and disable PreambleSuppress bit
+	 */
+	RegWr32(REG_SelfCTL, 0x4e00);
+
+	/*
+	 * read BM status Reg; Link Status Bit remains cleared until the Reg is
+	 * read.
+	 */
+	val = phy_rd(1);
+
+	/*
+	 * read BMStaReg again to get the current link status
+	 */
+	val = phy_rd(1);
+	if (val & 0x0004)
+		status = phy_autoNegotiation(pD);
+
+	RegWr32(REG_SelfCTL, oldVal);
+
+	return status;
+}
+
+/*****************************************************************************
+* phy_reset()
+*****************************************************************************/
+#if 0
+static int
+phy_reset(struct net_device *pD)
+{
+	int i;
+
+
+	phy_wr(0, 1 << 15);
+
+	for (i = 0; i < 1000; i++)
+		if ((phy_rd(0) & (1 << 15)) == 0)
+			break;
+
+	if ((phy_rd(0) & (1 << 15)) != 0) {
+		_PRTK_HWFAIL(("phy_reset(): PHY reset does not self-clear\n"));
+		return -1;
+	}
+
+	phy_wr(19, 0x00);
+	phy_wr(4, (1 << 8) | (1 << 7) | (1 << 6) | (1 << 5) | (0x01 << 0));
+	phy_wr(0, (1 << 12) | (1 << 9));
+
+	return 0;
+}
+#endif
+
+#ifndef _PRTK_DUMP
+# define _dbg_ep93xxEth_dumpQueues(pD)
+#else
+/*****************************************************************************
+* _dbg_ep93xxEth_dumpQueues()
+*****************************************************************************/
+static void
+_dbg_ep93xxEth_dumpQueues(struct net_device *pD)
+{
+	struct ep93xxEth_info *pP = pD->priv;
+	int i;
+
+	_PRTK_DUMP(("Dumping Descriptor/Status Queues\n"));
+	_PRTK_DUMP((" pD:0x%p, Base Address:0x%x\n", pD,
+		    (unsigned int)pD->base_addr));
+
+	_PRTK_DUMP((" o Rx Status Queue: at 0x%p, %d entries\n",
+		    pP->s.pQueRxSts, LEN_QueRxSts));
+	for (i = 0; i < LEN_QueRxSts; i++)
+		_PRTK_DUMP(("  - %2d: 0x%08x 0x%08x \n", i,
+			    (unsigned int)pP->s.pQueRxSts[i].w.e0,
+			    (unsigned int)pP->s.pQueRxSts[i].w.e1));
+
+	_PRTK_DUMP((" o Rx Descriptor Queue: at 0x%p, %d entries\n",
+		    pP->s.pQueRxDesc, LEN_QueRxDesc));
+	for (i = 0; i < LEN_QueRxDesc; i++)
+		_PRTK_DUMP(("  - %2d: 0x%08x 0x%08x \n", i,
+			    (unsigned int)pP->s.pQueRxDesc[i].w.e0,
+			    (unsigned int)pP->s.pQueRxDesc[i].w.e1));
+
+	_PRTK_DUMP((" o Tx Status Queue: at 0x%p, %d entries\n",
+		    pP->s.pQueTxSts, LEN_QueTxSts));
+	for (i = 0; i < LEN_QueTxSts; i++)
+		_PRTK_DUMP(("  - %2d: 0x%08x \n", i,
+			    (unsigned int)pP->s.pQueTxSts[i].w.e0));
+
+	_PRTK_DUMP((" o Tx Descriptor Queue: at 0x%p, %d entries\n",
+		    pP->s.pQueTxDesc, LEN_QueTxDesc));
+	for (i = 0; i < LEN_QueTxDesc; i++)
+		_PRTK_DUMP(("  - %2d: 0x%08x 0x%08x \n", i,
+			    (unsigned int)pP->s.pQueTxDesc[i].w.e0,
+			    (unsigned int)pP->s.pQueTxDesc[i].w.e1));
+}
+#endif
+
+/*****************************************************************************
+* devQue_start()
+*
+  make descriptor queues active
+  allocate queue entries if needed
+  and set device registers up to make it operational
+  assume device has been initialized
+*
+*****************************************************************************/
+static int
+devQue_start(struct net_device *pD)
+{
+	int err;
+	struct ep93xxEth_info *pP = pD->priv;
+	int i;
+	void *pBuf;
+	U32 phyA;
+
+	RegWr32(REG_BMCtl, BMCtl_RxDis | BMCtl_TxDis | RegRd32(REG_BMCtl));
+	err = waitOnReg32(pD, REG_BMSts, BMSts_TxAct, ~BMSts_TxAct, 1);
+	err |= waitOnReg32(pD, REG_BMSts, BMSts_RxAct, ~BMSts_RxAct, 1);
+	if (err)
+		_PRTK_HWFAIL(("devQue_start(): BM does not stop\n"));
+
+	memset(pP->s.pQueTxSts, 0, sizeof(pP->s.pQueTxSts[0]) * LEN_QueTxSts);
+	pP->d.idxQueTxSts = 0;
+	RegWr32(REG_TxSBA, pP->s.phyQueTxSts);
+	RegWr32(REG_TxSCA, pP->s.phyQueTxSts);
+	RegWr16(REG_TxSBL, sizeof(pP->s.pQueTxSts[0]) * LEN_QueTxSts);
+	RegWr16(REG_TxSCL, sizeof(pP->s.pQueTxSts[0]) * LEN_QueTxSts);
+
+	memset(pP->s.pQueTxDesc, 0,
+	       sizeof(pP->s.pQueTxDesc[0]) * LEN_QueTxDesc);
+	pP->d.idxQueTxDescHead = pP->d.idxQueTxDescTail = 0;
+	RegWr32(REG_TxDBA, pP->s.phyQueTxDesc);
+	RegWr32(REG_TxDCA, pP->s.phyQueTxDesc);
+	RegWr16(REG_TxDBL, sizeof(pP->s.pQueTxDesc[0]) * LEN_QueTxDesc);
+	RegWr16(REG_TxDCL, sizeof(pP->s.pQueTxDesc[0]) * LEN_QueTxDesc);
+
+	memset(pP->s.pQueRxSts, 0, sizeof(pP->s.pQueRxSts[0]) * LEN_QueRxSts);
+	pP->d.idxQueRxSts = 0;
+	RegWr32(REG_RxSBA, pP->s.phyQueRxSts);
+	RegWr32(REG_RxSCA, pP->s.phyQueRxSts);
+	RegWr16(REG_RxSBL, sizeof(pP->s.pQueRxSts[0]) * LEN_QueRxSts);
+	RegWr16(REG_RxSCL, sizeof(pP->s.pQueRxSts[0]) * LEN_QueRxSts);
+
+	memset(pP->s.pQueRxDesc, 0,
+	       sizeof(pP->s.pQueRxDesc[0]) * LEN_QueRxDesc);
+	phyA = pP->s.phyRxBuf;
+	for (i = 0; i < LEN_QueRxDesc; i++) {
+		pP->s.pQueRxDesc[i].f.bi = i;
+		pP->s.pQueRxDesc[i].f.ba = phyA;
+		pP->s.pQueRxDesc[i].f.bl = LEN_RxBuf;
+		phyA += (LEN_RxBuf + 3) & ~0x03;
+	}
+	pP->d.idxQueRxDesc = 0;
+	RegWr32(REG_RxDBA, pP->s.phyQueRxDesc);
+	RegWr32(REG_RxDCA, pP->s.phyQueRxDesc);
+	RegWr16(REG_RxDBL, sizeof(pP->s.pQueRxDesc[0]) * LEN_QueRxDesc);
+	RegWr16(REG_RxDCL, sizeof(pP->s.pQueRxDesc[0]) * LEN_QueRxDesc);
+
+	pBuf = pP->s.pRxBuf;
+	for (i = 0; i < LEN_QueRxDesc; i++) {
+		pP->s.pRxBufDesc[i].vaddr = pBuf;
+		pP->s.pRxBufDesc[i].pFreeRtn = 0;
+		pBuf += (LEN_RxBuf + 3) & ~0x03;
+	}
+
+	memset(pP->s.pTxBufDesc, 0x0,
+	       sizeof(*pP->s.pTxBufDesc) * LEN_QueTxDesc);
+	pP->s.pTxBuf = &gTxDataBuff[0][0];
+	for (i = 0; i < LEN_QueTxDesc; i++) {
+		pP->s.pTxBufDesc[i].vaddr = &gTxDataBuff[i][0];
+		pP->s.pTxBufDesc[i].pFreeRtn = 0;
+	}
+
+	RegWr32(REG_BMCtl, BMCtl_TxEn | BMCtl_RxEn | RegRd32(REG_BMCtl));
+	err = waitOnReg32(pD, REG_BMSts, BMSts_TxAct | BMSts_TxAct,
+			  BMSts_TxAct | BMSts_TxAct, 1);
+	if(err)
+		_PRTK_HWFAIL(("devQue_start(): BM does not start\n"));
+
+	RegWr32(REG_RxSEQ, LEN_QueRxSts);
+	RegWr32(REG_RxDEQ, LEN_QueRxDesc);
+
+	return 0;
+}
+
+/*****************************************************************************
+* devQue_init()
+  init device descriptor queues at system level
+  device access is not recommended at this point
+*
+*****************************************************************************/
+static int
+devQue_init(struct net_device *pD)
+{
+	struct ep93xxEth_info *pP = pD->priv;
+	void *pBuf;
+	int size;
+
+	if (sizeof(receiveDescriptor) != 8) {
+		_PRTK_SWERR(("devQue_init(): size of receiveDescriptor is not 8 bytes!!!\n"));
+		return -1;
+	} else if (sizeof(receiveStatus) != 8) {
+		_PRTK_SWERR(("devQue_init(): size of receiveStatus is not 8 bytes!!!\n"));
+		return -1;
+	} else if (sizeof(transmitDescriptor) != 8) {
+		_PRTK_SWERR(("devQue_init(): size of transmitDescriptor is not 8 bytes!!!\n"));
+		return -1;
+	} else if (sizeof(transmitStatus) != 4) {
+		_PRTK_SWERR(("devQue_init(): size of transmitStatus is not 4 bytes!!!\n"));
+		return -1;
+	}
+
+	size = sizeof(receiveDescriptor) * (LEN_QueRxDesc + 1) +
+		sizeof(receiveStatus) * (LEN_QueRxSts + 1) +
+		sizeof(transmitDescriptor) * (LEN_QueTxDesc + 1) +
+		sizeof(transmitStatus) * (LEN_QueTxSts + 1) +
+		sizeof(unsigned long) * 4;
+
+	pBuf = MALLOC_DMA(size, &pP->s.phyQueueBase);
+	if(!pBuf)
+		return -1;
+
+	pP->s.pQueRxDesc = (void *)Align32(pBuf);
+	pBuf = (char *)pBuf + sizeof(receiveDescriptor) * (LEN_QueRxDesc + 1);
+	pP->s.pQueRxSts = (void *)Align32(pBuf);
+	pBuf = (char *)pBuf + sizeof(receiveStatus) * (LEN_QueRxSts + 1);
+	pP->s.pQueTxDesc = (void *)Align32(pBuf);
+	pBuf = (char *)pBuf + sizeof(transmitDescriptor) * (LEN_QueTxDesc + 1);
+	pP->s.pQueTxSts = (void *)Align32(pBuf);
+	pBuf = (char *)pBuf + sizeof(transmitStatus) * (LEN_QueTxSts + 1);
+
+	pP->s.phyQueRxDesc = Align32(pP->s.phyQueueBase);
+	pP->s.phyQueRxSts = pP->s.phyQueRxDesc + ((U32)pP->s.pQueRxSts -
+						  (U32)pP->s.pQueRxDesc);
+	pP->s.phyQueTxDesc = pP->s.phyQueRxDesc + ((U32)pP->s.pQueTxDesc -
+						   (U32)pP->s.pQueRxDesc);
+	pP->s.phyQueTxSts = pP->s.phyQueRxDesc + ((U32)pP->s.pQueTxSts -
+						  (U32)pP->s.pQueRxDesc);
+
+	memset(pP->s.pQueRxDesc, 0, sizeof(receiveDescriptor) * LEN_QueRxDesc);
+	memset(pP->s.pQueRxSts, 0, sizeof(receiveStatus) * LEN_QueRxSts);
+	memset(pP->s.pQueTxDesc, 0,
+	       sizeof(transmitDescriptor) * LEN_QueTxDesc);
+	memset(pP->s.pQueTxSts, 0, sizeof(transmitStatus) * LEN_QueTxSts);
+
+	pP->s.pRxBuf = MALLOC_DMA(((LEN_RxBuf + 3) & ~0x03) * LEN_QueRxDesc,
+				  &pP->s.phyRxBuf);
+	if (!pP->s.pRxBuf) {
+		pP->s.pRxBuf = 0;
+		_PRTK_SYSFAIL(("devQue_init(): fail to allocate memory for RxBuf\n"));
+		return -1;
+	}
+
+	size = sizeof(bufferDescriptor) * (LEN_QueRxDesc + LEN_QueTxDesc);
+	pBuf = kmalloc(size, GFP_KERNEL);
+	if(!pBuf) {
+		_PRTK_SYSFAIL(("devQue_initAll(): fail to allocate memory for buf desc\n"));
+		return -1;
+	}
+	memset(pBuf, 0x0, size);
+	pP->s.pRxBufDesc = pBuf;
+	pP->s.pTxBufDesc = pBuf + sizeof(bufferDescriptor) * LEN_QueRxDesc;
+
+	return 0;
+}
+
+#ifndef _PRTK_DUMP
+# define _dbg_ep93xxeth_dumpReg(pD)
+#else
+/*****************************************************************************
+* _dbg_ep93xxeth_dumpReg()
+*****************************************************************************/
+static void
+_dbg_ep93xxeth_dumpReg(struct net_device *pD)
+{
+	struct ep93xxEth_info  *pP = pD->priv;
+
+	_PRTK_DUMP(("Dumping registers of Ethernet Module Embedded within EP93xx\n"));
+	_PRTK_DUMP((" pD:0x%p, Base Address:0x%x\n", pD,
+		    (unsigned int)pD->base_addr));
+
+	_PRTK_DUMP((" RxCTL:0x%08x  TxCTL:0x%08x  TestCTL:0x%08x\n",
+		    (unsigned int)RegRd32(REG_RxCTL),
+		    (unsigned int)RegRd32(REG_TxCTL),
+		    (unsigned int)RegRd32(REG_TestCTL)));
+	_PRTK_DUMP((" SelfCTL:0x%08x  IntEn:0x%08x  IntStsP:0x%08x\n",
+		    (unsigned int)RegRd32(REG_SelfCTL),
+		    (unsigned int)RegRd32(REG_IntEn),
+		    (unsigned int)RegRd32(REG_IntStsP)));
+	_PRTK_DUMP((" GT:0x%08x  FCT:0x%08x  FCF:0x%08x\n",
+		    (unsigned int)RegRd32(REG_GT),
+		    (unsigned int)RegRd32(REG_FCT),
+		    (unsigned int)RegRd32(REG_FCF)));
+	_PRTK_DUMP((" AFP:0x%08x\n", (unsigned int)RegRd32(REG_AFP)));
+	_PRTK_DUMP((" TxCollCnt:0x%08x  RxMissCnt:0x%08x  RxRntCnt:0x%08x\n",
+		    (unsigned int)RegRd32(REG_TxCollCnt),
+		    (unsigned int)RegRd32(REG_RxMissCnt),
+		    (unsigned int)RegRd32(REG_RxRntCnt)));
+	_PRTK_DUMP((" BMCtl:0x%08x  BMSts:0x%08x\n",
+		    (unsigned int)RegRd32(REG_BMCtl),
+		    (unsigned int)RegRd32(REG_BMSts)));
+	_PRTK_DUMP((" RBCA:0x%08x  TBCA:0x%08x\n",
+		    (unsigned int)RegRd32(REG_RBCA),
+		    (unsigned int)RegRd32(REG_TBCA)));
+	_PRTK_DUMP((" RxDBA:0x%08x  RxDBL/CL:0x%08x  RxDCA:0x%08x\n",
+		    (unsigned int)RegRd32(REG_RxDBA),
+		    (unsigned int)RegRd32(REG_RxDBL),
+		    (unsigned int)RegRd32(REG_RxDCA)));
+	_PRTK_DUMP((" RxSBA:0x%08x  RxSBL/CL:0x%08x  RxSCA:0x%08x\n",
+		    (unsigned int)RegRd32(REG_RxSBA),
+		    (unsigned int)RegRd32(REG_RxSBL),
+		    (unsigned int)RegRd32(REG_RxSCA)));
+	_PRTK_DUMP((" RxDEQ:0x%08x  RxSEQ:0x%08x\n",
+		    (unsigned int)RegRd32(REG_RxDEQ),
+		    (unsigned int)RegRd32(REG_RxSEQ)));
+	_PRTK_DUMP((" TxDBA:0x%08x  TxDBL/CL:0x%08x  TxDCA:0x%08x\n",
+		    (unsigned int)RegRd32(REG_TxDBA),
+		    (unsigned int)RegRd32(REG_TxDBL),
+		    (unsigned int)RegRd32(REG_TxDCA)));
+	_PRTK_DUMP((" TxSBA:0x%08x  TxSBL/CL:0x%08x  TxSCA:0x%08x\n",
+		    (unsigned int)RegRd32(REG_TxSBA),
+		    (unsigned int)RegRd32(REG_TxSBL),
+		    (unsigned int)RegRd32(REG_TxSCA)));
+	_PRTK_DUMP((" TxDEQ:0x%08x\n",(unsigned int)RegRd32(REG_TxDEQ)));
+	_PRTK_DUMP((" RxBTH:0x%08x  TxBTH:0x%08x  RxSTH:0x%08x\n",
+		    (unsigned int)RegRd32(REG_RxBTH),
+		    (unsigned int)RegRd32(REG_TxBTH),
+		    (unsigned int)RegRd32(REG_RxSTH)));
+	_PRTK_DUMP((" TxSTH:0x%08x  RxDTH:0x%08x  TxDTH:0x%08x\n",
+		    (unsigned int)RegRd32(REG_TxSTH),
+		    (unsigned int)RegRd32(REG_RxDTH),
+		    (unsigned int)RegRd32(REG_TxDTH)));
+	_PRTK_DUMP((" MaxFL:0x%08x  RxHL:0x%08x\n",
+		    (unsigned int)RegRd32(REG_MaxFL),
+		    (unsigned int)RegRd32(REG_RxHL)));
+	_PRTK_DUMP((" MACCFG0-3:0x%08x 0x%08x 0x%08x 0x%08x\n",
+		    (unsigned int)RegRd32(REG_MACCFG0),
+		    (unsigned int)RegRd32(REG_MACCFG1),
+		    (unsigned int)RegRd32(REG_MACCFG2),
+		    (unsigned int)RegRd32(REG_MACCFG3)));
+
+	/*
+	_PRTK_DUMP((" ---INT Controller Reg---\n"));
+	_PRTK_DUMP((" RawIrqSts :0x%08x 0x%08x\n", _RegRd(U32,0x80800004),
+		    _RegRd(U32,0x80800018)));
+	_PRTK_DUMP((" IrqMask   :0x%08x 0x%08x\n", _RegRd(U32,0x80800008),
+		    _RegRd(U32,0x8080001c)));
+	_PRTK_DUMP((" MaskIrqSts:0x%08x 0x%08x\n", _RegRd(U32,0x80800000),
+		    _RegRd(U32,0x80800014)));
+	*/
+
+
+	_PRTK_DUMP(("Dumping private data:\n"));
+	_PRTK_DUMP((" d.txStopped:%d  d.idxQueTxSts:%d  d.idxQueTxDescHead:%d  d.idxQueTxDescTail:%d\n",
+		    pP->d.txStopped, pP->d.idxQueTxSts, pP->d.idxQueTxDescHead,
+		    pP->d.idxQueTxDescTail));
+	_PRTK_DUMP((" d.idxQueRxDesc:%d  d.idxQueRxSts:%d\n",
+		    pP->d.idxQueRxDesc, pP->d.idxQueRxSts));
+}
+#endif
+
+#define CRC_PRIME 0xFFFFFFFF
+#define CRC_POLYNOMIAL 0x04C11DB6
+/*****************************************************************************
+* calculate_hash_index()
+*****************************************************************************/
+static unsigned char
+calculate_hash_index(char *pMulticastAddr)
+{
+	unsigned long CRC;
+	unsigned char HashIndex;
+	unsigned char AddrByte;
+	unsigned char *pC;
+	unsigned long HighBit;
+	int Byte;
+	int Bit;
+
+	CRC = CRC_PRIME;
+	pC = pMulticastAddr;
+
+	for (Byte = 0; Byte < 6; Byte++) {
+		AddrByte = *pC;
+		pC++;
+
+		for (Bit = 8; Bit > 0; Bit--)
+		{
+			HighBit = CRC >> 31;
+			CRC <<= 1;
+
+			if (HighBit ^ (AddrByte & 1))
+			{
+				CRC ^= CRC_POLYNOMIAL;
+				CRC |= 1;
+			}
+
+			AddrByte >>= 1;
+		}
+	}
+
+	for (Bit = 0, HashIndex = 0; Bit < 6; Bit++)
+	{
+		HashIndex <<= 1;
+		HashIndex |= (unsigned char)(CRC & 1);
+		CRC >>= 1;
+	}
+
+	return HashIndex;
+}
+
+/*****************************************************************************
+* eth_setMulticastTbl()
+*****************************************************************************/
+static void
+eth_setMulticastTbl(struct net_device *pD, U8 *pBuf)
+{
+	int i;
+	unsigned char position;
+	struct dev_mc_list *cur_addr;
+
+	memset(pBuf, 0x00, 8);
+
+	cur_addr = pD->mc_list;
+	for (i = 0; i < pD->mc_count; i++, cur_addr = cur_addr->next) {
+		if (!cur_addr)
+			break;
+		if (!(*cur_addr->dmi_addr & 1))
+			continue;
+		position = calculate_hash_index(cur_addr->dmi_addr);
+		pBuf[position >> 3] |= 1 << (position & 0x07);
+	}
+}
+
+/*****************************************************************************
+* eth_indAddrWr()
+*****************************************************************************/
+static int
+eth_indAddrWr(struct net_device *pD, int afp, char *pBuf)
+{
+	U32 rxctl;
+	int i, len;
+
+	afp &= 0x07;
+	if (afp == 4 || afp == 5) {
+		_PRTK_SWERR(("eth_indAddrWr(): invalid afp value\n"));
+		return -1;
+	}
+	len = (afp == AFP_AFP_HASH) ? 8 : 6;
+
+	rxctl = RegRd32(REG_RxCTL);
+	RegWr32(REG_RxCTL, ~RxCTL_SRxON & rxctl);
+	RegWr32(REG_AFP, afp);
+	for (i = 0; i < len; i++)
+		RegWr8(REG_IndAD + i, pBuf[i]);
+	RegWr32(REG_RxCTL, rxctl);
+
+	return 0;
+}
+
+/*****************************************************************************
+* eth_indAddrRd()
+*****************************************************************************/
+#if 0
+static int
+eth_indAddrRd(struct net_device *pD, int afp, char *pBuf)
+{
+	int i, len;
+
+	afp &= 0x07;
+	if (afp == 4 || afp == 5) {
+		_PRTK_SWERR(("eth_indAddrRd(): invalid afp value\n"));
+		return -1;
+	}
+
+	RegWr32(REG_AFP, afp);
+	len = (afp == AFP_AFP_HASH) ? 8 : 6;
+	for (i = 0; i < len; i++)
+		pBuf[i] = RegRd8(REG_IndAD + i);
+
+	return 0;
+}
+#endif
+
+/*****************************************************************************
+* eth_rxCtl()
+*****************************************************************************/
+static int
+eth_rxCtl(struct net_device *pD, int sw)
+{
+	/*
+	 * Workaround for MAC lost 60-byte-long frames: must enable
+	 * Runt_CRC_Accept bit
+	 */
+	RegWr32(REG_RxCTL,
+		sw ? RegRd32(REG_RxCTL) | RxCTL_SRxON | RxCTL_RCRCA :
+		RegRd32(REG_RxCTL) & ~RxCTL_SRxON);
+
+	return 0;
+}
+
+/*****************************************************************************
+* eth_chkTxLvl()
+*****************************************************************************/
+static void
+eth_chkTxLvl(struct net_device *pD)
+{
+	struct ep93xxEth_info *pP = pD->priv;
+	int idxQTxDescHd;
+	int filled;
+
+	idxQTxDescHd = pP->d.idxQueTxDescHead;
+
+	filled = idxQTxDescHd - pP->d.idxQueTxDescTail;
+	if (filled < 0)
+		filled += LEN_QueTxDesc;
+
+	if (pP->d.txStopped && filled <= (LVL_TxResume + 1)) {
+		pP->d.txStopped = 0;
+		pD->trans_start = jiffies;
+		netif_wake_queue(pD);
+	}
+}
+
+/*****************************************************************************
+* eth_cleanUpTx()
+*****************************************************************************/
+static int
+eth_cleanUpTx(struct net_device *pD)
+{
+	struct ep93xxEth_info *pP = pD->priv;
+	transmitStatus *pQTxSts;
+	int idxSts, bi;
+
+	while (pP->s.pQueTxSts[pP->d.idxQueTxSts].f.txfp) {
+		idxSts = pP->d.idxQueTxSts;
+
+		pP->d.idxQueTxSts = IdxNext(pP->d.idxQueTxSts,LEN_QueTxSts);
+		pQTxSts = &pP->s.pQueTxSts[idxSts];
+		if (!pQTxSts->f.txfp) {
+			_PRTK_HWFAIL(("eth_cleanUpTx(): QueTxSts[%d]:x%08x is empty\n",
+				      idxSts, (int)pQTxSts->w.e0));
+			return -1;
+		}
+
+		pQTxSts->f.txfp = 0;
+
+		bi = pQTxSts->f.bi;
+#if 0
+		if (pP->d.idxQueTxDescTail != bi) {
+			_PRTK_HWFAIL(("eth_cleanUpTx(): unmatching QTxSts[%d].BI:%d idxQTxDTail:%d\n",
+				      idxSts,bi, pP->d.idxQueTxDescTail));
+		}
+#endif
+
+		if (pP->s.pTxBufDesc[bi].pFreeRtn) {
+			(*pP->s.pTxBufDesc[bi].pFreeRtn)(pP->s.pTxBufDesc[bi].vaddr);
+			pP->s.pTxBufDesc[bi].pFreeRtn = 0;
+		}
+
+		if (pQTxSts->f.txwe) {
+			pP->d.stats.tx_packets++;
+		} else {
+			pP->d.stats.tx_errors++;
+			if (pQTxSts->f.lcrs)
+				pP->d.stats.tx_carrier_errors++;
+			if(pQTxSts->f.txu)
+				pP->d.stats.tx_fifo_errors++;
+			if(pQTxSts->f.ecoll)
+				pP->d.stats.collisions++;
+		}
+
+		pP->d.idxQueTxDescTail = IdxNext(pP->d.idxQueTxDescTail,
+						 LEN_QueTxDesc);
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+* eth_restartTx()
+*****************************************************************************/
+static int
+eth_restartTx(struct net_device *pD)
+{
+	struct ep93xxEth_info *pP = pD->priv;
+	int i;
+
+	RegWr32(REG_GIntMsk, RegRd32(REG_GIntMsk) & ~GIntMsk_IntEn);
+
+	RegWr32(REG_TxCTL, RegRd32(REG_TxCTL) & ~TxCTL_STxON);
+	RegWr32(REG_BMCtl, RegRd32(REG_BMCtl) | BMCtl_TxDis);
+
+	RegWr32(REG_BMCtl, BMCtl_TxChR | RegRd32(REG_BMCtl));
+
+	for (i = 0; i < LEN_QueTxDesc; i++) {
+		if (pP->s.pTxBufDesc[i].pFreeRtn) {
+			pP->s.pTxBufDesc[i].pFreeRtn(pP->s.pTxBufDesc[i].vaddr);
+			pP->s.pTxBufDesc[i].pFreeRtn = 0;
+		}
+		pP->d.stats.tx_dropped++;
+	}
+
+	memset(pP->s.pQueTxSts, 0, sizeof(pP->s.pQueTxSts[0]) * LEN_QueTxSts);
+
+	pP->d.txStopped = 0;
+	pP->d.idxQueTxSts = pP->d.idxQueTxDescHead = pP->d.idxQueTxDescTail =
+		0;
+
+	waitOnReg32(pD, REG_BMSts, BMCtl_TxChR, ~BMCtl_TxChR, 1);
+	RegWr32(REG_TxSBA, pP->s.phyQueTxSts);
+	RegWr32(REG_TxSCA, pP->s.phyQueTxSts);
+	RegWr16(REG_TxSBL, sizeof(pP->s.pQueTxSts[0]) * LEN_QueTxSts);
+	RegWr16(REG_TxSCL, sizeof(pP->s.pQueTxSts[0]) * LEN_QueTxSts);
+	RegWr32(REG_TxDBA, pP->s.phyQueTxDesc);
+	RegWr32(REG_TxDCA, pP->s.phyQueTxDesc);
+	RegWr16(REG_TxDBL, sizeof(pP->s.pQueTxDesc[0]) * LEN_QueTxDesc);
+	RegWr16(REG_TxDCL, sizeof(pP->s.pQueTxDesc[0]) * LEN_QueTxDesc);
+
+	RegWr32(REG_TxCTL, RegRd32(REG_TxCTL) | TxCTL_STxON);
+	RegWr32(REG_BMCtl, RegRd32(REG_BMCtl) | BMCtl_TxEn);
+
+	RegWr32(REG_GIntMsk, RegRd32(REG_GIntMsk) | GIntMsk_IntEn);
+
+	return 0;
+}
+
+/*****************************************************************************
+* eth_reset()
+*****************************************************************************/
+static int
+eth_reset(struct net_device *pD)
+{
+	int err;
+
+	RegWr8(REG_SelfCTL, SelfCTL_RESET);
+	err = waitOnReg32(pD, REG_SelfCTL, SelfCTL_RESET, ~SelfCTL_RESET, 1);
+	if (err)
+		_PRTK_WARN(("eth_reset(): Soft Reset does not self-clear\n"));
+
+	//phy_reset(pD);
+
+	return 0;
+}
+
+/*****************************************************************************
+ . Function: eth_shutDown()
+ . Purpose:  closes down the Ethernet module
+ . Make sure to:
+ .	1. disable all interrupt mask
+ .	2. disable Rx
+ .	3. disable Tx
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.   Empirical results do not show this working.
+*
+*****************************************************************************/
+static int
+eth_shutDown(struct net_device *pD)
+{
+	eth_reset(pD);
+
+	return 0;
+}
+
+/*****************************************************************************
+*  eth_enable()
+
+  Purpose:
+        Turn on device interrupt for interrupt driven operation.
+        Also turn on Rx but no Tx.
+*
+*****************************************************************************/
+static int
+eth_enable(struct net_device *pD)
+{
+	RegWr32(REG_IntEn, Default_IntSrc);
+	RegWr32(REG_GIntMsk, GIntMsk_IntEn);
+	eth_rxCtl(pD, 1);
+
+	return 0;
+}
+
+/*****************************************************************************
+*  eth_init()
+
+  Purpose:
+        Reset and initialize the device.
+        Device should be initialized enough to function in polling mode.
+        Tx and Rx must be disabled and no INT generation.
+*
+*****************************************************************************/
+static int
+eth_init(struct net_device *pD)
+{
+	int status;
+
+	eth_reset(pD);
+
+	gPhyAutoNegoDone = 0;
+	status = phy_init(pD);
+	if (status != 0)
+		printk(KERN_WARNING "%s: No network cable detected!\n", pD->name);
+
+	RegWr32(REG_SelfCTL, 0x0f00);
+	RegWr32(REG_GIntMsk, 0x00);
+	RegWr32(REG_RxCTL, RxCTL_BA | RxCTL_IA0);
+	RegWr32(REG_TxCTL, 0x00);
+	RegWr32(REG_GT, 0x00);
+	RegWr32(REG_BMCtl, 0x00);
+	RegWr32(REG_RxBTH, (0x80 << 16) | (0x40 << 0));
+	RegWr32(REG_TxBTH, (0x80 << 16) | (0x40 << 0));
+	RegWr32(REG_RxSTH, (4 << 16) | (2 << 0));
+	RegWr32(REG_TxSTH, (4 << 16) | (2 << 0));
+	RegWr32(REG_RxDTH, (4 << 16) | (2 << 0));
+	RegWr32(REG_TxDTH, (4 << 16) | (2 << 0));
+	RegWr32(REG_MaxFL, ((1518 + 1) << 16) | (944 << 0));
+
+	RegRd32(REG_TxCollCnt);
+	RegRd32(REG_RxMissCnt);
+	RegRd32(REG_RxRntCnt);
+
+	RegRd32(REG_IntStsC);
+
+	RegWr32(REG_TxCTL, TxCTL_STxON | RegRd32(REG_TxCTL));
+
+	eth_indAddrWr(pD, AFP_AFP_IA0, &pD->dev_addr[0]);
+
+	devQue_start(pD);
+
+	return 0;
+}
+
+/*****************************************************************************
+* eth_isrRx()
+*
+*  Interrupt Service Routines
+*
+*****************************************************************************/
+static int
+eth_isrRx(struct net_device *pD)
+{
+	ep93xxEth_info *pP = pD->priv;
+	receiveStatus *pQRxSts;
+	int idxQRxStsHead;
+	int idxSts;
+	int cntStsProcessed, cntDescProcessed;
+	char *pDest;
+	struct sk_buff *pSkb;
+	int len;
+	UINT dt;
+
+	dt = RegRd32(REG_RxSCA);
+	idxQRxStsHead = (dt - pP->s.phyQueRxSts) / sizeof(pP->s.pQueRxSts[0]);
+	if (!(idxQRxStsHead >= 0 && idxQRxStsHead < LEN_QueRxSts)) {
+		_PRTK_HWFAIL(("eth_isrRx(): invalid REG_RxSCA:0x%x idx:%d (phyQueRxSts:0x%x Len:%x)\n",
+			      dt,idxQRxStsHead, (int)pP->s.phyQueRxSts,
+			      LEN_QueRxSts));
+		return -1;
+	}
+
+	cntStsProcessed = cntDescProcessed = 0;
+	while (idxQRxStsHead != pP->d.idxQueRxSts) {
+		idxSts = pP->d.idxQueRxSts;
+		pP->d.idxQueRxSts = IdxNext(pP->d.idxQueRxSts, LEN_QueRxSts);
+		pQRxSts = &pP->s.pQueRxSts[idxSts];
+		if (!pQRxSts->f.rfp) {
+			_PRTK_HWFAIL(("eth_isrRx(): QueRxSts[%d] is empty; Hd:%d\n",
+				      idxSts,idxQRxStsHead));
+			return -1;
+		}
+		pQRxSts->f.rfp = 0;
+
+		if(pQRxSts->f.eob) {
+			if(pQRxSts->f.bi == pP->d.idxQueRxDesc) {
+				pP->d.idxQueRxDesc =
+					IdxNext(pP->d.idxQueRxDesc,
+						LEN_QueRxDesc);
+				cntDescProcessed++;
+				if (pQRxSts->f.eof && pQRxSts->f.rwe) {
+					len = pQRxSts->f.fl;
+					pSkb = dev_alloc_skb(len + 5);
+					if (pSkb != NULL) {
+						skb_reserve(pSkb, 2);
+						pSkb->dev = pD;
+						pDest = skb_put(pSkb, len);
+
+						memcpy(pDest,
+						       pP->s.pRxBufDesc[pQRxSts->f.bi].vaddr,
+						       len);
+						pSkb->protocol =
+							eth_type_trans(pSkb,
+								       pD);
+						netif_rx(pSkb);
+						pP->d.stats.rx_packets++;
+						if(pQRxSts->f.am == 3)
+							pP->d.stats.multicast++;
+					} else
+						_PRTK_SYSFAIL(("eth_isrRx(): Low Memory, Rx dropped\n"));
+						pP->d.stats.rx_dropped++;
+				} else {
+					pP->d.stats.rx_errors++;
+					if (pQRxSts->f.oe)
+						pP->d.stats.rx_fifo_errors++;
+					if (pQRxSts->f.fe)
+						pP->d.stats.rx_frame_errors++;
+					if (pQRxSts->f.runt ||
+					    pQRxSts->f.edata)
+						pP->d.stats.rx_length_errors++;
+					if (pQRxSts->f.crce)
+						pP->d.stats.rx_crc_errors++;
+				}
+			} else
+				_PRTK_HWFAIL(("eth_isrRx(): unmatching QueRxSts[%d].BI:0x%x; idxQueRxDesc:0x%x\n",
+					      idxSts, pQRxSts->f.bi,
+					      pP->d.idxQueRxDesc));
+		}
+
+		cntStsProcessed++;
+	}
+
+	RegWr32(REG_RxSEQ, cntStsProcessed);
+	RegWr32(REG_RxDEQ, cntDescProcessed);
+
+	return 0;
+}
+
+/*****************************************************************************
+* eth_isrTx()
+*****************************************************************************/
+static int
+eth_isrTx(struct net_device *pD)
+{
+	eth_cleanUpTx(pD);
+	eth_chkTxLvl(pD);
+	return 0;
+}
+
+/*****************************************************************************
+* ep93xxEth_isr()
+*****************************************************************************/
+static irqreturn_t
+ep93xxEth_isr(int irq,void *pDev,struct pt_regs *pRegs)
+{
+	struct net_device *pD = pDev;
+	int lpCnt;
+	U32 intS;
+
+	lpCnt = 0;
+	do {
+		intS = RegRd32(REG_IntStsC);
+
+		if (!intS)
+			break;
+		if (intS & IntSts_RxSQ)
+			eth_isrRx(pD);
+		if (intS & IntSts_TxSQ)
+			eth_isrTx(pD);
+	} while (lpCnt++ < 64);
+
+	if (lpCnt)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+/*=========================================================
+ *  Exposed Driver Routines to the Outside World
+ *=======================================================*/
+
+/*****************************************************************************
+* ep93xxEth_getStats()
+*****************************************************************************/
+static struct net_device_stats *
+ep93xxEth_getStats(struct net_device *pD)
+{
+	return &((struct ep93xxEth_info *)pD->priv)->d.stats;
+}
+
+/*****************************************************************************
+* ep93xxEth_setMulticastList()
+*****************************************************************************/
+static void
+ep93xxEth_setMulticastList(struct net_device *pD)
+{
+	U8 tblMulti[8 + 1];
+
+	if (pD->flags & IFF_PROMISC)
+		RegWr32(REG_RxCTL, RxCTL_PA | RegRd32(REG_RxCTL));
+	else if(pD->flags & IFF_ALLMULTI) {
+		RegWr32(REG_RxCTL, RxCTL_MA |
+			(~RxCTL_PA & RegRd32(REG_RxCTL)));
+		eth_indAddrWr(pD, AFP_AFP_HASH,
+			      "\xff\xff\xff\xff\xff\xff\xff\xff");
+	} else if(pD->mc_count) {
+		RegWr32(REG_RxCTL, RxCTL_MA |
+			(~RxCTL_PA & RegRd32(REG_RxCTL)));
+		eth_setMulticastTbl(pD, &tblMulti[0]);
+		eth_indAddrWr(pD, AFP_AFP_HASH, &tblMulti[0]);
+	} else
+		RegWr32(REG_RxCTL,
+			~(RxCTL_PA | RxCTL_MA) & RegRd32(REG_RxCTL));
+}
+
+/*****************************************************************************
+* ep93xxEth_txTimeout()
+*****************************************************************************/
+static void
+ep93xxEth_txTimeout(struct net_device *pD)
+{
+	int status;
+
+	_PRTK_WARN(("ep93xxEth_txTimeout(): transmit timed out\n"));
+
+	if (gPhyAutoNegoDone == 0) {
+		status = phy_init(pD);
+		if (status != 0)
+		{
+			printk(KERN_WARNING "%s: No network cable detected!\n",
+			       pD->name);
+			return;
+		}
+	}
+
+	eth_restartTx(pD);
+
+	pD->trans_start = jiffies;
+	netif_wake_queue(pD);
+}
+
+/*****************************************************************************
+* ep93xxEth_hardStartXmit()
+*****************************************************************************/
+static int
+ep93xxEth_hardStartXmit(struct sk_buff *pSkb, struct net_device *pD)
+{
+	struct ep93xxEth_info *pP = pD->priv;
+	transmitDescriptor *pQTxDesc;
+	int idxQTxDescHd;
+	int filled;
+	int status;
+
+	if (gPhyAutoNegoDone == 0) {
+		status = phy_init(pD);
+		if (status != 0)
+		{
+			return 1;
+		}
+	}
+
+	idxQTxDescHd = pP->d.idxQueTxDescHead;
+	pQTxDesc = &pP->s.pQueTxDesc[idxQTxDescHd];
+
+	filled = idxQTxDescHd - pP->d.idxQueTxDescTail;
+	if (filled < 0)
+		filled += LEN_QueTxDesc;
+	filled += 1;
+
+	if(filled >= LVL_TxStop) {
+		netif_stop_queue(pD);
+		pP->d.txStopped = 1;
+		if(filled > LVL_TxStop) {
+			_PRTK_SYSFAIL(("ep93xxEth_hardStartXmit(): a Tx Request while stop\n"));
+			return 1;
+		}
+	}
+
+	if (pSkb->len < 60) {
+		pQTxDesc->f.bl = 60;
+		memset(pP->s.pTxBufDesc[idxQTxDescHd].vaddr, 0, 60);
+	} else
+		pQTxDesc->f.bl = pSkb->len;
+	pQTxDesc->f.ba = virt_to_bus(pP->s.pTxBufDesc[idxQTxDescHd].vaddr);
+	pQTxDesc->f.bi = idxQTxDescHd;
+	pQTxDesc->f.af = 0;
+	pQTxDesc->f.eof = 1;
+
+	memcpy(pP->s.pTxBufDesc[idxQTxDescHd].vaddr, pSkb->data, pSkb->len);
+	pP->s.pTxBufDesc[idxQTxDescHd].pFreeRtn = 0;
+
+	free_skb(pSkb);
+
+	pP->d.idxQueTxDescHead = IdxNext(pP->d.idxQueTxDescHead,
+					 LEN_QueTxDesc);
+	RegWr32(REG_TxDEQ, 1);
+
+	return 0;
+}
+
+/*****************************************************************************
+ . ep93xxEth_close()
+ .
+ . this makes the board clean up everything that it can
+ . and not talk to the outside world.   Caused by
+ . an 'ifconfig ethX down'
+ *
+*****************************************************************************/
+static int
+ep93xxEth_close(struct net_device *pD)
+{
+	netif_stop_queue(pD);
+	eth_shutDown(pD);
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+/*******************************************************
+ * ep93xxEth_open()
+ *
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc ..
+ *
+ ******************************************************/
+static int
+ep93xxEth_open(struct net_device *pD)
+{
+	int status;
+	struct ep93xxEth_info  *pP = pD->priv;
+
+	memset(&pP->d, 0, sizeof(pP->d));
+
+	MOD_INC_USE_COUNT;
+
+	status = eth_init(pD);
+	if (status != 0 )
+		return -EAGAIN;
+
+	eth_enable(pD);
+
+#if 0
+	_dbg_phy_dumpReg(pD);
+	_dbg_ep93xxeth_dumpReg(pD);
+	_dbg_ep93xxEth_dumpQueues(pD);
+#endif
+
+	netif_start_queue(pD);
+
+	return 0;
+}
+
+/*****************************************************************************
+ .
+ . ep93xxEth_probe( struct net_device * dev )
+ .   This is the first routine called to probe device existance
+ .   and initialize the driver if the device found.
+ .
+ .   Input parameters:
+ .	dev->base_addr == 0, try to find all possible locations
+ .	dev->base_addr == 1, return failure code
+ .	dev->base_addr == 2, always allocate space,  and return success
+ .	dev->base_addr == <anything else>   this is the address to check
+ .
+ .   Output:
+ .	0 --> there is a device
+ .	anything else, error
+
+*****************************************************************************/
+int __init
+ep93xxEth_probe(struct net_device *pD) {
+	struct ep93xxEth_info *pP;
+	int err;
+	int i;
+
+	if (pD->priv == 0) {
+		pD->priv = kmalloc(sizeof(struct ep93xxEth_info), GFP_KERNEL);
+		if(pD->priv == 0)
+			return -ENOMEM;
+	}
+	memset(pD->priv, 0x00, sizeof(struct ep93xxEth_info));
+
+	pP = pD->priv;
+	pP->s.id = numOfInstance;
+	pP->s.miiIdPhy = 1;
+
+	for (i = 0; i < 6; i++)
+		pD->dev_addr[i] = default_mac[i];
+	GET_MAC_ADDR(pD, pD->dev_addr);
+
+	err = (int)request_irq(pD->irq, &ep93xxEth_isr, 0, cardname, pD);
+	if(err) {
+		kfree(pD->priv);
+		return -EAGAIN;
+	}
+
+	pD->open               = &ep93xxEth_open;
+	pD->stop               = &ep93xxEth_close;
+	pD->hard_start_xmit    = &ep93xxEth_hardStartXmit;
+	pD->tx_timeout         = &ep93xxEth_txTimeout;
+	pD->watchdog_timeo     = HZ * 5;
+	pD->get_stats          = &ep93xxEth_getStats;
+	pD->set_multicast_list = &ep93xxEth_setMulticastList;
+
+	ether_setup(pD);
+
+	devQue_init(pD);
+	eth_reset(pD);
+
+	numOfInstance++;
+
+	err = register_netdev(pD);
+	if (err) {
+		free_irq(pD->irq, pD);
+		kfree(pP);
+		return err;
+	}
+
+	return 0;
+}
+
+static int
+ep93xxEth_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev;
+	struct resource *res;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	if (!request_mem_region(res->start, 0x10000, cardname))
+		return -EBUSY;
+
+	ndev = alloc_etherdev(sizeof(struct ep93xxEth_info));
+	if (!ndev) {
+		release_mem_region(res->start, 0x10000);
+		return -ENOMEM;
+	}
+
+	SET_MODULE_OWNER(ndev);
+	SET_NETDEV_DEV(ndev, dev);
+
+	ndev->base_addr = HwRegToVirt(res->start);
+	ndev->irq = platform_get_irq(pdev, 0);
+
+	dev_set_drvdata(dev, ndev);
+
+	ret = ep93xxEth_probe(ndev);
+	if (ret != 0) {
+		free_netdev(ndev);
+		release_mem_region(res->start, 0x10000);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int
+ep93xxEth_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct resource *res;
+
+	dev_set_drvdata(dev, NULL);
+
+	unregister_netdev(ndev);
+
+	free_irq(ndev->irq, ndev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, 0x10000);
+
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static struct device_driver ep93xxEth_driver = {
+	.name		= cardname,
+	.bus		= &platform_bus_type,
+	.probe		= ep93xxEth_drv_probe,
+	.remove		= ep93xxEth_drv_remove,
+};
+
+static int __init ep93xxEth_init(void)
+{
+	return driver_register(&ep93xxEth_driver);
+}
+
+static void __exit ep93xxEth_cleanup(void)
+{
+	driver_unregister(&ep93xxEth_driver);
+}
+
+module_init(ep93xxEth_init);
+module_exit(ep93xxEth_cleanup);
+
+MODULE_AUTHOR("Cirrus Logic");
+MODULE_DESCRIPTION("EP93xx ethernet driver");
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/drivers/net/ep93xx_eth.h linux-2.6.8.1/drivers/net/ep93xx_eth.h
--- linux-2.6.8.1-orig/drivers/net/ep93xx_eth.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/net/ep93xx_eth.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,402 @@
+/*------------------------------------------------------------------------
+ * ep93xx_eth.h
+ * : header file of Ethernet Device Driver for Cirrus Logic EP93xx.
+ *
+ * Copyright (C) 2003 by Cirrus Logic www.cirrus.com 
+ * This software may be used and distributed according to the terms
+ * of the GNU Public License.
+ *
+ * This file contains device related information like register info
+ * and register access method macros for the Ethernet device 
+ * embedded within Cirrus Logic's EP93xx SOC chip.  
+ *
+ * Information contained in this file was obtained from 
+ * the EP9312 Manual Revision 0.12 and 0.14 from Cirrus Logic.
+ *
+ * History
+ * 05/18/01  Sungwook Kim  Initial release
+ * 03/25/2003  Melody Modified for EP92xx
+ *--------------------------------------------------------------------------*/
+
+
+#ifndef _EP9213_ETH_H_
+#define _EP9213_ETH_H_
+
+
+/*---------------------------------------------------------------
+ *  Definition of H/W Defects and Their Workarounds
+ *-------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------
+ *  Data types used in this driver
+ *-------------------------------------------------------------*/
+typedef  unsigned char   U8;
+typedef  unsigned short  U16;
+typedef  unsigned long   U32;
+typedef  unsigned int    UINT;
+
+
+
+/*---------------------------------------------------------------
+ * Definition of the registers.
+ * For details, refer to the datasheet  .
+ * 
+ * Basically, most registers are 32 bits width register.
+ * But some are 16 bits and some are 6 or 8 bytes long.
+ *-------------------------------------------------------------*/
+
+#define  REG_RxCTL  0x0000  /*offset to Receiver Control Reg*/
+#define  RxCTL_PauseA  (1<<20)
+#define  RxCTL_RxFCE1  (1<<19)
+#define  RxCTL_RxFCE0  (1<<18)
+#define  RxCTL_BCRC    (1<<17)
+#define  RxCTL_SRxON   (1<<16)
+#define  RxCTL_RCRCA   (1<<13)
+#define  RxCTL_RA      (1<<12)
+#define  RxCTL_PA      (1<<11)
+#define  RxCTL_BA      (1<<10)
+#define  RxCTL_MA      (1<<9)
+#define  RxCTL_IAHA    (1<<8)
+#define  RxCTL_IA3     (1<<3)
+#define  RxCTL_IA2     (1<<2)
+#define  RxCTL_IA1     (1<<1)
+#define  RxCTL_IA0     (1<<0)
+
+#define  REG_TxCTL  0x0004  /*offset to Transmit Control Reg*/
+#define  TxCTL_DefDis  (1<<7)
+#define  TxCTL_MBE     (1<<6)
+#define  TxCTL_ICRC    (1<<5)
+#define  TxCTL_TxPD    (1<<5)
+#define  TxCTL_OColl   (1<<3)
+#define  TxCTL_SP      (1<<2)
+#define  TxCTL_PB      (1<<1)
+#define  TxCTL_STxON   (1<<0)
+
+#define  REG_TestCTL   0x0008  /*Test Control Reg, R/W*/
+#define  TestCTL_MACF  (1<<7)
+#define  TestCTL_MFDX  (1<<6)
+#define  TestCTL_DB    (1<<5)
+#define  TestCTL_MIIF  (1<<4)
+
+#define  REG_MIICmd  0x0010  /*offset to MII Command Reg, R/W*/
+#define  MIICmd_OP     (0x03<<14)
+#define  MIICmd_OP_RD  (2<<14)
+#define  MIICmd_OP_WR  (1<<14)
+#define  MIICmd_PHYAD  (0x1f<<5)
+#define  MIICmd_REGAD  (0x1f<<0)
+
+#define  REG_MIIData  0x0014  /*offset to MII Data Reg, R/W*/
+#define  MIIData_MIIData  (0xffff<<0)
+
+#define  REG_MIISts  0x0018  /*offset to MII Status Reg, R*/
+#define  MIISts_Busy  (1<<0)
+
+#define  REG_SelfCTL  0x0020  /*offset to Self Control Reg*/
+#define  SelfCTL_RWP    (1<<7)    /*Remote Wake Pin*/
+#define  SelfCTL_GPO0   (1<<5)
+#define  SelfCTL_PUWE   (1<<4)
+#define  SelfCTL_PDWE   (1<<3)
+#define  SelfCTL_MIIL   (1<<2)
+#define  SelfCTL_RESET  (1<<0)
+
+#define  REG_IntEn   0x0024  /*Interrupt Enable Reg, R/W*/
+#define  IntEn_RWIE    (1<<30)
+#define  IntEn_RxMIE   (1<<29)
+#define  IntEn_RxBIE   (1<<28)
+#define  IntEn_RxSQIE  (1<<27)
+#define  IntEn_TxLEIE  (1<<26)
+#define  IntEn_ECIE    (1<<25)
+#define  IntEn_TxUHIE  (1<<24)
+#define  IntEn_MOIE    (1<<18)
+#define  IntEn_TxCOIE  (1<<17)
+#define  IntEn_RxROIE  (1<<16)
+#define  IntEn_MIIIE   (1<<12)
+#define  IntEn_PHYSIE  (1<<11)
+#define  IntEn_TIE     (1<<10)
+#define  IntEn_SWIE    (1<<8)
+#define  IntEn_TxSQIE   (1<<3)
+#define  IntEn_RxEOFIE  (1<<2)
+#define  IntEn_RxEOBIE  (1<<1)
+#define  IntEn_RxHDRIE  (1<<0)
+
+#define  REG_IntStsP  0x0028  /*offset to Interrupt Status Preserve Reg, R/W*/
+#define  REG_IntStsC  0x002c  /*offset to Interrupt Status Clear Reg, R*/
+#define  IntSts_RWI    (1<<30)
+#define  IntSts_RxMI   (1<<29)
+#define  IntSts_RxBI   (1<<28)
+#define  IntSts_RxSQI  (1<<27)
+#define  IntSts_TxLEI  (1<<26)
+#define  IntSts_ECI    (1<<25)
+#define  IntSts_TxUHI  (1<<24)
+#define  IntSts_MOI    (1<<18)
+#define  IntSts_TxCOI  (1<<17)
+#define  IntSts_RxROI  (1<<16)
+#define  IntSts_MIII   (1<<12)
+#define  IntSts_PHYSI  (1<<11)
+#define  IntSts_TI     (1<<10)
+#define  IntSts_AHBE   (1<<9)
+#define  IntSts_SWI    (1<<8)
+#define  IntSts_OTHER  (1<<4)
+#define  IntSts_TxSQ   (1<<3)
+#define  IntSts_RxSQ   (1<<2)
+
+#define  REG_GT  0x0040  /*offset to General Timer Reg*/
+#define  GT_GTC  (0xffff<<16)
+#define  GT_GTP  (0xffff<<0)
+
+#define  REG_FCT  0x0044  /*offset to Flow Control Timer Reg*/
+#define  FCT_FCT  (0x00ffffff<<0)
+
+#define  REG_FCF  0x0048  /*offset to Flow Control Format Reg*/
+#define  FCF_MACCT  (0xffff<<16)
+#define  FCF_TPT    (0xffff<<0)
+
+#define  REG_AFP  0x004c  /*offset to Address Filter Pointer Reg*/
+#define  AFP_AFP  (0x07<<0)  /*Address Filter Pointer (bank control for REG_IndAD)*/
+#define  AFP_AFP_IA0   0       /*Primary Individual Address (MAC Addr)*/
+#define  AFP_AFP_IA1   1       /*Individual Address 1*/
+#define  AFP_AFP_IA2   2       /*Individual Address 2*/
+#define  AFP_AFP_IA3   3       /*Individual Address 3*/
+#define  AFP_AFP_DTxP  6       /*Destination Address of Tx Pause Frame*/
+#define  AFP_AFP_HASH  7       /*Hash Table*/
+
+#define  REG_IndAD      0x0050  /*offset to Individual Address Reg, n bytes, R/W*/
+
+#define  REG_GIntSts    0x0060  /*offset to Global Interrupt Status Reg (writing 1 will clear)*/
+#define  REG_GIntROS    0x0068  /*offset to Global Interrupt Status Read Only Reg*/
+#define  GIntSts_INT  (1<<15)     /*Global Interrupt Request Status*/
+
+#define  REG_GIntMsk    0x0064  /*offset to Global Interrupt Mask Reg*/
+#define  GIntMsk_IntEn  (1<<15)   /*Global Interrupt Enable*/
+
+#define  REG_GIntFrc    0x006c  /*offset to Global Interrupt Force Reg*/
+#define  GIntFrc_INT  (1<<15)     /*Force to set GIntSts*/
+
+#define  REG_TxCollCnt  0x0070  /*Transmit Collision Count Reg, R*/
+#define  REG_RxMissCnt  0x0074  /*Receive Miss Count Reg, R*/
+#define  REG_RxRntCnt   0x0078  /*Receive Runt Count Reg, R*/
+
+#define  REG_BMCtl  0x0080  /*offset to Bus Master Control Reg, R/W*/
+#define  BMCtl_MT     (1<<13)
+#define  BMCtl_TT     (1<<12)
+#define  BMCtl_UnH    (1<<11)
+#define  BMCtl_TxChR  (1<<10)
+#define  BMCtl_TxDis  (1<<9)
+#define  BMCtl_TxEn   (1<<8)
+#define  BMCtl_EH2    (1<<6)
+#define  BMCtl_EH1    (1<<5)
+#define  BMCtl_EEOB   (1<<4)
+#define  BMCtl_RxChR  (1<<2)
+#define  BMCtl_RxDis  (1<<1)
+#define  BMCtl_RxEn   (1<<0)
+
+#define  REG_BMSts  0x0084  /*offset to Bus Master Status Reg, R*/
+#define  BMSts_TxAct  (1<<7)
+#define  BMSts_TP     (1<<4)
+#define  BMSts_RxAct  (1<<3)
+#define  BMSts_QID    (0x07<<0)
+#define  BMSts_QID_RxDt   (0<<0)
+#define  BMSts_QID_TxDt   (1<<0)
+#define  BMSts_QID_RxSts  (2<<0)
+#define  BMSts_QID_TxSts  (3<<0)
+#define  BMSts_QID_RxDesc (4<<0)
+#define  BMSts_QID_TxDesc (5<<0)
+
+#define  REG_RBCA   0x0088  /*offset to Receive Buffer Current Address Reg, R*/
+#define  REG_TBCA   0x008c  /*offset to Transmit Buffer Current Address Reg, R*/
+
+#define  REG_RxDBA  0x0090  /*offset to Receive Descriptor Queue Base Address Reg, R/W*/
+#define  REG_RxDBL  0x0094  /*offset to Receive Descriptor Queue Base Length Reg, R/W, 16bits*/
+#define  REG_RxDCL  0x0096  /*offset to Receive Descriptor Queue Current Length Reg, R/W, 16bits*/
+#define  REG_RxDCA  0x0098  /*offset to Receive Descriptor Queue Current Address Reg, R/W*/
+
+#define  REG_RxDEQ  0x009c  /*offset to Receive Descriptor Enqueue Reg, R/W*/
+#define  RxDEQ_RDV  (0xffff<<16)  /*R 16bit; Receive Descriptor Value*/
+#define  RxDEQ_RDI  (0xff<<0)     /*W 8bit; Receive Descriptor Increment*/
+
+#define  REG_RxSBA  0x00a0  /*offset to Receive Status Queue Base Address Reg, R/W*/
+#define  REG_RxSBL  0x00a4  /*offset to Receive Status Queue Base Length Reg, R/W, 16bits*/
+#define  REG_RxSCL  0x00a6  /*offset to Receive Status Queue Current Length Reg, R/W, 16bits*/
+#define  REG_RxSCA  0x00a8  /*offset to Receive Status Queue Current Address Reg, R/W*/
+
+#define  REG_RxSEQ  0x00ac  /*offset to Receive Status Queue Current Address Reg, R/W*/
+#define  RxSEQ_RSV  (0xffff<<16)
+#define  RxSEQ_RSI  (0xff<<0)
+
+#define  REG_TxDBA  0x00b0  /*offset to Transmit Descriptor Queue Base Address Reg, R/W*/
+#define  REG_TxDBL  0x00b4  /*offset to Transmit Descriptor Queue Base Length Reg, R/W, 16bits*/
+#define  REG_TxDCL  0x00b6  /*offset to Transmit Descriptor Queue Current Length Reg, R/W, 16bits*/
+#define  REG_TxDCA  0x00b8  /*offset to Transmit Descriptor Queue Current Address Reg, R/W*/
+
+#define  REG_TxDEQ  0x00bc  /*offset to Transmit Descriptor Queue Current Address Reg, R/W*/
+#define  TxDEQ_TDV  (0xffff<<16)
+#define  TxDEQ_TDI  (0xff<<0)
+
+#define  REG_TxSBA  0x00c0  /*offset to Transmit Status Queue Base Address Reg, R/W*/
+#define  REG_TxSBL  0x00c4  /*offset to Transmit Status Queue Base Length Reg, R/W, 16bits*/
+#define  REG_TxSCL  0x00c6  /*offset to Transmit Status Queue Current Length Reg, R/W, 16bits*/
+#define  REG_TxSCA  0x00c8  /*offset to Transmit Status Queue Current Address Reg, R/W*/
+
+#define  REG_RxBTH  0x00d0  /*offset to Receive Buffer Threshold Reg, R/W*/
+#define  RxBTH_RDHT  (0x03ff<<16)
+#define  RxBTH_RDST  (0x03ff<<0)
+
+#define  REG_TxBTH  0x00d4  /*offset to Transmit Buffer Threshold Reg, R/W*/
+#define  TxBTH_TDHT  (0x03ff<<16)
+#define  TxBTH_TDST  (0x03ff<<0)
+
+#define  REG_RxSTH  0x00d8  /*offset to Receive Status Threshold Reg, R/W*/
+#define  RxSTH_RSHT  (0x003f<<16)
+#define  RxSTH_RSST  (0x003f<<0)
+
+#define  REG_TxSTH  0x00dc  /*offset to Transmit Status Threshold Reg, R/W*/
+#define  TxSTH_TSHT  (0x003f<<16)
+#define  TxSTH_TSST  (0x003f<<0)
+
+#define  REG_RxDTH  0x00e0  /*offset to Receive Descriptor Threshold Reg, R/W*/
+#define  RxDTH_RDHT  (0x003f<<16)
+#define  RxDTH_RDST  (0x003f<<0)
+
+#define  REG_TxDTH  0x00e4  /*offset to Transmit Descriptor Threshold Reg, R/W*/
+#define  TxDTH_TDHT  (0x003f<<16)
+#define  TxDTH_TDST  (0x003f<<0)
+
+#define  REG_MaxFL  0x00e8  /*offset to Max Frame Length Reg, R/W*/
+#define  MaxFL_MFL  (0x07ff<<16)
+#define  MaxFL_TST  (0x07ff<<0)
+
+#define  REG_RxHL  0x00ec  /*offset to Receive Header Length Reg, R/W*/
+#define  RxHL_RHL2  (0x07ff<<16)
+#define  RxHL_RHL1  (0x03ff<<0)
+
+#define  REG_MACCFG0  0x0100  /*offset to Test Reg #0, R/W*/
+#define  MACCFG0_DbgSel  (1<<7)
+#define  MACCFG0_LCKEN   (1<<6)
+#define  MACCFG0_LRATE   (1<<5)
+#define  MACCFG0_RXERR   (1<<4)
+#define  MACCFG0_BIT33   (1<<2)
+#define  MACCFG0_PMEEN   (1<<1)
+#define  MACCFG0_PMEST   (1<<0)
+
+#define  REG_MACCFG1  0x0104  /*offset to Test Reg #1, R/W*/
+#define  REG_MACCFG2  0x0108  /*offset to Test Reg #2, R*/
+#define  REG_MACCFG3  0x010c  /*offset to Test Reg #3, R*/
+
+
+
+/*---------------------------------------------------------------
+ * Definition of Descriptor/Status Queue Entry
+ *-------------------------------------------------------------*/
+
+typedef  union receiveDescriptor  {  /*data structure of Receive Descriptor Queue Entry*/
+    struct {        /*whole value*/
+        U32  e0,      /*1st dword entry*/
+             e1;      /*2nd dword entry*/
+    }  w;
+    struct {        /*bit field definitions*/
+        U32  ba:32,   /*Buffer Address (keep in mind this is physical address)*/
+             bl:16,   /*b15-0; Buffer Length*/
+             bi:15,   /*b30-16; Buffer Index*/
+             nsof:1;  /*b31; Not Start Of Frame*/
+    }  f;
+}  receiveDescriptor;
+
+
+typedef  union receiveStatus  {  /*data structure of Receive Status Queue Entry*/
+    struct {         /*whole word*/
+        U32  e0,       /*1st dword entry*/
+             e1;       /*2nd dword entry*/
+    }  w;
+    struct {         /*bit field*/
+        U32  rsrv1:8,  /*b7-0: reserved*/
+             hti:6,    /*b13-8: Hash Table Index*/
+             rsrv2:1,  /*b14: reserved*/
+             crci:1,   /*b15: CRC Included*/
+             crce:1,   /*b16: CRC Error*/
+             edata:1,  /*b17: Extra Data*/
+             runt:1,   /*b18: Runt Frame*/
+             fe:1,     /*b19: Framing Error*/
+             oe:1,     /*b20: Overrun Error*/
+             rxerr:1,  /*b21: Rx Error*/
+             am:2,     /*b23-22: Address Match*/
+             rsrv3:4,  /*b27-24: reserved*/
+             eob:1,    /*b28: End Of Buffer*/
+             eof:1,    /*b29: End Of Frame*/
+             rwe:1,    /*b30: Received Without Error*/
+             rfp:1,    /*b31: Receive Frame Processed*/
+             fl:16,    /*b15-0: frame length*/
+             bi:15,    /*b30-16: Buffer Index*/
+             rfp2:1;   /*b31: Receive Frame Processed at 2nd word*/
+    }  f;
+}  receiveStatus;
+
+
+typedef  union transmitDescriptor  {  /*data structure of Transmit Descriptor Queue Entry*/
+    struct {         /*whole value*/
+        U32  e0,       /*1st dword entry*/
+             e1;       /*2nd dword entry*/
+    }  w;
+    struct {         /*bit field*/
+        U32  ba:32,    /*b31-0: Buffer Address (keep in mind this is physical address)*/
+             bl:12,    /*b11-0: Buffer Length*/
+             rsrv1:3,  /*b14-12: reserved*/
+             af:1,     /*b15: Abort Frame*/
+             bi:15,    /*b30-16: Buffer Index*/
+             eof:1;    /*b31: End Of Frame*/
+
+    }  f;
+}  transmitDescriptor;
+
+
+typedef  union transmitStatus  {  /*data structure of Transmit Status Queue Entry*/
+    struct {         /*whole word*/
+        U32  e0;       /*1st dword entry*/
+    }  w;
+    struct {         /*bit field*/
+        U32  bi:15,    /*b14-0: Buffer Index*/
+             rsrv3:1,  /*b15: reserved*/
+             ncoll:5,  /*b20-16: Number of Collisions*/
+             rsrv2:3,  /*b23-21: reserved*/
+             ecoll:1,  /*b24: Excess Collisions*/
+             txu:1,    /*b25: Tx Underrun*/
+             ow:1,     /*b26: Out of Window*/
+             rsrv1:1,  /*b27: reserved*/
+             lcrs:1,   /*b28: Loss of CRS*/
+             fa:1,     /*b29: Frame Abort*/
+             txwe:1,   /*b30: Transmitted Without Error*/
+             txfp:1;   /*b31: Transmit Frame Processed*/
+    }  f;
+}  transmitStatus;
+
+
+
+/*---------------------------------------------------------------
+ *  Size of device registers occupied in memory/IO address map
+ *-------------------------------------------------------------*/
+#define  DEV_REG_SPACE  0x00010000
+
+/*
+#define U8 unsigned char
+#define U16 unsigned short
+#define U32 unsigned long
+*/
+
+/*---------------------------------------------------------------
+ * A definition of register access macros
+ *-------------------------------------------------------------*/
+#define  _RegRd(type,ofs)     (*(volatile type*)(ofs))
+#define  _RegWr(type,ofs,dt)  *(volatile type*)(ofs)=((type)(dt))
+
+#define  RegRd8(ofs)   _RegRd(U8,(char*)pD->base_addr+(ofs))
+#define  RegRd16(ofs)  _RegRd(U16,(char*)pD->base_addr+(ofs))
+#define  RegRd32(ofs)  _RegRd(U32,(char*)pD->base_addr+(ofs))
+#define  RegWr8(ofs,dt)   _RegWr(U8,(char*)pD->base_addr+(ofs),(dt))
+#define  RegWr16(ofs,dt)  _RegWr(U16,(char*)pD->base_addr+(ofs),(dt))
+#define  RegWr32(ofs,dt)  _RegWr(U32,(char*)pD->base_addr+(ofs),(dt))
+
+
+
+#endif  /* _EP9213_ETH_H_ */
+
diff -burN linux-2.6.8.1-orig/drivers/net/irda/Kconfig linux-2.6.8.1/drivers/net/irda/Kconfig
--- linux-2.6.8.1-orig/drivers/net/irda/Kconfig	2004-08-14 19:55:48.000000000 +0900
+++ linux-2.6.8.1/drivers/net/irda/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -32,6 +32,11 @@
 	  kernel: saying N will just cause the configurator to skip all
 	  the questions about serial dongles.
 
+config EP93XX_SIR
+	tristate "Cirrus EP93xx SIR dongle"
+	depends on DONGLE && IRDA
+	default y
+	
 config ESI_DONGLE
 	tristate "ESI JetEye PC dongle"
 	depends on DONGLE && IRDA
diff -burN linux-2.6.8.1-orig/drivers/net/irda/Makefile linux-2.6.8.1/drivers/net/irda/Makefile
--- linux-2.6.8.1-orig/drivers/net/irda/Makefile	2004-08-14 19:55:24.000000000 +0900
+++ linux-2.6.8.1/drivers/net/irda/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -28,6 +28,7 @@
 obj-$(CONFIG_MCP2120_DONGLE_OLD)	+= mcp2120.o
 obj-$(CONFIG_ACT200L_DONGLE_OLD)	+= act200l.o
 obj-$(CONFIG_MA600_DONGLE_OLD)	+= ma600.o
+obj-$(CONFIG_EP93XX_SIR)        += ep93xx_sir.o
 obj-$(CONFIG_EP7211_IR)		+= ep7211_ir.o
 obj-$(CONFIG_AU1000_FIR)	+= au1k_ir.o
 # New SIR drivers
diff -burN linux-2.6.8.1-orig/drivers/net/irda/ep93xx_sir.c linux-2.6.8.1/drivers/net/irda/ep93xx_sir.c
--- linux-2.6.8.1-orig/drivers/net/irda/ep93xx_sir.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/net/irda/ep93xx_sir.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,298 @@
+/*
+ * SIR IR port driver for the Cirrus Logic EP93xx.
+ *
+ * SIR on the EP93xx hangs off of UART2 so this is emplemented
+ * as a dongle driver.
+ *
+ * Copyright 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/tty.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+
+#include <net/irda/irda.h>
+#include <net/irda/irmod.h>
+#include <net/irda/irda_device.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/hardware/serial_amba.h>
+
+#include "sir-dev.h"
+
+#define MIN_DELAY 25      /* 15 us, but wait a little more to be sure */
+#define MAX_DELAY 10000   /* 1 ms */
+
+
+#define w388sd_STRINGIFY_HELPER(n)	#n 
+#define w388sd_STRINGIFY(n)         w388sd_STRINGIFY_HELPER(n)
+#define WDEBUG_HDR				"IRDA-SIR" ":" w388sd_STRINGIFY(__LINE__) ":"
+
+
+#if		0
+#undef DEBUG
+//#define DEBUG 1
+#ifdef DEBUG
+#define DPRINTK( x... )  printk( ##x )
+#else
+#define DPRINTK( x... )
+#endif
+#endif
+
+ #define DPRINTK(...)			printk(  WDEBUG_HDR		\
+								"Oliver :"__VA_ARGS__ )
+static int power_level = 3;
+static int tx_lpm;
+static int max_rate = 4000000;
+
+/*
+ * We need access to the UART2 control register so we can
+ * do a read-modify-write and enable SIR.
+ */
+
+static int  ep93xx_sir_open(struct sir_dev *dev);
+static int  ep93xx_sir_close(struct sir_dev *dev);
+static int  ep93xx_sir_change_speed(struct sir_dev *, unsigned);
+static int  ep93xx_sir_reset(struct sir_dev *);
+
+/* These are the baudrates supported, in the order available */
+/* Note : the 220L doesn't support 38400, but we will fix that below */
+static unsigned baud_rates[] = { 9600, 19200, 57600, 115200, 38400 };
+
+#define MAX_SPEEDS (sizeof(baud_rates)/sizeof(baud_rates[0]))
+
+static struct dongle_driver ep93xx_dongle = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "IRDA EP93XX SIR",
+	.type		= IRDA_EP93XX_SIR,
+	.open		= ep93xx_sir_open,
+	.close		= ep93xx_sir_close,
+	.reset		= ep93xx_sir_reset,
+	.set_speed	= ep93xx_sir_change_speed,
+};
+
+
+static int ep93xx_sir_open(struct sir_dev *dev)
+{
+    unsigned int uiTemp;
+    struct qos_info *qos = &dev->qos;	
+
+    DPRINTK("----------------\n ep93xx_sir_open \n-----------------\n");
+    
+    /* 
+     * Set UART2 to be an IrDA interface
+     */
+    uiTemp = inl(SYSCON_DEVCFG);
+    SysconSetLocked(SYSCON_DEVCFG, (uiTemp | SYSCON_DEVCFG_IonU2) );
+    
+    /*
+     * Set the pulse width.
+     */
+    //uiTemp = inl(UART2ILPR);
+	outl( 3, UART2ILPR );
+
+    /*
+     * Set SIREN bit in UART2 - this enables the SIR encoder/decoder.
+     */
+    uiTemp = inl(UART2CR);
+    outl( (uiTemp | AMBA_UARTCR_SIREN), UART2CR );
+
+    /*
+     * Enable Ir in SIR mode.
+     */
+    /* Write the reg twice because of the IrDA errata.  */
+	outl( IrEnable_EN_SIR, IrEnable );
+	outl( IrEnable_EN_SIR, IrEnable );
+
+	sirdev_set_dtr_rts(dev, TRUE, TRUE);
+
+	/* Set the speeds we can accept */
+	qos->baud_rate.bits &= IR_9600|IR_19200|IR_38400|IR_57600|IR_115200;
+
+	/* Remove support for 38400 if this is not a 220L+ dongle */
+	if (dev->dongle_drv->type == IRDA_ACTISYS_DONGLE)
+		qos->baud_rate.bits &= ~IR_38400;
+
+	qos->min_turn_time.bits = 0x7f; /* Needs 0.01 ms */
+	irda_qos_bits_to_value(qos);
+
+	/* irda thread waits 50 msec for power settling */
+
+	return 0;
+	
+
+//    MOD_INC_USE_COUNT;
+}
+
+static int  ep93xx_sir_close(struct sir_dev *dev)
+{
+    unsigned int uiTemp;
+
+    DPRINTK("----------------\n ep93xx_sir_close \n-----------------\n");
+
+    /*
+     * Disable Ir.
+     */
+     /* for now, don't write irda regs due to errata. */
+	//outl( IrEnable_EN_NONE, IrEnable );
+
+    /* 
+     * Set UART2 to be an UART
+     */
+    uiTemp = inl( SYSCON_DEVCFG );
+    SysconSetLocked(SYSCON_DEVCFG, (uiTemp & ~(SYSCON_DEVCFG_IonU2)) );
+
+//    MOD_DEC_USE_COUNT;
+	/* Power off the dongle */
+	sirdev_set_dtr_rts(dev, FALSE, FALSE);
+
+	return 0;
+}
+
+/*
+ * Function ep93xx_sir_change_speed (task)
+ *
+ *   Change speed of the EP93xx I/R port. We don't have to do anything
+ *   here as long as the rate is being changed at the serial port
+ *   level.  irtty.c should take care of that.
+ */
+static int ep93xx_sir_change_speed(struct sir_dev *dev, unsigned speed)
+{
+
+	int ret = 0;
+	int i = 0;
+
+        IRDA_DEBUG(4, "%s(), speed=%d (was %d)\n", __FUNCTION__,
+        	speed, dev->speed);
+
+	/* dongle was already resetted from irda_request state machine,
+	 * we are in known state (dongle default)
+	 */
+
+	/* 
+	 * Now, we can set the speed requested. Send RTS pulses until we
+         * reach the target speed 
+	 */
+	for (i = 0; i < MAX_SPEEDS; i++) {
+		if (speed == baud_rates[i]) {
+			dev->speed = speed;
+			break;
+		}
+		/* Set RTS low for 10 us */
+		sirdev_set_dtr_rts(dev, TRUE, FALSE);
+		udelay(MIN_DELAY);
+
+		/* Set RTS high for 10 us */
+		sirdev_set_dtr_rts(dev, TRUE, TRUE);
+		udelay(MIN_DELAY);
+	}
+
+	/* Check if life is sweet... */
+	if (i >= MAX_SPEEDS) {
+		ep93xx_sir_reset(dev);
+		ret = -EINVAL;  /* This should not happen */
+	}
+
+	/* Basta lavoro, on se casse d'ici... */
+	return ret;
+	
+
+//    DPRINTK("----------------\n ep93xx_sir_change_speed \n-----------------\n");
+//    irda_task_next_state(task, IRDA_TASK_DONE);
+//    return 0;
+}
+
+/*
+ * Function ep93xx_sir_reset (task)
+ *
+ *      Reset the EP93xx IrDA. We don't really have to do anything.
+ *
+ */
+static int ep93xx_sir_reset(struct sir_dev *dev)
+{
+//    DPRINTK("----------------\n ep93xx_sir_reset \n-----------------\n");
+//    irda_task_next_state(task, IRDA_TASK_DONE);
+//    return 0;
+
+	/* Reset the dongle : set DTR low for 10 us */
+	sirdev_set_dtr_rts(dev, FALSE, TRUE);
+	udelay(MIN_DELAY);
+
+	/* Go back to normal mode */
+	sirdev_set_dtr_rts(dev, TRUE, TRUE);
+	
+	dev->speed = 9600;	/* That's the default */
+	
+}
+
+/*
+ * Function ep93xx_sir_init(void)
+ *
+ *    Initialize EP93xx IrDA block in SIR mode.
+ *
+ */
+int __init ep93xx_sir_init(void)
+{
+
+int ret;
+	printk( WDEBUG_HDR "Oliver in ep93xx_sir_init\r\n" );
+    DPRINTK("----------------\n ep93xx_sir_init \n-----------------\n");
+//	return irda_device_register_dongle(&dongle);
+	
+
+	/* First, register an Actisys 220L dongle */
+	ret = irda_register_dongle(&ep93xx_dongle);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+	
+}
+
+/*
+ * Function ep93xx_sir_cleanup(void)
+ *
+ *    Cleanup EP93xx IrDA module
+ *
+ */
+static void __exit ep93xx_sir_cleanup(void)
+{
+    DPRINTK("----------------\n ep93xx_sir_cleanup \n-----------------\n");
+ //   irda_device_unregister_dongle(&dongle);
+ 	irda_unregister_dongle(&ep93xx_dongle);
+}
+
+
+//MODULE_DESCRIPTION("EP93xx SIR IrDA driver");
+// MODULE_LICENSE("GPL");
+        
+//#ifdef MODULE
+module_init(ep93xx_sir_init);
+module_exit(ep93xx_sir_cleanup);
+//#endif
+
+MODULE_AUTHOR("Oliver Ran <rmk@arm.linux.org.uk>");
+MODULE_DESCRIPTION("EP93XX IrDA driver");
+MODULE_LICENSE("GPL");
+MODULE_PARM_DESC(power_level, "IrDA power level, 1 (low) to 3 (high)");
+MODULE_PARM_DESC(tx_lpm, "Enable transmitter low power (1.6us) mode");
+MODULE_PARM_DESC(max_rate, "Maximum baud rate (4000000, 115200, 57600, 38400, 19200, 9600)");
+
+
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/3c574_cs.c linux-2.6.8.1/drivers/net/pcmcia/3c574_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/3c574_cs.c	2004-08-14 19:54:51.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/3c574_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -132,6 +132,139 @@
 #define DEBUG(n, args...)
 #endif
 
+/*
+static void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+*/
+
+static void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+/*
+static void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+*/
+
+static void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+static void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+
+static void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+
+
+
+
 /*====================================================================*/
 
 /* Time in jiffies before concluding the transmitter is hung. */
@@ -145,7 +278,7 @@
 #define EL3_CMD		0x0e
 #define EL3_STATUS	0x0e
 
-#define EL3WINDOW(win_num) outw(SelectWindow + (win_num), ioaddr + EL3_CMD)
+#define EL3WINDOW(win_num) pcnet_outw(SelectWindow + (win_num), ioaddr + EL3_CMD)
 
 /* The top five bits written to EL3_CMD are a command, the lower
    11 bits are the parameter, if applicable. */
@@ -465,12 +598,12 @@
 
 	{
 		u_char mcr;
-		outw(2<<11, ioaddr + RunnerRdCtrl);
-		mcr = inb(ioaddr + 2);
-		outw(0<<11, ioaddr + RunnerRdCtrl);
+		pcnet_outw(2<<11, ioaddr + RunnerRdCtrl);
+		mcr = pcnet_inb(ioaddr + 2);
+		pcnet_outw(0<<11, ioaddr + RunnerRdCtrl);
 		printk(KERN_INFO "  ASIC rev %d,", mcr>>3);
 		EL3WINDOW(3);
-		config.i = inl(ioaddr + Wn3_Config);
+		config.i = pcnet_inl(ioaddr + Wn3_Config);
 		lp->default_media = config.u.xcvr;
 		lp->autoselect = config.u.autoselect;
 	}
@@ -481,13 +614,13 @@
 		int phy;
 		
 		/* Roadrunner only: Turn on the MII transceiver */
-		outw(0x8040, ioaddr + Wn3_Options);
+		pcnet_outw(0x8040, ioaddr + Wn3_Options);
 		mdelay(1);
-		outw(0xc040, ioaddr + Wn3_Options);
+		pcnet_outw(0xc040, ioaddr + Wn3_Options);
 		tc574_wait_for_completion(dev, TxReset);
 		tc574_wait_for_completion(dev, RxReset);
 		mdelay(1);
-		outw(0x8040, ioaddr + Wn3_Options);
+		pcnet_outw(0x8040, ioaddr + Wn3_Options);
 		
 		EL3WINDOW(4);
 		for (phy = 1; phy <= 32; phy++) {
@@ -619,13 +752,13 @@
 	ioaddr_t ioaddr = dev->base_addr;
 	EL3WINDOW(1);
 	printk(KERN_INFO "  irq status %04x, rx status %04x, tx status "
-		   "%02x, tx free %04x\n", inw(ioaddr+EL3_STATUS),
-		   inw(ioaddr+RxStatus), inb(ioaddr+TxStatus),
-		   inw(ioaddr+TxFree));
+		   "%02x, tx free %04x\n", pcnet_inw(ioaddr+EL3_STATUS),
+		   pcnet_inw(ioaddr+RxStatus), pcnet_inb(ioaddr+TxStatus),
+		   pcnet_inw(ioaddr+TxFree));
 	EL3WINDOW(4);
 	printk(KERN_INFO "  diagnostics: fifo %04x net %04x ethernet %04x"
-		   " media %04x\n", inw(ioaddr+0x04), inw(ioaddr+0x06),
-		   inw(ioaddr+0x08), inw(ioaddr+0x0a));
+		   " media %04x\n", pcnet_inw(ioaddr+0x04), pcnet_inw(ioaddr+0x06),
+		   pcnet_inw(ioaddr+0x08), pcnet_inw(ioaddr+0x0a));
 	EL3WINDOW(1);
 }
 
@@ -635,9 +768,9 @@
 static void tc574_wait_for_completion(struct net_device *dev, int cmd)
 {
 	int i = 1500;
-	outw(cmd, dev->base_addr + EL3_CMD);
+	pcnet_outw(cmd, dev->base_addr + EL3_CMD);
 	while (--i > 0)
-		if (!(inw(dev->base_addr + EL3_STATUS) & 0x1000)) break;
+		if (!(pcnet_inw(dev->base_addr + EL3_STATUS) & 0x1000)) break;
 	if (i == 0)
 		printk(KERN_NOTICE "%s: command 0x%04x did not complete!\n", dev->name, cmd);
 }
@@ -648,13 +781,13 @@
 static unsigned short read_eeprom(ioaddr_t ioaddr, int index)
 {
 	int timer;
-	outw(EEPROM_Read + index, ioaddr + Wn0EepromCmd);
+	pcnet_outw(EEPROM_Read + index, ioaddr + Wn0EepromCmd);
 	/* Pause for at least 162 usec for the read to take place. */
 	for (timer = 1620; timer >= 0; timer--) {
-		if ((inw(ioaddr + Wn0EepromCmd) & 0x8000) == 0)
+		if ((pcnet_inw(ioaddr + Wn0EepromCmd) & 0x8000) == 0)
 			break;
 	}
-	return inw(ioaddr + Wn0EepromData);
+	return pcnet_inw(ioaddr + Wn0EepromData);
 }
 
 /* MII transceiver control section.
@@ -679,8 +812,8 @@
 
 	/* Establish sync by sending at least 32 logic ones. */
 	while (-- bits >= 0) {
-		outw(MDIO_DATA_WRITE1, mdio_addr);
-		outw(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);
+		pcnet_outw(MDIO_DATA_WRITE1, mdio_addr);
+		pcnet_outw(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);
 	}
 }
 
@@ -697,14 +830,14 @@
 	/* Shift the read command bits out. */
 	for (i = 14; i >= 0; i--) {
 		int dataval = (read_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-		outw(dataval, mdio_addr);
-		outw(dataval | MDIO_SHIFT_CLK, mdio_addr);
+		pcnet_outw(dataval, mdio_addr);
+		pcnet_outw(dataval | MDIO_SHIFT_CLK, mdio_addr);
 	}
 	/* Read the two transition, 16 data, and wire-idle bits. */
 	for (i = 19; i > 0; i--) {
-		outw(MDIO_ENB_IN, mdio_addr);
-		retval = (retval << 1) | ((inw(mdio_addr) & MDIO_DATA_READ) ? 1 : 0);
-		outw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);
+		pcnet_outw(MDIO_ENB_IN, mdio_addr);
+		retval = (retval << 1) | ((pcnet_inw(mdio_addr) & MDIO_DATA_READ) ? 1 : 0);
+		pcnet_outw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);
 	}
 	return (retval>>1) & 0xffff;
 }
@@ -721,13 +854,13 @@
 	/* Shift the command bits out. */
 	for (i = 31; i >= 0; i--) {
 		int dataval = (write_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-		outw(dataval, mdio_addr);
-		outw(dataval | MDIO_SHIFT_CLK, mdio_addr);
+		pcnet_outw(dataval, mdio_addr);
+		pcnet_outw(dataval | MDIO_SHIFT_CLK, mdio_addr);
 	}
 	/* Leave the interface idle. */
 	for (i = 1; i >= 0; i--) {
-		outw(MDIO_ENB_IN, mdio_addr);
-		outw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);
+		pcnet_outw(MDIO_ENB_IN, mdio_addr);
+		pcnet_outw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);
 	}
 
 	return;
@@ -744,25 +877,25 @@
 
 	spin_lock_irqsave(&lp->window_lock, flags);
 	/* Clear any transactions in progress. */
-	outw(0, ioaddr + RunnerWrCtrl);
-	outw(0, ioaddr + RunnerRdCtrl);
+	pcnet_outw(0, ioaddr + RunnerWrCtrl);
+	pcnet_outw(0, ioaddr + RunnerRdCtrl);
 
 	/* Set the station address and mask. */
 	EL3WINDOW(2);
 	for (i = 0; i < 6; i++)
-		outb(dev->dev_addr[i], ioaddr + i);
+		pcnet_outb(dev->dev_addr[i], ioaddr + i);
 	for (; i < 12; i+=2)
-		outw(0, ioaddr + i);
+		pcnet_outw(0, ioaddr + i);
 
 	/* Reset config options */
 	EL3WINDOW(3);
-	outb((dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);
-	outl((lp->autoselect ? 0x01000000 : 0) | 0x0062001b,
+	pcnet_outb((dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);
+	pcnet_outl((lp->autoselect ? 0x01000000 : 0) | 0x0062001b,
 		 ioaddr + Wn3_Config);
 	/* Roadrunner only: Turn on the MII transceiver. */
-	outw(0x8040, ioaddr + Wn3_Options);
+	pcnet_outw(0x8040, ioaddr + Wn3_Options);
 	mdelay(1);
-	outw(0xc040, ioaddr + Wn3_Options);
+	pcnet_outw(0xc040, ioaddr + Wn3_Options);
 	EL3WINDOW(1);
 	spin_unlock_irqrestore(&lp->window_lock, flags);
 	
@@ -771,21 +904,21 @@
 	mdelay(1);
 	spin_lock_irqsave(&lp->window_lock, flags);
 	EL3WINDOW(3);
-	outw(0x8040, ioaddr + Wn3_Options);
+	pcnet_outw(0x8040, ioaddr + Wn3_Options);
 
 	/* Switch to the stats window, and clear all stats by reading. */
-	outw(StatsDisable, ioaddr + EL3_CMD);
+	pcnet_outw(StatsDisable, ioaddr + EL3_CMD);
 	EL3WINDOW(6);
 	for (i = 0; i < 10; i++)
-		inb(ioaddr + i);
-	inw(ioaddr + 10);
-	inw(ioaddr + 12);
+		pcnet_inb(ioaddr + i);
+	pcnet_inw(ioaddr + 10);
+	pcnet_inw(ioaddr + 12);
 	EL3WINDOW(4);
-	inb(ioaddr + 12);
-	inb(ioaddr + 13);
+	pcnet_inb(ioaddr + 12);
+	pcnet_inb(ioaddr + 13);
 
 	/* .. enable any extra statistics bits.. */
-	outw(0x0040, ioaddr + Wn4_NetDiag);
+	pcnet_outw(0x0040, ioaddr + Wn4_NetDiag);
 	
 	EL3WINDOW(1);
 	spin_unlock_irqrestore(&lp->window_lock, flags);
@@ -803,15 +936,15 @@
 	/* Switch to register set 1 for normal use, just for TxFree. */
 	set_rx_mode(dev);
 	spin_unlock_irqrestore(&lp->window_lock, flags);
-	outw(StatsEnable, ioaddr + EL3_CMD); /* Turn on statistics. */
-	outw(RxEnable, ioaddr + EL3_CMD); /* Enable the receiver. */
-	outw(TxEnable, ioaddr + EL3_CMD); /* Enable transmitter. */
+	pcnet_outw(StatsEnable, ioaddr + EL3_CMD); /* Turn on statistics. */
+	pcnet_outw(RxEnable, ioaddr + EL3_CMD); /* Enable the receiver. */
+	pcnet_outw(TxEnable, ioaddr + EL3_CMD); /* Enable transmitter. */
 	/* Allow status bits to be seen. */
-	outw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);
+	pcnet_outw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);
 	/* Ack all pending events, and set active indicator mask. */
-	outw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,
+	pcnet_outw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,
 		 ioaddr + EL3_CMD);
-	outw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull
+	pcnet_outw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull
 		 | AdapterFailure | RxEarly, ioaddr + EL3_CMD);
 }
 
@@ -833,7 +966,7 @@
 	add_timer(&lp->media);
 	
 	DEBUG(2, "%s: opened, status %4.4x.\n",
-		  dev->name, inw(dev->base_addr + EL3_STATUS));
+		  dev->name, pcnet_inw(dev->base_addr + EL3_STATUS));
 	
 	return 0;
 }
@@ -849,7 +982,7 @@
 	dev->trans_start = jiffies;
 	/* Issue TX_RESET and TX_START commands. */
 	tc574_wait_for_completion(dev, TxReset);
-	outw(TxEnable, ioaddr + EL3_CMD);
+	pcnet_outw(TxEnable, ioaddr + EL3_CMD);
 	netif_wake_queue(dev);
 }
 
@@ -861,7 +994,7 @@
     
 	/* Clear the Tx status stack. */
 	for (i = 32; i > 0; i--) {
-		u_char tx_status = inb(ioaddr + TxStatus);
+		u_char tx_status = pcnet_inb(ioaddr + TxStatus);
 		if (!(tx_status & 0x84))
 			break;
 		/* reset transmitter on jabber error or underrun */
@@ -870,10 +1003,10 @@
 		if (tx_status & 0x38) {
 			DEBUG(1, "%s: transmit error: status 0x%02x\n",
 				  dev->name, tx_status);
-			outw(TxEnable, ioaddr + EL3_CMD);
+			pcnet_outw(TxEnable, ioaddr + EL3_CMD);
 			lp->stats.tx_aborted_errors++;
 		}
-		outb(0x00, ioaddr + TxStatus); /* Pop the status stack. */
+		pcnet_outb(0x00, ioaddr + TxStatus); /* Pop the status stack. */
 	}
 }
 
@@ -885,21 +1018,21 @@
 
 	DEBUG(3, "%s: el3_start_xmit(length = %ld) called, "
 		  "status %4.4x.\n", dev->name, (long)skb->len,
-		  inw(ioaddr + EL3_STATUS));
+		  pcnet_inw(ioaddr + EL3_STATUS));
 
 	spin_lock_irqsave(&lp->window_lock, flags);
-	outw(skb->len, ioaddr + TX_FIFO);
-	outw(0, ioaddr + TX_FIFO);
-	outsl(ioaddr + TX_FIFO, skb->data, (skb->len+3)>>2);
+	pcnet_outw(skb->len, ioaddr + TX_FIFO);
+	pcnet_outw(0, ioaddr + TX_FIFO);
+	pcnet_outsl(ioaddr + TX_FIFO, skb->data, (skb->len+3)>>2);
 
 	dev->trans_start = jiffies;
 
 	/* TxFree appears only in Window 1, not offset 0x1c. */
-	if (inw(ioaddr + TxFree) <= 1536) {
+	if (pcnet_inw(ioaddr + TxFree) <= 1536) {
 		netif_stop_queue(dev);
 		/* Interrupt us when the FIFO has room for max-sized packet. 
 		   The threshold is in units of dwords. */
-		outw(SetTxThreshold + (1536>>2), ioaddr + EL3_CMD);
+		pcnet_outw(SetTxThreshold + (1536>>2), ioaddr + EL3_CMD);
 	}
 
 	pop_tx_status(dev);
@@ -922,11 +1055,11 @@
 	ioaddr = dev->base_addr;
 
 	DEBUG(3, "%s: interrupt, status %4.4x.\n",
-		  dev->name, inw(ioaddr + EL3_STATUS));
+		  dev->name, pcnet_inw(ioaddr + EL3_STATUS));
 
 	spin_lock(&lp->window_lock);
 	
-	while ((status = inw(ioaddr + EL3_STATUS)) &
+	while ((status = pcnet_inw(ioaddr + EL3_STATUS)) &
 		   (IntLatch | RxComplete | RxEarly | StatsFull)) {
 		if (!netif_device_present(dev) ||
 			((status & 0xe000) != 0x2000)) {
@@ -942,7 +1075,7 @@
 		if (status & TxAvailable) {
 			DEBUG(3, "  TX room bit was handled.\n");
 			/* There's room in the FIFO for a full-sized packet. */
-			outw(AckIntr | TxAvailable, ioaddr + EL3_CMD);
+			pcnet_outw(AckIntr | TxAvailable, ioaddr + EL3_CMD);
 			netif_wake_queue(dev);
 		}
 
@@ -955,27 +1088,27 @@
 				update_stats(dev);
 			if (status & RxEarly) {
 				work_budget = el3_rx(dev, work_budget);
-				outw(AckIntr | RxEarly, ioaddr + EL3_CMD);
+				pcnet_outw(AckIntr | RxEarly, ioaddr + EL3_CMD);
 			}
 			if (status & AdapterFailure) {
 				u16 fifo_diag;
 				EL3WINDOW(4);
-				fifo_diag = inw(ioaddr + Wn4_FIFODiag);
+				fifo_diag = pcnet_inw(ioaddr + Wn4_FIFODiag);
 				EL3WINDOW(1);
 				printk(KERN_NOTICE "%s: adapter failure, FIFO diagnostic"
 					   " register %04x.\n", dev->name, fifo_diag);
 				if (fifo_diag & 0x0400) {
 					/* Tx overrun */
 					tc574_wait_for_completion(dev, TxReset);
-					outw(TxEnable, ioaddr + EL3_CMD);
+					pcnet_outw(TxEnable, ioaddr + EL3_CMD);
 				}
 				if (fifo_diag & 0x2000) {
 					/* Rx underrun */
 					tc574_wait_for_completion(dev, RxReset);
 					set_rx_mode(dev);
-					outw(RxEnable, ioaddr + EL3_CMD);
+					pcnet_outw(RxEnable, ioaddr + EL3_CMD);
 				}
-				outw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);
+				pcnet_outw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);
 			}
 		}
 
@@ -983,15 +1116,15 @@
 			DEBUG(0, "%s: Too much work in interrupt, "
 				  "status %4.4x.\n", dev->name, status);
 			/* Clear all interrupts */
-			outw(AckIntr | 0xFF, ioaddr + EL3_CMD);
+			pcnet_outw(AckIntr | 0xFF, ioaddr + EL3_CMD);
 			break;
 		}
 		/* Acknowledge the IRQ. */
-		outw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);
+		pcnet_outw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);
 	}
 
 	DEBUG(3, "%s: exiting interrupt, status %4.4x.\n",
-		  dev->name, inw(ioaddr + EL3_STATUS));
+		  dev->name, pcnet_inw(ioaddr + EL3_STATUS));
 		  
 	spin_unlock(&lp->window_lock);
 	return IRQ_RETVAL(handled);
@@ -1015,7 +1148,7 @@
 	
 	/* Check for pending interrupt with expired latency timer: with
 	   this, we can limp along even if the interrupt is blocked */
-	if ((inw(ioaddr + EL3_STATUS) & IntLatch) && (inb(ioaddr + Timer) == 0xff)) {
+	if ((pcnet_inw(ioaddr + EL3_STATUS) & IntLatch) && (pcnet_inb(ioaddr + Timer) == 0xff)) {
 		if (!lp->fast_poll)
 			printk(KERN_INFO "%s: interrupt(s) dropped!\n", dev->name);
 		el3_interrupt(dev->irq, lp, NULL);
@@ -1056,7 +1189,7 @@
 			}
 
 			EL3WINDOW(3);
-			outb((partner & 0x0140 ? 0x20 : 0) |
+			pcnet_outb((partner & 0x0140 ? 0x20 : 0) |
 				 (dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);
 			EL3WINDOW(1);
 
@@ -1100,29 +1233,29 @@
 
 	DEBUG(2, "%s: updating the statistics.\n", dev->name);
 
-	if (inw(ioaddr+EL3_STATUS) == 0xffff) /* No card. */
+	if (pcnet_inw(ioaddr+EL3_STATUS) == 0xffff) /* No card. */
 		return;
 		
 	/* Unlike the 3c509 we need not turn off stats updates while reading. */
 	/* Switch to the stats window, and read everything. */
 	EL3WINDOW(6);
-	lp->stats.tx_carrier_errors 		+= inb(ioaddr + 0);
-	lp->stats.tx_heartbeat_errors		+= inb(ioaddr + 1);
-	/* Multiple collisions. */	   	inb(ioaddr + 2);
-	lp->stats.collisions			+= inb(ioaddr + 3);
-	lp->stats.tx_window_errors		+= inb(ioaddr + 4);
-	lp->stats.rx_fifo_errors		+= inb(ioaddr + 5);
-	lp->stats.tx_packets			+= inb(ioaddr + 6);
-	up		 			 = inb(ioaddr + 9);
+	lp->stats.tx_carrier_errors 		+= pcnet_inb(ioaddr + 0);
+	lp->stats.tx_heartbeat_errors		+= pcnet_inb(ioaddr + 1);
+	/* Multiple collisions. */	   	pcnet_inb(ioaddr + 2);
+	lp->stats.collisions			+= pcnet_inb(ioaddr + 3);
+	lp->stats.tx_window_errors		+= pcnet_inb(ioaddr + 4);
+	lp->stats.rx_fifo_errors		+= pcnet_inb(ioaddr + 5);
+	lp->stats.tx_packets			+= pcnet_inb(ioaddr + 6);
+	up		 			 = pcnet_inb(ioaddr + 9);
 	lp->stats.tx_packets			+= (up&0x30) << 4;
-	/* Rx packets   */			   inb(ioaddr + 7);
-	/* Tx deferrals */			   inb(ioaddr + 8);
-	rx		 			 = inw(ioaddr + 10);
-	tx					 = inw(ioaddr + 12);
+	/* Rx packets   */			   pcnet_inb(ioaddr + 7);
+	/* Tx deferrals */			   pcnet_inb(ioaddr + 8);
+	rx		 			 = pcnet_inw(ioaddr + 10);
+	tx					 = pcnet_inw(ioaddr + 12);
 
 	EL3WINDOW(4);
-	/* BadSSD */				   inb(ioaddr + 12);
-	up					 = inb(ioaddr + 13);
+	/* BadSSD */				   pcnet_inb(ioaddr + 12);
+	up					 = pcnet_inb(ioaddr + 13);
 
 	lp->stats.tx_bytes 			+= tx + ((up & 0xf0) << 12);
 
@@ -1136,8 +1269,8 @@
 	short rx_status;
 	
 	DEBUG(3, "%s: in rx_packet(), status %4.4x, rx_status %4.4x.\n",
-		  dev->name, inw(ioaddr+EL3_STATUS), inw(ioaddr+RxStatus));
-	while (!((rx_status = inw(ioaddr + RxStatus)) & 0x8000) &&
+		  dev->name, pcnet_inw(ioaddr+EL3_STATUS), pcnet_inw(ioaddr+RxStatus));
+	while (!((rx_status = pcnet_inw(ioaddr + RxStatus)) & 0x8000) &&
 		   (--worklimit >= 0)) {
 		if (rx_status & 0x4000) { /* Error, update stats. */
 			short error = rx_status & 0x3800;
@@ -1161,7 +1294,7 @@
 			if (skb != NULL) {
 				skb->dev = dev;
 				skb_reserve(skb, 2);
-				insl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),
+				pcnet_insl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),
 						((pkt_len+3)>>2));
 				skb->protocol = eth_type_trans(skb, dev);
 				netif_rx(skb);
@@ -1211,7 +1344,7 @@
 			unsigned long flags;
 
 			spin_lock_irqsave(&lp->window_lock, flags);
-			saved_window = inw(ioaddr + EL3_CMD) >> 13;
+			saved_window = pcnet_inw(ioaddr + EL3_CMD) >> 13;
 			EL3WINDOW(4);
 			data[3] = mdio_read(ioaddr, data[0] & 0x1f, data[1] & 0x1f);
 			EL3WINDOW(saved_window);
@@ -1226,7 +1359,7 @@
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
 			spin_lock_irqsave(&lp->window_lock, flags);
-			saved_window = inw(ioaddr + EL3_CMD) >> 13;
+			saved_window = pcnet_inw(ioaddr + EL3_CMD) >> 13;
 			EL3WINDOW(4);
 			mdio_write(ioaddr, data[0] & 0x1f, data[1] & 0x1f, data[2]);
 			EL3WINDOW(saved_window);
@@ -1251,12 +1384,12 @@
 	ioaddr_t ioaddr = dev->base_addr;
 
 	if (dev->flags & IFF_PROMISC)
-		outw(SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm,
+		pcnet_outw(SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm,
 			 ioaddr + EL3_CMD);
 	else if (dev->mc_count || (dev->flags & IFF_ALLMULTI))
-		outw(SetRxFilter|RxStation|RxMulticast|RxBroadcast, ioaddr + EL3_CMD);
+		pcnet_outw(SetRxFilter|RxStation|RxMulticast|RxBroadcast, ioaddr + EL3_CMD);
 	else
-		outw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);
+		pcnet_outw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);
 }
 
 static int el3_close(struct net_device *dev)
@@ -1271,11 +1404,11 @@
 		unsigned long flags;
 
 		/* Turn off statistics ASAP.  We update lp->stats below. */
-		outw(StatsDisable, ioaddr + EL3_CMD);
+		pcnet_outw(StatsDisable, ioaddr + EL3_CMD);
 		
 		/* Disable the receiver and transmitter. */
-		outw(RxDisable, ioaddr + EL3_CMD);
-		outw(TxDisable, ioaddr + EL3_CMD);
+		pcnet_outw(RxDisable, ioaddr + EL3_CMD);
+		pcnet_outw(TxDisable, ioaddr + EL3_CMD);
 		
 		/* Note: Switching to window 0 may disable the IRQ. */
 		EL3WINDOW(0);
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/3c589_cs.c linux-2.6.8.1/drivers/net/pcmcia/3c589_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/3c589_cs.c	2004-08-14 19:56:22.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/3c589_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -52,6 +52,139 @@
 #include <asm/system.h>
 #include <asm/bitops.h>
 
+/*
+static void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+*/
+
+static void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+/*
+static void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+*/
+
+static void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+/*
+static void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+*/
+static unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+
+static void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+
+
+
+
 /* To minimize the size of the driver source I only define operating
    constants if they are used several times.  You'll need the manual
    if you want to understand driver details. */
@@ -64,7 +197,7 @@
 #define EEPROM_READ	0x0080
 #define EEPROM_BUSY	0x8000
 
-#define EL3WINDOW(win_num) outw(SelectWindow + (win_num), ioaddr + EL3_CMD)
+#define EL3WINDOW(win_num) pcnet_outw(SelectWindow + (win_num), ioaddr + EL3_CMD)
 
 /* The top five bits written to EL3_CMD are a command, the lower
    11 bits are the parameter, if applicable. */
@@ -120,6 +253,10 @@
 
 /*====================================================================*/
 
+
+
+
+
 /* Module parameters */
 
 MODULE_AUTHOR("David Hinds <dahinds@users.sourceforge.net>");
@@ -380,8 +517,8 @@
 
     /* The address and resource configuration register aren't loaded from
        the EEPROM and *must* be set to 0 and IRQ3 for the PCMCIA version. */
-    outw(0x3f00, ioaddr + 8);
-    fifo = inl(ioaddr);
+    pcnet_outw(0x3f00, ioaddr + 8);
+    fifo = pcnet_inl(ioaddr);
 
     /* The if_port symbol can be set when the module is loaded */
     if ((if_port >= 0) && (if_port <= 3))
@@ -498,9 +635,9 @@
 static void tc589_wait_for_completion(struct net_device *dev, int cmd)
 {
     int i = 100;
-    outw(cmd, dev->base_addr + EL3_CMD);
+    pcnet_outw(cmd, dev->base_addr + EL3_CMD);
     while (--i > 0)
-	if (!(inw(dev->base_addr + EL3_STATUS) & 0x1000)) break;
+	if (!(pcnet_inw(dev->base_addr + EL3_STATUS) & 0x1000)) break;
     if (i == 0)
 	printk(KERN_WARNING "%s: command 0x%04x did not complete!\n",
 	       dev->name, cmd);
@@ -513,12 +650,12 @@
 static u16 read_eeprom(ioaddr_t ioaddr, int index)
 {
     int i;
-    outw(EEPROM_READ + index, ioaddr + 10);
+    pcnet_outw(EEPROM_READ + index, ioaddr + 10);
     /* Reading the eeprom takes 162 us */
     for (i = 1620; i >= 0; i--)
-	if ((inw(ioaddr + 10) & EEPROM_BUSY) == 0)
+	if ((pcnet_inw(ioaddr + 10) & EEPROM_BUSY) == 0)
 	    break;
-    return inw(ioaddr + 12);
+    return pcnet_inw(ioaddr + 12);
 }
 
 /*
@@ -532,15 +669,15 @@
     
     EL3WINDOW(0);
     switch (if_port) {
-    case 0: case 1: outw(0, ioaddr + 6); break;
-    case 2: outw(3<<14, ioaddr + 6); break;
-    case 3: outw(1<<14, ioaddr + 6); break;
+    case 0: case 1: pcnet_outw(0, ioaddr + 6); break;
+    case 2: pcnet_outw(3<<14, ioaddr + 6); break;
+    case 3: pcnet_outw(1<<14, ioaddr + 6); break;
     }
     /* On PCMCIA, this just turns on the LED */
-    outw((if_port == 2) ? StartCoax : StopCoax, ioaddr + EL3_CMD);
+    pcnet_outw((if_port == 2) ? StartCoax : StopCoax, ioaddr + EL3_CMD);
     /* 10baseT interface, enable link beat and jabber check. */
     EL3WINDOW(4);
-    outw(MEDIA_LED | ((if_port < 2) ? MEDIA_TP : 0), ioaddr + WN4_MEDIA);
+    pcnet_outw(MEDIA_LED | ((if_port < 2) ? MEDIA_TP : 0), ioaddr + WN4_MEDIA);
     EL3WINDOW(1);
     if (if_port == 2)
 	lp->media_status = ((dev->if_port == 0) ? 0x8000 : 0x4000);
@@ -553,13 +690,13 @@
     ioaddr_t ioaddr = dev->base_addr;
     EL3WINDOW(1);
     printk(KERN_INFO "  irq status %04x, rx status %04x, tx status "
-	   "%02x  tx free %04x\n", inw(ioaddr+EL3_STATUS),
-	   inw(ioaddr+RX_STATUS), inb(ioaddr+TX_STATUS),
-	   inw(ioaddr+TX_FREE));
+	   "%02x  tx free %04x\n", pcnet_inw(ioaddr+EL3_STATUS),
+	   pcnet_inw(ioaddr+RX_STATUS), pcnet_inb(ioaddr+TX_STATUS),
+	   pcnet_inw(ioaddr+TX_FREE));
     EL3WINDOW(4);
     printk(KERN_INFO "  diagnostics: fifo %04x net %04x ethernet %04x"
-	   " media %04x\n", inw(ioaddr+0x04), inw(ioaddr+0x06),
-	   inw(ioaddr+0x08), inw(ioaddr+0x0a));
+	   " media %04x\n", pcnet_inw(ioaddr+0x04), pcnet_inw(ioaddr+0x06),
+	   pcnet_inw(ioaddr+0x08), pcnet_inw(ioaddr+0x0a));
     EL3WINDOW(1);
 }
 
@@ -570,38 +707,38 @@
     int i;
     
     EL3WINDOW(0);
-    outw(0x0001, ioaddr + 4);			/* Activate board. */ 
-    outw(0x3f00, ioaddr + 8);			/* Set the IRQ line. */
+    pcnet_outw(0x0001, ioaddr + 4);			/* Activate board. */ 
+    pcnet_outw(0x3f00, ioaddr + 8);			/* Set the IRQ line. */
     
     /* Set the station address in window 2. */
     EL3WINDOW(2);
     for (i = 0; i < 6; i++)
-	outb(dev->dev_addr[i], ioaddr + i);
+	pcnet_outb(dev->dev_addr[i], ioaddr + i);
 
     tc589_set_xcvr(dev, dev->if_port);
     
     /* Switch to the stats window, and clear all stats by reading. */
-    outw(StatsDisable, ioaddr + EL3_CMD);
+    pcnet_outw(StatsDisable, ioaddr + EL3_CMD);
     EL3WINDOW(6);
     for (i = 0; i < 9; i++)
-	inb(ioaddr+i);
-    inw(ioaddr + 10);
-    inw(ioaddr + 12);
+	pcnet_inb(ioaddr+i);
+    pcnet_inw(ioaddr + 10);
+    pcnet_inw(ioaddr + 12);
     
     /* Switch to register set 1 for normal use. */
     EL3WINDOW(1);
 
     /* Accept b-cast and phys addr only. */
-    outw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);
-    outw(StatsEnable, ioaddr + EL3_CMD); /* Turn on statistics. */
-    outw(RxEnable, ioaddr + EL3_CMD); /* Enable the receiver. */
-    outw(TxEnable, ioaddr + EL3_CMD); /* Enable transmitter. */
+    pcnet_outw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);
+    pcnet_outw(StatsEnable, ioaddr + EL3_CMD); /* Turn on statistics. */
+    pcnet_outw(RxEnable, ioaddr + EL3_CMD); /* Enable the receiver. */
+    pcnet_outw(TxEnable, ioaddr + EL3_CMD); /* Enable transmitter. */
     /* Allow status bits to be seen. */
-    outw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);
+    pcnet_outw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);
     /* Ack all pending events, and set active indicator mask. */
-    outw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,
+    pcnet_outw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,
 	 ioaddr + EL3_CMD);
-    outw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull
+    pcnet_outw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull
 	 | AdapterFailure, ioaddr + EL3_CMD);
 }
 
@@ -666,7 +803,7 @@
     add_timer(&lp->media);
 
     DEBUG(1, "%s: opened, status %4.4x.\n",
-	  dev->name, inw(dev->base_addr + EL3_STATUS));
+	  dev->name, pcnet_inw(dev->base_addr + EL3_STATUS));
     
     return 0;
 }
@@ -682,7 +819,7 @@
     dev->trans_start = jiffies;
     /* Issue TX_RESET and TX_START commands. */
     tc589_wait_for_completion(dev, TxReset);
-    outw(TxEnable, ioaddr + EL3_CMD);
+    pcnet_outw(TxEnable, ioaddr + EL3_CMD);
     netif_wake_queue(dev);
 }
 
@@ -694,7 +831,7 @@
     
     /* Clear the Tx status stack. */
     for (i = 32; i > 0; i--) {
-	u_char tx_status = inb(ioaddr + TX_STATUS);
+	u_char tx_status = pcnet_inb(ioaddr + TX_STATUS);
 	if (!(tx_status & 0x84)) break;
 	/* reset transmitter on jabber error or underrun */
 	if (tx_status & 0x30)
@@ -702,10 +839,10 @@
 	if (tx_status & 0x38) {
 	    DEBUG(1, "%s: transmit error: status 0x%02x\n",
 		  dev->name, tx_status);
-	    outw(TxEnable, ioaddr + EL3_CMD);
+	    pcnet_outw(TxEnable, ioaddr + EL3_CMD);
 	    lp->stats.tx_aborted_errors++;
 	}
-	outb(0x00, ioaddr + TX_STATUS); /* Pop the status stack. */
+	pcnet_outb(0x00, ioaddr + TX_STATUS); /* Pop the status stack. */
     }
 }
 
@@ -716,21 +853,21 @@
 
     DEBUG(3, "%s: el3_start_xmit(length = %ld) called, "
 	  "status %4.4x.\n", dev->name, (long)skb->len,
-	  inw(ioaddr + EL3_STATUS));
+	  pcnet_inw(ioaddr + EL3_STATUS));
 
     priv->stats.tx_bytes += skb->len;
 
     /* Put out the doubleword header... */
-    outw(skb->len, ioaddr + TX_FIFO);
-    outw(0x00, ioaddr + TX_FIFO);
+    pcnet_outw(skb->len, ioaddr + TX_FIFO);
+    pcnet_outw(0x00, ioaddr + TX_FIFO);
     /* ... and the packet rounded to a doubleword. */
-    outsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);
+    pcnet_outsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);
 
     dev->trans_start = jiffies;
-    if (inw(ioaddr + TX_FREE) <= 1536) {
+    if (pcnet_inw(ioaddr + TX_FREE) <= 1536) {
 	netif_stop_queue(dev);
 	/* Interrupt us when the FIFO has room for max-sized packet. */
-	outw(SetTxThreshold + 1536, ioaddr + EL3_CMD);
+	pcnet_outw(SetTxThreshold + 1536, ioaddr + EL3_CMD);
     }
 
     dev_kfree_skb(skb);
@@ -753,10 +890,10 @@
     ioaddr = dev->base_addr;
 
     DEBUG(3, "%s: interrupt, status %4.4x.\n",
-	  dev->name, inw(ioaddr + EL3_STATUS));
+	  dev->name, pcnet_inw(ioaddr + EL3_STATUS));
 
     spin_lock(&lp->lock);    
-    while ((status = inw(ioaddr + EL3_STATUS)) &
+    while ((status = pcnet_inw(ioaddr + EL3_STATUS)) &
 	(IntLatch | RxComplete | StatsFull)) {
 	if ((status & 0xe000) != 0x2000) {
 	    DEBUG(1, "%s: interrupt from dead card\n", dev->name);
@@ -770,7 +907,7 @@
 	if (status & TxAvailable) {
 	    DEBUG(3, "    TX room bit was handled.\n");
 	    /* There's room in the FIFO for a full-sized packet. */
-	    outw(AckIntr | TxAvailable, ioaddr + EL3_CMD);
+	    pcnet_outw(AckIntr | TxAvailable, ioaddr + EL3_CMD);
 	    netif_wake_queue(dev);
 	}
 	
@@ -783,27 +920,27 @@
 		update_stats(dev);
 	    if (status & RxEarly) {		/* Rx early is unused. */
 		el3_rx(dev);
-		outw(AckIntr | RxEarly, ioaddr + EL3_CMD);
+		pcnet_outw(AckIntr | RxEarly, ioaddr + EL3_CMD);
 	    }
 	    if (status & AdapterFailure) {
 		u16 fifo_diag;
 		EL3WINDOW(4);
-		fifo_diag = inw(ioaddr + 4);
+		fifo_diag = pcnet_inw(ioaddr + 4);
 		EL3WINDOW(1);
 		printk(KERN_WARNING "%s: adapter failure, FIFO diagnostic"
 		       " register %04x.\n", dev->name, fifo_diag);
 		if (fifo_diag & 0x0400) {
 		    /* Tx overrun */
 		    tc589_wait_for_completion(dev, TxReset);
-		    outw(TxEnable, ioaddr + EL3_CMD);
+		    pcnet_outw(TxEnable, ioaddr + EL3_CMD);
 		}
 		if (fifo_diag & 0x2000) {
 		    /* Rx underrun */
 		    tc589_wait_for_completion(dev, RxReset);
 		    set_multicast_list(dev);
-		    outw(RxEnable, ioaddr + EL3_CMD);
+		    pcnet_outw(RxEnable, ioaddr + EL3_CMD);
 		}
-		outw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);
+		pcnet_outw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);
 	    }
 	}
 	
@@ -811,17 +948,17 @@
 	    printk(KERN_ERR "%s: infinite loop in interrupt, "
 		   "status %4.4x.\n", dev->name, status);
 	    /* Clear all interrupts */
-	    outw(AckIntr | 0xFF, ioaddr + EL3_CMD);
+	    pcnet_outw(AckIntr | 0xFF, ioaddr + EL3_CMD);
 	    break;
 	}
 	/* Acknowledge the IRQ. */
-	outw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);
+	pcnet_outw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);
     }
 
     lp->last_irq = jiffies;
     spin_unlock(&lp->lock);    
     DEBUG(3, "%s: exiting interrupt, status %4.4x.\n",
-	  dev->name, inw(ioaddr + EL3_STATUS));
+	  dev->name, pcnet_inw(ioaddr + EL3_STATUS));
     return IRQ_RETVAL(handled);
 }
 
@@ -838,8 +975,8 @@
     EL3WINDOW(1);
     /* Check for pending interrupt with expired latency timer: with
        this, we can limp along even if the interrupt is blocked */
-    if ((inw(ioaddr + EL3_STATUS) & IntLatch) &&
-	(inb(ioaddr + EL3_TIMER) == 0xff)) {
+    if ((pcnet_inw(ioaddr + EL3_STATUS) & IntLatch) &&
+	(pcnet_inb(ioaddr + EL3_TIMER) == 0xff)) {
 	if (!lp->fast_poll)
 	    printk(KERN_WARNING "%s: interrupt(s) dropped!\n", dev->name);
 	el3_interrupt(dev->irq, lp, NULL);
@@ -856,7 +993,7 @@
        when the lock is held */
     spin_lock_irqsave(&lp->lock, flags);    
     EL3WINDOW(4);
-    media = inw(ioaddr+WN4_MEDIA) & 0xc810;
+    media = pcnet_inw(ioaddr+WN4_MEDIA) & 0xc810;
 
     /* Ignore collisions unless we've had no irq's recently */
     if (jiffies - lp->last_irq < HZ) {
@@ -864,9 +1001,9 @@
     } else {
 	/* Try harder to detect carrier errors */
 	EL3WINDOW(6);
-	outw(StatsDisable, ioaddr + EL3_CMD);
-	errs = inb(ioaddr + 0);
-	outw(StatsEnable, ioaddr + EL3_CMD);
+	pcnet_outw(StatsDisable, ioaddr + EL3_CMD);
+	errs = pcnet_inb(ioaddr + 0);
+	pcnet_outw(StatsEnable, ioaddr + EL3_CMD);
 	lp->stats.tx_carrier_errors += errs;
 	if (errs || (lp->media_status & 0x0010)) media |= 0x0010;
     }
@@ -935,24 +1072,24 @@
 
     DEBUG(2, "%s: updating the statistics.\n", dev->name);
     /* Turn off statistics updates while reading. */
-    outw(StatsDisable, ioaddr + EL3_CMD);
+    pcnet_outw(StatsDisable, ioaddr + EL3_CMD);
     /* Switch to the stats window, and read everything. */
     EL3WINDOW(6);
-    lp->stats.tx_carrier_errors 	+= inb(ioaddr + 0);
-    lp->stats.tx_heartbeat_errors	+= inb(ioaddr + 1);
-    /* Multiple collisions. */	   	inb(ioaddr + 2);
-    lp->stats.collisions		+= inb(ioaddr + 3);
-    lp->stats.tx_window_errors		+= inb(ioaddr + 4);
-    lp->stats.rx_fifo_errors		+= inb(ioaddr + 5);
-    lp->stats.tx_packets		+= inb(ioaddr + 6);
-    /* Rx packets   */			inb(ioaddr + 7);
-    /* Tx deferrals */			inb(ioaddr + 8);
-    /* Rx octets */			inw(ioaddr + 10);
-    /* Tx octets */			inw(ioaddr + 12);
+    lp->stats.tx_carrier_errors 	+= pcnet_inb(ioaddr + 0);
+    lp->stats.tx_heartbeat_errors	+= pcnet_inb(ioaddr + 1);
+    /* Multiple collisions. */	   	pcnet_inb(ioaddr + 2);
+    lp->stats.collisions		+= pcnet_inb(ioaddr + 3);
+    lp->stats.tx_window_errors		+= pcnet_inb(ioaddr + 4);
+    lp->stats.rx_fifo_errors		+= pcnet_inb(ioaddr + 5);
+    lp->stats.tx_packets		+= pcnet_inb(ioaddr + 6);
+    /* Rx packets   */			pcnet_inb(ioaddr + 7);
+    /* Tx deferrals */			pcnet_inb(ioaddr + 8);
+    /* Rx octets */			pcnet_inw(ioaddr + 10);
+    /* Tx octets */			pcnet_inw(ioaddr + 12);
     
     /* Back to window 1, and turn statistics back on. */
     EL3WINDOW(1);
-    outw(StatsEnable, ioaddr + EL3_CMD);
+    pcnet_outw(StatsEnable, ioaddr + EL3_CMD);
 }
 
 static int el3_rx(struct net_device *dev)
@@ -963,8 +1100,8 @@
     short rx_status;
     
     DEBUG(3, "%s: in rx_packet(), status %4.4x, rx_status %4.4x.\n",
-	  dev->name, inw(ioaddr+EL3_STATUS), inw(ioaddr+RX_STATUS));
-    while (!((rx_status = inw(ioaddr + RX_STATUS)) & 0x8000) &&
+	  dev->name, pcnet_inw(ioaddr+EL3_STATUS), pcnet_inw(ioaddr+RX_STATUS));
+    while (!((rx_status = pcnet_inw(ioaddr + RX_STATUS)) & 0x8000) &&
 	   (--worklimit >= 0)) {
 	if (rx_status & 0x4000) { /* Error, update stats. */
 	    short error = rx_status & 0x3800;
@@ -988,7 +1125,7 @@
 	    if (skb != NULL) {
 		skb->dev = dev;
 		skb_reserve(skb, 2);
-		insl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),
+		pcnet_insl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),
 			(pkt_len+3)>>2);
 		skb->protocol = eth_type_trans(skb, dev);
 		netif_rx(skb);
@@ -1021,7 +1158,7 @@
 	opts |= RxMulticast | RxProm;
     else if (dev->mc_count || (dev->flags & IFF_ALLMULTI))
 	opts |= RxMulticast;
-    outw(opts, ioaddr + EL3_CMD);
+    pcnet_outw(opts, ioaddr + EL3_CMD);
 }
 
 static int el3_close(struct net_device *dev)
@@ -1034,28 +1171,28 @@
 
     if (DEV_OK(link)) {
 	/* Turn off statistics ASAP.  We update lp->stats below. */
-	outw(StatsDisable, ioaddr + EL3_CMD);
+	pcnet_outw(StatsDisable, ioaddr + EL3_CMD);
 	
 	/* Disable the receiver and transmitter. */
-	outw(RxDisable, ioaddr + EL3_CMD);
-	outw(TxDisable, ioaddr + EL3_CMD);
+	pcnet_outw(RxDisable, ioaddr + EL3_CMD);
+	pcnet_outw(TxDisable, ioaddr + EL3_CMD);
 	
 	if (dev->if_port == 2)
 	    /* Turn off thinnet power.  Green! */
-	    outw(StopCoax, ioaddr + EL3_CMD);
+	    pcnet_outw(StopCoax, ioaddr + EL3_CMD);
 	else if (dev->if_port == 1) {
 	    /* Disable link beat and jabber */
 	    EL3WINDOW(4);
-	    outw(0, ioaddr + WN4_MEDIA);
+	    pcnet_outw(0, ioaddr + WN4_MEDIA);
 	}
 	
 	/* Switching back to window 0 disables the IRQ. */
 	EL3WINDOW(0);
 	/* But we explicitly zero the IRQ line select anyway. */
-	outw(0x0f00, ioaddr + WN0_IRQ);
+	pcnet_outw(0x0f00, ioaddr + WN0_IRQ);
         
 	/* Check if the card still exists */
-	if ((inw(ioaddr+EL3_STATUS) & 0xe000) == 0x2000)
+	if ((pcnet_inw(ioaddr+EL3_STATUS) & 0xe000) == 0x2000)
 	    update_stats(dev);
     }
 
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/axnet_cs.c linux-2.6.8.1/drivers/net/pcmcia/axnet_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/axnet_cs.c	2004-08-14 19:55:33.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/axnet_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -66,6 +66,145 @@
 #define IS_AX88790	0x0002
 
 /*====================================================================*/
+static void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+
+/*
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+*/
+
 
 /* Module parameters */
 
@@ -284,7 +423,7 @@
     mdelay(10);
 
     for (i = 0; i < sizeof(program_seq)/sizeof(program_seq[0]); i++)
-	outb_p(program_seq[i].value, ioaddr + program_seq[i].offset);
+	pcnet_outb_p(program_seq[i].value, ioaddr + program_seq[i].offset);
 
     for (i = 0; i < 6; i += 2) {
 	j = inw(ioaddr + AXNET_DATAPORT);
@@ -431,13 +570,13 @@
     ei_status.block_input = &block_input;
     ei_status.block_output = &block_output;
 
-    if (inb(dev->base_addr + AXNET_TEST) != 0)
+    if (pcnet_inb(dev->base_addr + AXNET_TEST) != 0)
 	info->flags |= IS_AX88790;
     else
 	info->flags |= IS_AX88190;
 
     if (info->flags & IS_AX88790)
-	outb(0x10, dev->base_addr + AXNET_GPIO);  /* select Internal PHY */
+	pcnet_outb(0x10, dev->base_addr + AXNET_GPIO);  /* select Internal PHY */
 
     for (i = 0; i < 32; i++) {
 	j = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 1);
@@ -577,8 +716,8 @@
 {
     int bits;
     for (bits = 0; bits < 32; bits++) {
-	outb_p(MDIO_DATA_WRITE1, addr);
-	outb_p(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);
+	pcnet_outb_p(MDIO_DATA_WRITE1, addr);
+	pcnet_outb_p(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);
     }
 }
 
@@ -590,13 +729,13 @@
     mdio_sync(addr);
     for (i = 14; i >= 0; i--) {
 	int dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-	outb_p(dat, addr);
-	outb_p(dat | MDIO_SHIFT_CLK, addr);
+	pcnet_outb_p(dat, addr);
+	pcnet_outb_p(dat | MDIO_SHIFT_CLK, addr);
     }
     for (i = 19; i > 0; i--) {
-	outb_p(MDIO_ENB_IN, addr);
-	retval = (retval << 1) | ((inb_p(addr) & MDIO_DATA_READ) != 0);
-	outb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);
+	pcnet_outb_p(MDIO_ENB_IN, addr);
+	retval = (retval << 1) | ((pcnet_inb(addr) & MDIO_DATA_READ) != 0);
+	pcnet_outb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);
     }
     return (retval>>1) & 0xffff;
 }
@@ -609,12 +748,12 @@
     mdio_sync(addr);
     for (i = 31; i >= 0; i--) {
 	int dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-	outb_p(dat, addr);
-	outb_p(dat | MDIO_SHIFT_CLK, addr);
+	pcnet_outb_p(dat, addr);
+	pcnet_outb_p(dat | MDIO_SHIFT_CLK, addr);
     }
     for (i = 1; i >= 0; i--) {
-	outb_p(MDIO_ENB_IN, addr);
-	outb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);
+	pcnet_outb_p(MDIO_ENB_IN, addr);
+	pcnet_outb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);
     }
 }
 
@@ -677,16 +816,16 @@
 
     ei_status.txing = ei_status.dmaing = 0;
 
-    outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);
+    pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);
 
-    outb(inb(nic_base + AXNET_RESET), nic_base + AXNET_RESET);
+    pcnet_outb(pcnet_inb(nic_base + AXNET_RESET), nic_base + AXNET_RESET);
 
     for (i = 0; i < 100; i++) {
-	if ((inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)
+	if ((pcnet_inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)
 	    break;
 	udelay(100);
     }
-    outb_p(ENISR_RESET, nic_base + EN0_ISR); /* Ack intr. */
+    pcnet_outb_p(ENISR_RESET, nic_base + EN0_ISR); /* Ack intr. */
     
     if (i == 100)
 	printk(KERN_ERR "%s: axnet_reset_8390() did not complete.\n",
@@ -715,7 +854,7 @@
 
     /* Check for pending interrupt with expired latency timer: with
        this, we can limp along even if the interrupt is blocked */
-    if (info->stale++ && (inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {
+    if (info->stale++ && (pcnet_inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {
 	if (!info->fast_poll)
 	    printk(KERN_INFO "%s: interrupt(s) dropped!\n", dev->name);
 	ei_irq_wrapper(dev->irq, dev, NULL);
@@ -802,11 +941,11 @@
 {
     ioaddr_t nic_base = dev->base_addr;
 
-    outb_p(0, nic_base + EN0_RSARLO);		/* On page boundary */
-    outb_p(ring_page, nic_base + EN0_RSARHI);
-    outb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);
+    pcnet_outb_p(0, nic_base + EN0_RSARLO);		/* On page boundary */
+    pcnet_outb_p(ring_page, nic_base + EN0_RSARHI);
+    pcnet_outb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);
 
-    insw(nic_base + AXNET_DATAPORT, hdr,
+    pcnet_insw(nic_base + AXNET_DATAPORT, hdr,
 	    sizeof(struct e8390_pkt_hdr)>>1);
     /* Fix for big endian systems */
     hdr->count = le16_to_cpu(hdr->count);
@@ -826,13 +965,13 @@
     if ((ei_debug > 4) && (count != 4))
 	printk(KERN_DEBUG "%s: [bi=%d]\n", dev->name, count+4);
 #endif
-    outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);
-    outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);
-    outb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);
+    pcnet_outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);
+    pcnet_outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);
+    pcnet_outb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);
 
-    insw(nic_base + AXNET_DATAPORT,buf,count>>1);
+    pcnet_insw(nic_base + AXNET_DATAPORT,buf,count>>1);
     if (count & 0x01)
-	buf[count-1] = inb(nic_base + AXNET_DATAPORT), xfer_count++;
+	buf[count-1] = pcnet_inb(nic_base + AXNET_DATAPORT), xfer_count++;
 
 }
 
@@ -854,10 +993,10 @@
     if (count & 0x01)
 	count++;
 
-    outb_p(0x00, nic_base + EN0_RSARLO);
-    outb_p(start_page, nic_base + EN0_RSARHI);
-    outb_p(E8390_RWRITE+E8390_START, nic_base + AXNET_CMD);
-    outsw(nic_base + AXNET_DATAPORT, buf, count>>1);
+    pcnet_outb_p(0x00, nic_base + EN0_RSARLO);
+    pcnet_outb_p(start_page, nic_base + EN0_RSARHI);
+    pcnet_outb_p(E8390_RWRITE+E8390_START, nic_base + AXNET_CMD);
+    pcnet_outsw(nic_base + AXNET_DATAPORT, (void *)buf, count>>1);
 }
 
 static struct pcmcia_driver axnet_cs_driver = {
@@ -1091,8 +1230,8 @@
 	ei_local->stat.tx_errors++;
 
 	spin_lock_irqsave(&ei_local->page_lock, flags);
-	txsr = inb(e8390_base+EN0_TSR);
-	isr = inb(e8390_base+EN0_ISR);
+	txsr = pcnet_inb(e8390_base+EN0_TSR);
+	isr = pcnet_inb(e8390_base+EN0_ISR);
 	spin_unlock_irqrestore(&ei_local->page_lock, flags);
 
 	printk(KERN_DEBUG "%s: Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d.\n",
@@ -1145,7 +1284,7 @@
 	   up trashing the mcast filter not disabling irqs if we don't lock */
 	   
 	spin_lock_irqsave(&ei_local->page_lock, flags);
-	outb_p(0x00, e8390_base + EN0_IMR);
+	pcnet_outb_p(0x00, e8390_base + EN0_IMR);
 	spin_unlock_irqrestore(&ei_local->page_lock, flags);
 	
 	/*
@@ -1191,7 +1330,7 @@
 				dev->name, ei_local->tx1, ei_local->tx2, ei_local->lasttx);
 		ei_local->irqlock = 0;
 		netif_stop_queue(dev);
-		outb_p(ENISR_ALL, e8390_base + EN0_IMR);
+		pcnet_outb_p(ENISR_ALL, e8390_base + EN0_IMR);
 		spin_unlock(&ei_local->page_lock);
 		enable_irq(dev->irq);
 		ei_local->stat.tx_errors++;
@@ -1237,7 +1376,7 @@
 
 	/* Turn 8390 interrupts back on. */
 	ei_local->irqlock = 0;
-	outb_p(ENISR_ALL, e8390_base + EN0_IMR);
+	pcnet_outb_p(ENISR_ALL, e8390_base + EN0_IMR);
 	
 	spin_unlock(&ei_local->page_lock);
 	enable_irq(dev->irq);
@@ -1291,8 +1430,8 @@
 		printk(ei_local->irqlock
 			   ? "%s: Interrupted while interrupts are masked! isr=%#2x imr=%#2x.\n"
 			   : "%s: Reentering the interrupt handler! isr=%#2x imr=%#2x.\n",
-			   dev->name, inb_p(e8390_base + EN0_ISR),
-			   inb_p(e8390_base + EN0_IMR));
+			   dev->name, pcnet_inb_p(e8390_base + EN0_ISR),
+			   pcnet_inb_p(e8390_base + EN0_IMR));
 #endif
 		spin_unlock(&ei_local->page_lock);
 		return IRQ_NONE;
@@ -1300,31 +1439,31 @@
     
 	if (ei_debug > 3)
 		printk(KERN_DEBUG "%s: interrupt(isr=%#2.2x).\n", dev->name,
-			   inb_p(e8390_base + EN0_ISR));
+			   pcnet_inb_p(e8390_base + EN0_ISR));
 
-	outb_p(0x00, e8390_base + EN0_ISR);
+	pcnet_outb_p(0x00, e8390_base + EN0_ISR);
 	ei_local->irqlock = 1;
    
 	/* !!Assumption!! -- we stay in page 0.	 Don't break this. */
-	while ((interrupts = inb_p(e8390_base + EN0_ISR)) != 0
+	while ((interrupts = pcnet_inb_p(e8390_base + EN0_ISR)) != 0
 		   && ++nr_serviced < MAX_SERVICE) 
 	{
 		if (!netif_running(dev) || (interrupts == 0xff)) {
 			if (ei_debug > 1)
 				printk(KERN_WARNING "%s: interrupt from stopped card\n", dev->name);
-			outb_p(interrupts, e8390_base + EN0_ISR);
+			pcnet_outb_p(interrupts, e8390_base + EN0_ISR);
 			interrupts = 0;
 			break;
 		}
 		handled = 1;
 
 		/* AX88190 bug fix. */
-		outb_p(interrupts, e8390_base + EN0_ISR);
+		pcnet_outb_p(interrupts, e8390_base + EN0_ISR);
 		for (i = 0; i < 10; i++) {
-			if (!(inb(e8390_base + EN0_ISR) & interrupts))
+			if (!(pcnet_inb(e8390_base + EN0_ISR) & interrupts))
 				break;
-			outb_p(0, e8390_base + EN0_ISR);
-			outb_p(interrupts, e8390_base + EN0_ISR);
+			pcnet_outb_p(0, e8390_base + EN0_ISR);
+			pcnet_outb_p(interrupts, e8390_base + EN0_ISR);
 		}
 		if (interrupts & ENISR_OVER) 
 			ei_rx_overrun(dev);
@@ -1341,9 +1480,9 @@
 
 		if (interrupts & ENISR_COUNTERS) 
 		{
-			ei_local->stat.rx_frame_errors += inb_p(e8390_base + EN0_COUNTER0);
-			ei_local->stat.rx_crc_errors   += inb_p(e8390_base + EN0_COUNTER1);
-			ei_local->stat.rx_missed_errors+= inb_p(e8390_base + EN0_COUNTER2);
+			ei_local->stat.rx_frame_errors += pcnet_inb_p(e8390_base + EN0_COUNTER0);
+			ei_local->stat.rx_crc_errors   += pcnet_inb_p(e8390_base + EN0_COUNTER1);
+			ei_local->stat.rx_missed_errors+= pcnet_inb_p(e8390_base + EN0_COUNTER2);
 		}
 	}
     
@@ -1356,16 +1495,16 @@
 			if(interrupts!=0xFF)
 				printk(KERN_WARNING "%s: Too much work at interrupt, status %#2.2x\n",
 				   dev->name, interrupts);
-			outb_p(ENISR_ALL, e8390_base + EN0_ISR); /* Ack. most intrs. */
+			pcnet_outb_p(ENISR_ALL, e8390_base + EN0_ISR); /* Ack. most intrs. */
 		} else {
 			printk(KERN_WARNING "%s: unknown interrupt %#2x\n", dev->name, interrupts);
-			outb_p(0xff, e8390_base + EN0_ISR); /* Ack. all intrs. */
+			pcnet_outb_p(0xff, e8390_base + EN0_ISR); /* Ack. all intrs. */
 		}
 	}
 
 	/* Turn 8390 interrupts back on. */
 	ei_local->irqlock = 0;
-	outb_p(ENISR_ALL, e8390_base + EN0_IMR);
+	pcnet_outb_p(ENISR_ALL, e8390_base + EN0_IMR);
 
 	spin_unlock(&ei_local->page_lock);
 	return IRQ_RETVAL(handled);
@@ -1389,7 +1528,7 @@
 {
 	long e8390_base = dev->base_addr;
 	struct ei_device *ei_local = (struct ei_device *) netdev_priv(dev);
-	unsigned char txsr = inb_p(e8390_base+EN0_TSR);
+	unsigned char txsr = pcnet_inb_p(e8390_base+EN0_TSR);
 	unsigned char tx_was_aborted = txsr & (ENTSR_ABT+ENTSR_FU);
 
 #ifdef VERBOSE_ERROR_DUMP
@@ -1430,7 +1569,7 @@
 {
 	long e8390_base = dev->base_addr;
 	struct ei_device *ei_local = (struct ei_device *) netdev_priv(dev);
-	int status = inb(e8390_base + EN0_TSR);
+	int status = pcnet_inb(e8390_base + EN0_TSR);
     
 	/*
 	 * There are two Tx buffers, see which one finished, and trigger
@@ -1521,10 +1660,10 @@
 		int pkt_len, pkt_stat;
 		
 		/* Get the rx page (incoming packet pointer). */
-		rxing_page = inb_p(e8390_base + EN1_CURPAG -1);
+		rxing_page = pcnet_inb_p(e8390_base + EN1_CURPAG -1);
 		
 		/* Remove one frame from the ring.  Boundary is always a page behind. */
-		this_frame = inb_p(e8390_base + EN0_BOUNDARY) + 1;
+		this_frame = pcnet_inb_p(e8390_base + EN0_BOUNDARY) + 1;
 		if (this_frame >= ei_local->stop_page)
 			this_frame = ei_local->rx_start_page;
 		
@@ -1606,7 +1745,7 @@
 			next_frame = ei_local->rx_start_page;
 		}
 		ei_local->current_page = next_frame;
-		outb_p(next_frame-1, e8390_base+EN0_BOUNDARY);
+		pcnet_outb_p(next_frame-1, e8390_base+EN0_BOUNDARY);
 	}
 
 	return;
@@ -1636,8 +1775,8 @@
 	 * Record whether a Tx was in progress and then issue the
 	 * stop command.
 	 */
-	was_txing = inb_p(e8390_base+E8390_CMD) & E8390_TRANS;
-	outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);
+	was_txing = pcnet_inb_p(e8390_base+E8390_CMD) & E8390_TRANS;
+	pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);
     
 	if (ei_debug > 1)
 		printk(KERN_DEBUG "%s: Receiver overrun.\n", dev->name);
@@ -1655,8 +1794,8 @@
 	/*
 	 * Reset RBCR[01] back to zero as per magic incantation.
 	 */
-	outb_p(0x00, e8390_base+EN0_RCNTLO);
-	outb_p(0x00, e8390_base+EN0_RCNTHI);
+	pcnet_outb_p(0x00, e8390_base+EN0_RCNTLO);
+	pcnet_outb_p(0x00, e8390_base+EN0_RCNTHI);
 
 	/*
 	 * See if any Tx was interrupted or not. According to NS, this
@@ -1665,7 +1804,7 @@
 
 	if (was_txing)
 	{ 
-		unsigned char tx_completed = inb_p(e8390_base+EN0_ISR) & (ENISR_TX+ENISR_TX_ERR);
+		unsigned char tx_completed = pcnet_inb_p(e8390_base+EN0_ISR) & (ENISR_TX+ENISR_TX_ERR);
 		if (!tx_completed)
 			must_resend = 1;
 	}
@@ -1674,8 +1813,8 @@
 	 * Have to enter loopback mode and then restart the NIC before
 	 * you are allowed to slurp packets up off the ring.
 	 */
-	outb_p(E8390_TXOFF, e8390_base + EN0_TXCR);
-	outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START, e8390_base + E8390_CMD);
+	pcnet_outb_p(E8390_TXOFF, e8390_base + EN0_TXCR);
+	pcnet_outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START, e8390_base + E8390_CMD);
 
 	/*
 	 * Clear the Rx ring of all the debris, and ack the interrupt.
@@ -1685,9 +1824,9 @@
 	/*
 	 * Leave loopback mode, and resend any packet that got stopped.
 	 */
-	outb_p(E8390_TXCONFIG | info->duplex_flag, e8390_base + EN0_TXCR); 
+	pcnet_outb_p(E8390_TXCONFIG | info->duplex_flag, e8390_base + EN0_TXCR); 
 	if (must_resend)
-    		outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START + E8390_TRANS, e8390_base + E8390_CMD);
+    		pcnet_outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START + E8390_TRANS, e8390_base + E8390_CMD);
 }
 
 /*
@@ -1706,9 +1845,9 @@
 
 	spin_lock_irqsave(&ei_local->page_lock,flags);
 	/* Read the counter registers, assuming we are in page 0. */
-	ei_local->stat.rx_frame_errors += inb_p(ioaddr + EN0_COUNTER0);
-	ei_local->stat.rx_crc_errors   += inb_p(ioaddr + EN0_COUNTER1);
-	ei_local->stat.rx_missed_errors+= inb_p(ioaddr + EN0_COUNTER2);
+	ei_local->stat.rx_frame_errors += pcnet_inb_p(ioaddr + EN0_COUNTER0);
+	ei_local->stat.rx_crc_errors   += pcnet_inb_p(ioaddr + EN0_COUNTER1);
+	ei_local->stat.rx_missed_errors+= pcnet_inb_p(ioaddr + EN0_COUNTER2);
 	spin_unlock_irqrestore(&ei_local->page_lock, flags);
     
 	return &ei_local->stat;
@@ -1727,11 +1866,11 @@
 	long e8390_base = dev->base_addr;
 
   	if(dev->flags&IFF_PROMISC)
-  		outb_p(E8390_RXCONFIG | 0x58, e8390_base + EN0_RXCR);
+  		pcnet_outb_p(E8390_RXCONFIG | 0x58, e8390_base + EN0_RXCR);
 	else if(dev->flags&IFF_ALLMULTI || dev->mc_list)
-  		outb_p(E8390_RXCONFIG | 0x48, e8390_base + EN0_RXCR);
+  		pcnet_outb_p(E8390_RXCONFIG | 0x48, e8390_base + EN0_RXCR);
   	else
-  		outb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);
+  		pcnet_outb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);
 }
 
 /*
@@ -1798,32 +1937,32 @@
 	if(sizeof(struct e8390_pkt_hdr)!=4)
     		panic("8390.c: header struct mispacked\n");    
 	/* Follow National Semi's recommendations for initing the DP83902. */
-	outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD); /* 0x21 */
-	outb_p(endcfg, e8390_base + EN0_DCFG);	/* 0x48 or 0x49 */
+	pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD); /* 0x21 */
+	pcnet_outb_p(endcfg, e8390_base + EN0_DCFG);	/* 0x48 or 0x49 */
 	/* Clear the remote byte count registers. */
-	outb_p(0x00,  e8390_base + EN0_RCNTLO);
-	outb_p(0x00,  e8390_base + EN0_RCNTHI);
+	pcnet_outb_p(0x00,  e8390_base + EN0_RCNTLO);
+	pcnet_outb_p(0x00,  e8390_base + EN0_RCNTHI);
 	/* Set to monitor and loopback mode -- this is vital!. */
-	outb_p(E8390_RXOFF|0x40, e8390_base + EN0_RXCR); /* 0x60 */
-	outb_p(E8390_TXOFF, e8390_base + EN0_TXCR); /* 0x02 */
+	pcnet_outb_p(E8390_RXOFF|0x40, e8390_base + EN0_RXCR); /* 0x60 */
+	pcnet_outb_p(E8390_TXOFF, e8390_base + EN0_TXCR); /* 0x02 */
 	/* Set the transmit page and receive ring. */
-	outb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);
+	pcnet_outb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);
 	ei_local->tx1 = ei_local->tx2 = 0;
-	outb_p(ei_local->rx_start_page, e8390_base + EN0_STARTPG);
-	outb_p(ei_local->stop_page-1, e8390_base + EN0_BOUNDARY);	/* 3c503 says 0x3f,NS0x26*/
+	pcnet_outb_p(ei_local->rx_start_page, e8390_base + EN0_STARTPG);
+	pcnet_outb_p(ei_local->stop_page-1, e8390_base + EN0_BOUNDARY);	/* 3c503 says 0x3f,NS0x26*/
 	ei_local->current_page = ei_local->rx_start_page;		/* assert boundary+1 */
-	outb_p(ei_local->stop_page, e8390_base + EN0_STOPPG);
+	pcnet_outb_p(ei_local->stop_page, e8390_base + EN0_STOPPG);
 	/* Clear the pending interrupts and mask. */
-	outb_p(0xFF, e8390_base + EN0_ISR);
-	outb_p(0x00,  e8390_base + EN0_IMR);
+	pcnet_outb_p(0xFF, e8390_base + EN0_ISR);
+	pcnet_outb_p(0x00,  e8390_base + EN0_IMR);
     
 	/* Copy the station address into the DS8390 registers. */
 
-	outb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, e8390_base+E8390_CMD); /* 0x61 */
+	pcnet_outb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, e8390_base+E8390_CMD); /* 0x61 */
 	for(i = 0; i < 6; i++) 
 	{
-		outb_p(dev->dev_addr[i], e8390_base + EN1_PHYS_SHIFT(i));
-		if(inb_p(e8390_base + EN1_PHYS_SHIFT(i))!=dev->dev_addr[i])
+		pcnet_outb_p(dev->dev_addr[i], e8390_base + EN1_PHYS_SHIFT(i));
+		if(pcnet_inb_p(e8390_base + EN1_PHYS_SHIFT(i))!=dev->dev_addr[i])
 			printk(KERN_ERR "Hw. address read/write mismap %d\n",i);
 	}
 	/*
@@ -1831,10 +1970,10 @@
 	 * the higher levels can do the filtering.
 	 */
 	for (i = 0; i < 8; i++)
-		outb_p(0xff, e8390_base + EN1_MULT + i);
+		pcnet_outb_p(0xff, e8390_base + EN1_MULT + i);
 
-	outb_p(ei_local->rx_start_page, e8390_base + EN1_CURPAG);
-	outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);
+	pcnet_outb_p(ei_local->rx_start_page, e8390_base + EN1_CURPAG);
+	pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);
 
 	netif_start_queue(dev);
 	ei_local->tx1 = ei_local->tx2 = 0;
@@ -1842,13 +1981,13 @@
 
 	if (startp) 
 	{
-		outb_p(0xff,  e8390_base + EN0_ISR);
-		outb_p(ENISR_ALL,  e8390_base + EN0_IMR);
-		outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);
-		outb_p(E8390_TXCONFIG | info->duplex_flag,
+		pcnet_outb_p(0xff,  e8390_base + EN0_ISR);
+		pcnet_outb_p(ENISR_ALL,  e8390_base + EN0_IMR);
+		pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);
+		pcnet_outb_p(E8390_TXCONFIG | info->duplex_flag,
 		       e8390_base + EN0_TXCR); /* xmit on. */
 		/* 3c503 TechMan says rxconfig only after the NIC is started. */
-		outb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR); /* rx on, */
+		pcnet_outb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR); /* rx on, */
 		do_set_multicast_list(dev);	/* (re)load the mcast table */
 	}
 }
@@ -1862,14 +2001,14 @@
 	long e8390_base = dev->base_addr;
  	struct ei_device *ei_local __attribute((unused)) = (struct ei_device *) netdev_priv(dev);
     
-	if (inb_p(e8390_base) & E8390_TRANS) 
+	if (pcnet_inb_p(e8390_base) & E8390_TRANS) 
 	{
 		printk(KERN_WARNING "%s: trigger_send() called with the transmitter busy.\n",
 			dev->name);
 		return;
 	}
-	outb_p(length & 0xff, e8390_base + EN0_TCNTLO);
-	outb_p(length >> 8, e8390_base + EN0_TCNTHI);
-	outb_p(start_page, e8390_base + EN0_TPSR);
-	outb_p(E8390_NODMA+E8390_TRANS+E8390_START, e8390_base+E8390_CMD);
+	pcnet_outb_p(length & 0xff, e8390_base + EN0_TCNTLO);
+	pcnet_outb_p(length >> 8, e8390_base + EN0_TCNTHI);
+	pcnet_outb_p(start_page, e8390_base + EN0_TPSR);
+	pcnet_outb_p(E8390_NODMA+E8390_TRANS+E8390_START, e8390_base+E8390_CMD);
 }
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/com20020_cs.c linux-2.6.8.1/drivers/net/pcmcia/com20020_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/com20020_cs.c	2004-08-14 19:55:32.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/com20020_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -54,6 +54,148 @@
 
 #define VERSION "arcnet: COM20020 PCMCIA support loaded.\n"
 
+static
+void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+
+
+
+
+
+
 #ifdef PCMCIA_DEBUG
 
 static int pc_debug = PCMCIA_DEBUG;
@@ -70,15 +212,15 @@
     {
 	if (!(count % 16))
 	    printk("\n%04X: ", count);
-	printk("%02X ", inb(count));
+	printk("%02X ", pcnet_inb(count));
     }
     printk("\n");
     
     printk("buffer0 dump:\n");
 	/* set up the address register */
         count = 0;
-	outb((count >> 8) | RDDATAflag | AUTOINCflag, _ADDR_HI);
-	outb(count & 0xff, _ADDR_LO);
+	pcnet_outb((count >> 8) | RDDATAflag | AUTOINCflag, _ADDR_HI);
+	pcnet_outb(count & 0xff, _ADDR_LO);
     
     for (count = 0; count < 256+32; count++)
     {
@@ -86,7 +228,7 @@
 	    printk("\n%04X: ", count);
 	
 	/* copy the data */
-	printk("%02X ", inb(_MEMDATA));
+	printk("%02X ", pcnet_inb(_MEMDATA));
     }
     printk("\n");
 }
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/fmvj18x_cs.c linux-2.6.8.1/drivers/net/pcmcia/fmvj18x_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/fmvj18x_cs.c	2004-08-14 19:55:47.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/fmvj18x_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -62,6 +62,171 @@
 
 /*====================================================================*/
 
+
+static
+void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+
+/*
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+*/
+
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+/*
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+*/
+
+static
+unsigned char pcnet_readb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return readb(port);
+
+#endif
+}
+
+static
+void pcnet_writeb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	writeb(addr, port);
+#endif
+}
+
+
 /* Module parameters */
 
 MODULE_DESCRIPTION("fmvj18x and compatible PCMCIA ethernet driver");
@@ -519,15 +684,15 @@
 
     /* Reset controller */
     if (sram_config == 0) 
-	outb(CONFIG0_RST, ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_RST, ioaddr + CONFIG_0);
     else
-	outb(CONFIG0_RST_1, ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_RST_1, ioaddr + CONFIG_0);
 
     /* Power On chip and select bank 0 */
     if (cardtype == MBH10302)
-	outb(BANK_0, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_0, ioaddr + CONFIG_1);
     else
-	outb(BANK_0U, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_0U, ioaddr + CONFIG_1);
     
     /* Set hardware address */
     switch (cardtype) {
@@ -565,7 +730,7 @@
     case UNGERMANN:
 	/* Read MACID from register */
 	for (i = 0; i < 6; i++) 
-	    dev->dev_addr[i] = inb(ioaddr + UNGERMANN_MAC_ID + i);
+	    dev->dev_addr[i] = pcnet_inb(ioaddr + UNGERMANN_MAC_ID + i);
 	card_name = "Access/CARD";
 	break;
     case XXX10304:
@@ -583,7 +748,7 @@
     default:
 	/* Read MACID from register */
 	for (i = 0; i < 6; i++) 
-	    dev->dev_addr[i] = inb(ioaddr + MAC_ID + i);
+	    dev->dev_addr[i] = pcnet_inb(ioaddr + MAC_ID + i);
 	card_name = "FMV-J181";
 	break;
     }
@@ -648,18 +813,18 @@
      *  'yy' is MAC address.
     */ 
     for (i = 0; i < 0x200; i++) {
-	if (readb(base+i*2) == 0x22) {	
-	    if (readb(base+(i-1)*2) == 0xff
-	     && readb(base+(i+5)*2) == 0x04
-	     && readb(base+(i+6)*2) == 0x06
-	     && readb(base+(i+13)*2) == 0xff) 
+	if (pcnet_readb((unsigned long)(base+i*2)) == 0x22) {	
+	    if (pcnet_readb((unsigned long)(base+(i-1)*2)) == 0xff
+	     && pcnet_readb((unsigned long)(base+(i+5)*2)) == 0x04
+	     && pcnet_readb((unsigned long)(base+(i+6)*2)) == 0x06
+	     && pcnet_readb((unsigned long)(base+(i+13)*2)) == 0xff) 
 		break;
 	}
     }
 
     if (i != 0x200) {
 	for (j = 0 ; j < 6; j++,i++) {
-	    node_id[j] = readb(base+(i+7)*2);
+	    node_id[j] = pcnet_readb((unsigned long)(base+(i+7)*2));
 	}
     }
 
@@ -697,14 +862,14 @@
     pcmcia_map_mem_page(link->win, &mem);
 
     ioaddr = dev->base_addr;
-    writeb(0x47, base+0x800);	/* Config Option Register of LAN */
-    writeb(0x0, base+0x802);	/* Config and Status Register */
+    pcnet_writeb(0x47, (unsigned long)(base+0x800));	/* Config Option Register of LAN */
+    pcnet_writeb(0x0, (unsigned long)(base+0x802));	/* Config and Status Register */
 
-    writeb(ioaddr & 0xff, base+0x80a);		/* I/O Base(Low) of LAN */
-    writeb((ioaddr >> 8) & 0xff, base+0x80c);	/* I/O Base(High) of LAN */
+    pcnet_writeb(ioaddr & 0xff, (unsigned long)(base+0x80a) );		/* I/O Base(Low) of LAN */
+    pcnet_writeb((ioaddr >> 8) & 0xff, (unsigned long)(base+0x80c) );	/* I/O Base(High) of LAN */
    
-    writeb(0x45, base+0x820);	/* Config Option Register of Modem */
-    writeb(0x8, base+0x822);	/* Config and Status Register */
+    pcnet_writeb(0x45,(unsigned long) (base+0x820) );	/* Config Option Register of Modem */
+    pcnet_writeb(0x8, (unsigned long )(base+0x822) );	/* Config and Status Register */
 
     iounmap(base);
     j = pcmcia_release_window(link->win);
@@ -816,23 +981,23 @@
     ioaddr = dev->base_addr;
 
     /* avoid multiple interrupts */
-    outw(0x0000, ioaddr + TX_INTR);
+    pcnet_outw(0x0000, ioaddr + TX_INTR);
 
     /* wait for a while */
     udelay(1);
 
     /* get status */
-    tx_stat = inb(ioaddr + TX_STATUS);
-    rx_stat = inb(ioaddr + RX_STATUS);
+    tx_stat = pcnet_inb(ioaddr + TX_STATUS);
+    rx_stat = pcnet_inb(ioaddr + RX_STATUS);
 
     /* clear status */
-    outb(tx_stat, ioaddr + TX_STATUS);
-    outb(rx_stat, ioaddr + RX_STATUS);
+    pcnet_outb(tx_stat, ioaddr + TX_STATUS);
+    pcnet_outb(rx_stat, ioaddr + RX_STATUS);
     
     DEBUG(4, "%s: interrupt, rx_status %02x.\n", dev->name, rx_stat);
     DEBUG(4, "               tx_status %02x.\n", tx_stat);
     
-    if (rx_stat || (inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {
+    if (rx_stat || (pcnet_inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {
 	/* there is packet(s) in rx buffer */
 	fjn_rx(dev);
     }
@@ -840,7 +1005,7 @@
 	lp->stats.tx_packets += lp->sent ;
         lp->sent = 0 ;
 	if (lp->tx_queue) {
-	    outb(DO_TX | lp->tx_queue, ioaddr + TX_START);
+	    pcnet_outb(DO_TX | lp->tx_queue, ioaddr + TX_START);
 	    lp->sent = lp->tx_queue ;
 	    lp->tx_queue = 0;
 	    lp->tx_queue_len = 0;
@@ -853,8 +1018,8 @@
     DEBUG(4, "%s: exiting interrupt,\n", dev->name);
     DEBUG(4, "    tx_status %02x, rx_status %02x.\n", tx_stat, rx_stat);
 
-    outb(D_TX_INTR, ioaddr + TX_INTR);
-    outb(D_RX_INTR, ioaddr + RX_INTR);
+    pcnet_outb(D_TX_INTR, ioaddr + TX_INTR);
+    pcnet_outb(D_RX_INTR, ioaddr + RX_INTR);
     return IRQ_HANDLED;
 
 } /* fjn_interrupt */
@@ -867,16 +1032,16 @@
     ioaddr_t ioaddr = dev->base_addr;
 
     printk(KERN_NOTICE "%s: transmit timed out with status %04x, %s?\n",
-	   dev->name, htons(inw(ioaddr + TX_STATUS)),
-	   inb(ioaddr + TX_STATUS) & F_TMT_RDY
+	   dev->name, htons(pcnet_inw(ioaddr + TX_STATUS)),
+	   pcnet_inb(ioaddr + TX_STATUS) & F_TMT_RDY
 	   ? "IRQ conflict" : "network cable problem");
     printk(KERN_NOTICE "%s: timeout registers: %04x %04x %04x "
 	   "%04x %04x %04x %04x %04x.\n",
-	   dev->name, htons(inw(ioaddr + 0)),
-	   htons(inw(ioaddr + 2)), htons(inw(ioaddr + 4)),
-	   htons(inw(ioaddr + 6)), htons(inw(ioaddr + 8)),
-	   htons(inw(ioaddr +10)), htons(inw(ioaddr +12)),
-	   htons(inw(ioaddr +14)));
+	   dev->name, htons(pcnet_inw(ioaddr + 0)),
+	   htons(pcnet_inw(ioaddr + 2)), htons(pcnet_inw(ioaddr + 4)),
+	   htons(pcnet_inw(ioaddr + 6)), htons(pcnet_inw(ioaddr + 8)),
+	   htons(pcnet_inw(ioaddr +10)), htons(pcnet_inw(ioaddr +12)),
+	   htons(pcnet_inw(ioaddr +14)));
     lp->stats.tx_errors++;
     /* ToDo: We should try to restart the adaptor... */
     local_irq_disable();
@@ -921,20 +1086,20 @@
 	lp->stats.tx_bytes += skb->len;
 
 	/* Disable both interrupts. */
-	outw(0x0000, ioaddr + TX_INTR);
+	pcnet_outw(0x0000, ioaddr + TX_INTR);
 
 	/* wait for a while */
 	udelay(1);
 
-	outw(length, ioaddr + DATAPORT);
-	outsw(ioaddr + DATAPORT, buf, (length + 1) >> 1);
+	pcnet_outw(length, ioaddr + DATAPORT);
+	pcnet_outsw(ioaddr + DATAPORT, buf, (length + 1) >> 1);
 
 	lp->tx_queue++;
 	lp->tx_queue_len += ((length+3) & ~1);
 
 	if (lp->tx_started == 0) {
 	    /* If the Tx is idle, always trigger a transmit. */
-	    outb(DO_TX | lp->tx_queue, ioaddr + TX_START);
+	    pcnet_outb(DO_TX | lp->tx_queue, ioaddr + TX_START);
 	    lp->sent = lp->tx_queue ;
 	    lp->tx_queue = 0;
 	    lp->tx_queue_len = 0;
@@ -955,8 +1120,8 @@
 	}
 
 	/* Re-enable interrupts */
-	outb(D_TX_INTR, ioaddr + TX_INTR);
-	outb(D_RX_INTR, ioaddr + RX_INTR);
+	pcnet_outb(D_TX_INTR, ioaddr + TX_INTR);
+	pcnet_outb(D_RX_INTR, ioaddr + RX_INTR);
     }
     dev_kfree_skb (skb);
 
@@ -975,78 +1140,78 @@
 
     /* Reset controller */
     if( sram_config == 0 ) 
-	outb(CONFIG0_RST, ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_RST, ioaddr + CONFIG_0);
     else
-	outb(CONFIG0_RST_1, ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_RST_1, ioaddr + CONFIG_0);
 
     /* Power On chip and select bank 0 */
     if (lp->cardtype == MBH10302)
-	outb(BANK_0, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_0, ioaddr + CONFIG_1);
     else
-	outb(BANK_0U, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_0U, ioaddr + CONFIG_1);
 
     /* Set Tx modes */
-    outb(D_TX_MODE, ioaddr + TX_MODE);
+    pcnet_outb(D_TX_MODE, ioaddr + TX_MODE);
     /* set Rx modes */
-    outb(ID_MATCHED, ioaddr + RX_MODE);
+    pcnet_outb(ID_MATCHED, ioaddr + RX_MODE);
 
     /* Set hardware address */
     for (i = 0; i < 6; i++) 
-        outb(dev->dev_addr[i], ioaddr + NODE_ID + i);
+        pcnet_outb(dev->dev_addr[i], ioaddr + NODE_ID + i);
 
     /* Switch to bank 1 */
     if (lp->cardtype == MBH10302)
-	outb(BANK_1, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_1, ioaddr + CONFIG_1);
     else
-	outb(BANK_1U, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_1U, ioaddr + CONFIG_1);
 
     /* set the multicast table to accept none. */
     for (i = 0; i < 6; i++) 
-        outb(0x00, ioaddr + MAR_ADR + i);
+        pcnet_outb(0x00, ioaddr + MAR_ADR + i);
 
     /* Switch to bank 2 (runtime mode) */
     if (lp->cardtype == MBH10302)
-	outb(BANK_2, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_2, ioaddr + CONFIG_1);
     else
-	outb(BANK_2U, ioaddr + CONFIG_1);
+	pcnet_outb(BANK_2U, ioaddr + CONFIG_1);
 
     /* set 16col ctrl bits */
     if( lp->cardtype == TDK || lp->cardtype == CONTEC) 
-        outb(TDK_AUTO_MODE, ioaddr + COL_CTRL);
+        pcnet_outb(TDK_AUTO_MODE, ioaddr + COL_CTRL);
     else
-        outb(AUTO_MODE, ioaddr + COL_CTRL);
+        pcnet_outb(AUTO_MODE, ioaddr + COL_CTRL);
 
     /* clear Reserved Regs */
-    outb(0x00, ioaddr + BMPR12);
-    outb(0x00, ioaddr + BMPR13);
+    pcnet_outb(0x00, ioaddr + BMPR12);
+    pcnet_outb(0x00, ioaddr + BMPR13);
 
     /* reset Skip packet reg. */
-    outb(0x01, ioaddr + RX_SKIP);
+    pcnet_outb(0x01, ioaddr + RX_SKIP);
 
     /* Enable Tx and Rx */
     if( sram_config == 0 )
-	outb(CONFIG0_DFL, ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_DFL, ioaddr + CONFIG_0);
     else
-	outb(CONFIG0_DFL_1, ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_DFL_1, ioaddr + CONFIG_0);
 
     /* Init receive pointer ? */
-    inw(ioaddr + DATAPORT);
-    inw(ioaddr + DATAPORT);
+    pcnet_inw(ioaddr + DATAPORT);
+    pcnet_inw(ioaddr + DATAPORT);
 
     /* Clear all status */
-    outb(0xff, ioaddr + TX_STATUS);
-    outb(0xff, ioaddr + RX_STATUS);
+    pcnet_outb(0xff, ioaddr + TX_STATUS);
+    pcnet_outb(0xff, ioaddr + RX_STATUS);
 
     if (lp->cardtype == MBH10302)
-	outb(INTR_OFF, ioaddr + LAN_CTRL);
+	pcnet_outb(INTR_OFF, ioaddr + LAN_CTRL);
 
     /* Turn on Rx interrupts */
-    outb(D_TX_INTR, ioaddr + TX_INTR);
-    outb(D_RX_INTR, ioaddr + RX_INTR);
+    pcnet_outb(D_TX_INTR, ioaddr + TX_INTR);
+    pcnet_outb(D_RX_INTR, ioaddr + RX_INTR);
 
     /* Turn on interrupts from LAN card controller */
     if (lp->cardtype == MBH10302)
-	outb(INTR_ON, ioaddr + LAN_CTRL);
+	pcnet_outb(INTR_ON, ioaddr + LAN_CTRL);
 } /* fjn_reset */
 
 /*====================================================================*/
@@ -1058,16 +1223,16 @@
     int boguscount = 10;	/* 5 -> 10: by agy 19940922 */
 
     DEBUG(4, "%s: in rx_packet(), rx_status %02x.\n",
-	  dev->name, inb(ioaddr + RX_STATUS));
+	  dev->name, pcnet_inb(ioaddr + RX_STATUS));
 
-    while ((inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {
-	u_short status = inw(ioaddr + DATAPORT);
+    while ((pcnet_inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {
+	u_short status = pcnet_inw(ioaddr + DATAPORT);
 
 	DEBUG(4, "%s: Rxing packet mode %02x status %04x.\n",
-	      dev->name, inb(ioaddr + RX_MODE), status);
+	      dev->name, pcnet_inb(ioaddr + RX_MODE), status);
 #ifndef final_version
 	if (status == 0) {
-	    outb(F_SKP_PKT, ioaddr + RX_SKIP);
+	    pcnet_outb(F_SKP_PKT, ioaddr + RX_SKIP);
 	    break;
 	}
 #endif
@@ -1078,14 +1243,14 @@
 	    if (status & F_CRC_ERR) lp->stats.rx_crc_errors++;
 	    if (status & F_OVR_FLO) lp->stats.rx_over_errors++;
 	} else {
-	    u_short pkt_len = inw(ioaddr + DATAPORT);
+	    u_short pkt_len = pcnet_inw(ioaddr + DATAPORT);
 	    /* Malloc up new buffer. */
 	    struct sk_buff *skb;
 
 	    if (pkt_len > 1550) {
 		printk(KERN_NOTICE "%s: The FMV-18x claimed a very "
 		       "large packet, size %d.\n", dev->name, pkt_len);
-		outb(F_SKP_PKT, ioaddr + RX_SKIP);
+		pcnet_outb(F_SKP_PKT, ioaddr + RX_SKIP);
 		lp->stats.rx_errors++;
 		break;
 	    }
@@ -1093,14 +1258,14 @@
 	    if (skb == NULL) {
 		printk(KERN_NOTICE "%s: Memory squeeze, dropping "
 		       "packet (len %d).\n", dev->name, pkt_len);
-		outb(F_SKP_PKT, ioaddr + RX_SKIP);
+		pcnet_outb(F_SKP_PKT, ioaddr + RX_SKIP);
 		lp->stats.rx_dropped++;
 		break;
 	    }
 	    skb->dev = dev;
 
 	    skb_reserve(skb, 2);
-	    insw(ioaddr + DATAPORT, skb_put(skb, pkt_len),
+	    pcnet_insw(ioaddr + DATAPORT, skb_put(skb, pkt_len),
 		 (pkt_len + 1) >> 1);
 	    skb->protocol = eth_type_trans(skb, dev);
 
@@ -1131,15 +1296,15 @@
     if (lp->cardtype != TDK) {
 	int i;
 	for (i = 0; i < 20; i++) {
-	    if ((inb(ioaddr + RX_MODE) & F_BUF_EMP) == F_BUF_EMP)
+	    if ((pcnet_inb(ioaddr + RX_MODE) & F_BUF_EMP) == F_BUF_EMP)
 		break;
-	    (void)inw(ioaddr + DATAPORT);  /+ dummy status read +/
-	    outb(F_SKP_PKT, ioaddr + RX_SKIP);
+	    (void)pcnet_inw(ioaddr + DATAPORT);  /+ dummy status read +/
+	    pcnet_outb(F_SKP_PKT, ioaddr + RX_SKIP);
 	}
 
 	if (i > 0)
 	    DEBUG(5, "%s: Exint Rx packet with mode %02x after "
-		  "%d ticks.\n", dev->name, inb(ioaddr + RX_MODE), i);
+		  "%d ticks.\n", dev->name, pcnet_inb(ioaddr + RX_MODE), i);
     }
 */
 
@@ -1218,18 +1383,18 @@
 
     /* Set configuration register 0 to disable Tx and Rx. */
     if( sram_config == 0 ) 
-	outb(CONFIG0_RST ,ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_RST ,ioaddr + CONFIG_0);
     else
-	outb(CONFIG0_RST_1 ,ioaddr + CONFIG_0);
+	pcnet_outb(CONFIG0_RST_1 ,ioaddr + CONFIG_0);
 
     /* Update the statistics -- ToDo. */
 
     /* Power-down the chip.  Green, green, green! */
-    outb(CHIP_OFF ,ioaddr + CONFIG_1);
+    pcnet_outb(CHIP_OFF ,ioaddr + CONFIG_1);
 
     /* Set the ethernet adaptor disable IRQ */
     if (lp->cardtype == MBH10302)
-	outb(INTR_OFF, ioaddr + LAN_CTRL);
+	pcnet_outb(INTR_OFF, ioaddr + LAN_CTRL);
 
     link->open--;
 
@@ -1262,15 +1427,15 @@
 	/* Unconditionally log net taps. */
 	printk("%s: Promiscuous mode enabled.\n", dev->name);
 	memset(mc_filter, 0xff, sizeof(mc_filter));
-	outb(3, ioaddr + RX_MODE);	/* Enable promiscuous mode */
+	pcnet_outb(3, ioaddr + RX_MODE);	/* Enable promiscuous mode */
     } else if (dev->mc_count > MC_FILTERBREAK
 	       ||  (dev->flags & IFF_ALLMULTI)) {
 	/* Too many to filter perfectly -- accept all multicasts. */
 	memset(mc_filter, 0xff, sizeof(mc_filter));
-	outb(2, ioaddr + RX_MODE);	/* Use normal mode. */
+	pcnet_outb(2, ioaddr + RX_MODE);	/* Use normal mode. */
     } else if (dev->mc_count == 0) {
 	memset(mc_filter, 0x00, sizeof(mc_filter));
-	outb(1, ioaddr + RX_MODE);	/* Ignore almost all multicasts. */
+	pcnet_outb(1, ioaddr + RX_MODE);	/* Ignore almost all multicasts. */
     } else {
 	struct dev_mc_list *mclist;
 	int i;
@@ -1286,13 +1451,13 @@
 
     local_irq_save(flags); 
     if (memcmp(mc_filter, lp->mc_filter, sizeof(mc_filter))) {
-	int saved_bank = inb(ioaddr + CONFIG_1);
+	int saved_bank = pcnet_inb(ioaddr + CONFIG_1);
 	/* Switch to bank 1 and set the multicast table. */
-	outb(0xe4, ioaddr + CONFIG_1);
+	pcnet_outb(0xe4, ioaddr + CONFIG_1);
 	for (i = 0; i < 8; i++)
-	    outb(mc_filter[i], ioaddr + 8 + i);
+	    pcnet_outb(mc_filter[i], ioaddr + 8 + i);
 	memcpy(lp->mc_filter, mc_filter, sizeof(mc_filter));
-	outb(saved_bank, ioaddr + CONFIG_1);
+	pcnet_outb(saved_bank, ioaddr + CONFIG_1);
     }
     local_irq_restore(flags);
 }
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/ibmtr_cs.c linux-2.6.8.1/drivers/net/pcmcia/ibmtr_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/ibmtr_cs.c	2004-08-14 19:55:33.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/ibmtr_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -82,6 +82,147 @@
 #define DEBUG(n, args...)
 #endif
 
+
+
+static
+void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+
+
+
 /*====================================================================*/
 
 /* Parameters that can be set with 'insmod' */
@@ -492,15 +633,15 @@
 
     /* First nibble provides 4 bits of mmio */
     i = (mmiobase >> 16) & 0x0F;
-    outb(i, dev->base_addr);
+    pcnet_outb(i, dev->base_addr);
 
     /* Second nibble provides 3 bits of mmio */
     i = 0x10 | ((mmiobase >> 12) & 0x0E);
-    outb(i, dev->base_addr);
+    pcnet_outb(i, dev->base_addr);
 
     /* Third nibble, hard-coded values */
     i = 0x26;
-    outb(i, dev->base_addr);
+    pcnet_outb(i, dev->base_addr);
 
     /* Fourth nibble sets shared ram page size */
 
@@ -513,10 +654,10 @@
 	i |= 2;
     if (dev->base_addr == 0xA24)
 	i |= 1;
-    outb(i, dev->base_addr);
+    pcnet_outb(i, dev->base_addr);
 
     /* 0x40 will release the card for use */
-    outb(0x40, dev->base_addr);
+    pcnet_outb(0x40, dev->base_addr);
 
     return;
 }
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/nmclan_cs.c linux-2.6.8.1/drivers/net/pcmcia/nmclan_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/nmclan_cs.c	2004-08-14 19:54:48.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/nmclan_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -157,6 +157,150 @@
 #include <asm/system.h>
 #include <asm/bitops.h>
 
+
+static
+void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+/*
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+*/
+
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+/*
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+*/
+
+
+
 /* ----------------------------------------------------------------------------
 Defines
 ---------------------------------------------------------------------------- */
@@ -295,7 +439,7 @@
 #define MACE_UTR_RESERVED		0x01
 
 /* Switch MACE register bank (only 0 and 1 are valid) */
-#define MACEBANK(win_num) outb((win_num), ioaddr + AM2150_MACE_BANK)
+#define MACEBANK(win_num) pcnet_outb((win_num), ioaddr + AM2150_MACE_BANK)
 
 #define MACE_IMR_DEFAULT \
   (0xFF - \
@@ -579,12 +723,12 @@
 
   switch (reg >> 4) {
     case 0: /* register 0-15 */
-      data = inb(ioaddr + AM2150_MACE_BASE + reg);
+      data = pcnet_inb(ioaddr + AM2150_MACE_BASE + reg);
       break;
     case 1: /* register 16-31 */
       spin_lock_irqsave(&lp->bank_lock, flags);
       MACEBANK(1);
-      data = inb(ioaddr + AM2150_MACE_BASE + (reg & 0x0F));
+      data = pcnet_inb(ioaddr + AM2150_MACE_BASE + (reg & 0x0F));
       MACEBANK(0);
       spin_unlock_irqrestore(&lp->bank_lock, flags);
       break;
@@ -605,12 +749,12 @@
 
   switch (reg >> 4) {
     case 0: /* register 0-15 */
-      outb(data & 0xFF, ioaddr + AM2150_MACE_BASE + reg);
+      pcnet_outb(data & 0xFF, ioaddr + AM2150_MACE_BASE + reg);
       break;
     case 1: /* register 16-31 */
       spin_lock_irqsave(&lp->bank_lock, flags);
       MACEBANK(1);
-      outb(data & 0xFF, ioaddr + AM2150_MACE_BASE + (reg & 0x0F));
+      pcnet_outb(data & 0xFF, ioaddr + AM2150_MACE_BASE + (reg & 0x0F));
       MACEBANK(0);
       spin_unlock_irqrestore(&lp->bank_lock, flags);
       break;
@@ -975,7 +1119,7 @@
   DEBUG(2, "%s: shutting down ethercard.\n", dev->name);
 
   /* Mask off all interrupts from the MACE chip. */
-  outb(0xFF, ioaddr + AM2150_MACE_BASE + MACE_IMR);
+  pcnet_outb(0xFF, ioaddr + AM2150_MACE_BASE + MACE_IMR);
 
   link->open--;
   netif_stop_queue(dev);
@@ -1050,7 +1194,7 @@
 
 #if (!TX_INTERRUPTABLE)
   /* Disable MACE TX interrupts. */
-  outb(MACE_IMR_DEFAULT | MACE_IR_XMTINT,
+  pcnet_outb(MACE_IMR_DEFAULT | MACE_IR_XMTINT,
     ioaddr + AM2150_MACE_BASE + MACE_IMR);
   lp->tx_irq_disabled=1;
 #endif /* #if (!TX_INTERRUPTABLE) */
@@ -1066,13 +1210,13 @@
     lp->tx_free_frames--;
 
     /* WARNING: Write the _exact_ number of bytes written in the header! */
-    /* Put out the word header [must be an outw()] . . . */
-    outw(skb->len, ioaddr + AM2150_XMT);
-    /* . . . and the packet [may be any combination of outw() and outb()] */
-    outsw(ioaddr + AM2150_XMT, skb->data, skb->len >> 1);
+    /* Put out the word header [must be an pcnet_outw()] . . . */
+    pcnet_outw(skb->len, ioaddr + AM2150_XMT);
+    /* . . . and the packet [may be any combination of pcnet_outw() and pcnet_outb()] */
+    pcnet_outsw(ioaddr + AM2150_XMT, skb->data, skb->len >> 1);
     if (skb->len & 1) {
       /* Odd byte transfer */
-      outb(skb->data[skb->len-1], ioaddr + AM2150_XMT);
+      pcnet_outb(skb->data[skb->len-1], ioaddr + AM2150_XMT);
     }
 
     dev->trans_start = jiffies;
@@ -1086,7 +1230,7 @@
 #if (!TX_INTERRUPTABLE)
   /* Re-enable MACE TX interrupts. */
   lp->tx_irq_disabled=0;
-  outb(MACE_IMR_DEFAULT, ioaddr + AM2150_MACE_BASE + MACE_IMR);
+  pcnet_outb(MACE_IMR_DEFAULT, ioaddr + AM2150_MACE_BASE + MACE_IMR);
 #endif /* #if (!TX_INTERRUPTABLE) */
 
   dev_kfree_skb(skb);
@@ -1120,8 +1264,8 @@
        KERN_NOTICE "%s: Re-entering the interrupt handler "
        "[isr=%02X, imr=%02X]\n"),
       dev->name,
-      inb(ioaddr + AM2150_MACE_BASE + MACE_IR),
-      inb(ioaddr + AM2150_MACE_BASE + MACE_IMR)
+      pcnet_inb(ioaddr + AM2150_MACE_BASE + MACE_IR),
+      pcnet_inb(ioaddr + AM2150_MACE_BASE + MACE_IMR)
     );
     /* WARNING: MACE_IR has been read! */
     return IRQ_NONE;
@@ -1134,7 +1278,7 @@
 
   do {
     /* WARNING: MACE_IR is a READ/CLEAR port! */
-    status = inb(ioaddr + AM2150_MACE_BASE + MACE_IR);
+    status = pcnet_inb(ioaddr + AM2150_MACE_BASE + MACE_IR);
 
     DEBUG(3, "mace_interrupt: irq 0x%X status 0x%X.\n", irq, status);
 
@@ -1147,19 +1291,19 @@
       unsigned char xmtrc;
       unsigned char xmtfs;
 
-      fifofc = inb(ioaddr + AM2150_MACE_BASE + MACE_FIFOFC);
+      fifofc = pcnet_inb(ioaddr + AM2150_MACE_BASE + MACE_FIFOFC);
       if ((fifofc & MACE_FIFOFC_XMTFC)==0) {
 	lp->linux_stats.tx_errors++;
-	outb(0xFF, ioaddr + AM2150_XMT_SKIP);
+	pcnet_outb(0xFF, ioaddr + AM2150_XMT_SKIP);
       }
 
       /* Transmit Retry Count (XMTRC, reg 4) */
-      xmtrc = inb(ioaddr + AM2150_MACE_BASE + MACE_XMTRC);
+      xmtrc = pcnet_inb(ioaddr + AM2150_MACE_BASE + MACE_XMTRC);
       if (xmtrc & MACE_XMTRC_EXDEF) lp->mace_stats.exdef++;
       lp->mace_stats.xmtrc += (xmtrc & MACE_XMTRC_XMTRC);
 
       if (
-        (xmtfs = inb(ioaddr + AM2150_MACE_BASE + MACE_XMTFS)) &
+        (xmtfs = pcnet_inb(ioaddr + AM2150_MACE_BASE + MACE_XMTFS)) &
         MACE_XMTFS_XMTSV /* Transmit Status Valid */
       ) {
 	lp->mace_stats.xmtsv++;
@@ -1249,11 +1393,11 @@
   unsigned short rx_status;
 
   while (
-    ((rx_framecnt = inb(ioaddr + AM2150_RCV_FRAME_COUNT)) > 0) &&
+    ((rx_framecnt = pcnet_inb(ioaddr + AM2150_RCV_FRAME_COUNT)) > 0) &&
     (rx_framecnt <= 12) && /* rx_framecnt==0xFF if card is extracted. */
     (RxCnt--)
   ) {
-    rx_status = inw(ioaddr + AM2150_RCV);
+    rx_status = pcnet_inw(ioaddr + AM2150_RCV);
 
     DEBUG(3, "%s: in mace_rx(), framecnt 0x%X, rx_status"
 	  " 0x%X.\n", dev->name, rx_framecnt, rx_status);
@@ -1277,9 +1421,9 @@
         /* Auto Strip is off, always subtract 4 */
       struct sk_buff *skb;
 
-      lp->mace_stats.rfs_rntpc += inb(ioaddr + AM2150_RCV);
+      lp->mace_stats.rfs_rntpc += pcnet_inb(ioaddr + AM2150_RCV);
         /* runt packet count */
-      lp->mace_stats.rfs_rcvcc += inb(ioaddr + AM2150_RCV);
+      lp->mace_stats.rfs_rcvcc += pcnet_inb(ioaddr + AM2150_RCV);
         /* rcv collision count */
 
       DEBUG(3, "    receiving packet size 0x%X rx_status"
@@ -1291,9 +1435,9 @@
 	skb->dev = dev;
 
 	skb_reserve(skb, 2);
-	insw(ioaddr + AM2150_RCV, skb_put(skb, pkt_len), pkt_len>>1);
+	pcnet_insw(ioaddr + AM2150_RCV, skb_put(skb, pkt_len), pkt_len>>1);
 	if (pkt_len & 1)
-	    *(skb->tail-1) = inb(ioaddr + AM2150_RCV);
+	    *(skb->tail-1) = pcnet_inb(ioaddr + AM2150_RCV);
 	skb->protocol = eth_type_trans(skb, dev);
 	
 	netif_rx(skb); /* Send the packet to the upper (protocol) layers. */
@@ -1301,7 +1445,7 @@
 	dev->last_rx = jiffies;
 	lp->linux_stats.rx_packets++;
 	lp->linux_stats.rx_bytes += skb->len;
-	outb(0xFF, ioaddr + AM2150_RCV_NEXT); /* skip to next frame */
+	pcnet_outb(0xFF, ioaddr + AM2150_RCV_NEXT); /* skip to next frame */
 	continue;
       } else {
 	DEBUG(1, "%s: couldn't allocate a sk_buff of size"
@@ -1309,7 +1453,7 @@
 	lp->linux_stats.rx_dropped++;
       }
     }
-    outb(0xFF, ioaddr + AM2150_RCV_NEXT); /* skip to next frame */
+    pcnet_outb(0xFF, ioaddr + AM2150_RCV_NEXT); /* skip to next frame */
   } /* while */
 
   return 0;
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/pcnet_cs.c linux-2.6.8.1/drivers/net/pcmcia/pcnet_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/pcnet_cs.c	2004-08-14 19:56:00.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/pcnet_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -79,6 +79,149 @@
 #define DEBUG(n, args...)
 #endif
 
+static
+void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+
+
+
+
+/*
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+*/
+
+
 /*====================================================================*/
 
 /* Module parameters */
@@ -426,10 +569,10 @@
     mdelay(10);
 
     for (i = 0; i < sizeof(program_seq)/sizeof(program_seq[0]); i++)
-	outb_p(program_seq[i].value, ioaddr + program_seq[i].offset);
+	pcnet_outb_p(program_seq[i].value, ioaddr + program_seq[i].offset);
 
     for (i = 0; i < 32; i++)
-	prom[i] = inb(ioaddr + PCNET_DATAPORT);
+	prom[i] = pcnet_inb(ioaddr + PCNET_DATAPORT);
     for (i = 0; i < NR_INFO; i++) {
 	if ((prom[0] == hw_info[i].a0) &&
 	    (prom[2] == hw_info[i].a1) &&
@@ -457,12 +600,12 @@
     u_char sum;
 
     for (sum = 0, i = 0x14; i < 0x1c; i++)
-	sum += inb_p(dev->base_addr + i);
+	sum += pcnet_inb_p(dev->base_addr + i);
     if (sum != 0xff)
 	return NULL;
     for (i = 0; i < 6; i++)
-	dev->dev_addr[i] = inb_p(dev->base_addr + 0x14 + i);
-    i = inb(dev->base_addr + 0x1f);
+	dev->dev_addr[i] = pcnet_inb_p(dev->base_addr + 0x14 + i);
+    i = pcnet_inb(dev->base_addr + 0x1f);
     return ((i == 0x91)||(i == 0x99)) ? &dl10022_info : &dl10019_info;
 }
 
@@ -482,10 +625,10 @@
     if (link->conf.ConfigBase != 0x03c0)
 	return NULL;
 
-    outb_p(0x01, ioaddr + EN0_DCFG);	/* Set word-wide access. */
-    outb_p(0x00, ioaddr + EN0_RSARLO);	/* DMA starting at 0x0400. */
-    outb_p(0x04, ioaddr + EN0_RSARHI);
-    outb_p(E8390_RREAD+E8390_START, ioaddr + E8390_CMD);
+    pcnet_outb_p(0x01, ioaddr + EN0_DCFG);	/* Set word-wide access. */
+    pcnet_outb_p(0x00, ioaddr + EN0_RSARLO);	/* DMA starting at 0x0400. */
+    pcnet_outb_p(0x04, ioaddr + EN0_RSARHI);
+    pcnet_outb_p(E8390_RREAD+E8390_START, ioaddr + E8390_CMD);
 
     for (i = 0; i < 6; i += 2) {
 	j = inw(ioaddr + PCNET_DATAPORT);
@@ -713,7 +856,7 @@
     SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
 
     if (info->flags & (IS_DL10019|IS_DL10022)) {
-	u_char id = inb(dev->base_addr + 0x1a);
+	u_char id = pcnet_inb(dev->base_addr + 0x1a);
 	dev->do_ioctl = &ei_ioctl;
 	mii_phy_probe(dev);
 	if ((id == 0x30) && !info->pna_phy && (info->eth_phy == 4))
@@ -723,6 +866,8 @@
     link->dev = &info->node;
     link->state &= ~DEV_CONFIG_PENDING;
 
+//    SET_NETDEV_DEV(dev, &handle_to_dev(handle));
+
 #ifdef CONFIG_NET_POLL_CONTROLLER
     dev->poll_controller = ei_poll;
 #endif
@@ -736,7 +881,7 @@
     strcpy(info->node.dev_name, dev->name);
 
     if (info->flags & (IS_DL10019|IS_DL10022)) {
-	u_char id = inb(dev->base_addr + 0x1a);
+	u_char id = pcnet_inb(dev->base_addr + 0x1a);
 	printk(KERN_INFO "%s: NE2000 (DL100%d rev %02x): ",
 	       dev->name, ((info->flags & IS_DL10022) ? 22 : 19), id);
 	if (info->pna_phy)
@@ -864,28 +1009,28 @@
 
 static void mdio_sync(ioaddr_t addr)
 {
-    int bits, mask = inb(addr) & MDIO_MASK;
+    int bits, mask = pcnet_inb(addr) & MDIO_MASK;
     for (bits = 0; bits < 32; bits++) {
-	outb(mask | MDIO_DATA_WRITE1, addr);
-	outb(mask | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(mask | MDIO_DATA_WRITE1, addr);
+	pcnet_outb(mask | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);
     }
 }
 
 static int mdio_read(ioaddr_t addr, int phy_id, int loc)
 {
     u_int cmd = (0x06<<10)|(phy_id<<5)|loc;
-    int i, retval = 0, mask = inb(addr) & MDIO_MASK;
+    int i, retval = 0, mask = pcnet_inb(addr) & MDIO_MASK;
 
     mdio_sync(addr);
     for (i = 13; i >= 0; i--) {
 	int dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-	outb(mask | dat, addr);
-	outb(mask | dat | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(mask | dat, addr);
+	pcnet_outb(mask | dat | MDIO_SHIFT_CLK, addr);
     }
     for (i = 19; i > 0; i--) {
-	outb(mask, addr);
-	retval = (retval << 1) | ((inb(addr) & MDIO_DATA_READ) != 0);
-	outb(mask | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(mask, addr);
+	retval = (retval << 1) | ((pcnet_inb(addr) & MDIO_DATA_READ) != 0);
+	pcnet_outb(mask | MDIO_SHIFT_CLK, addr);
     }
     return (retval>>1) & 0xffff;
 }
@@ -893,27 +1038,27 @@
 static void mdio_write(ioaddr_t addr, int phy_id, int loc, int value)
 {
     u_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;
-    int i, mask = inb(addr) & MDIO_MASK;
+    int i, mask = pcnet_inb(addr) & MDIO_MASK;
 
     mdio_sync(addr);
     for (i = 31; i >= 0; i--) {
 	int dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-	outb(mask | dat, addr);
-	outb(mask | dat | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(mask | dat, addr);
+	pcnet_outb(mask | dat | MDIO_SHIFT_CLK, addr);
     }
     for (i = 1; i >= 0; i--) {
-	outb(mask, addr);
-	outb(mask | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(mask, addr);
+	pcnet_outb(mask | MDIO_SHIFT_CLK, addr);
     }
 }
 
 static void mdio_reset(ioaddr_t addr, int phy_id)
 {
-    outb_p(0x08, addr);
-    outb_p(0x0c, addr);
-    outb_p(0x08, addr);
-    outb_p(0x0c, addr);
-    outb_p(0x00, addr);
+    pcnet_outb_p(0x08, addr);
+    pcnet_outb_p(0x0c, addr);
+    pcnet_outb_p(0x08, addr);
+    pcnet_outb_p(0x0c, addr);
+    pcnet_outb_p(0x00, addr);
 }
 
 /*======================================================================
@@ -939,25 +1084,25 @@
     ioaddr_t ee_addr = ioaddr + DLINK_EEPROM;
     int read_cmd = location | (EE_READ_CMD << 8);
 
-    outb(0, ee_addr);
-    outb(EE_EEP|EE_CS, ee_addr);
+    pcnet_outb(0, ee_addr);
+    pcnet_outb(EE_EEP|EE_CS, ee_addr);
 
     /* Shift the read command bits out. */
     for (i = 10; i >= 0; i--) {
 	short dataval = (read_cmd & (1 << i)) ? EE_DO : 0;
-	outb_p(EE_EEP|EE_CS|dataval, ee_addr);
-	outb_p(EE_EEP|EE_CS|dataval|EE_CK, ee_addr);
+	pcnet_outb_p(EE_EEP|EE_CS|dataval, ee_addr);
+	pcnet_outb_p(EE_EEP|EE_CS|dataval|EE_CK, ee_addr);
     }
-    outb(EE_EEP|EE_CS, ee_addr);
+    pcnet_outb(EE_EEP|EE_CS, ee_addr);
 
     for (i = 16; i > 0; i--) {
-	outb_p(EE_EEP|EE_CS | EE_CK, ee_addr);
-	retval = (retval << 1) | ((inb(ee_addr) & EE_DI) ? 1 : 0);
-	outb_p(EE_EEP|EE_CS, ee_addr);
+	pcnet_outb_p(EE_EEP|EE_CS | EE_CK, ee_addr);
+	retval = (retval << 1) | ((pcnet_inb(ee_addr) & EE_DI) ? 1 : 0);
+	pcnet_outb_p(EE_EEP|EE_CS, ee_addr);
     }
 
     /* Terminate the EEPROM access. */
-    outb(0, ee_addr);
+    pcnet_outb(0, ee_addr);
     return retval;
 }
 
@@ -976,36 +1121,36 @@
 
 	asic_data |= read_eeprom(ioaddr, location);
 
-	outb(0, ee_addr);
-	outb(EE_ASIC|EE_CS|EE_DI, ee_addr);
+	pcnet_outb(0, ee_addr);
+	pcnet_outb(EE_ASIC|EE_CS|EE_DI, ee_addr);
 
 	read_cmd = read_cmd >> 1;
 
 	/* Shift the read command bits out. */
 	for (i = 9; i >= 0; i--) {
 		dataval = (read_cmd & (1 << i)) ? EE_DO : 0;
-		outb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);
-		outb_p(EE_ASIC|EE_CS|EE_DI|dataval|EE_CK, ee_addr);
-		outb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);
+		pcnet_outb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);
+		pcnet_outb_p(EE_ASIC|EE_CS|EE_DI|dataval|EE_CK, ee_addr);
+		pcnet_outb_p(EE_ASIC|EE_CS|EE_DI|dataval, ee_addr);
 	}
 	// sync
-	outb(EE_ASIC|EE_CS, ee_addr);
-	outb(EE_ASIC|EE_CS|EE_CK, ee_addr);
-	outb(EE_ASIC|EE_CS, ee_addr);
+	pcnet_outb(EE_ASIC|EE_CS, ee_addr);
+	pcnet_outb(EE_ASIC|EE_CS|EE_CK, ee_addr);
+	pcnet_outb(EE_ASIC|EE_CS, ee_addr);
 
 	for (i = 15; i >= 0; i--) {
 		dataval = (asic_data & (1 << i)) ? EE_ADOT : 0;
-		outb_p(EE_ASIC|EE_CS|dataval, ee_addr);
-		outb_p(EE_ASIC|EE_CS|dataval|EE_CK, ee_addr);
-		outb_p(EE_ASIC|EE_CS|dataval, ee_addr);
+		pcnet_outb_p(EE_ASIC|EE_CS|dataval, ee_addr);
+		pcnet_outb_p(EE_ASIC|EE_CS|dataval|EE_CK, ee_addr);
+		pcnet_outb_p(EE_ASIC|EE_CS|dataval, ee_addr);
 	}
 
 	/* Terminate the ASIC access. */
-	outb(EE_ASIC|EE_DI, ee_addr);
-	outb(EE_ASIC|EE_DI| EE_CK, ee_addr);
-	outb(EE_ASIC|EE_DI, ee_addr);
+	pcnet_outb(EE_ASIC|EE_DI, ee_addr);
+	pcnet_outb(EE_ASIC|EE_DI| EE_CK, ee_addr);
+	pcnet_outb(EE_ASIC|EE_DI, ee_addr);
 
-	outb(0, ee_addr);
+	pcnet_outb(0, ee_addr);
 }
 
 /*====================================================================*/
@@ -1017,14 +1162,14 @@
     u_char tmp;
     
     if (info->flags & HAS_MISC_REG) {
-	tmp = inb_p(nic_base + PCNET_MISC) & ~3;
+	tmp = pcnet_inb_p(nic_base + PCNET_MISC) & ~3;
 	if (dev->if_port == 2)
 	    tmp |= 1;
 	if (info->flags & USE_BIG_BUF)
 	    tmp |= 2;
 	if (info->flags & HAS_IBM_MISC)
 	    tmp |= 8;
-	outb_p(tmp, nic_base + PCNET_MISC);
+	pcnet_outb_p(tmp, nic_base + PCNET_MISC);
     }
     if (info->flags & IS_DL10022) {
 	if (info->flags & HAS_MII) {
@@ -1034,7 +1179,7 @@
 	    mdio_write(nic_base + DLINK_GPIO, info->eth_phy, 0, 0x1200);
 	    info->mii_reset = jiffies;
 	} else {
-	    outb(full_duplex ? 4 : 0, nic_base + DLINK_DIAG);
+	    pcnet_outb(full_duplex ? 4 : 0, nic_base + DLINK_DIAG);
 	}
     }
 }
@@ -1124,16 +1269,16 @@
 
     ei_status.txing = ei_status.dmaing = 0;
 
-    outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);
+    pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);
 
-    outb(inb(nic_base + PCNET_RESET), nic_base + PCNET_RESET);
+    pcnet_outb(pcnet_inb(nic_base + PCNET_RESET), nic_base + PCNET_RESET);
 
     for (i = 0; i < 100; i++) {
-	if ((inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)
+	if ((pcnet_inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)
 	    break;
 	udelay(100);
     }
-    outb_p(ENISR_RESET, nic_base + EN0_ISR); /* Ack intr. */
+    pcnet_outb_p(ENISR_RESET, nic_base + EN0_ISR); /* Ack intr. */
     
     if (i == 100)
 	printk(KERN_ERR "%s: pcnet_reset_8390() did not complete.\n",
@@ -1185,8 +1330,8 @@
 
     /* Check for pending interrupt with expired latency timer: with
        this, we can limp along even if the interrupt is blocked */
-    outb_p(E8390_NODMA+E8390_PAGE0, nic_base + E8390_CMD);
-    if (info->stale++ && (inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {
+    pcnet_outb_p(E8390_NODMA+E8390_PAGE0, nic_base + E8390_CMD);
+    if (info->stale++ && (pcnet_inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {
 	if (!info->fast_poll)
 	    printk(KERN_INFO "%s: interrupt(s) dropped!\n", dev->name);
 	ei_irq_wrapper(dev->irq, dev, NULL);
@@ -1221,7 +1366,7 @@
 	       (link) ? "found" : "lost");
 	if (link && (info->flags & IS_DL10022)) {
 	    /* Disable collision detection on full duplex links */
-	    outb((p & 0x0140) ? 4 : 0, nic_base + DLINK_DIAG);
+	    pcnet_outb((p & 0x0140) ? 4 : 0, nic_base + DLINK_DIAG);
 	} else if (link && (info->flags & IS_DL10019)) {
 	    /* Disable collision detection on full duplex links */
 	    write_asic(dev->base_addr, 4, (p & 0x140) ? DL19FDUPLX : 0);
@@ -1313,19 +1458,19 @@
     }
     
     ei_status.dmaing |= 0x01;
-    outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);
-    outb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);
-    outb_p(0, nic_base + EN0_RCNTHI);
-    outb_p(0, nic_base + EN0_RSARLO);		/* On page boundary */
-    outb_p(ring_page, nic_base + EN0_RSARHI);
-    outb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);
+    pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);
+    pcnet_outb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);
+    pcnet_outb_p(0, nic_base + EN0_RCNTHI);
+    pcnet_outb_p(0, nic_base + EN0_RSARLO);		/* On page boundary */
+    pcnet_outb_p(ring_page, nic_base + EN0_RSARHI);
+    pcnet_outb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);
 
-    insw(nic_base + PCNET_DATAPORT, hdr,
+    pcnet_insw(nic_base + PCNET_DATAPORT, hdr,
 	    sizeof(struct e8390_pkt_hdr)>>1);
     /* Fix for big endian systems */
     hdr->count = le16_to_cpu(hdr->count);
 
-    outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+    pcnet_outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
     ei_status.dmaing &= ~0x01;
 }
 
@@ -1349,16 +1494,16 @@
 	return;
     }
     ei_status.dmaing |= 0x01;
-    outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);
-    outb_p(count & 0xff, nic_base + EN0_RCNTLO);
-    outb_p(count >> 8, nic_base + EN0_RCNTHI);
-    outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);
-    outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);
-    outb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);
+    pcnet_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + PCNET_CMD);
+    pcnet_outb_p(count & 0xff, nic_base + EN0_RCNTLO);
+    pcnet_outb_p(count >> 8, nic_base + EN0_RCNTHI);
+    pcnet_outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);
+    pcnet_outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);
+    pcnet_outb_p(E8390_RREAD+E8390_START, nic_base + PCNET_CMD);
 
-    insw(nic_base + PCNET_DATAPORT,buf,count>>1);
+    pcnet_insw(nic_base + PCNET_DATAPORT,buf,count>>1);
     if (count & 0x01)
-	buf[count-1] = inb(nic_base + PCNET_DATAPORT), xfer_count++;
+	buf[count-1] = pcnet_inb(nic_base + PCNET_DATAPORT), xfer_count++;
 
     /* This was for the ALPHA version only, but enough people have
        encountering problems that it is still here. */
@@ -1366,10 +1511,10 @@
     if (ei_debug > 4) {		/* DMA termination address check... */
 	int addr, tries = 20;
 	do {
-	    /* DON'T check for 'inb_p(EN0_ISR) & ENISR_RDC' here
+	    /* DON'T check for 'pcnet_pcnet_inb_p(EN0_ISR) & ENISR_RDC' here
 	       -- it's broken for Rx on some cards! */
-	    int high = inb_p(nic_base + EN0_RSARHI);
-	    int low = inb_p(nic_base + EN0_RSARLO);
+	    int high = pcnet_inb_p(nic_base + EN0_RSARHI);
+	    int low = pcnet_inb_p(nic_base + EN0_RSARLO);
 	    addr = (high << 8) + low;
 	    if (((ring_offset + xfer_count) & 0xff) == (addr & 0xff))
 		break;
@@ -1380,7 +1525,7 @@
 		   dev->name, ring_offset + xfer_count, addr);
     }
 #endif
-    outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+    pcnet_outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
     ei_status.dmaing &= ~0x01;
 } /* dma_block_input */
 
@@ -1414,22 +1559,22 @@
     }
     ei_status.dmaing |= 0x01;
     /* We should already be in page 0, but to be safe... */
-    outb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base+PCNET_CMD);
+    pcnet_outb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base+PCNET_CMD);
 
 #ifdef PCMCIA_DEBUG
   retry:
 #endif
 
-    outb_p(ENISR_RDC, nic_base + EN0_ISR);
+    pcnet_outb_p(ENISR_RDC, nic_base + EN0_ISR);
 
     /* Now the normal output. */
-    outb_p(count & 0xff, nic_base + EN0_RCNTLO);
-    outb_p(count >> 8,   nic_base + EN0_RCNTHI);
-    outb_p(0x00, nic_base + EN0_RSARLO);
-    outb_p(start_page, nic_base + EN0_RSARHI);
+    pcnet_outb_p(count & 0xff, nic_base + EN0_RCNTLO);
+    pcnet_outb_p(count >> 8,   nic_base + EN0_RCNTHI);
+    pcnet_outb_p(0x00, nic_base + EN0_RSARLO);
+    pcnet_outb_p(start_page, nic_base + EN0_RSARHI);
 
-    outb_p(E8390_RWRITE+E8390_START, nic_base + PCNET_CMD);
-    outsw(nic_base + PCNET_DATAPORT, buf, count>>1);
+    pcnet_outb_p(E8390_RWRITE+E8390_START, nic_base + PCNET_CMD);
+    pcnet_outsw(nic_base + PCNET_DATAPORT, (void *)buf, count>>1);
 
     dma_start = jiffies;
 
@@ -1439,8 +1584,8 @@
     if (ei_debug > 4) {	/* DMA termination address check... */
 	int addr, tries = 20;
 	do {
-	    int high = inb_p(nic_base + EN0_RSARHI);
-	    int low = inb_p(nic_base + EN0_RSARLO);
+	    int high = pcnet_inb_p(nic_base + EN0_RSARHI);
+	    int low = pcnet_inb_p(nic_base + EN0_RSARLO);
 	    addr = (high << 8) + low;
 	    if ((start_page << 8) + count == addr)
 		break;
@@ -1455,7 +1600,7 @@
     }
 #endif
 
-    while ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)
+    while ((pcnet_inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)
 	if (time_after(jiffies, dma_start + PCNET_RDC_TIMEOUT)) {
 	    printk(KERN_NOTICE "%s: timeout waiting for Tx RDC.\n",
 		   dev->name);
@@ -1464,7 +1609,7 @@
 	    break;
 	}
 
-    outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+    pcnet_outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
     if (info->flags & DELAY_OUTPUT)
 	udelay((long)delay_time);
     ei_status.dmaing &= ~0x01;
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/smc91c92_cs.c linux-2.6.8.1/drivers/net/pcmcia/smc91c92_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/smc91c92_cs.c	2004-08-14 19:55:47.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/smc91c92_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -93,6 +93,170 @@
 #define DRV_NAME	"smc91c92_cs"
 #define DRV_VERSION	"1.122"
 
+
+
+
+
+static
+void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+/*
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+*/
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+
+/*
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+*/
+static
+unsigned char pcnet_readb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return readb(port);
+
+#endif
+}
+
+static
+void pcnet_writeb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	writeb(addr, port);
+#endif
+}
+
+
+
 /*====================================================================*/
 
 /* Operational parameter that usually are not changed. */
@@ -159,7 +323,7 @@
 
 /* Symbolic constants for the SMC91c9* series chips, from Erik Stahlman. */
 #define	BANK_SELECT		14		/* Window select register. */
-#define SMC_SELECT_BANK(x)  { outw(x, ioaddr + BANK_SELECT); }
+#define SMC_SELECT_BANK(x)  { pcnet_outw(x, ioaddr + BANK_SELECT); }
 
 /* Bank 0 registers. */
 #define	TCR 		0	/* transmit control register */
@@ -275,8 +439,8 @@
 #define RS_MULTICAST	0x0001
 #define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
 
-#define set_bits(v, p) outw(inw(p)|(v), (p))
-#define mask_bits(v, p) outw(inw(p)&(v), (p))
+#define set_bits(v, p) pcnet_outw(pcnet_inw(p)|(v), (p))
+#define mask_bits(v, p) pcnet_outw(pcnet_inw(p)&(v), (p))
 
 /*====================================================================*/
 
@@ -488,17 +652,17 @@
     u_char tmp;
 
     /* Read the ISR twice... */
-    readb(smc->base+MEGAHERTZ_ISR);
+    pcnet_readb((unsigned long)(smc->base+MEGAHERTZ_ISR));
     udelay(5);
-    readb(smc->base+MEGAHERTZ_ISR);
+    pcnet_readb((unsigned long)(smc->base+MEGAHERTZ_ISR));
 
     /* Pause 200ms... */
     mdelay(200);
 
     /* Now read and write the COR... */
-    tmp = readb(smc->base + link->conf.ConfigBase + CISREG_COR);
+    tmp = pcnet_readb((unsigned long)(smc->base + link->conf.ConfigBase + CISREG_COR));
     udelay(5);
-    writeb(tmp, smc->base + link->conf.ConfigBase + CISREG_COR);
+    pcnet_writeb(tmp, (unsigned long)(smc->base + link->conf.ConfigBase + CISREG_COR));
 
     return 0;
 }
@@ -624,14 +788,14 @@
     ioaddr_t iouart = link->io.BasePort2;
 
     /* Set UART base address and force map with COR bit 1 */
-    writeb(iouart & 0xff,        smc->base + MOT_UART + CISREG_IOBASE_0);
-    writeb((iouart >> 8) & 0xff, smc->base + MOT_UART + CISREG_IOBASE_1);
-    writeb(MOT_NORMAL,           smc->base + MOT_UART + CISREG_COR);
+    pcnet_writeb(iouart & 0xff,        (unsigned long)(smc->base + MOT_UART + CISREG_IOBASE_0));
+    pcnet_writeb((iouart >> 8) & 0xff, (unsigned long)(smc->base + MOT_UART + CISREG_IOBASE_1));
+    pcnet_writeb(MOT_NORMAL,           (unsigned long)(smc->base + MOT_UART + CISREG_COR));
 
     /* Set SMC base address and force map with COR bit 1 */
-    writeb(ioaddr & 0xff,        smc->base + MOT_LAN + CISREG_IOBASE_0);
-    writeb((ioaddr >> 8) & 0xff, smc->base + MOT_LAN + CISREG_IOBASE_1);
-    writeb(MOT_NORMAL,           smc->base + MOT_LAN + CISREG_COR);
+    pcnet_writeb(ioaddr & 0xff,        (unsigned long)(smc->base + MOT_LAN + CISREG_IOBASE_0));
+    pcnet_writeb((ioaddr >> 8) & 0xff, (unsigned long)(smc->base + MOT_LAN + CISREG_IOBASE_1));
+    pcnet_writeb(MOT_NORMAL,           (unsigned long)(smc->base + MOT_LAN + CISREG_COR));
 
     /* Wait for things to settle down */
     mdelay(100);
@@ -648,20 +812,20 @@
 
     for (i = 0; i < 3; i++) {
 	SMC_SELECT_BANK(2);
-	outw(MOT_EEPROM + i, ioaddr + POINTER);
+	pcnet_outw(MOT_EEPROM + i, ioaddr + POINTER);
 	SMC_SELECT_BANK(1);
-	outw((CTL_RELOAD | CTL_EE_SELECT), ioaddr + CONTROL);
+	pcnet_outw((CTL_RELOAD | CTL_EE_SELECT), ioaddr + CONTROL);
 
 	for (loop = wait = 0; loop < 200; loop++) {
 	    udelay(10);
-	    wait = ((CTL_RELOAD | CTL_STORE) & inw(ioaddr + CONTROL));
+	    wait = ((CTL_RELOAD | CTL_STORE) & pcnet_inw(ioaddr + CONTROL));
 	    if (wait == 0) break;
 	}
 	
 	if (wait)
 	    return -1;
 	
-	addr = inw(ioaddr + GENERAL);
+	addr = pcnet_inw(ioaddr + GENERAL);
 	dev->dev_addr[2*i]   = addr & 0xff;
 	dev->dev_addr[2*i+1] = (addr >> 8) & 0xff;
     }
@@ -811,7 +975,7 @@
 	 (cardid == PRODID_PSION_NET100))) {
 	/* Download the Seven of Diamonds firmware */
 	for (i = 0; i < sizeof(__Xilinx7OD); i++) {
-	    outb(__Xilinx7OD[i], link->io.BasePort1+2);
+	    pcnet_outb(__Xilinx7OD[i], link->io.BasePort1+2);
 	    udelay(50);
 	}
     } else if (manfid == MANFID_OSITECH) {
@@ -820,8 +984,8 @@
 	/* Now, turn on the interrupt for both card functions */
 	set_bits(0x300, link->io.BasePort1 + OSITECH_RESET_ISR);
 	DEBUG(2, "AUI/PWR: %4.4x RESET/ISR: %4.4x\n",
-	      inw(link->io.BasePort1 + OSITECH_AUI_PWR),
-	      inw(link->io.BasePort1 + OSITECH_RESET_ISR));
+	      pcnet_inw(link->io.BasePort1 + OSITECH_AUI_PWR),
+	      pcnet_inw(link->io.BasePort1 + OSITECH_RESET_ISR));
     }
 
     return 0;
@@ -842,27 +1006,27 @@
     u_short s;
 
     SMC_SELECT_BANK(1);
-    if (inw(ioaddr + BANK_SELECT) >> 8 != 0x33) {
+    if (pcnet_inw(ioaddr + BANK_SELECT) >> 8 != 0x33) {
 	/* Try powering up the chip */
-	outw(0, ioaddr + CONTROL);
+	pcnet_outw(0, ioaddr + CONTROL);
 	mdelay(55);
     }
 
     /* Try setting bus width */
     width = (link->io.Attributes1 == IO_DATA_PATH_WIDTH_AUTO);
-    s = inb(ioaddr + CONFIG);
+    s = pcnet_inb(ioaddr + CONFIG);
     if (width)
 	s |= CFG_16BIT;
     else
 	s &= ~CFG_16BIT;
-    outb(s, ioaddr + CONFIG);
+    pcnet_outb(s, ioaddr + CONFIG);
 
     /* Check Base Address Register to make sure bus width is OK */
-    s = inw(ioaddr + BASE_ADDR);
-    if ((inw(ioaddr + BANK_SELECT) >> 8 == 0x33) &&
+    s = pcnet_inw(ioaddr + BASE_ADDR);
+    if ((pcnet_inw(ioaddr + BANK_SELECT) >> 8 == 0x33) &&
 	((s >> 8) != (s & 0xff))) {
 	SMC_SELECT_BANK(3);
-	s = inw(ioaddr + REVISION);
+	s = pcnet_inw(ioaddr + REVISION);
 	return (s & 0xff);
     }
 
@@ -993,13 +1157,13 @@
     if (rev > 0) {
 	u_long mcr;
 	SMC_SELECT_BANK(0);
-	mir = inw(ioaddr + MEMINFO) & 0xff;
+	mir = pcnet_inw(ioaddr + MEMINFO) & 0xff;
 	if (mir == 0xff) mir++;
 	/* Get scale factor for memory size */
-	mcr = ((rev >> 4) > 3) ? inw(ioaddr + MEMCFG) : 0x0200;
+	mcr = ((rev >> 4) > 3) ? pcnet_inw(ioaddr + MEMCFG) : 0x0200;
 	mir *= 128 * (1<<((mcr >> 9) & 7));
 	SMC_SELECT_BANK(1);
-	smc->cfg = inw(ioaddr + CONFIG) & ~CFG_AUI_SELECT;
+	smc->cfg = pcnet_inw(ioaddr + CONFIG) & ~CFG_AUI_SELECT;
 	smc->cfg |= CFG_NO_WAIT | CFG_16BIT | CFG_STATIC;
 	if (smc->manfid == MANFID_OSITECH)
 	    smc->cfg |= CFG_IRQ_SEL_1 | CFG_IRQ_SEL_0;
@@ -1153,7 +1317,7 @@
 	 	(smc->cardid == PRODID_PSION_NET100))) {
 		/* Download the Seven of Diamonds firmware */
 		for (i = 0; i < sizeof(__Xilinx7OD); i++) {
-	    	    outb(__Xilinx7OD[i], link->io.BasePort1+2);
+	    	    pcnet_outb(__Xilinx7OD[i], link->io.BasePort1+2);
 	   	    udelay(50);
 		}
 	    }
@@ -1183,8 +1347,8 @@
 {
     int bits;
     for (bits = 0; bits < 32; bits++) {
-	outb(MDIO_DATA_WRITE1, addr);
-	outb(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(MDIO_DATA_WRITE1, addr);
+	pcnet_outb(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);
     }
 }
 
@@ -1197,13 +1361,13 @@
     mdio_sync(addr);
     for (i = 13; i >= 0; i--) {
 	int dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-	outb(dat, addr);
-	outb(dat | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(dat, addr);
+	pcnet_outb(dat | MDIO_SHIFT_CLK, addr);
     }
     for (i = 19; i > 0; i--) {
-	outb(0, addr);
-	retval = (retval << 1) | ((inb(addr) & MDIO_DATA_READ) != 0);
-	outb(MDIO_SHIFT_CLK, addr);
+	pcnet_outb(0, addr);
+	retval = (retval << 1) | ((pcnet_inb(addr) & MDIO_DATA_READ) != 0);
+	pcnet_outb(MDIO_SHIFT_CLK, addr);
     }
     return (retval>>1) & 0xffff;
 }
@@ -1217,12 +1381,12 @@
     mdio_sync(addr);
     for (i = 31; i >= 0; i--) {
 	int dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;
-	outb(dat, addr);
-	outb(dat | MDIO_SHIFT_CLK, addr);
+	pcnet_outb(dat, addr);
+	pcnet_outb(dat | MDIO_SHIFT_CLK, addr);
     }
     for (i = 1; i >= 0; i--) {
-	outb(0, addr);
-	outb(MDIO_SHIFT_CLK, addr);
+	pcnet_outb(0, addr);
+	pcnet_outb(MDIO_SHIFT_CLK, addr);
     }
 }
 
@@ -1238,15 +1402,15 @@
 {
     ioaddr_t ioaddr = dev->base_addr;
     u_short i, w, save;
-    save = inw(ioaddr + BANK_SELECT);
+    save = pcnet_inw(ioaddr + BANK_SELECT);
     for (w = 0; w < 4; w++) {
 	SMC_SELECT_BANK(w);
 	printk(KERN_DEBUG "bank %d: ", w);
 	for (i = 0; i < 14; i += 2)
-	    printk(" %04x", inw(ioaddr + i));
+	    printk(" %04x", pcnet_inw(ioaddr + i));
 	printk("\n");
     }
-    outw(save, ioaddr + BANK_SELECT);
+    pcnet_outw(save, ioaddr + BANK_SELECT);
 }
 #endif
 
@@ -1257,7 +1421,7 @@
 
 #ifdef PCMCIA_DEBUG
     DEBUG(0, "%s: smc_open(%p), ID/Window %4.4x.\n",
-	  dev->name, dev, inw(dev->base_addr + BANK_SELECT));
+	  dev->name, dev, pcnet_inw(dev->base_addr + BANK_SELECT));
     if (pc_debug > 1) smc_dump(dev);
 #endif
 
@@ -1294,21 +1458,21 @@
     ioaddr_t ioaddr = dev->base_addr;
 
     DEBUG(0, "%s: smc_close(), status %4.4x.\n",
-	  dev->name, inw(ioaddr + BANK_SELECT));
+	  dev->name, pcnet_inw(ioaddr + BANK_SELECT));
 
     netif_stop_queue(dev);
 
     /* Shut off all interrupts, and turn off the Tx and Rx sections.
        Don't bother to check for chip present. */
     SMC_SELECT_BANK(2);	/* Nominally paranoia, but do no assume... */
-    outw(0, ioaddr + INTERRUPT);
+    pcnet_outw(0, ioaddr + INTERRUPT);
     SMC_SELECT_BANK(0);
     mask_bits(0xff00, ioaddr + RCR);
     mask_bits(0xff00, ioaddr + TCR);
 
     /* Put the chip into power-down mode. */
     SMC_SELECT_BANK(1);
-    outw(CTL_POWERDOWN, ioaddr + CONTROL );
+    pcnet_outw(CTL_POWERDOWN, ioaddr + CONTROL );
 
     link->open--;
     del_timer_sync(&smc->media);
@@ -1337,7 +1501,7 @@
     }
 
     /* There should be a packet slot waiting. */
-    packet_no = inw(ioaddr + PNR_ARR) >> 8;
+    packet_no = pcnet_inw(ioaddr + PNR_ARR) >> 8;
     if (packet_no & 0x80) {
 	/* If not, there is a hardware problem!  Likely an ejected card. */
 	printk(KERN_WARNING "%s: 91c92 hardware Tx buffer allocation"
@@ -1350,9 +1514,9 @@
 
     smc->stats.tx_bytes += skb->len;
     /* The card should use the just-allocated buffer. */
-    outw(packet_no, ioaddr + PNR_ARR);
+    pcnet_outw(packet_no, ioaddr + PNR_ARR);
     /* point to the beginning of the packet */
-    outw(PTR_AUTOINC , ioaddr + POINTER);
+    pcnet_outw(PTR_AUTOINC , ioaddr + POINTER);
 
     /* Send the packet length (+6 for status, length and ctl byte)
        and the status word (set to zeros). */
@@ -1364,21 +1528,21 @@
 	      dev->name, length);
 	
 	/* send the packet length: +6 for status word, length, and ctl */
-	outw(0, ioaddr + DATA_1);
-	outw(length + 6, ioaddr + DATA_1);
-	outsw(ioaddr + DATA_1, buf, length >> 1);
+	pcnet_outw(0, ioaddr + DATA_1);
+	pcnet_outw(length + 6, ioaddr + DATA_1);
+	pcnet_outsw(ioaddr + DATA_1, buf, length >> 1);
 	
 	/* The odd last byte, if there is one, goes in the control word. */
-	outw((length & 1) ? 0x2000 | buf[length-1] : 0, ioaddr + DATA_1);
+	pcnet_outw((length & 1) ? 0x2000 | buf[length-1] : 0, ioaddr + DATA_1);
     }
 
     /* Enable the Tx interrupts, both Tx (TxErr) and TxEmpty. */
-    outw(((IM_TX_INT|IM_TX_EMPTY_INT)<<8) |
-	 (inw(ioaddr + INTERRUPT) & 0xff00),
+    pcnet_outw(((IM_TX_INT|IM_TX_EMPTY_INT)<<8) |
+	 (pcnet_inw(ioaddr + INTERRUPT) & 0xff00),
 	 ioaddr + INTERRUPT);
 
     /* The chip does the rest of the work. */
-    outw(MC_ENQUEUE , ioaddr + MMU_CMD);
+    pcnet_outw(MC_ENQUEUE , ioaddr + MMU_CMD);
 
     smc->saved_skb = NULL;
     dev_kfree_skb_irq(skb);
@@ -1396,7 +1560,7 @@
 
     printk(KERN_NOTICE "%s: SMC91c92 transmit timed out, "
 	   "Tx_status %2.2x status %4.4x.\n",
-	   dev->name, inw(ioaddr)&0xff, inw(ioaddr + 2));
+	   dev->name, pcnet_inw(ioaddr)&0xff, pcnet_inw(ioaddr + 2));
     smc->stats.tx_errors++;
     smc_reset(dev);
     dev->trans_start = jiffies;
@@ -1414,7 +1578,7 @@
     netif_stop_queue(dev);
 
     DEBUG(2, "%s: smc_start_xmit(length = %d) called,"
-	  " status %4.4x.\n", dev->name, skb->len, inw(ioaddr + 2));
+	  " status %4.4x.\n", dev->name, skb->len, pcnet_inw(ioaddr + 2));
 
     if (smc->saved_skb) {
 	/* THIS SHOULD NEVER HAPPEN. */
@@ -1441,17 +1605,17 @@
 
     /* need MC_RESET to keep the memory consistent. errata? */
     if (smc->rx_ovrn) {
-	outw(MC_RESET, ioaddr + MMU_CMD);
+	pcnet_outw(MC_RESET, ioaddr + MMU_CMD);
 	smc->rx_ovrn = 0;
     }
 
     /* Allocate the memory; send the packet now if we win. */
-    outw(MC_ALLOC | num_pages, ioaddr + MMU_CMD);
+    pcnet_outw(MC_ALLOC | num_pages, ioaddr + MMU_CMD);
     for (time_out = MEMORY_WAIT_TIME; time_out >= 0; time_out--) {
-	ir = inw(ioaddr+INTERRUPT);
+	ir = pcnet_inw(ioaddr+INTERRUPT);
 	if (ir & IM_ALLOC_INT) {
 	    /* Acknowledge the interrupt, send the packet. */
-	    outw((ir&0xff00) | IM_ALLOC_INT, ioaddr + INTERRUPT);
+	    pcnet_outw((ir&0xff00) | IM_ALLOC_INT, ioaddr + INTERRUPT);
 	    smc_hardware_send_packet(dev);	/* Send the packet now.. */
 	    return 0;
 	}
@@ -1459,7 +1623,7 @@
 
     /* Otherwise defer until the Tx-space-allocated interrupt. */
     DEBUG(2, "%s: memory allocation deferred.\n", dev->name);
-    outw((IM_ALLOC_INT << 8) | (ir & 0xff00), ioaddr + INTERRUPT);
+    pcnet_outw((IM_ALLOC_INT << 8) | (ir & 0xff00), ioaddr + INTERRUPT);
 
     return 0;
 }
@@ -1474,17 +1638,17 @@
 {
     struct smc_private *smc = netdev_priv(dev);
     ioaddr_t ioaddr = dev->base_addr;
-    int saved_packet = inw(ioaddr + PNR_ARR) & 0xff;
-    int packet_no = inw(ioaddr + FIFO_PORTS) & 0x7f;
+    int saved_packet = pcnet_inw(ioaddr + PNR_ARR) & 0xff;
+    int packet_no = pcnet_inw(ioaddr + FIFO_PORTS) & 0x7f;
     int tx_status;
 
     /* select this as the packet to read from */
-    outw(packet_no, ioaddr + PNR_ARR);
+    pcnet_outw(packet_no, ioaddr + PNR_ARR);
 
     /* read the first word from this packet */
-    outw(PTR_AUTOINC | PTR_READ | 0, ioaddr + POINTER);
+    pcnet_outw(PTR_AUTOINC | PTR_READ | 0, ioaddr + POINTER);
 
-    tx_status = inw(ioaddr + DATA_1);
+    tx_status = pcnet_inw(ioaddr + DATA_1);
 
     smc->stats.tx_errors++;
     if (tx_status & TS_LOSTCAR) smc->stats.tx_carrier_errors++;
@@ -1500,15 +1664,15 @@
     }
     /* re-enable transmit */
     SMC_SELECT_BANK(0);
-    outw(inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);
+    pcnet_outw(pcnet_inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);
     SMC_SELECT_BANK(2);
 
-    outw(MC_FREEPKT, ioaddr + MMU_CMD); 	/* Free the packet memory. */
+    pcnet_outw(MC_FREEPKT, ioaddr + MMU_CMD); 	/* Free the packet memory. */
 
     /* one less packet waiting for me */
     smc->packets_waiting--;
 
-    outw(saved_packet, ioaddr + PNR_ARR);
+    pcnet_outw(saved_packet, ioaddr + PNR_ARR);
     return;
 }
 
@@ -1521,11 +1685,11 @@
     u_short card_stats, ephs;
 
     SMC_SELECT_BANK(0);
-    ephs = inw(ioaddr + EPH);
+    ephs = pcnet_inw(ioaddr + EPH);
     DEBUG(2, "%s: Ethernet protocol handler interrupt, status"
 	  " %4.4x.\n", dev->name, ephs);
     /* Could be a counter roll-over warning: update stats. */
-    card_stats = inw(ioaddr + COUNTER);
+    card_stats = pcnet_inw(ioaddr + COUNTER);
     /* single collisions */
     smc->stats.collisions += card_stats & 0xF;
     card_stats >>= 4;
@@ -1536,12 +1700,12 @@
     card_stats >>= 4;			/* excess deferred */
 #endif
     /* If we had a transmit error we must re-enable the transmitter. */
-    outw(inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);
+    pcnet_outw(pcnet_inw(ioaddr + TCR) | TCR_ENABLE | smc->duplex, ioaddr + TCR);
 
     /* Clear a link error interrupt. */
     SMC_SELECT_BANK(1);
-    outw(CTL_AUTO_RELEASE | 0x0000, ioaddr + CONTROL);
-    outw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,
+    pcnet_outw(CTL_AUTO_RELEASE | 0x0000, ioaddr + CONTROL);
+    pcnet_outw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,
 	 ioaddr + CONTROL);
     SMC_SELECT_BANK(2);
 }
@@ -1566,7 +1730,7 @@
 	  irq, ioaddr);
 
     smc->watchdog = 0;
-    saved_bank = inw(ioaddr + BANK_SELECT);
+    saved_bank = pcnet_inw((unsigned long)(ioaddr + BANK_SELECT));
     if ((saved_bank & 0xff00) != 0x3300) {
 	/* The device does not exist -- the card could be off-line, or
 	   maybe it has been ejected. */
@@ -1577,13 +1741,13 @@
     }
 
     SMC_SELECT_BANK(2);
-    saved_pointer = inw(ioaddr + POINTER);
-    mask = inw(ioaddr + INTERRUPT) >> 8;
+    saved_pointer = pcnet_inw((unsigned long)(ioaddr + POINTER));
+    mask = pcnet_inw((unsigned long)(ioaddr + INTERRUPT)) >> 8;
     /* clear all interrupts */
-    outw(0, ioaddr + INTERRUPT);
+    pcnet_outw(0, ioaddr + INTERRUPT);
 
     do { /* read the status flag, and mask it */
-	status = inw(ioaddr + INTERRUPT) & 0xff;
+	status = pcnet_inw((unsigned long)(ioaddr + INTERRUPT)) & 0xff;
 	DEBUG(3, "%s: Status is %#2.2x (mask %#2.2x).\n", dev->name,
 	      status, mask);
 	if ((status & mask) == 0) {
@@ -1597,11 +1761,11 @@
 	}
 	if (status & IM_TX_INT) {
 	    smc_tx_err(dev);
-	    outw(IM_TX_INT, ioaddr + INTERRUPT);
+	    pcnet_outw(IM_TX_INT, (unsigned long)(ioaddr + INTERRUPT) );
 	}
 	status &= mask;
 	if (status & IM_TX_EMPTY_INT) {
-	    outw(IM_TX_EMPTY_INT, ioaddr + INTERRUPT);
+	    pcnet_outw(IM_TX_EMPTY_INT, (unsigned long)(ioaddr + INTERRUPT));
 	    mask &= ~IM_TX_EMPTY_INT;
 	    smc->stats.tx_packets += smc->packets_waiting;
 	    smc->packets_waiting = 0;
@@ -1623,7 +1787,7 @@
 	    smc->stats.rx_fifo_errors++;
 	    if (smc->duplex)
 		smc->rx_ovrn = 1; /* need MC_RESET outside smc_interrupt */
-	    outw(IM_RX_OVRN_INT, ioaddr + INTERRUPT);
+	    pcnet_outw(IM_RX_OVRN_INT, (unsigned long)(ioaddr + INTERRUPT));
 	}
 	if (status & IM_EPH_INT)
 	    smc_eph_irq(dev);
@@ -1633,8 +1797,8 @@
 	  " pointer %4.4x.\n", mask, saved_bank, saved_pointer);
 
     /* restore state register */
-    outw((mask<<8), ioaddr + INTERRUPT);
-    outw(saved_pointer, ioaddr + POINTER);
+    pcnet_outw((mask<<8), (ioaddr + INTERRUPT));
+    pcnet_outw(saved_pointer, ioaddr + POINTER);
     SMC_SELECT_BANK(saved_bank);
 
     DEBUG(3, "%s: Exiting interrupt IRQ%d.\n", dev->name, irq);
@@ -1649,17 +1813,17 @@
     }
     if (smc->manfid == MANFID_MOTOROLA) {
 	u_char cor;
-	cor = readb(smc->base + MOT_UART + CISREG_COR);
-	writeb(cor & ~COR_IREQ_ENA, smc->base + MOT_UART + CISREG_COR);
-	writeb(cor, smc->base + MOT_UART + CISREG_COR);
-	cor = readb(smc->base + MOT_LAN + CISREG_COR);
-	writeb(cor & ~COR_IREQ_ENA, smc->base + MOT_LAN + CISREG_COR);
-	writeb(cor, smc->base + MOT_LAN + CISREG_COR);
+	cor = pcnet_readb((unsigned long)(smc->base + MOT_UART + CISREG_COR));
+	pcnet_writeb(cor & ~COR_IREQ_ENA, (unsigned long)(smc->base + MOT_UART + CISREG_COR));
+	pcnet_writeb(cor, (unsigned long)(smc->base + MOT_UART + CISREG_COR));
+	cor = pcnet_readb((unsigned long)(smc->base + MOT_LAN + CISREG_COR));
+	pcnet_writeb(cor & ~COR_IREQ_ENA, (unsigned long)(smc->base + MOT_LAN + CISREG_COR));
+	pcnet_writeb(cor, (unsigned long)(smc->base + MOT_LAN + CISREG_COR));
     }
 #ifdef DOES_NOT_WORK
     if (smc->base != NULL) { /* Megahertz MFC's */
-	readb(smc->base+MEGAHERTZ_ISR);
-	readb(smc->base+MEGAHERTZ_ISR);
+	pcnet_readb((unsigned long)(smc->base+MEGAHERTZ_ISR));
+	pcnet_readb((unsigned long)(smc->base+MEGAHERTZ_ISR));
     }
 #endif
     return IRQ_RETVAL(handled);
@@ -1677,16 +1841,16 @@
 
     /* Assertion: we are in Window 2. */
 
-    if (inw(ioaddr + FIFO_PORTS) & FP_RXEMPTY) {
+    if (pcnet_inw(ioaddr + FIFO_PORTS) & FP_RXEMPTY) {
 	printk(KERN_ERR "%s: smc_rx() with nothing on Rx FIFO.\n",
 	       dev->name);
 	return;
     }
 
     /*  Reset the read pointer, and read the status and packet length. */
-    outw(PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER);
-    rx_status = inw(ioaddr + DATA_1);
-    packet_length = inw(ioaddr + DATA_1) & 0x07ff;
+    pcnet_outw(PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER);
+    rx_status = pcnet_inw(ioaddr + DATA_1);
+    packet_length = pcnet_inw(ioaddr + DATA_1) & 0x07ff;
 
     DEBUG(2, "%s: Receive status %4.4x length %d.\n",
 	  dev->name, rx_status, packet_length);
@@ -1701,13 +1865,13 @@
 	if (skb == NULL) {
 	    DEBUG(1, "%s: Low memory, packet dropped.\n", dev->name);
 	    smc->stats.rx_dropped++;
-	    outw(MC_RELEASE, ioaddr + MMU_CMD);
+	    pcnet_outw(MC_RELEASE, ioaddr + MMU_CMD);
 	    return;
 	}
 	
 	packet_length -= (rx_status & RS_ODDFRAME ? 5 : 6);
 	skb_reserve(skb, 2);
-	insw(ioaddr+DATA_1, skb_put(skb, packet_length),
+	pcnet_insw(ioaddr+DATA_1, skb_put(skb, packet_length),
 	     (packet_length+1)>>1);
 	skb->protocol = eth_type_trans(skb, dev);
 	
@@ -1728,7 +1892,7 @@
 	if (rx_status & RS_BADCRC)	smc->stats.rx_crc_errors++;
     }
     /* Let the MMU free the memory of this packet. */
-    outw(MC_RELEASE, ioaddr + MMU_CMD);
+    pcnet_outw(MC_RELEASE, ioaddr + MMU_CMD);
 
     return;
 }
@@ -1801,7 +1965,7 @@
     outl(multicast_table[0], ioaddr + MULTICAST0);
     outl(multicast_table[1], ioaddr + MULTICAST4);
     SMC_SELECT_BANK(0);
-    outw(rx_cfg_setting, ioaddr + RCR);
+    pcnet_outw(rx_cfg_setting, ioaddr + RCR);
     SMC_SELECT_BANK(2);
     spin_unlock_irqrestore(&smc->lock, flags);
 
@@ -1846,16 +2010,16 @@
     ioaddr_t ioaddr = dev->base_addr;
     u_short saved_bank;
 
-    saved_bank = inw(ioaddr + BANK_SELECT);
+    saved_bank = pcnet_inw(ioaddr + BANK_SELECT);
     SMC_SELECT_BANK(1);
     if (if_port == 2) {
-	outw(smc->cfg | CFG_AUI_SELECT, ioaddr + CONFIG);
+	pcnet_outw(smc->cfg | CFG_AUI_SELECT, ioaddr + CONFIG);
 	if ((smc->manfid == MANFID_OSITECH) &&
 	    (smc->cardid != PRODID_OSITECH_SEVEN))
 	    set_bits(OSI_AUI_PWR, ioaddr - 0x10 + OSITECH_AUI_PWR);
 	smc->media_status = ((dev->if_port == 0) ? 0x0001 : 0x0002);
     } else {
-	outw(smc->cfg, ioaddr + CONFIG);
+	pcnet_outw(smc->cfg, ioaddr + CONFIG);
 	if ((smc->manfid == MANFID_OSITECH) &&
 	    (smc->cardid != PRODID_OSITECH_SEVEN))
 	    mask_bits(~OSI_AUI_PWR, ioaddr - 0x10 + OSITECH_AUI_PWR);
@@ -1876,40 +2040,40 @@
        of sleep mode. */
     SMC_SELECT_BANK(0);
     /* Reset the chip. */
-    outw(RCR_SOFTRESET, ioaddr + RCR);
+    pcnet_outw(RCR_SOFTRESET, ioaddr + RCR);
     udelay(10);
 
     /* Clear the transmit and receive configuration registers. */
-    outw(RCR_CLEAR, ioaddr + RCR);
-    outw(TCR_CLEAR, ioaddr + TCR);
+    pcnet_outw(RCR_CLEAR, ioaddr + RCR);
+    pcnet_outw(TCR_CLEAR, ioaddr + TCR);
 
     /* Set the Window 1 control, configuration and station addr registers.
        No point in writing the I/O base register ;-> */
     SMC_SELECT_BANK(1);
     /* Automatically release succesfully transmitted packets,
        Accept link errors, counter and Tx error interrupts. */
-    outw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,
+    pcnet_outw(CTL_AUTO_RELEASE | CTL_TE_ENABLE | CTL_CR_ENABLE,
 	 ioaddr + CONTROL);
     smc_set_xcvr(dev, dev->if_port);
     if ((smc->manfid == MANFID_OSITECH) &&
 	(smc->cardid != PRODID_OSITECH_SEVEN))
-	outw((dev->if_port == 2 ? OSI_AUI_PWR : 0) |
-	     (inw(ioaddr-0x10+OSITECH_AUI_PWR) & 0xff00),
+	pcnet_outw((dev->if_port == 2 ? OSI_AUI_PWR : 0) |
+	     (pcnet_inw(ioaddr-0x10+OSITECH_AUI_PWR) & 0xff00),
 	     ioaddr - 0x10 + OSITECH_AUI_PWR);
 
     /* Fill in the physical address.  The databook is wrong about the order! */
     for (i = 0; i < 6; i += 2)
-	outw((dev->dev_addr[i+1]<<8)+dev->dev_addr[i],
+	pcnet_outw((dev->dev_addr[i+1]<<8)+dev->dev_addr[i],
 	     ioaddr + ADDR0 + i);
 
     /* Reset the MMU */
     SMC_SELECT_BANK(2);
-    outw(MC_RESET, ioaddr + MMU_CMD);
-    outw(0, ioaddr + INTERRUPT);
+    pcnet_outw(MC_RESET, ioaddr + MMU_CMD);
+    pcnet_outw(0, ioaddr + INTERRUPT);
 
     /* Re-enable the chip. */
     SMC_SELECT_BANK(0);
-    outw(((smc->cfg & CFG_MII_SELECT) ? 0 : TCR_MONCSN) |
+    pcnet_outw(((smc->cfg & CFG_MII_SELECT) ? 0 : TCR_MONCSN) |
 	 TCR_ENABLE | TCR_PAD_EN | smc->duplex, ioaddr + TCR);
     set_rx_mode(dev);
 
@@ -1929,7 +2093,7 @@
 
     /* Enable interrupts. */
     SMC_SELECT_BANK(2);
-    outw((IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT) << 8,
+    pcnet_outw((IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT) << 8,
 	 ioaddr + INTERRUPT);
 }
 
@@ -1947,7 +2111,7 @@
     u_short i, media, saved_bank;
     u_short link;
 
-    saved_bank = inw(ioaddr + BANK_SELECT);
+    saved_bank = pcnet_inw(ioaddr + BANK_SELECT);
 
     if (!netif_device_present(dev))
 	goto reschedule;
@@ -1956,14 +2120,14 @@
 
     /* need MC_RESET to keep the memory consistent. errata? */
     if (smc->rx_ovrn) {
-	outw(MC_RESET, ioaddr + MMU_CMD);
+	pcnet_outw(MC_RESET, ioaddr + MMU_CMD);
 	smc->rx_ovrn = 0;
     }
-    i = inw(ioaddr + INTERRUPT);
+    i = pcnet_inw(ioaddr + INTERRUPT);
     SMC_SELECT_BANK(0);
-    media = inw(ioaddr + EPH) & EPH_LINK_OK;
+    media = pcnet_inw(ioaddr + EPH) & EPH_LINK_OK;
     SMC_SELECT_BANK(1);
-    media |= (inw(ioaddr + CONFIG) & CFG_AUI_SELECT) ? 2 : 1;
+    media |= (pcnet_inw(ioaddr + CONFIG) & CFG_AUI_SELECT) ? 2 : 1;
 
     /* Check for pending interrupt with watchdog flag set: with
        this, we can limp along even if the interrupt is blocked */
@@ -2007,7 +2171,7 @@
 		       (smc->duplex ? 'F' : 'H'));
 	    }
 	    SMC_SELECT_BANK(0);
-	    outw(inw(ioaddr + TCR) | smc->duplex, ioaddr + TCR);
+	    pcnet_outw(pcnet_inw(ioaddr + TCR) | smc->duplex, ioaddr + TCR);
 	    smc->link_status = link;
 	}
 	goto reschedule;
@@ -2062,7 +2226,7 @@
 	return mii_link_ok(&smc->mii_if);
     } else {
         SMC_SELECT_BANK(0);
-	return inw(ioaddr + EPH) & EPH_LINK_OK;
+	return pcnet_inw(ioaddr + EPH) & EPH_LINK_OK;
     }
 }
 
@@ -2075,14 +2239,14 @@
 	SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full);
 		
     SMC_SELECT_BANK(1);
-    tmp = inw(ioaddr + CONFIG);
+    tmp = pcnet_inw(ioaddr + CONFIG);
     ecmd->port = (tmp & CFG_AUI_SELECT) ? PORT_AUI : PORT_TP;
     ecmd->transceiver = XCVR_INTERNAL;
     ecmd->speed = SPEED_10;
     ecmd->phy_address = ioaddr + MGMT;
 
     SMC_SELECT_BANK(0);
-    tmp = inw(ioaddr + TCR);
+    tmp = pcnet_inw(ioaddr + TCR);
     ecmd->duplex = (tmp & TCR_FDUPLX) ? DUPLEX_FULL : DUPLEX_HALF;
 
     return 0;
@@ -2108,12 +2272,12 @@
 	smc_set_xcvr(dev, 0);
 
     SMC_SELECT_BANK(0);
-    tmp = inw(ioaddr + TCR);
+    tmp = pcnet_inw(ioaddr + TCR);
     if (ecmd->duplex == DUPLEX_FULL)
 	tmp |= TCR_FDUPLX;
     else
 	tmp &= ~TCR_FDUPLX;
-    outw(ioaddr + TCR, tmp);
+    pcnet_outw(ioaddr + TCR, tmp);
 	
     return 0;
 }
@@ -2226,7 +2390,7 @@
 
     switch (cmd) {
     case SIOCETHTOOL:
-	saved_bank = inw(ioaddr + BANK_SELECT);
+	saved_bank = pcnet_inw(ioaddr + BANK_SELECT);
 	SMC_SELECT_BANK(3);
 	rc = smc_ethtool_ioctl(dev, rq->ifr_data);
 	SMC_SELECT_BANK(saved_bank);
@@ -2234,7 +2398,7 @@
 
     default:
 	spin_lock_irq(&smc->lock);
-	saved_bank = inw(ioaddr + BANK_SELECT);
+	saved_bank = pcnet_inw(ioaddr + BANK_SELECT);
 	SMC_SELECT_BANK(3);
 	rc = generic_mii_ioctl(&smc->mii_if, mii, cmd, NULL);
 	SMC_SELECT_BANK(saved_bank);
diff -burN linux-2.6.8.1-orig/drivers/net/pcmcia/xirc2ps_cs.c linux-2.6.8.1/drivers/net/pcmcia/xirc2ps_cs.c
--- linux-2.6.8.1-orig/drivers/net/pcmcia/xirc2ps_cs.c	2004-08-14 19:55:19.000000000 +0900
+++ linux-2.6.8.1/drivers/net/pcmcia/xirc2ps_cs.c	2007-01-24 13:03:31.000000000 +0900
@@ -248,6 +248,166 @@
 #define XIR_CM56    12	/* (prodid 5) modem only: not supported here */
 #define XIR_CG	    13	/* (prodid 1) GSM modem only: not supported */
 #define XIR_CBE     14	/* (prodid 1) cardbus ethernet: not supported */
+
+/*
+static
+void pcnet_insw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+#else
+	insw(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsw(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+#else
+	outsw(port,addr,count);
+#endif
+}
+*/
+static
+void pcnet_outb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb(port);
+
+#endif
+}
+/*
+static
+void pcnet_outb_p(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	outb_p(addr, port);
+#endif
+}
+
+static
+unsigned char pcnet_inb_p(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return inb_p(addr,port);
+#endif
+}
+*/
+static
+void pcnet_outw(u16 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outw(addr, port);
+#else
+	outw(addr, port);
+#endif
+}
+static
+unsigned short pcnet_inw(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inw(port);
+#else
+	return inw(port);
+
+#endif
+}
+/*
+static
+void pcnet_outl(u32 addr, unsigned long port)
+{	
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned short usValue;
+	usValue = (unsigned short)(addr&0x0000ffff); 	
+	ep93xx_pcmcia_ide_outw(usValue, port);
+	usValue = (unsigned short)((addr&0xffff0000)>>16); 	
+	ep93xx_pcmcia_ide_outw(usValue, port+1);
+#else
+	outl(addr, port);
+#endif
+}
+
+static
+unsigned long pcnet_inl(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	unsigned long 	ulValue;
+	unsigned short	usValueL,usValueH;
+	
+	usValueL	= ep93xx_pcmcia_ide_inw(port);
+	usValueH = ep93xx_pcmcia_ide_inw(port+1);
+	ulValue	= (usValueH<<16)|(usValueL);
+	return ulValue;
+#else
+	return inl(port);
+
+#endif
+}
+
+
+
+static
+void pcnet_insl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_insw(port, addr,count);
+	ep93xx_pcmcia_ide_insw(port+count, addr+count,count);
+#else
+	insl(port,addr,count);
+#endif
+}
+
+static
+void pcnet_outsl(unsigned long port, void *addr, u32 count)
+{ 
+#ifdef CONFIG_ARCH_EP93XX
+	ep93xx_pcmcia_ide_outsw(port, addr,count);
+	ep93xx_pcmcia_ide_outsw(port+count, addr+count,count);
+#else
+	outsl(port,addr,count);
+#endif
+}
+
+static
+unsigned char pcnet_readb(unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX
+	return ep93xx_pcmcia_ide_inb(port);
+#else
+	return readb(port);
+
+#endif
+}
+*/
+static
+void pcnet_writeb(u8 addr, unsigned long port)
+{
+#ifdef CONFIG_ARCH_EP93XX 
+	ep93xx_pcmcia_ide_outb(addr, port);
+#else
+	writeb(addr, port);
+#endif
+}
+
+
 /*====================================================================*/
 
 /* Module parameters */
@@ -412,11 +572,11 @@
 	return err;
 }
 
-#define SelectPage(pgnr)   outb((pgnr), ioaddr + XIRCREG_PR)
-#define GetByte(reg)	   ((unsigned)inb(ioaddr + (reg)))
-#define GetWord(reg)	   ((unsigned)inw(ioaddr + (reg)))
-#define PutByte(reg,value) outb((value), ioaddr+(reg))
-#define PutWord(reg,value) outw((value), ioaddr+(reg))
+#define SelectPage(pgnr)   pcnet_outb((pgnr), ioaddr + XIRCREG_PR)
+#define GetByte(reg)	   ((unsigned)pcnet_inb(ioaddr + (reg)))
+#define GetWord(reg)	   ((unsigned)pcnet_inw(ioaddr + (reg)))
+#define PutByte(reg,value) pcnet_outb((value), ioaddr+(reg))
+#define PutWord(reg,value) pcnet_outw((value), ioaddr+(reg))
 
 #define Wait(n) do { \
 	set_current_state(TASK_UNINTERRUPTIBLE); \
@@ -1066,40 +1226,40 @@
 	/* Setup the CCRs; there are no infos in the CIS about the Ethernet
 	 * part.
 	 */
-	writeb(0x47, local->dingo_ccr + CISREG_COR);
+	pcnet_writeb(0x47, (unsigned long)(local->dingo_ccr + CISREG_COR));
 	ioaddr = link->io.BasePort1;
-	writeb(ioaddr & 0xff	  , local->dingo_ccr + CISREG_IOBASE_0);
-	writeb((ioaddr >> 8)&0xff , local->dingo_ccr + CISREG_IOBASE_1);
+	pcnet_writeb(ioaddr & 0xff	  , (unsigned long)(local->dingo_ccr + CISREG_IOBASE_0));
+	pcnet_writeb((ioaddr >> 8)&0xff , (unsigned long)(local->dingo_ccr + CISREG_IOBASE_1));
 
       #if 0
 	{
 	    u_char tmp;
 	    printk(KERN_INFO "ECOR:");
 	    for (i=0; i < 7; i++) {
-		tmp = readb(local->dingo_ccr + i*2);
+		tmp = pcnet_readb(local->dingo_ccr + i*2);
 		printk(" %02x", tmp);
 	    }
 	    printk("\n");
 	    printk(KERN_INFO "DCOR:");
 	    for (i=0; i < 4; i++) {
-		tmp = readb(local->dingo_ccr + 0x20 + i*2);
+		tmp = pcnet_readb(local->dingo_ccr + 0x20 + i*2);
 		printk(" %02x", tmp);
 	    }
 	    printk("\n");
 	    printk(KERN_INFO "SCOR:");
 	    for (i=0; i < 10; i++) {
-		tmp = readb(local->dingo_ccr + 0x40 + i*2);
+		tmp = pcnet_readb(local->dingo_ccr + 0x40 + i*2);
 		printk(" %02x", tmp);
 	    }
 	    printk("\n");
 	}
       #endif
 
-	writeb(0x01, local->dingo_ccr + 0x20);
-	writeb(0x0c, local->dingo_ccr + 0x22);
-	writeb(0x00, local->dingo_ccr + 0x24);
-	writeb(0x00, local->dingo_ccr + 0x26);
-	writeb(0x00, local->dingo_ccr + 0x28);
+	pcnet_writeb(0x01, (unsigned long)(local->dingo_ccr + 0x20));
+	pcnet_writeb(0x0c, (unsigned long)(local->dingo_ccr + 0x22));
+	pcnet_writeb(0x00, (unsigned long)(local->dingo_ccr + 0x24));
+	pcnet_writeb(0x00, (unsigned long)(local->dingo_ccr + 0x26));
+	pcnet_writeb(0x00, (unsigned long)(local->dingo_ccr + 0x28));
     }
 
     /* The if_port symbol can be set when the module is loaded */
diff -burN linux-2.6.8.1-orig/drivers/pcmcia/Kconfig linux-2.6.8.1/drivers/pcmcia/Kconfig
--- linux-2.6.8.1-orig/drivers/pcmcia/Kconfig	2004-08-14 19:55:48.000000000 +0900
+++ linux-2.6.8.1/drivers/pcmcia/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -133,10 +133,16 @@
 	help
 	  Say Y here to include support for the PXA2xx PCMCIA controller
 
+config PCMCIA_EP93XX
+	tristate "EP93xx support"
+	depends on ARCH_EP93XX && PCMCIA
+	help
+	Say Y here to include support for PCMCIA_EP93xx PCMCIA or CF
+	sockets.
 
 config PCMCIA_PROBE
 	bool
-	default y if ISA && !ARCH_SA1100 && !ARCH_CLPS711X
+	default y if PCMCIA_EP93XX||ISA 
 
 endmenu
 
diff -burN linux-2.6.8.1-orig/drivers/pcmcia/Makefile linux-2.6.8.1/drivers/pcmcia/Makefile
--- linux-2.6.8.1-orig/drivers/pcmcia/Makefile	2004-08-14 19:55:59.000000000 +0900
+++ linux-2.6.8.1/drivers/pcmcia/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -17,6 +17,7 @@
 obj-$(CONFIG_PCMCIA_SA1100)			+= sa11xx_core.o sa1100_cs.o
 obj-$(CONFIG_PCMCIA_SA1111)			+= sa11xx_core.o sa1111_cs.o
 obj-$(CONFIG_PCMCIA_PXA2XX)                     += pxa2xx_core.o pxa2xx_cs.o
+obj-$(CONFIG_PCMCIA_EP93XX)                    	+= ep93xx_pcmcia.o
 
 pcmcia_core-y					+= cistpl.o rsrc_mgr.o bulkmem.o cs.o socket_sysfs.o
 pcmcia_core-$(CONFIG_CARDBUS)			+= cardbus.o
diff -burN linux-2.6.8.1-orig/drivers/pcmcia/ep93xx_pcmcia.c linux-2.6.8.1/drivers/pcmcia/ep93xx_pcmcia.c
--- linux-2.6.8.1-orig/drivers/pcmcia/ep93xx_pcmcia.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/pcmcia/ep93xx_pcmcia.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,2098 @@
+/*======================================================================
+
+  Device driver for the PCMCIA control functionality of PXA2xx
+  microprocessors.
+
+    The contents of this file may be used under the
+    terms of the GNU Public License version 2 (the "GPL")
+
+    (c) Ian Molton (spyro@f2s.com) 2003
+    (c) Stefan Eletzhofer (stefan.eletzhofer@inquant.de) 2003,4
+
+    derived from sa11xx_base.c
+
+     Portions created by John G. Dorsey are
+     Copyright (C) 1999 John G. Dorsey.
+
+  ======================================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/cpufreq.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+
+#include <linux/delay.h>
+//#include <linux/tqueue.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/bulkmem.h>
+#include <pcmcia/cistpl.h>
+
+
+/*-------------------------------------------------------------------------------------------*/
+#include "ep93xx_pcmcia.h"
+
+#undef PCMCIA_DEBUG
+#undef DEBUG
+//#define PCMCIA_DEBUG 1
+//#define DEBUG        1
+
+#if 0
+#define DEBUG(n, args...) printk(args);
+#else
+#define DEBUG(n, args...)
+
+#ifdef PCMCIA_DEBUG
+static int pc_debug = PCMCIA_DEBUG;
+MODULE_PARM(pc_debug, "i");
+#define DEBUG(n, args...) printk(KERN_DEBUG "ep93xx_pcmcia: " args);
+
+#else
+#define DEBUG(n, args...)
+#endif
+
+#endif
+
+#define PCMCIA_INFO(args...) printk(KERN_INFO "ep93xx_pcmcia: "args)
+#define PCMCIA_ERROR(args...) printk(KERN_ERR "ep93xx_pcmcia: "args)
+
+/*--------------------------------------------------------------------------------------------*/
+/* Maximum number of IO windows per socket */
+#define EP93XX_MAX_IO_WIN 2
+
+/* Maximum number of memory windows per socket */
+#define EP93XX_MAX_MEM_WIN 5
+
+#define EP93XX_UNCONFIGURED_VOLTAGE 0xFF
+
+struct pcmcia_irq_info {
+	unsigned int sock;
+	unsigned int irq;
+};
+
+static struct irqs {
+	int irq;
+	unsigned int gpio;
+	const char *str;
+} ep93xx_pcmcia_irqs[] =
+{
+	// Interrupt number       GPIO port F pin mask      String
+	{ EP93XX_PCMCIA_INT_RDY,   EP93XX_PCMCIA_RDY,  "EP93XX PCMCIA RDY"  },
+	{ EP93XX_PCMCIA_INT_CD1,   EP93XX_PCMCIA_CD1,  "EP93XX PCMCIA CD1"  },
+	{ EP93XX_PCMCIA_INT_CD2,   EP93XX_PCMCIA_CD2,  "EP93XX PCMCIA CD2"  },
+	{ EP93XX_PCMCIA_INT_BVD2,  EP93XX_PCMCIA_BVD2, "EP93XX PCMCIA BVD2" },
+	{ EP93XX_PCMCIA_INT_BVD1,  EP93XX_PCMCIA_BVD1, "EP93XX PCMCIA BVD1" },
+};
+
+#define EP93XX_GPIOS        \
+	( EP93XX_PCMCIA_RDY |   \
+	  EP93XX_PCMCIA_CD1 |   \
+	  EP93XX_PCMCIA_CD2 |   \
+	  EP93XX_PCMCIA_BVD2 |  \
+	  EP93XX_PCMCIA_BVD1 )
+
+
+
+
+typedef struct bus_operations {
+    void	*priv;
+    u32		(*b_in)(void *bus, u32 port, s32 sz);
+    void	(*b_ins)(void *bus, u32 port, void *buf,
+			 u32 count, s32 sz);
+    void	(*b_out)(void *bus, u32 val, u32 port, s32 sz);
+    void	(*b_outs)(void *bus, u32 port, void *buf,
+			  u32 count, s32 sz);
+    void	*(*b_ioremap)(void *bus, u_long ofs, u_long sz);
+    void	(*b_iounmap)(void *bus, void *addr);
+    u32		(*b_read)(void *bus, void *addr, s32 sz);
+    void	(*b_write)(void *bus, u32 val, void *addr, s32 sz);
+    void	(*b_copy_from)(void *bus, void *d, void *s, u32 count);
+    void	(*b_copy_to)(void *bus, void *d, void *s, u32 count);
+    int		(*b_request_irq)(void *bus, u_int irq,
+				 void (*handler)(int, void *,
+						 struct pt_regs *),
+				 u_long flags, const char *device,
+				 void *dev_id);
+    void	(*b_free_irq)(void *bus, u_int irq, void *dev_id);
+} bus_operations;
+
+/* This structure maintains housekeeping state for each socket, such
+ * as the last known values of the card detect pins, or the Card Services
+ * callback value associated with the socket:
+ */
+struct socket_info_t {
+
+	struct pcmcia_socket	socket;
+	struct device		*dev;
+	/*the number of the sockets*/
+	unsigned int		nr;
+	unsigned int		irq;
+	struct timer_list		poll_timer;
+	struct list_head		node;
+	unsigned int		irq_processing;
+	/*=======================================*/
+	socket_state_t      		state;
+	struct pccard_mem_map 	mem_map[EP93XX_MAX_MEM_WIN];
+	struct pccard_io_map  	io_map[EP93XX_MAX_IO_WIN];
+
+	// The CS event handler:
+	void               	 	(*cs_event_handler)(void *info, u_int events);
+	void                		*cs_handler_info;
+
+	// IRQ handler for card driver
+	void                		(*card_irq_handler)(int, void *, struct pt_regs *);
+	void                		*dev_id;
+
+	void                		*virt_io;
+	unsigned short      		speed_io, speed_attr, speed_mem;
+	unsigned int        		uiStatus;
+	unsigned long       		IrqsToEnable;
+	u_char              		Vcc;
+	
+	struct bus_operations 	bus_ops;
+};
+
+static struct socket_info_t socket_info[EP93XX_MAX_SOCK];
+
+/*-------------------------------------------------------------------------------------------*/
+
+static irqreturn_t ep93xx_interrupt(int irq, void *dev, struct pt_regs *regs);
+static void ep93xx_interrupt_timer(int irq, void *dev, struct pt_regs *regs);
+/*static void ep93xx_pcmcia_poll_event(unsigned long dummy);*/
+static void ep93xx_timer(void *data);
+static int ep93xx_get_status( struct pcmcia_socket *sock, unsigned int  *uiStatus );
+
+//static struct tq_struct ep93xx_timer_task ;
+
+struct bittbl {
+	unsigned int mask;
+	const char *name;
+};
+
+/*
+static struct bittbl status_bits[] = {
+	{ SS_WRPROT,		"SS_WRPROT"	},
+	{ SS_BATDEAD,		"SS_BATDEAD"	},
+	{ SS_BATWARN,		"SS_BATWARN"	},
+	{ SS_READY,		"SS_READY"	},
+	{ SS_DETECT,		"SS_DETECT"	},
+	{ SS_POWERON,		"SS_POWERON"	},
+	{ SS_STSCHG,		"SS_STSCHG"	},
+	{ SS_3VCARD,		"SS_3VCARD"	},
+	{ SS_XVCARD,		"SS_XVCARD"	},
+};
+
+static struct bittbl conf_bits[] = {
+	{ SS_PWR_AUTO,		"SS_PWR_AUTO"	},
+	{ SS_IOCARD,		"SS_IOCARD"	},
+	{ SS_RESET,		"SS_RESET"	},
+	{ SS_DMA_MODE,		"SS_DMA_MODE"	},
+	{ SS_SPKR_ENA,		"SS_SPKR_ENA"	},
+	{ SS_OUTPUT_ENA,	"SS_OUTPUT_ENA"	},
+};
+
+static void
+dump_bits(char **p, const char *prefix, unsigned int val, struct bittbl *bits, int sz)
+{
+	char *b = *p;
+	int i;
+
+	b += sprintf(b, "%-9s:", prefix);
+	for (i = 0; i < sz; i++)
+		if (val & bits[i].mask)
+			b += sprintf(b, " %s", bits[i].name);
+	*b++ = '\n';
+	*p = b;
+}
+
+*/
+
+
+/*
+ * Implements the /sys/class/pcmcia_socket/??/status file.
+ *
+ * Returns: the number of characters added to the buffer
+ */
+static ssize_t show_status(struct class_device *class_dev, char *buf)
+{
+/*
+	struct soc_pcmcia_socket *skt =
+		container_of(class_dev, struct soc_pcmcia_socket, socket.dev);
+	char *p = buf;
+
+	p+=sprintf(p, "slot     : %d\n", skt->nr);
+
+	dump_bits(&p, "status", skt->status,
+		  status_bits, ARRAY_SIZE(status_bits));
+	dump_bits(&p, "csc_mask", skt->cs_state.csc_mask,
+		  status_bits, ARRAY_SIZE(status_bits));
+	dump_bits(&p, "cs_flags", skt->cs_state.flags,
+		  conf_bits, ARRAY_SIZE(conf_bits));
+
+	p+=sprintf(p, "Vcc      : %d\n", skt->cs_state.Vcc);
+	p+=sprintf(p, "Vpp      : %d\n", skt->cs_state.Vpp);
+	p+=sprintf(p, "IRQ      : %d (%d)\n", skt->cs_state.io_irq, skt->irq);
+
+	if (skt->ops->show_timing)
+		p+=skt->ops->show_timing(skt, p);
+
+	return p-buf;
+*/
+	return 0;
+
+}
+static CLASS_DEVICE_ATTR(status, S_IRUGO, show_status, NULL);
+
+
+/*--------------------------------------------------------------------------------------------*/
+static u32 ep93xx_bus_in(void *bus, u32 port, s32 sz){
+  	DEBUG(5, "%s(%08x, %d)\n", __FUNCTION__, port, sz);
+
+	  switch(sz){
+		  case  0: return inb(port);
+		  case  1: return le16_to_cpu(inw(port));
+		  case -1: return inw(port);
+		  case  2: return le32_to_cpu(inl(port));
+		  case -2: return inl(port);
+	  }
+
+	  printk(KERN_ERR "%s(): invalid size %d\n", __FUNCTION__, sz);
+	  return 0;
+}
+
+static void ep93xx_bus_out(void *bus, u32 val, u32 port, s32 sz){
+	  DEBUG(5, "%s(%08x, %08x, %d)\n", __FUNCTION__, val, port, sz);
+
+	  switch(sz){
+		  case  0: outb(val, port);               break;
+		  case  1: outw(cpu_to_le16(val), port);  break;
+		  case -1: outw(val, port);               break;
+		  case  2: outl(cpu_to_le32(val), port);  break;
+		  case -2: outl(val, port);               break;
+		  default: printk(KERN_ERR "%s(): invalid size %d\n", __FUNCTION__, sz);
+	  }
+}
+/*
+static void ep93xx_bus_ins(void *bus, u32 port, void *buf,  u32 count, s32 sz){
+	s32 sCount=0;  
+	DEBUG(5, "%s(%08x, %p, %u, %d)\n", __FUNCTION__, port, buf, count, sz);
+
+	  switch(sz){
+	  case 0:
+		sCount = sz;
+		while((sCount--)>0){
+		  *(((unsigned char *)buf)++)= inb(port);}
+		break;
+
+	  case 1:
+		while((sz--)>0)
+		  *(((unsigned short *)buf)++)=le16_to_cpu(inw(port));
+		break;
+
+	  case -1:
+		while((sz--)>0)
+		  *(((unsigned short *)buf)++)=inw(port);
+		break;
+
+	  case 2:
+		while((sz--)>0)
+		  *(((unsigned int *)buf)++)=le32_to_cpu(inl(port));
+		break;
+
+	  case -2:
+		while((sz--)>0)
+		  *(((unsigned int *)buf)++)=inl(port);
+		break;
+
+	  default: printk(KERN_ERR "%s(): invalid size %d\n", __FUNCTION__, sz);
+	  }
+	}
+
+static void ep93xx_bus_outs(void *bus, u32 port, void *buf,	u32 count, s32 sz){
+	  DEBUG(5, "%s(%08x, %p, %u, %d)\n", __FUNCTION__, port, buf, count, sz);
+
+	  switch(sz){
+	  case 0:
+		while((sz--)>0)
+		  outb(*(((unsigned char *)buf)++), port);
+		break;
+		
+	  case 1:
+		while((sz--)>0)
+		  outw(cpu_to_le16(*(((unsigned short *)buf)++)), port);
+		break;
+
+	  case -1:
+		while((sz--)>0)
+		  outw(*(((unsigned short *)buf)++), port);
+		break;
+
+	  case 2:
+		while((sz--)>0)
+		  outl(cpu_to_le32(*(((unsigned int *)buf)++)), port);
+		break;
+
+	  case -2:
+		while((sz--)>0)
+		  outl(*(((unsigned int *)buf)++), port);
+		break;
+
+	  default: printk(KERN_ERR "%s(): invalid size %d\n", __FUNCTION__, sz);
+	  }
+}
+*/
+static void *ep93xx_bus_ioremap(void *bus, u_long ofs, u_long sz){
+	  DEBUG(5, "%s(%08lx, %lu)\n", __FUNCTION__, ofs, sz);
+	//  return (void *)ofs;
+	  return ioremap( ofs, sz );
+}
+
+static void ep93xx_bus_iounmap(void *bus, void *addr){
+	  DEBUG(5, "%s(%p)\n", __FUNCTION__, addr);
+	  iounmap( addr );
+}
+
+static u32 ep93xx_bus_read(void *bus, void *addr, s32 sz){
+	  DEBUG(5, "%s(%p, %d)\n", __FUNCTION__, addr, sz);
+	  
+	  switch(sz){
+		//  case  0: return *((unsigned char *)addr);
+		  case  0: 
+		  { 
+			unsigned char ucTemp = *((unsigned char *)addr); 
+			DEBUG(5, "%s(%p, %d): 0x%02x\n", __FUNCTION__, addr, sz, ucTemp);
+			return ucTemp;
+		  }
+		  case  1: return le16_to_cpu(*((unsigned short *)addr));
+		  case -1: return *((unsigned short *)addr);
+		  case  2: return le32_to_cpu(*((unsigned int *)addr));
+		  case -2: return *((unsigned int *)addr);
+	  }
+
+	  printk(KERN_ERR "%s(): invalid size %d\n", __FUNCTION__, sz);
+	  return 0;
+}
+
+static void ep93xx_bus_write(void *bus, u32 val, void *addr, s32 sz){
+	DEBUG(5, "%s(%x, %p, %d)\n", __FUNCTION__, val, addr, sz);
+
+	switch(sz)
+	{
+		case  0: *((unsigned char *)addr)=(unsigned char)val;                break;
+		case  1: *((unsigned short *)addr)=cpu_to_le16((unsigned short)val); break;
+		case -1: *((unsigned short *)addr)=(unsigned short)val;              break;
+		case  2: *((unsigned int *)addr)=cpu_to_le32((unsigned int)val);     break;
+		case -2: *((unsigned int *)addr)=(unsigned int)val;                  break;
+		default: printk(KERN_ERR "%s(): invalid size %d\n", __FUNCTION__, sz);
+	}
+}
+
+static void ep93xx_bus_copy_from(void *bus, void *d, void *s, u32 count){
+	DEBUG(5, "%s(%p, %p, %u)\n", __FUNCTION__, d, s, count);
+	_memcpy_fromio(d, (unsigned long)s, count);
+}
+
+static void ep93xx_bus_copy_to(void *bus, void *d, void *s, u32 count){
+	DEBUG(5, "%s(%p, %p, %u)\n", __FUNCTION__, d, s, count);
+	_memcpy_toio((unsigned long)d, s, count);
+}
+
+static int 
+ep93xx_bus_request_irq
+( 
+	void *bus, 
+	u_int irq, 
+	void (*handler)(int, void *, struct pt_regs *), 
+	u_long flags, 
+	const char *device, 
+	void *dev_id 
+)
+{
+	if (irq!=EP93XX_PCMCIA_INT_RDY)
+		return -1;
+
+	DEBUG(5, "%s(%u, %p, %08lx, \"%s\", %p)\n", __FUNCTION__, irq, handler,
+	flags, device, dev_id);
+
+	socket_info[0].dev_id = dev_id;
+	socket_info[0].card_irq_handler = handler;
+	
+	return 0;
+}
+
+static void 
+ep93xx_bus_free_irq(void *bus, u_int irq, void *dev_id)
+{
+	DEBUG(5, "%s(%u, %p)\n", __FUNCTION__, irq, dev_id);
+	
+	if (irq!=EP93XX_PCMCIA_INT_RDY)
+		return;
+		
+	socket_info[0].card_irq_handler = NULL;
+}
+
+/*-------------------------------------------------------------------------------------------*/
+static struct timer_list poll_timer;
+/*
+static struct tq_struct ep93xx_timer_task = {
+	.routine 	=ep93xx_timer,
+	
+};
+*/
+#define EP9315_PCMCIA_POLL_PERIOD    (2*HZ)
+
+static void ep93xx_timer(void *data)
+{
+       	struct socket_info_t * skt = &socket_info[0];
+        	DEBUG(3, "poll event\n");
+                                                                                                                             
+        	mod_timer(&poll_timer, jiffies + EP9315_PCMCIA_POLL_PERIOD);
+
+	if(skt->irq_processing==0)
+        		ep93xx_interrupt_timer( 0, NULL, NULL );
+	
+}
+
+
+/*
+static void ep93xx_pcmcia_poll_event(unsigned long dummy)
+{
+  	//DEBUG(4, "%s(): polling for events\n", __FUNCTION__);
+  	poll_timer.function = 	(void *)ep93xx_timer;//ep93xx_pcmcia_poll_event;
+  	poll_timer.expires = 	jiffies + EP9315_PCMCIA_POLL_PERIOD;
+	poll_timer.data =	(unsigned long)socket_info;
+  	add_timer(&poll_timer);
+  	//schedule_task(&ep93xx_timer_task);
+}
+*/
+
+/*----------------------------------------------------------------------------------------------*/
+
+/*
+ * We bit-bang the pcmcia power controller using this function.
+ */
+static void ep93xx_bitbang
+( 
+	unsigned long ulNewEEValue 
+)
+{
+	unsigned long ulGdata;
+
+	ulGdata = inl( GPIO_PGDR );
+
+	ulGdata &= ~(GPIOA_EECLK | GPIOA_EEDAT | GPIOA_SLA0);
+
+	ulNewEEValue &= (GPIOA_EECLK | GPIOA_EEDAT | GPIOA_SLA0);
+
+	ulGdata |= ulNewEEValue;
+
+	outl( ulGdata, GPIO_PGDR );
+	ulGdata = inl( GPIO_PGDR ); // read to push write out wrapper
+	
+	// Voltage controller's data sheet says minimum pulse width is 
+	// one microsecond.
+	udelay(5);
+}
+
+static int
+ep93xx_set_voltage( u_short sock, u_char NewVcc )
+{
+	struct socket_info_t * skt = &socket_info[sock];
+	unsigned long ulSwitchSettings, ulDataBit, ulGdirection;
+	int       i;
+	
+	if (sock >= EP93XX_MAX_SOCK){
+		DEBUG(3, "ep93xx_set_voltage sock %x vcc %d\n",sock,NewVcc);
+		return -EINVAL;}
+
+	if( skt->Vcc == NewVcc ){
+		DEBUG(3, "Power already set to %d\n", NewVcc );
+		return 0;
+	}
+	
+	ulSwitchSettings = EE_ADDRESS | ENABLE;
+	switch( NewVcc ) 
+	{
+		case 0:
+			DEBUG(3, "Configure the socket for 0 Volts\n");
+			ulSwitchSettings |= AVCC_0V;
+			break;
+
+		case 50:
+			ulSwitchSettings |= AVCC_5V;
+			DEBUG(3, "Configure the socket for 5 Volts\n");
+			break;
+			
+		case 33:
+			DEBUG(3, "Configure the socket for 3.3 Volts\n");
+			ulSwitchSettings |= AVCC_33V;
+			break;
+
+		default:
+			printk(KERN_ERR "%s(): unrecognized Vcc %u\n", __FUNCTION__,
+				NewVcc);
+			return -1;
+	}
+
+	//
+	// Configure the proper GPIO pins as outputs.
+	//
+	ep93xx_bitbang( GPIOA_EECLK | GPIOA_EEDAT );
+	
+	//
+	// Read modify write the data direction register, set the
+	// proper lines to be outputs.
+	//
+	ulGdirection = inl( GPIO_PGDDR );
+	ulGdirection |= GPIOA_EECLK | GPIOA_EEDAT | GPIOA_SLA0;
+	outl( ulGdirection, GPIO_PGDDR );
+	ulGdirection = inl( GPIO_PGDDR ); // read to push write out wrapper
+	
+	//
+	// Clear all except EECLK
+	// Lower the clock.
+	// 
+	ep93xx_bitbang( GPIOA_EECLK );
+	ep93xx_bitbang( 0 );
+
+	//
+	// Serial shift the command word out to the voltage controller.
+	//
+	for( i=18 ; i>=0 ; --i )
+	{
+		if( (ulSwitchSettings >> i) & 0x1 )
+			ulDataBit = GPIOA_EEDAT;
+		else
+			ulDataBit = 0;
+		
+		//
+		// Put the data on the bus and lower the clock.
+		// Raise the clock to latch the data in.
+		// Lower the clock again.
+		//
+		ep93xx_bitbang( ulDataBit );
+		ep93xx_bitbang( ulDataBit | GPIOA_EECLK );
+		ep93xx_bitbang( ulDataBit );
+	}
+		
+	//
+	// Raise and lower the Latch.
+	// Raise EECLK, delay, raise EEDAT, leave them that way.
+	//
+	ep93xx_bitbang( GPIOA_SLA0 );
+	ep93xx_bitbang( 0 );
+	ep93xx_bitbang( GPIOA_EECLK );
+	ep93xx_bitbang( GPIOA_EECLK | GPIOA_EEDAT );
+
+	skt->Vcc = NewVcc;
+	
+	DEBUG(3, "ep93xx_set_voltage - exit\n");
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------------------------*/
+#define PCMCIA_BOARD_DELAY          40
+
+
+//****************************************************************************
+// CalculatePcmciaTimings
+//****************************************************************************
+// Calculate the pcmcia timings based on the register settings. 
+// For example here is for Attribute/Memory Read.
+//
+//
+// Address:   _______XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX___________
+//
+// Data:      __________________________XXXXXXXXXXXXXX________________________
+//
+// CE#:       -------______________________________________________-----------
+//
+// REG#:      -------______________________________________________-----------
+//
+// OE#:       --------------------___________________-------------------------
+//
+//
+//                   |<---------------Cycle time ----------------->|
+//
+//                   |< Address >|<-- Access Time -->|< Hold Time >|
+//                      Time           ta(CE)             th(CE)
+//                      tsu(A)
+//
+//  See PCMCIA Electrical Specification Section 4.7 for the timing numbers.
+//
+//
+static unsigned long ep93xx_calculate_timing( unsigned long ulNsSpeed )
+{
+	unsigned long ulAddressTime, ulHoldTime, ulAccessTime, ulHPeriod, ulSMC;
+	unsigned long ulHAccessTime, ulHAddressTime, ulHHoldTime, ulHCLK = 50000000;
+	
+	switch( ulNsSpeed )
+	{
+		case 600:
+		default:
+			ulAccessTime = 600; ulAddressTime = 100; ulHoldTime = 35;
+			break;
+			
+		case 300:
+			ulAccessTime = 300; ulAddressTime = 30;	 ulHoldTime = 20;
+			break;
+			
+		case 250:
+			ulAccessTime = 250; ulAddressTime = 30;	 ulHoldTime = 20;
+			break;
+			
+		case 200:
+			ulAccessTime = 200; ulAddressTime = 20; ulHoldTime = 20;
+			break;
+			
+		case 150:
+			ulAccessTime = 150; ulAddressTime = 20;	ulHoldTime = 20;
+			break;
+			
+		case 100:
+			ulAccessTime = 100;	ulAddressTime = 10;	ulHoldTime = 15;
+			break;
+			
+		// Special case for I/O all access.
+		case 0:
+			ulAccessTime = 165; ulAddressTime = 70; ulHoldTime = 20;
+			break;
+	}
+
+	//
+	// Add in a board delay.
+	//
+	ulAccessTime    += PCMCIA_BOARD_DELAY;
+	ulAddressTime   += PCMCIA_BOARD_DELAY;
+	ulHoldTime      += PCMCIA_BOARD_DELAY;
+	
+	//
+	// This gives us the period in nanosecods.
+	//
+	// = 1000000000 (ns/s) / HCLK (cycle/s)
+	//
+	// = (ns/cycle)
+	//
+	ulHPeriod       = (1000000000/ ulHCLK);
+	
+	//
+	// Find the number of hclk cycles for cycle time, address time and
+	// hold time.
+	//
+	// = ulAccessTime  (ns) / ulHPeriod (ns/Cycles)
+	// = ulAddressTime (ns) / ulHPeriod (ns/Cycles)
+	// = ulHoldTime    (ns) / ulHPeriod (ns/Cycles)
+	//
+	ulHAccessTime    = ulAccessTime / ulHPeriod;
+	if(ulHAccessTime > 0xFF)
+		ulHAccessTime  = 0xFF;
+	
+	ulHAddressTime  = ulAddressTime / ulHPeriod;
+	if(ulHAddressTime > 0xFF)
+		ulHAddressTime = 0xFF;
+			
+	ulHHoldTime     = (ulHoldTime /ulHPeriod) + 1;
+	if(ulHHoldTime >0xF)
+		ulHHoldTime     = 0xF;
+
+	ulSMC = (PCCONFIG_ADDRESSTIME_MASK & (ulHAddressTime << PCCONFIG_ADDRESSTIME_SHIFT)) |
+			(PCCONFIG_HOLDTIME_MASK & (ulHHoldTime << PCCONFIG_HOLDTIME_SHIFT)) |
+			(PCCONFIG_ACCESSTIME_MASK & (ulHAccessTime << PCCONFIG_ACCESSTIME_SHIFT)) ;
+
+	//DEBUG(3, "pcmciatiming: %d uSec. SMC reg value 0x%08x\n",
+	//		(unsigned int)ulNsSpeed, (unsigned int)ulSMC );
+	
+	return ulSMC;    
+}
+
+/*-------------------------------------------------------------------------------------------*/
+static spinlock_t status_lock = SPIN_LOCK_UNLOCKED;
+
+static irqreturn_t ep93xx_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	unsigned long ulTemp;
+	unsigned int uiStatus, uiNewEvents;
+	
+	// Assuming we have only one socket.
+	struct socket_info_t * skt = &socket_info[0];
+  	unsigned long flags;
+//	if( irq != 0 )
+//    	printk( "ep93xx_interrupt enter intstatus=0x%02x\n", inl(GPIO_INTSTATUSF) );
+//	else
+//		printk( "." );
+	/*shrek modify*/
+	DEBUG(3, "enter_irq\n");
+	skt->irq_processing	=	1;
+	spin_lock_irqsave(&status_lock, flags);
+
+	/*ep93xx_get_status( 0, &uiStatus );*/
+	ep93xx_get_status(&(skt->socket), &uiStatus );
+	
+	//
+	// We're going to report only the events that have changed and that
+	// are not masked off.
+	//
+	
+	uiNewEvents = (uiStatus ^ skt->uiStatus) & skt->state.csc_mask;
+	skt->uiStatus = uiStatus;
+	
+/*shrek modify*/
+	//printk("int 0\n");
+/*	DEBUG(4, "events: %s%s%s%s%s%s\n",
+		uiNewEvents == 0         ? "<NONE>"   : "",
+		uiNewEvents & SS_DETECT  ? "DETECT "  : "",
+		uiNewEvents & SS_READY   ? "READY "   : "",
+		uiNewEvents & SS_BATDEAD ? "BATDEAD " : "",
+		uiNewEvents & SS_BATWARN ? "BATWARN " : "",
+		uiNewEvents & SS_STSCHG  ? "STSCHG "  : "");
+*/
+	if (uiNewEvents){
+		pcmcia_parse_events(&skt->socket, uiNewEvents);
+		/*printk("pcmcia_parse_events uiNewEvents\n");*/
+	}
+	//printk("int 1\n");
+	/*
+	if( (skt->cs_event_handler != 0) && (uiNewEvents != 0) )
+		skt->cs_event_handler( skt->cs_handler_info, uiNewEvents );
+	*/
+	
+	// Clear whatever interrupt we're servicing.
+	switch( irq )
+	{
+		case EP93XX_PCMCIA_INT_CD1:
+			outl( EP93XX_PCMCIA_CD1, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_CD2:
+			outl( EP93XX_PCMCIA_CD2, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_BVD1:
+			outl( EP93XX_PCMCIA_BVD1, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_BVD2:
+			outl( EP93XX_PCMCIA_BVD2, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_RDY:
+			/*
+			if( skt->card_irq_handler )
+				skt->card_irq_handler( irq, skt->dev_id, regs );
+			*/
+			outl( EP93XX_PCMCIA_RDY, GPIO_FEOI );
+			break;
+
+		default:
+			break;
+	}
+	ulTemp = inl( GPIO_FEOI ); // read to push write out wrapper
+
+
+	spin_unlock_irqrestore(&status_lock, flags);
+	skt->irq_processing	=	0;
+	DEBUG(3, "exit_irq\n");
+
+	return IRQ_HANDLED;
+}
+
+static void ep93xx_interrupt_timer(int irq, void *dev, struct pt_regs *regs)
+{
+	unsigned long ulTemp;
+	unsigned int uiStatus, uiNewEvents;
+	
+	// Assuming we have only one socket.
+	struct socket_info_t * skt = &socket_info[0];
+  	unsigned long flags;
+//	if( irq != 0 )
+//    	printk( "ep93xx_interrupt enter intstatus=0x%02x\n", inl(GPIO_INTSTATUSF) );
+//	else
+//		printk( "." );
+	/*shrek modify*/
+	DEBUG(3, "enter_timer\n");
+	skt->irq_processing	=	1;
+	spin_lock_irqsave(&status_lock, flags);
+
+	/*ep93xx_get_status( 0, &uiStatus );*/
+	ep93xx_get_status((struct pcmcia_socket *) &(skt->socket), &uiStatus );
+	
+	//
+	// We're going to report only the events that have changed and that
+	// are not masked off.
+	//
+	
+	uiNewEvents = (uiStatus ^ skt->uiStatus) & skt->state.csc_mask;
+	skt->uiStatus = uiStatus;
+	
+/*shrek modify*/
+	//printk("int 0\n");
+/*	DEBUG(4, "events: %s%s%s%s%s%s\n",
+		uiNewEvents == 0         ? "<NONE>"   : "",
+		uiNewEvents & SS_DETECT  ? "DETECT "  : "",
+		uiNewEvents & SS_READY   ? "READY "   : "",
+		uiNewEvents & SS_BATDEAD ? "BATDEAD " : "",
+		uiNewEvents & SS_BATWARN ? "BATWARN " : "",
+		uiNewEvents & SS_STSCHG  ? "STSCHG "  : "");
+*/
+	if (uiNewEvents){
+		pcmcia_parse_events(&skt->socket, uiNewEvents);
+		/*printk("pcmcia_parse_events uiNewEvents\n");*/
+	}
+	//printk("int 1\n");
+	/*
+	if( (skt->cs_event_handler != 0) && (uiNewEvents != 0) )
+		skt->cs_event_handler( skt->cs_handler_info, uiNewEvents );
+	*/
+	
+	// Clear whatever interrupt we're servicing.
+	switch( irq )
+	{
+		case EP93XX_PCMCIA_INT_CD1:
+			outl( EP93XX_PCMCIA_CD1, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_CD2:
+			outl( EP93XX_PCMCIA_CD2, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_BVD1:
+			outl( EP93XX_PCMCIA_BVD1, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_BVD2:
+			outl( EP93XX_PCMCIA_BVD2, GPIO_FEOI );
+			break;
+
+		case EP93XX_PCMCIA_INT_RDY:
+			/*
+			if( skt->card_irq_handler )
+				skt->card_irq_handler( irq, skt->dev_id, regs );
+			*/
+			outl( EP93XX_PCMCIA_RDY, GPIO_FEOI );
+			break;
+
+		default:
+			break;
+	}
+	ulTemp = inl( GPIO_FEOI ); // read to push write out wrapper
+
+
+	spin_unlock_irqrestore(&status_lock, flags);
+	skt->irq_processing	=	0;
+	DEBUG(3, "exit_timer\n");
+
+	
+}
+
+
+/*-------------------------------------------------------------------------------------------*/
+//#define to_pcmcia_socket(x)	container_of(x, struct socket_info_t, socket_info)
+
+static int 
+/*ep93xx_register_callback(u_short sock, ss_callback_t *call)*/
+ep93xx_register_callback(struct pcmcia_socket *sock, void (*handler)(void *, unsigned int), void * info)
+{
+	struct socket_info_t * skt = &socket_info[sock->sock];
+	
+	DEBUG(3, "ep93xx_register_callback - enter\n");
+	
+	if (sock->sock >= EP93XX_MAX_SOCK)
+		return -EINVAL;
+
+	if ((info == NULL)||(handler==NULL)) {
+		skt->cs_event_handler = NULL;
+		MOD_DEC_USE_COUNT;
+	} else {
+		MOD_INC_USE_COUNT;
+		skt->cs_event_handler = handler;
+		skt->cs_handler_info = info;
+	}
+	
+	DEBUG(3, "ep93xx_register_callback - exit\n");
+	return 0;
+}
+
+
+static int ep93xx_get_status( struct pcmcia_socket *sock, unsigned int  *uiStatus )
+{
+	struct socket_info_t * skt = &socket_info[sock->sock];
+	
+	unsigned long ulPFDR;
+	
+	DEBUG(3,"ep93xx_get_status - sock = %d  number %x\n", sock,sock->sock );
+
+	if (sock->sock >= EP93XX_MAX_SOCK)
+		return -EINVAL;
+
+	//
+	// Read the GPIOs that are connected to the PCMCIA slot.
+	//
+	ulPFDR  = inl(GPIO_PFDR);
+	
+	*uiStatus = 0;
+	
+	//
+	// If both CD1 and CD2 are low, set SS_DETECT bit.
+	//
+	*uiStatus = ((ulPFDR & (EP93XX_PCMCIA_CD1|EP93XX_PCMCIA_CD2)) == 0) ?
+				SS_DETECT : 0;
+
+	*uiStatus |= (ulPFDR & EP93XX_PCMCIA_WP) ? SS_WRPROT : 0;
+
+	if (skt->state.flags & SS_IOCARD)
+	{
+		*uiStatus |= (ulPFDR & EP93XX_PCMCIA_BVD1) ? SS_STSCHG : 0;
+	}
+	else 
+	{
+		*uiStatus |= (ulPFDR & EP93XX_PCMCIA_RDY) ? SS_READY : 0;
+		*uiStatus |= (ulPFDR & EP93XX_PCMCIA_BVD1) ? 0 : SS_BATDEAD;
+		*uiStatus |= (ulPFDR & EP93XX_PCMCIA_BVD2) ? 0 : SS_BATWARN;
+	}
+	
+	*uiStatus |= skt->state.Vcc ? SS_POWERON : 0;
+	
+	*uiStatus |= (ulPFDR & EP93XX_PCMCIA_VS1) ? 0 : SS_3VCARD;
+	
+	// We don't support X v.
+	//*uiStatus |= state[sock].vs_Xv ? SS_XVCARD : 0;
+
+	DEBUG(3, "ep93xx_get_status: %08x %s%s%s%s%s%s%s%s\n", 
+		(unsigned int)ulPFDR,
+		*uiStatus & SS_DETECT  ? "DETECT "  : "",
+		*uiStatus & SS_READY   ? "READY "   : "",
+		*uiStatus & SS_BATDEAD ? "BATDEAD " : "",
+		*uiStatus & SS_BATWARN ? "BATWARN " : "",
+		*uiStatus & SS_POWERON ? "POWERON " : "",
+		*uiStatus & SS_STSCHG  ? "STSCHG "  : "",
+		*uiStatus & SS_3VCARD  ? "3VCARD "  : "",
+		*uiStatus & SS_XVCARD  ? "XVCARD "  : "");
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+static int ep93xx_inquire_socket(u_short sock, socket_cap_t *cap)
+{
+	DEBUG(3,"ep93xx_inquire_socket - sock = %d\n", sock );
+
+	if (sock >= EP93XX_MAX_SOCK)
+		return -EINVAL;
+
+	cap->features=(SS_CAP_PAGE_REGS  | SS_CAP_VIRTUAL_BUS | SS_CAP_MEM_ALIGN |
+		 SS_CAP_STATIC_MAP | SS_CAP_PCCARD);
+	cap->irq_mask  = 0;
+	cap->map_size  = PAGE_SIZE;
+	cap->pci_irq   = EP93XX_PCMCIA_INT_RDY;
+	cap->cardbus   = 0;
+	cap->cb_bus    = NULL;
+	cap->bus       = &(socket_info[sock].bus_ops);
+
+	return 0;
+}
+*/
+/* ------------------------------------------------------------------------- */
+
+static int ep93xx_get_socket(struct pcmcia_socket *sock, socket_state_t *state)
+{
+	DEBUG(3,"ep93xx_get_socket - sock = %d  number %x\n", sock,sock->sock );
+
+	if (sock->sock >= EP93XX_MAX_SOCK)
+		return -EINVAL;
+
+	*state = socket_info[sock->sock].state; /* copy the whole structure */
+
+	DEBUG(3, "GetSocket(%d) = flags %#3.3x, Vcc %d, Vpp %d, "
+		  "io_irq %d, csc_mask %#2.2x\n", sock->sock, state->flags,
+		  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static int
+ep93xx_set_socket( struct pcmcia_socket *sock, socket_state_t *state )
+{
+	struct socket_info_t * skt = &socket_info[sock->sock];
+	
+	unsigned long ulTemp, IrqsToEnable = 0;
+
+	DEBUG(2, "%s() for sock %u number %x\n", __FUNCTION__, sock,sock->sock);
+
+	if (sock->sock >= EP93XX_MAX_SOCK)
+		return -EINVAL;
+
+	DEBUG(3, "\tmask:  %s%s%s%s%s%s\n\tflags: %s%s%s%s%s%s\n",
+		(state->csc_mask==0)?"<NONE>":"",
+		(state->csc_mask&SS_DETECT)?"DETECT ":"",
+		(state->csc_mask&SS_READY)?"READY ":"",
+		(state->csc_mask&SS_BATDEAD)?"BATDEAD ":"",
+		(state->csc_mask&SS_BATWARN)?"BATWARN ":"",
+		(state->csc_mask&SS_STSCHG)?"STSCHG ":"",
+		(state->flags==0)?"<NONE>":"",
+		(state->flags&SS_PWR_AUTO)?"PWR_AUTO ":"",
+		(state->flags&SS_IOCARD)?"IOCARD ":"",
+		(state->flags&SS_RESET)?"RESET ":"",
+		(state->flags&SS_SPKR_ENA)?"SPKR_ENA ":"",
+		(state->flags&SS_OUTPUT_ENA)?"OUTPUT_ENA ":"");
+
+	DEBUG(3, "\tVcc %d  Vpp %d  irq %d\n",
+		state->Vcc, state->Vpp, state->io_irq);
+
+	//
+	// Set Vcc level.  If an illegal voltage is specified, bail w/ error.
+	//
+	if( ep93xx_set_voltage( sock->sock, state->Vcc ) < 0 )
+		return -EINVAL;
+
+
+	/* Silently ignore output enable, speaker enable. */
+
+	//
+	// Enable PCMCIA, Enable Wait States, Set or Clear card reset.
+	//
+	ulTemp = (inl( SMC_PCMCIACtrl ) | PCCONT_WEN | PCCONT_PC1EN) & ~PCCONT_PC1RST;
+	if( state->flags & SS_RESET )
+		ulTemp |= PCCONT_PC1RST;
+
+	outl( ulTemp, SMC_PCMCIACtrl );
+	ulTemp = inl( SMC_PCMCIACtrl );
+	
+	//
+	// Enable interrupts in hw that are specified in csc_mask.
+	//
+	if (state->csc_mask & SS_DETECT)
+		IrqsToEnable |= EP93XX_PCMCIA_CD1 | EP93XX_PCMCIA_CD2;
+
+	if( state->flags & SS_IOCARD ) 
+	{
+		if (state->csc_mask & SS_STSCHG)  IrqsToEnable |= EP93XX_PCMCIA_BVD1;
+	} 
+	else 
+	{
+		if (state->csc_mask & SS_BATDEAD) IrqsToEnable |= EP93XX_PCMCIA_BVD1;
+		if (state->csc_mask & SS_BATWARN) IrqsToEnable |= EP93XX_PCMCIA_BVD2;
+		if (state->csc_mask & SS_READY)   IrqsToEnable |= EP93XX_PCMCIA_RDY;
+	}
+	
+	skt->IrqsToEnable = IrqsToEnable;
+
+	ulTemp = inl( GPIO_FINTEN ) & ~EP93XX_GPIOS;
+	outl( ulTemp, GPIO_FINTEN );
+	ulTemp = inl( GPIO_FINTEN );
+
+	//
+	// Clear and enable the new interrupts.
+	//
+	outl( IrqsToEnable | EP93XX_PCMCIA_RDY, GPIO_FEOI );
+	ulTemp = inl( GPIO_FEOI );
+
+	ulTemp = inl( GPIO_FINTEN ) & ~EP93XX_GPIOS;
+	ulTemp |= EP93XX_PCMCIA_RDY | IrqsToEnable;
+	outl( ulTemp, GPIO_FINTEN );
+	ulTemp = inl( GPIO_FINTEN );
+
+	skt->state = *state;
+	
+	DEBUG(2, "%s() exit\n", __FUNCTION__);
+	return 0;
+}
+
+
+/*
+static int
+ep93xx_get_io_map(u_short sock, struct pccard_io_map *io_map)
+{
+	if ( (sock >= EP93XX_MAX_SOCK) || (io_map->map >= EP93XX_MAX_IO_WIN) )
+		return -EINVAL;
+		
+	*io_map = socket_info[sock].io_map[io_map->map];
+
+	DEBUG(3,"GetIOMap(%d, %d) = %#2.2x, %d ns, "
+		  "%#4.4x-%#4.4x\n", sock, io_map->map, io_map->flags,
+		  io_map->speed, io_map->start, io_map->stop);
+
+	return 0;
+}
+*/
+
+
+static int
+ep93xx_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io_map)
+{
+	struct socket_info_t * skt = &socket_info[sock->sock];
+	
+	unsigned long ulSMC_PCIO;
+	unsigned int speed=0, i;
+	
+	/*printk( "%s() for sock %u number %x- Input:\n", __FUNCTION__, sock,sock->sock);*/
+
+	if (sock->sock >= EP93XX_MAX_SOCK)
+		return -EINVAL;
+
+	DEBUG(3, "\tmap %u  speed %u\n\tstart 0x%08x  stop 0x%08x\n",
+		io_map->map, io_map->speed, io_map->start, io_map->stop);
+		
+	DEBUG(3, "\tflags: %s%s%s%s%s%s%s%s\n",
+		(io_map->flags==0)?"<NONE>":"",
+		(io_map->flags&MAP_ACTIVE)?"ACTIVE ":"",
+		(io_map->flags&MAP_16BIT)?"16BIT ":"",
+		(io_map->flags&MAP_AUTOSZ)?"AUTOSZ ":"",
+		(io_map->flags&MAP_0WS)?"0WS ":"",
+		(io_map->flags&MAP_WRPROT)?"WRPROT ":"",
+		(io_map->flags&MAP_USE_WAIT)?"USE_WAIT ":"",
+		(io_map->flags&MAP_PREFETCH)?"PREFETCH ":"");
+
+	if ((io_map->map >= EP93XX_MAX_IO_WIN) || (io_map->stop < io_map->start)) 
+		return -EINVAL;
+
+	if (io_map->flags & MAP_ACTIVE) 
+	{
+		if (io_map->speed == 0)
+			io_map->speed = EP93XX_PCMCIA_IO_ACCESS;
+
+		speed = io_map->speed;
+
+		// Go thru our array of mappings, find the lowest speed 
+		// (largest # of nSec) for an active mapping...
+		for( i = 0 ; i < EP93XX_MAX_IO_WIN ; i++ ) {
+			if ( (skt->io_map[i].flags & MAP_ACTIVE) && 
+				 (speed > skt->io_map[i].speed) )
+				speed = skt->io_map[i].speed;
+		}
+
+		ulSMC_PCIO = ep93xx_calculate_timing( speed );
+
+		if( io_map->flags & MAP_16BIT )
+			ulSMC_PCIO |= PCCONFIG_MW_16BIT;
+
+		outl( ulSMC_PCIO, SMC_PCIO ); 
+		ulSMC_PCIO = inl( SMC_PCIO );
+
+		skt->speed_io = speed;
+	}
+
+	if (io_map->stop == 1)
+		io_map->stop = PAGE_SIZE-1;
+
+
+	io_map->stop = (io_map->stop - io_map->start) + (unsigned int)skt->virt_io;
+	io_map->start = (unsigned int)skt->virt_io;
+
+	skt->io_map[io_map->map] = *io_map;
+
+	DEBUG(2, "%s() for sock %u - Output:\n", __FUNCTION__, sock);
+
+	DEBUG(3, "\tmap %u  speed %u\n\tstart 0x%08x  stop 0x%08x (virt_io is 0x%08x)\n",
+		io_map->map, io_map->speed, io_map->start, io_map->stop, (unsigned int)skt->virt_io);
+		
+	DEBUG(3, "\tflags: %s%s%s%s%s%s%s%s\n",
+		(io_map->flags==0)?"<NONE>":"",
+		(io_map->flags&MAP_ACTIVE)?"ACTIVE ":"",
+		(io_map->flags&MAP_16BIT)?"16BIT ":"",
+		(io_map->flags&MAP_AUTOSZ)?"AUTOSZ ":"",
+		(io_map->flags&MAP_0WS)?"0WS ":"",
+		(io_map->flags&MAP_WRPROT)?"WRPROT ":"",
+		(io_map->flags&MAP_USE_WAIT)?"USE_WAIT ":"",
+		(io_map->flags&MAP_PREFETCH)?"PREFETCH ":"");
+
+//	printk("set_io_map: speed:%d  Attr:%08x  Comm:%08x  IO:%08x  Ctrl:%08x\n",  speed,
+//		inl( SMC_PCAttribute ), inl( SMC_PCCommon), 
+//		inl( SMC_PCIO ), inl( SMC_PCMCIACtrl ) );
+
+	return 0;
+}
+
+
+/*
+static int 
+ep93xx_get_mem_map(u_short sock, struct pccard_mem_map *mem_map)
+{
+	if( (sock>=EP93XX_MAX_SOCK) | (mem_map->map >= EP93XX_MAX_MEM_WIN) )
+		return -EINVAL;
+	
+	*mem_map = socket_info[sock].mem_map[mem_map->map]; // copy the struct 
+	
+	DEBUG(3, "GetMemMap(%d, %d) = %#2.2x, %d ns, "
+		  "%#5.5lx-%#5.5lx, %#5.5x\n", sock, mem_map->map, mem_map->flags,
+		  mem_map->speed, mem_map->sys_start, mem_map->sys_stop, mem_map->card_start);
+
+	return 0;
+}
+*/
+
+static int
+ep93xx_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *map)
+{
+	struct socket_info_t * skt = &socket_info[sock->sock];
+
+	
+	unsigned long start, ulRegValue;
+	unsigned int speed=0, i;
+
+	DEBUG(2, "%s() for sock %u  number %x Input:\n", __FUNCTION__, sock,sock->sock);
+
+	if (sock->sock >= EP93XX_MAX_SOCK)
+		return -EINVAL;
+
+	DEBUG(3, "\tmap %u speed %u sys_start %08lx sys_stop %08lx card_start %08x\n",
+		map->map, map->speed, map->sys_start, map->sys_stop, map->card_start);
+
+	DEBUG(3, "\tflags: %s%s%s%s%s%s%s%s\n",
+		(map->flags==0)?"<NONE>":"",
+		(map->flags&MAP_ACTIVE)?"ACTIVE ":"",
+		(map->flags&MAP_16BIT)?"16BIT ":"",
+		(map->flags&MAP_AUTOSZ)?"AUTOSZ ":"",
+		(map->flags&MAP_0WS)?"0WS ":"",
+		(map->flags&MAP_WRPROT)?"WRPROT ":"",
+		(map->flags&MAP_ATTRIB)?"ATTRIB ":"",
+		(map->flags&MAP_USE_WAIT)?"USE_WAIT ":"");
+
+	if (map->map >= EP93XX_MAX_MEM_WIN){
+		printk(KERN_ERR "%s(): map (%d) out of range\n", __FUNCTION__,
+			map->map);
+		return -1;
+	}
+
+	if (map->flags & MAP_ACTIVE){
+		if (map->speed == 0){
+			if (skt->state.Vcc == 33)
+				map->speed = EP93XX_PCMCIA_3V_MEM_ACCESS;
+			else
+				map->speed = EP93XX_PCMCIA_5V_MEM_ACCESS;
+		}
+		
+		speed = map->speed;
+
+		if (map->flags & MAP_ATTRIB) 
+		{
+			// Go thru our array of mappings, find the lowest speed 
+			// (largest # of nSec) for an active mapping...
+			for( i = 0 ; i < EP93XX_MAX_MEM_WIN ; i++ ) {
+				if( (skt->mem_map[i].flags & MAP_ACTIVE) && 
+					(speed > skt->mem_map[i].speed) )
+					speed = skt->mem_map[i].speed;
+			}
+
+			ulRegValue = ep93xx_calculate_timing( speed );
+
+			if( map->flags & MAP_16BIT )
+				ulRegValue |= PCCONFIG_MW_16BIT;
+
+			outl( ulRegValue, SMC_PCAttribute ); 
+			ulRegValue = inl( SMC_PCAttribute );
+			
+			skt->speed_attr = speed;
+		} 
+		else 
+		{
+			for( i = 0 ; i < EP93XX_MAX_MEM_WIN ; i++ )
+			{
+				if ((skt->mem_map[i].flags & MAP_ACTIVE) && 
+					(speed > skt->mem_map[i].speed) )
+					speed = skt->mem_map[i].speed;
+			}
+
+			ulRegValue = ep93xx_calculate_timing( speed );
+			if( map->flags & MAP_16BIT )
+				ulRegValue |= PCCONFIG_MW_16BIT;
+
+			outl( ulRegValue, SMC_PCCommon ); 
+			ulRegValue = inl( SMC_PCCommon );
+			
+			skt->speed_mem = speed;
+		}
+	}
+
+	start = (map->flags & MAP_ATTRIB) ? EP93XX_PHYS_ADDR_PCMCIAATTR : EP93XX_PHYS_ADDR_PCMCIAMEM;
+
+	if (map->sys_stop == 0)
+		map->sys_stop = PAGE_SIZE-1;
+
+	map->sys_stop -= map->sys_start;
+	map->sys_stop += start;
+	map->sys_start = start;
+
+	skt->mem_map[map->map] = *map;
+
+	DEBUG(2, "%s() for sock %u  Output:\n", __FUNCTION__, sock);
+
+	DEBUG(3, "\tmap %u speed %u sys_start %08lx sys_stop %08lx card_start %08x\n",
+		map->map, map->speed, map->sys_start, map->sys_stop, map->card_start);
+
+	DEBUG(3, "\tflags: %s%s%s%s%s%s%s%s\n",
+		(map->flags==0)?"<NONE>":"",
+		(map->flags&MAP_ACTIVE)?"ACTIVE ":"",
+		(map->flags&MAP_16BIT)?"16BIT ":"",
+		(map->flags&MAP_AUTOSZ)?"AUTOSZ ":"",
+		(map->flags&MAP_0WS)?"0WS ":"",
+		(map->flags&MAP_WRPROT)?"WRPROT ":"",
+		(map->flags&MAP_ATTRIB)?"ATTRIB ":"",
+		(map->flags&MAP_USE_WAIT)?"USE_WAIT ":"");
+
+	DEBUG(3, "ep93xx_set_mem_map - exit\n");
+	return 0;
+}
+
+
+/*
+socket_state_t dead_socket = {
+	.csc_mask	= SS_DETECT,
+};
+*/
+
+static void init_socket(struct pcmcia_socket *s)
+{
+	int i;
+    	pccard_io_map io = { 0, 0, 0, 0, 1 };
+    	pccard_mem_map mem = { 0, 0, 0, 0, 0, 0 };
+
+    	mem.sys_stop = 0;//s->map_size;
+    	s->socket = dead_socket;
+    	s->ops->set_socket(s,&s->socket);
+    	for (i = 0; i < 2; i++) {
+		io.map = i;
+		s->ops->set_io_map(s,&io);
+		//s->ss_entry(s->sock, SS_SetIOMap, &io);
+	//#ifdef CONFIG_VIRTUAL_BUS
+		s->io[i].Attributes=0;
+		s->io[i].BasePort=io.start;
+		s->io[i].NumPorts=(io.stop-io.start)+1;
+		s->io[i].InUse=0;
+		s->io[i].Config=0;
+	//#endif
+    	}
+    	for (i = 0; i < 5; i++) {
+		mem.map = i;
+		s->ops->set_mem_map(s,&mem);
+		//s->ss_entry(s->sock, SS_SetMemMap, &mem);
+    	}
+}
+
+
+static int ep93xx_pcmcia_sock_init(struct pcmcia_socket *sock)
+{
+	DEBUG(3, "ep93xx_pcmcia_sock_init  %x- enter\n",sock->sock);
+
+	init_socket(sock);
+	
+	DEBUG(3, "ep93xx_pcmcia_sock_init - exit\n");
+
+	return 0;
+}
+
+
+static int ep93xx_pcmcia_sock_suspend(struct pcmcia_socket *sock)
+{
+	
+	DEBUG(3, "ep93xx_pcmcia_sock_suspendt - enter\n");
+
+	return 0;
+}
+
+
+static struct pccard_operations ep93xx_pcmcia_operations = {
+	.init			= ep93xx_pcmcia_sock_init,
+	.suspend			= ep93xx_pcmcia_sock_suspend,
+	.register_callback		= ep93xx_register_callback,
+	.get_status		= ep93xx_get_status,
+	.get_socket		= ep93xx_get_socket,
+	.set_socket		= ep93xx_set_socket,
+	.set_io_map		= ep93xx_set_io_map,
+	.set_mem_map		= ep93xx_set_mem_map,
+};
+/*------------------------------------------------------------------------------------------*/
+static int ep93xx_shutdown(void)
+{
+	unsigned long ulTemp;
+	int i;
+
+	DEBUG(3, "ep93xx_shutdown - enter\n");
+
+	del_timer_sync(&poll_timer);
+
+	//
+	// Disable, clear pcmcia irqs in hw.
+	//
+	ulTemp = inl( GPIO_FINTEN );
+	outl( ulTemp & ~EP93XX_GPIOS, GPIO_FINTEN );
+	ulTemp = inl( GPIO_FINTEN );
+
+	outl( EP93XX_GPIOS, GPIO_FEOI );
+	ulTemp = inl( GPIO_FEOI );
+
+	//
+	// Set reset.
+	//
+	outl( (PCCONT_WEN | PCCONT_PC1RST | PCCONT_PC1EN), SMC_PCMCIACtrl );
+	ulTemp = inl( SMC_PCMCIACtrl );
+
+	//
+	// Release memory
+	// Free the pcmcia interrupts.
+	// Set socket voltage to zero
+	//
+	iounmap(socket_info[0].virt_io);
+	socket_info[0].Vcc = EP93XX_UNCONFIGURED_VOLTAGE;
+	ep93xx_set_voltage( 0, 0 );
+
+	for( i = 0; i < ARRAY_SIZE(ep93xx_pcmcia_irqs) ; i++ ) 
+		free_irq( ep93xx_pcmcia_irqs[i].irq, socket_info );
+
+	return 0;
+}
+
+/*
+static int __init ep93xx_init(void)
+{
+	servinfo_t info;
+	unsigned long ulRegValue;
+	int ret, i;
+	unsigned long ulTemp, flags;
+
+	DEBUG(3, "ep93xx_init - enter\n");
+
+	printk(KERN_INFO "EP93XX PCMCIA (CS release %s)\n", CS_RELEASE);
+	
+	//
+	// Initialize our socket info structure.
+	//
+	struct socket_info_t * skt = &socket_info[0];
+	
+	for( i = 0 ; i < EP93XX_MAX_IO_WIN ; i++ )
+	{
+		skt->io_map[i].flags = 0;
+		skt->io_map[i].speed = EP93XX_PCMCIA_IO_ACCESS;
+	}
+
+	for( i = 0 ; i < EP93XX_MAX_MEM_WIN ; i++ )
+	{
+		skt->mem_map[i].flags = 0;
+		skt->mem_map[i].speed = EP93XX_PCMCIA_3V_MEM_ACCESS;
+	}
+
+	skt->card_irq_handler = NULL;
+	skt->cs_event_handler = NULL;
+	skt->cs_handler_info = NULL;
+	skt->dev_id = NULL;
+	
+	skt->speed_io   = EP93XX_PCMCIA_IO_ACCESS;
+	skt->speed_attr = EP93XX_PCMCIA_5V_MEM_ACCESS;
+	skt->speed_mem  = EP93XX_PCMCIA_5V_MEM_ACCESS;
+
+	skt->uiStatus = 0;
+	skt->IrqsToEnable = 0;
+	
+	skt->Vcc = EP93XX_UNCONFIGURED_VOLTAGE;
+	ep93xx_set_voltage(0,0);
+
+	skt->virt_io    = ioremap( EP93XX_PHYS_ADDR_PCMCIAIO, 0x10000 );
+	DEBUG(3, "virt_io is 0x%08x\n", (unsigned int)skt->virt_io );
+	if (skt->virt_io == NULL) {
+		ep93xx_shutdown();
+		return -ENOMEM;
+	}
+
+	skt->bus_ops.priv = 0; // socket number = 0 
+	skt->bus_ops.b_in          = ep93xx_bus_in;
+	skt->bus_ops.b_ins         = ep93xx_bus_ins;
+	skt->bus_ops.b_out         = ep93xx_bus_out;
+	skt->bus_ops.b_outs        = ep93xx_bus_outs;
+	skt->bus_ops.b_ioremap     = ep93xx_bus_ioremap;
+	skt->bus_ops.b_iounmap     = ep93xx_bus_iounmap;
+	skt->bus_ops.b_read        = ep93xx_bus_read;
+	skt->bus_ops.b_write       = ep93xx_bus_write;
+	skt->bus_ops.b_copy_from   = ep93xx_bus_copy_from;
+	skt->bus_ops.b_copy_to     = ep93xx_bus_copy_to;
+	skt->bus_ops.b_request_irq = ep93xx_bus_request_irq;
+	skt->bus_ops.b_free_irq    = ep93xx_bus_free_irq;
+
+
+	CardServices(GetCardServicesInfo, &info);
+	if (info.Revision != CS_RELEASE_CODE){
+		printk(KERN_ERR "Card Services release codes do not match\n");
+		return -EINVAL;
+	}
+
+	//
+	// Disable interrupts in hw for pcmcia.
+	//
+	ulTemp = inl( GPIO_FINTEN );
+	outl( (ulTemp & ~EP93XX_GPIOS), GPIO_FINTEN );
+	ulTemp = inl( GPIO_FINTEN );
+	
+	//
+	// Set data direction to input for pcmcia socket lines.
+	//
+	ulTemp = inl( GPIO_PFDDR );
+	outl( (ulTemp & ~EP93XX_GPIOS), GPIO_PFDDR );
+	ulTemp = inl( GPIO_PFDDR );
+
+	//
+	// Enable debounce for the card detect lines
+	// Set interrupts to be edge sensitive, falling edge triggered.
+	//
+	ulTemp = inl( GPIO_FDB ) & ~EP93XX_GPIOS;
+	outl( (EP93XX_PCMCIA_CD1 | EP93XX_PCMCIA_CD2) | ulTemp, GPIO_FDB );
+
+	ulTemp = inl( GPIO_FINTTYPE1 ) & ~EP93XX_GPIOS;
+	outl(  EP93XX_GPIOS | ulTemp, GPIO_FINTTYPE1 );
+
+	ulTemp = inl( GPIO_FINTTYPE2 ) & ~EP93XX_GPIOS;
+	outl( ulTemp, GPIO_FINTTYPE2 );
+	ulTemp = inl( GPIO_FINTTYPE2 );
+
+	//
+	// Clear all interrupts for GPIO port F.
+	//
+	outl( EP93XX_GPIOS, GPIO_FEOI );
+	ulTemp = inl( GPIO_FEOI );
+
+	//
+	// Register ISR.  EP93XX_PCMCIA_INT_RDY is a shared interrupt as
+	// the kernel IDE stack has its own interrupt handler that it
+	// will register for it.
+	//
+	for( i = 0; i < ARRAY_SIZE(ep93xx_pcmcia_irqs) ; i++ )
+	{
+		if ( ep93xx_pcmcia_irqs[i].irq == EP93XX_PCMCIA_INT_RDY )
+			flags = SA_INTERRUPT | SA_SHIRQ;
+		else
+			flags = SA_INTERRUPT;
+		
+		if( request_irq( ep93xx_pcmcia_irqs[i].irq, ep93xx_interrupt, 
+				flags, ep93xx_pcmcia_irqs[i].str, socket_info ) ) 
+		{
+			printk( KERN_ERR "%s: request for IRQ%d failed\n",
+				   __FUNCTION__, ep93xx_pcmcia_irqs[i].irq );
+
+			while (i--)
+				free_irq( ep93xx_pcmcia_irqs[i].irq, socket_info );
+			
+			return -EINVAL;
+		}
+	}
+
+	DEBUG(3, "ep93xx_init GPIO_F: INTEN=0x%02x  DDR=0x%02x DB=0x%02x INTTYP1=0x%02x INTTYP2=0x%02x\n",
+		 inl( GPIO_FINTEN ), inl( GPIO_PFDDR ),	inl( GPIO_FDB ),
+		 inl( GPIO_FINTTYPE1 ), inl( GPIO_FINTTYPE2 ) );
+
+	//
+	// Set speed to the defaults
+	//
+	ulRegValue = ep93xx_calculate_timing( skt->speed_io );
+	outl( ulRegValue, SMC_PCIO );
+	ulRegValue = ep93xx_calculate_timing( skt->speed_attr );
+	outl( ulRegValue, SMC_PCAttribute ); 
+	ulRegValue = ep93xx_calculate_timing( skt->speed_mem );
+	outl( ulRegValue, SMC_PCCommon ); 
+	ulRegValue = inl( SMC_PCCommon ); // Push the out thru the wrapper
+
+	DEBUG(3, "INITIALIZING SMC: Attr:%08x  Comm:%08x  IO:%08x  Ctrl:%08x\n",
+		inl( SMC_PCAttribute ), inl( SMC_PCCommon), 
+		inl( SMC_PCIO ), inl( SMC_PCMCIACtrl ) );
+
+	// Only advertise as many sockets as we can detect 
+	if ((ret = register_ss_entry( EP93XX_MAX_SOCK, &ep93xx_service)) < 0){
+		printk(KERN_ERR "Unable to register sockets\n");
+		ep93xx_shutdown();
+		return ret;
+	}
+
+	//
+	// Clear and enable the RDY interrupt in hardware.  We leave this 
+	// interrupt enabled because the kernel IDE stack will register its own
+	// interrupt handler and not go thru this module to do it.  The
+	// other interrupts are enabled in set_socket.
+	//
+	outl( EP93XX_PCMCIA_RDY, GPIO_FEOI );
+	ulTemp = inl( GPIO_FEOI );
+	
+	ulTemp = inl( GPIO_FINTEN ) & ~EP93XX_GPIOS;
+	outl( ulTemp | EP93XX_PCMCIA_RDY, GPIO_FINTEN );
+	ulTemp = inl( GPIO_FINTEN );
+
+	//
+	 // Start the event poll timer.  It will reschedule by itself afterwards.
+	 //
+	ep93xx_pcmcia_poll_event(0);
+
+	return 0;
+}
+
+
+
+static void __exit ep93xx_exit(void)
+{
+	unregister_ss_entry(&ep93xx_service);
+	ep93xx_shutdown();
+}
+*/
+
+/*-------------------------------------------------------------------------------------------*/
+
+
+
+int ep93xx_drv_pcmcia_probe(struct device *dev)
+{
+	unsigned long ulRegValue;
+	unsigned long ulTemp, flags;
+	int ret=0, i;
+	
+
+	DEBUG(3, "ep93xx_init - enter\n");
+
+	//printk(KERN_INFO,"EP93XX PCMCIA (CS release %s)\n", CS_RELEASE);
+
+	if (!dev ){
+		DEBUG(3, "no device - error\n");
+		return -ENODEV;
+
+	}
+
+	/*down(&soc_pcmcia_sockets_lock);*/
+	
+	/*kmalloc  socket structure.*/
+	/*
+	sinfo = kmalloc(SKT_DEV_INFO_SIZE(nr), GFP_KERNEL);
+	if (!sinfo) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memset(sinfo, 0, SKT_DEV_INFO_SIZE(nr));
+	sinfo->nskt = nr;
+	*/
+
+	
+	/*
+	 * Initialise the per-socket structure.
+	 */
+	for (i = 0; i < EP93XX_MAX_SOCK; i++) {
+		/*struct soc_pcmcia_socket *skt = &sinfo->skt[i];*/
+		struct socket_info_t * skt = &socket_info[i];
+
+		skt->socket.ops 		= &ep93xx_pcmcia_operations;
+		skt->socket.owner 	= THIS_MODULE;
+		skt->socket.dev.dev 	= dev;
+
+		
+		/*init the poll timer*/
+		/*
+		init_timer(&skt->poll_timer);
+		skt->poll_timer.function = soc_common_pcmcia_poll_event;
+		skt->poll_timer.data = (unsigned long)skt;
+		skt->poll_timer.expires = jiffies + SOC_PCMCIA_POLL_PERIOD;
+		*/
+		init_timer(&poll_timer);
+	  	poll_timer.function = 	(void *)ep93xx_timer;//ep93xx_pcmcia_poll_event;
+  		poll_timer.expires = 	jiffies + EP9315_PCMCIA_POLL_PERIOD;
+		poll_timer.data =	(unsigned long)socket_info;
+
+
+	
+		skt->nr		=  i;
+		skt->irq		= NO_IRQ;
+		skt->dev		= dev;
+		
+		/*skt->ops	= ops;*/
+
+		/*resource*/
+		/*
+		skt->res_skt.start	= _PCMCIA(skt->nr);
+		skt->res_skt.end	= _PCMCIA(skt->nr) + PCMCIASp - 1;
+		skt->res_skt.name	= skt_names[skt->nr];
+		skt->res_skt.flags	= IORESOURCE_MEM;
+
+		ret = request_resource(&iomem_resource, &skt->res_skt);
+		if (ret)
+			goto out_err_1;
+		*/
+
+		
+		/*io_map resource*/
+		/*
+		skt->res_io.start	= _PCMCIAIO(skt->nr);
+		skt->res_io.end		= _PCMCIAIO(skt->nr) + PCMCIAIOSp - 1;
+		skt->res_io.name	= "io";
+		skt->res_io.flags	= IORESOURCE_MEM | IORESOURCE_BUSY;
+		
+		ret = request_resource(&skt->res_skt, &skt->res_io);
+		if (ret)
+			goto out_err_2;
+		*/
+		for( i = 0 ; i < EP93XX_MAX_IO_WIN ; i++ ){
+		skt->io_map[i].flags = 0;
+		skt->io_map[i].speed = EP93XX_PCMCIA_IO_ACCESS;
+		}		
+
+		/*mem_map resource*/
+		/*
+		skt->res_mem.start	= _PCMCIAMem(skt->nr);
+		skt->res_mem.end	= _PCMCIAMem(skt->nr) + PCMCIAMemSp - 1;
+		skt->res_mem.name	= "memory";
+		skt->res_mem.flags	= IORESOURCE_MEM;
+
+		ret = request_resource(&skt->res_skt, &skt->res_mem);
+		if (ret)
+			goto out_err_3;
+		*/
+		for( i = 0 ; i < EP93XX_MAX_MEM_WIN ; i++ ){
+		skt->mem_map[i].flags = 0;
+		skt->mem_map[i].speed = EP93XX_PCMCIA_3V_MEM_ACCESS;
+		}
+
+		/*attr_map resource*/
+		/*
+		skt->res_attr.start	= _PCMCIAAttr(skt->nr);
+		skt->res_attr.end	= _PCMCIAAttr(skt->nr) + PCMCIAAttrSp - 1;
+		skt->res_attr.name	= "attribute";
+		skt->res_attr.flags	= IORESOURCE_MEM;
+
+		ret = request_resource(&skt->res_skt, &skt->res_attr);
+		if (ret)
+			goto out_err_4;
+		*/
+
+		/*===========================================*/	
+		skt->card_irq_handler = NULL;
+		skt->cs_event_handler = NULL;
+		skt->cs_handler_info = NULL;
+		skt->dev_id = NULL;
+		
+		skt->speed_io   = EP93XX_PCMCIA_IO_ACCESS;
+		skt->speed_attr = EP93XX_PCMCIA_5V_MEM_ACCESS;
+		skt->speed_mem  = EP93XX_PCMCIA_5V_MEM_ACCESS;
+
+		skt->uiStatus = 0;
+		skt->IrqsToEnable = 0;
+		
+		skt->Vcc = EP93XX_UNCONFIGURED_VOLTAGE;
+		ep93xx_set_voltage(0,0);
+		/*===========================================*/
+
+		
+		/*virt memory remap*/
+		/*
+		skt->virt_io = ioremap(skt->res_io.start, 0x10000);
+		if (skt->virt_io == NULL) {
+			ret = -ENOMEM;
+			goto out_err_5;
+		}
+		*/
+		skt->virt_io    = ioremap( EP93XX_PHYS_ADDR_PCMCIAIO, 0x10000 );
+		DEBUG(3, "virt_io is 0x%08x\n", (unsigned int)skt->virt_io );
+		if (skt->virt_io == NULL) {
+			ep93xx_shutdown();
+			ret = -ENOMEM;
+			return -ENOMEM;
+		}
+		/*================================================*/
+		skt->bus_ops.priv = 0; /* socket number = 0 */
+		skt->bus_ops.b_in          = ep93xx_bus_in;
+		/*skt->bus_ops.b_ins         = ep93xx_bus_ins;*/
+		skt->bus_ops.b_out         = ep93xx_bus_out;
+		/*skt->bus_ops.b_outs        = ep93xx_bus_outs;*/
+		skt->bus_ops.b_ioremap     = ep93xx_bus_ioremap;
+		skt->bus_ops.b_iounmap     = ep93xx_bus_iounmap;
+		skt->bus_ops.b_read        = ep93xx_bus_read;
+		skt->bus_ops.b_write       = ep93xx_bus_write;
+		skt->bus_ops.b_copy_from   = ep93xx_bus_copy_from;
+		skt->bus_ops.b_copy_to     = ep93xx_bus_copy_to;
+		skt->bus_ops.b_request_irq = ep93xx_bus_request_irq;
+		skt->bus_ops.b_free_irq    = ep93xx_bus_free_irq;
+
+
+		/*CardServices(GetCardServicesInfo, &info);
+		if (info.Revision != CS_RELEASE_CODE){
+			printk(KERN_ERR "Card Services release codes do not match\n");
+			return -EINVAL;
+		}*/
+
+		//
+		// Disable interrupts in hw for pcmcia.
+		//
+		ulTemp = inl( GPIO_FINTEN );
+		outl( (ulTemp & ~EP93XX_GPIOS), GPIO_FINTEN );
+		ulTemp = inl( GPIO_FINTEN );
+		
+		//
+		// Set data direction to input for pcmcia socket lines.
+		//
+		ulTemp = inl( GPIO_PFDDR );
+		outl( (ulTemp & ~EP93XX_GPIOS), GPIO_PFDDR );
+		ulTemp = inl( GPIO_PFDDR );
+
+		//
+		// Enable debounce for the card detect lines
+		// Set interrupts to be edge sensitive, falling edge triggered.
+		//
+		ulTemp = inl( GPIO_FDB ) & ~EP93XX_GPIOS;
+		outl( (EP93XX_PCMCIA_CD1 | EP93XX_PCMCIA_CD2) | ulTemp, GPIO_FDB );
+
+		ulTemp = inl( GPIO_FINTTYPE1 ) & ~EP93XX_GPIOS;
+		outl(  EP93XX_GPIOS | ulTemp, GPIO_FINTTYPE1 );
+
+		ulTemp = inl( GPIO_FINTTYPE2 ) & ~EP93XX_GPIOS;
+		outl( ulTemp, GPIO_FINTTYPE2 );
+		ulTemp = inl( GPIO_FINTTYPE2 );
+
+		//
+		// Clear all interrupts for GPIO port F.
+		//
+		outl( EP93XX_GPIOS, GPIO_FEOI );
+		ulTemp = inl( GPIO_FEOI );
+
+		//
+		// Register ISR.  EP93XX_PCMCIA_INT_RDY is a shared interrupt as
+		// the kernel IDE stack has its own interrupt handler that it
+		// will register for it.
+		//
+		for( i = 0; i < ARRAY_SIZE(ep93xx_pcmcia_irqs) ; i++ )
+		{
+			if ( ep93xx_pcmcia_irqs[i].irq == EP93XX_PCMCIA_INT_RDY )
+				flags = SA_INTERRUPT | SA_SHIRQ;
+			else
+				flags = SA_INTERRUPT;
+			
+			if( request_irq( ep93xx_pcmcia_irqs[i].irq, ep93xx_interrupt, 
+					flags, ep93xx_pcmcia_irqs[i].str, socket_info ) ) 
+			{
+				printk( KERN_ERR "%s: request for IRQ%d failed\n",
+					   __FUNCTION__, ep93xx_pcmcia_irqs[i].irq );
+
+				while (i--)
+					free_irq( ep93xx_pcmcia_irqs[i].irq, socket_info );
+				
+				return -EINVAL;
+			}
+		}
+
+		DEBUG(3, "ep93xx_init GPIO_F: INTEN=0x%02x  DDR=0x%02x DB=0x%02x INTTYP1=0x%02x INTTYP2=0x%02x\n",
+			 inl( GPIO_FINTEN ), inl( GPIO_PFDDR ),	inl( GPIO_FDB ),
+			 inl( GPIO_FINTTYPE1 ), inl( GPIO_FINTTYPE2 ) );
+
+	
+		/*================================================*/
+		/*
+		if ( list_empty(&soc_pcmcia_sockets) )
+			soc_pcmcia_cpufreq_register();
+
+		list_add(&skt->node, &soc_pcmcia_sockets);
+		*/
+
+		/*
+		 * We initialize default socket timing here, because
+		 * we are not guaranteed to see a SetIOMap operation at
+		 * runtime.
+		 */
+		/*ops->set_timing(skt);*/
+		
+		//
+		// Set speed to the defaults
+		//
+		ulRegValue = ep93xx_calculate_timing( skt->speed_io );
+		outl( ulRegValue, SMC_PCIO );
+		ulRegValue = ep93xx_calculate_timing( skt->speed_attr );
+		outl( ulRegValue, SMC_PCAttribute ); 
+		ulRegValue = ep93xx_calculate_timing( skt->speed_mem );
+		outl( ulRegValue, SMC_PCCommon ); 
+		ulRegValue = inl( SMC_PCCommon ); // Push the out thru the wrapper
+
+		DEBUG(3, "INITIALIZING SMC: Attr:%08x  Comm:%08x  IO:%08x  Ctrl:%08x\n",
+			inl( SMC_PCAttribute ), inl( SMC_PCCommon), 
+			inl( SMC_PCIO ), inl( SMC_PCMCIACtrl ) );
+		
+		/*
+		 *initialize the  socket HW
+		 */
+		/*
+		ret = ops->hw_init(skt);
+		if (ret)
+			goto out_err_6;
+		*/
+		
+		/*initialize the  socket info*/
+		/*
+		skt->socket.features = SS_CAP_STATIC_MAP|SS_CAP_PCCARD;
+		skt->socket.irq_mask = 0;
+		skt->socket.map_size = PAGE_SIZE;
+		skt->socket.pci_irq = skt->irq;
+		skt->socket.io_offset = (unsigned long)skt->virt_io;
+		*/
+		skt->socket.features=(SS_CAP_PAGE_REGS  | SS_CAP_VIRTUAL_BUS | SS_CAP_MEM_ALIGN |
+		 			SS_CAP_STATIC_MAP | SS_CAP_PCCARD);
+		skt->socket.irq_mask  = 0;
+		skt->socket.map_size  = PAGE_SIZE;
+		skt->socket.pci_irq   = EP93XX_PCMCIA_INT_RDY;
+
+		skt->socket.sock   = i;
+		//cap->cardbus   = 0;
+		//cap->cb_bus    = NULL;
+		//cap->bus       = &(socket_info[sock].bus_ops);
+		skt->socket.io_offset = (unsigned long)skt->virt_io;
+
+		
+		/*skt->status = soc_common_pcmcia_skt_state(skt);*/
+		
+		ret = pcmcia_register_socket(&skt->socket);
+		if (ret){
+			/*goto out_err_7;*/
+			printk(KERN_ERR "Unable to register sockets\n");
+			ep93xx_shutdown();
+			return ret;
+
+		}
+
+		//WARN_ON(skt->socket.sock != i);
+
+		/*add_timer(&skt->poll_timer);*/
+
+		//
+		// Clear and enable the RDY interrupt in hardware.  We leave this 
+		// interrupt enabled because the kernel IDE stack will register its own
+		// interrupt handler and not go thru this module to do it.  The
+		// other interrupts are enabled in set_socket.
+		//
+		outl( EP93XX_PCMCIA_RDY, GPIO_FEOI );
+		ulTemp = inl( GPIO_FEOI );
+		
+		ulTemp = inl( GPIO_FINTEN ) & ~EP93XX_GPIOS;
+		outl( ulTemp | EP93XX_PCMCIA_RDY, GPIO_FINTEN );
+		ulTemp = inl( GPIO_FINTEN );
+
+		/*
+		 * Start the event poll timer.  It will reschedule by itself afterwards.
+		 */
+		//ep93xx_pcmcia_poll_event(0);
+		add_timer(&poll_timer);
+		DEBUG(3, "ep93xx_init - poll evevt \n");
+		
+		class_device_create_file(&skt->socket.dev, &class_device_attr_status);
+		DEBUG(3, "ep93xx_init - creat file \n");
+	}
+
+	dev_set_drvdata(dev, socket_info);
+/*
+	dev_set_drvdata(dev, sinfo);
+	ret = 0;
+	goto out;
+
+	do {
+		struct soc_pcmcia_socket *skt = &sinfo->skt[i];
+
+		del_timer_sync(&skt->poll_timer);
+		pcmcia_unregister_socket(&skt->socket);
+
+ out_err_7:
+		flush_scheduled_work();
+
+		ops->hw_shutdown(skt);
+ out_err_6:
+ 		list_del(&skt->node);
+		iounmap(skt->virt_io);
+ out_err_5:
+		release_resource(&skt->res_attr);
+out_err_4:
+		release_resource(&skt->res_mem);
+ out_err_3:
+		release_resource(&skt->res_io);
+ out_err_2:
+		release_resource(&skt->res_skt);
+ out_err_1:
+		i--;
+	} while (i > 0);
+
+	kfree(sinfo);
+
+ out:
+	up(&soc_pcmcia_sockets_lock);
+	return ret;
+*/
+	DEBUG(3, "ep93xx_init - exit %x\n",ret);
+	return ret;
+}
+
+
+int ep93xx_drv_pcmcia_remove(struct device *dev)
+{
+	int i;
+	DEBUG(3, "ep93xx_remove - enter \n");
+	for (i = 0; i < EP93XX_MAX_SOCK; i++) {
+		/*struct soc_pcmcia_socket *skt = &sinfo->skt[i];*/
+		struct socket_info_t * skt = &socket_info[i];
+
+		pcmcia_unregister_socket(&skt->socket);
+
+	}
+	ep93xx_shutdown();
+	DEBUG(3, "ep93xx_remove - exit \n");
+	return 0;
+}
+
+
+static int ep93xx_drv_pcmcia_suspend(struct device *dev, u32 state, u32 level)
+{
+	int ret = 0;
+	DEBUG(3, "ep93xx_drv_pcmcia_suspend - enter\n");
+
+	if (level == SUSPEND_SAVE_STATE)
+		ret = pcmcia_socket_dev_suspend(dev, state);
+	
+	DEBUG(3, "ep93xx_drv_pcmcia_suspend - exit\n");
+	return ret;
+}
+
+static int ep93xx_drv_pcmcia_resume(struct device *dev, u32 level)
+{
+	int ret = 0;
+	DEBUG(3, "ep93xx_drv_pcmcia_resume - enter\n");
+	
+	if (level == RESUME_RESTORE_STATE)
+		ret = pcmcia_socket_dev_resume(dev);
+
+	DEBUG(3, "ep93xx_drv_pcmcia_resume - exit\n");
+	return ret;
+}
+
+static struct device_driver ep93xx_pcmcia_driver = {
+	.probe		= ep93xx_drv_pcmcia_probe,
+	.remove		= ep93xx_drv_pcmcia_remove,
+	.suspend 		= ep93xx_drv_pcmcia_suspend,
+	.resume 		= ep93xx_drv_pcmcia_resume,
+	.name		= "ep93xx-pcmcia",
+	.bus		= &platform_bus_type,
+};
+
+static int __init ep93xx_pcmcia_init(void)
+{
+	return driver_register(&ep93xx_pcmcia_driver);
+}
+
+static void __exit ep93xx_pcmcia_exit(void)
+{
+	driver_unregister(&ep93xx_pcmcia_driver);
+}
+
+module_init(ep93xx_pcmcia_init);
+module_exit(ep93xx_pcmcia_exit);
+
+
+MODULE_AUTHOR("Shrek Wu");
+MODULE_DESCRIPTION("Cirrus Logic EP93xx pcmcia socket driver");
+MODULE_LICENSE("Dual MPL/GPL");
diff -burN linux-2.6.8.1-orig/drivers/pcmcia/ep93xx_pcmcia.h linux-2.6.8.1/drivers/pcmcia/ep93xx_pcmcia.h
--- linux-2.6.8.1-orig/drivers/pcmcia/ep93xx_pcmcia.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/pcmcia/ep93xx_pcmcia.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,93 @@
+/*
+ * ep93xx_pcmcia.h
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License
+ * at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and
+ * limitations under the License. 
+ *
+ * The initial developer of the original code is David A. Hinds
+ * <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
+ * are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
+ *
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License version 2 (the "GPL"), in
+ * which case the provisions of the GPL are applicable instead of the
+ * above.  If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use
+ * your version of this file under the MPL, indicate your decision by
+ * deleting the provisions above and replace them with the notice and
+ * other provisions required by the GPL.  If you do not delete the
+ * provisions above, a recipient may use your version of this file
+ * under either the MPL or the GPL.
+ */
+
+#ifndef _LINUX_EP93XX_PCMCIA_H
+#define _LINUX_EP93XX_PCMCIA_H
+
+//
+// PCMCIA memory mappings.
+//
+#define EP93XX_PHYS_ADDR_PCMCIAMEM 	(PCMCIA_BASE_PHYS + 0xC000000)
+#define EP93XX_SIZE_PCMCIAMEM		0x04000000
+
+#define EP93XX_PHYS_ADDR_PCMCIAATTR	(PCMCIA_BASE_PHYS + 0x8000000)
+#define EP93XX_SIZE_PCMCIAATTR		0x04000000
+
+#define EP93XX_PHYS_ADDR_PCMCIAIO	(PCMCIA_BASE_PHYS)
+#define EP93XX_SIZE_PCMCIAIO		0x04000000
+
+//
+// EEprom control signals.
+//
+#define  GPIOA_EECLK                    0x01
+#define  GPIOA_EEDAT                    0x02
+#define  GPIOA_SLA0                     0x04
+
+//
+// PCMCIA status signals = GPIO port F.
+// 
+#define EP93XX_PCMCIA_WP          		0x01
+#define EP93XX_PCMCIA_CD1         		0x02
+#define EP93XX_PCMCIA_CD2         		0x04
+#define EP93XX_PCMCIA_BVD1        		0x08
+#define EP93XX_PCMCIA_BVD2        		0x10
+#define EP93XX_PCMCIA_VS1         		0x20
+#define EP93XX_PCMCIA_RDY         		0x40
+#define EP93XX_PCMCIA_VS2				0x80
+
+#define EP93XX_PCMCIA_INT_WP			IRQ_GPIO0	/* 19 */
+#define EP93XX_PCMCIA_INT_CD1           IRQ_GPIO1	/* 20 */
+#define EP93XX_PCMCIA_INT_CD2           IRQ_GPIO2	/* 21 */
+#define EP93XX_PCMCIA_INT_BVD1          IRQ_GPIO3	/* 22 */
+#define EP93XX_PCMCIA_INT_BVD2          IRQ_GPIO4	/* 47 */
+#define EP93XX_PCMCIA_INT_VS1           IRQ_GPIO5	/* 48 */
+#define EP93XX_PCMCIA_INT_RDY           IRQ_GPIO6	/* 49 */
+#define EP93XX_PCMCIA_INT_VS2           IRQ_GPIO7	/* 50 */
+
+//
+// Definitions to program the TPS2202A PCMCIA controller.
+//
+#define AVCC_0V         			0x000
+#define AVCC_33V        			0x004
+#define AVCC_5V         			0x008
+#define BVCC_0V         			0x000
+#define BVCC_33V        			0x080
+#define BVCC_5V         			0x040
+#define AVPP_0V         			0x000
+#define BVPP_0V         			0x000
+#define ENABLE          			0x100
+#define EE_ADDRESS      			(0x55<<9)
+
+#define EP93XX_MAX_SOCK   (1)
+
+#define EP93XX_PCMCIA_IO_ACCESS      (300)
+#define EP93XX_PCMCIA_5V_MEM_ACCESS  (300)
+#define EP93XX_PCMCIA_3V_MEM_ACCESS  (600)
+
+#endif /* _LINUX_EP93XX_PCMCIA_H */
diff -burN linux-2.6.8.1-orig/drivers/serial/Kconfig linux-2.6.8.1/drivers/serial/Kconfig
--- linux-2.6.8.1-orig/drivers/serial/Kconfig	2004-08-14 19:56:22.000000000 +0900
+++ linux-2.6.8.1/drivers/serial/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -238,6 +238,37 @@
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_EP93XX
+	tristate "EP93xx serial port support"
+	depends on ARM && ARCH_EP93XX
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Cirrus Logic EP93xx CPU,
+	  providing /dev/ttyAM0, 1, and 2 (note, some machines may not provide
+	  all of these ports).
+
+config SERIAL_EP93XX_CONSOLE
+	bool "Support for console on EP93xx serial port"
+	depends on SERIAL_EP93XX=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default (if
+	  available), but you can alter that by using a kernel command line
+	  option such as "console=ttyAM0".
+
+config EP93XX_SERIAL_FLASH
+	tristate "device driver for SST 25LF0x0 serial flash on Cirrus Logic EP93xx boards"
+	depends on ARCH_EP93XX && SERIAL_EP93XX=y
+	help
+	    EDB93XX boards are usually equipped with AT25F1024 devices.
+	    Unfortunately these devices are not fully compatible with
+	    the EP93XX SPI interface. SST25LF010,020,040 devices, however
+	    do work properly with EP93XX. This device driver will allow 
+	    access to these devices from user applications.
+	    this driver might have side effects with other devices on
+	    the SPI interface.
+
 config SERIAL_S3C2410
 	tristate "Samsung S3C2410 Serial port support"
 	depends on ARM && ARCH_S3C2410
diff -burN linux-2.6.8.1-orig/drivers/serial/Makefile linux-2.6.8.1/drivers/serial/Makefile
--- linux-2.6.8.1-orig/drivers/serial/Makefile	2004-08-14 19:55:32.000000000 +0900
+++ linux-2.6.8.1/drivers/serial/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -18,6 +18,8 @@
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
+obj-$(CONFIG_SERIAL_EP93XX) += ep93xx.o
+obj-$(CONFIG_EP93XX_SERIAL_FLASH) += ep93xx_eeprom.o
 obj-$(CONFIG_SERIAL_PXA) += pxa.o
 obj-$(CONFIG_SERIAL_SA1100) += sa1100.o
 obj-$(CONFIG_SERIAL_S3C2410) += s3c2410.o
diff -burN linux-2.6.8.1-orig/drivers/serial/ep93xx.c linux-2.6.8.1/drivers/serial/ep93xx.c
--- linux-2.6.8.1-orig/drivers/serial/ep93xx.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/serial/ep93xx.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,973 @@
+/*
+ *  linux/drivers/serial/cs93xx.c
+ *
+ *  Driver for EP93xx serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o,
+ *  Deep Blue Solutions Ltd.
+ *
+ *  Copyright 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright (c) 2003 Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: ep93xx.c,v 1.2 2004/11/15 17:24:37 bkircher Exp $
+ *
+ * The EP93xx serial ports are AMBA, but at different addresses from the
+ * integrator.
+ * This is a generic driver for ARM AMBA-type serial ports.  They
+ * have a lot of 16550-like features, but are not register compatable.
+ * Note that although they do have CTS, DCD and DSR inputs, they do
+ * not have an RI input, nor do they have DTR or RTS outputs.  If
+ * required, these have to be supplied via some other means (eg, GPIO)
+ * and hooked into this driver.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#if defined(CONFIG_SERIAL_EP93XX_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/serial_core.h>
+
+#if defined(CONFIG_ARCH_EP9301) || defined(CONFIG_ARCH_EP9302)
+#ifdef CONFIG_EP93XX_IRDA
+#define UART_NR		1
+#else
+#define UART_NR		2
+#endif
+#else
+#ifdef CONFIG_EP93XX_IRDA
+#define UART_NR		2
+#else
+#define UART_NR		3
+#endif
+#endif
+
+#define SERIAL_EP93XX_MAJOR	204
+#define SERIAL_EP93XX_MINOR	16
+#define SERIAL_EP93XX_NR	UART_NR
+
+#define EP93XX_ISR_PASS_LIMIT	256
+
+/*
+ * Access macros for the AMBA UARTs
+ */
+#define UART_GET_INT_STATUS(p)	((readl((p)->membase + UARTIIR)) & 0xff)
+#define UART_PUT_ICR(p, c)	writel((c), (p)->membase + UARTICR)
+#define UART_GET_FR(p)		((readl((p)->membase + UARTFR)) & 0xff)
+#define UART_GET_CHAR(p)	((readl((p)->membase + UARTDR)) & 0xff)
+#define UART_PUT_CHAR(p, c)	writel((c), (p)->membase + UARTDR)
+#define UART_GET_RSR(p)		((readl((p)->membase + UARTRSR)) & 0xff)
+#define UART_PUT_RSR(p, c)	writel((c), (p)->membase + UARTRSR)
+#define UART_GET_CR(p)		((readl((p)->membase + UARTCR)) & 0xff)
+#define UART_PUT_CR(p,c)	writel((c), (p)->membase + UARTCR)
+#define UART_GET_LCRL(p)	((readl((p)->membase + UARTCR_L)) & 0xff)
+#define UART_PUT_LCRL(p,c)	writel((c), (p)->membase + UARTCR_L)
+#define UART_GET_LCRM(p)	((readl((p)->membase + UARTCR_M)) & 0xff)
+#define UART_PUT_LCRM(p,c)	writel((c), (p)->membase + UARTCR_M)
+#define UART_GET_LCRH(p)	((readl((p)->membase + UARTCR_H)) & 0xff)
+#define UART_PUT_LCRH(p,c)	writel((c), (p)->membase + UARTCR_H)
+#define UART_RX_DATA(s)		(((s) & UARTFR_RXFE) == 0)
+#define UART_TX_READY(s)	(((s) & UARTFR_TXFF) == 0)
+#define UART_TX_EMPTY(p)	((UART_GET_FR(p) & UARTFR_TMSK) == 0)
+
+#define UART_GET_MCR(p)		readl((p)->membase + UARTMCR)
+#define UART_PUT_MCR(c, p)	writel((c), (p)->membase + UARTMCR)
+#define UART_CLEAR_ECR(p)	writel( 0, (p)->membase + UARTECR)
+
+#define UART_DUMMY_RSR_RX	256
+#define UART_PORT_SIZE		65536
+
+/*
+ * We wrap our port structure around the generic uart_port.
+ */
+struct uart_ep93xx_port {
+	struct uart_port	port;
+	unsigned int		old_status;
+};
+
+
+static void
+ep93xxuart_enable_clocks(struct uart_port *port)
+{
+	unsigned int uiSysDevCfg;
+
+	/*
+	 * Enable the clocks to this UART in CSC_syscon
+	 * - Read DEVCFG
+	 * - OR in the correct uart enable bit
+	 * - Set the lock register
+	 * - Write back to DEVCFG
+	 */
+	uiSysDevCfg = inl(SYSCON_DEVCFG);
+
+	switch ((unsigned long)port->membase) {
+	case UART1_BASE:
+		uiSysDevCfg |= SYSCON_DEVCFG_U1EN;
+		break;
+
+	case UART2_BASE:
+		uiSysDevCfg |= SYSCON_DEVCFG_U2EN;
+		break;
+
+	case UART3_BASE:
+		uiSysDevCfg |= SYSCON_DEVCFG_U3EN;
+		break;
+	}
+
+	SysconSetLocked( SYSCON_DEVCFG, uiSysDevCfg );
+}
+
+static void
+ep93xxuart_disable_clocks(struct uart_port *port)
+{
+	unsigned int uiSysDevCfg;
+
+	/*
+	 * Disable the clocks to this UART in CSC_syscon
+	 * - Read DEVCFG
+	 * - AND to clear the correct uart enable bit
+	 * - Set the lock register
+	 * - Write back to DEVCFG
+	 */
+	uiSysDevCfg = inl(SYSCON_DEVCFG);
+
+	switch ((unsigned long)port->membase) {
+	case UART1_BASE:
+		uiSysDevCfg &= ~((unsigned int)SYSCON_DEVCFG_U1EN);
+		break;
+
+	case UART2_BASE:
+		uiSysDevCfg &= ~((unsigned int)SYSCON_DEVCFG_U2EN);
+		break;
+
+	case UART3_BASE:
+		uiSysDevCfg &= ~((unsigned int)SYSCON_DEVCFG_U3EN);
+		break;
+	}
+
+	SysconSetLocked( SYSCON_DEVCFG, uiSysDevCfg );
+}
+
+#if 1
+static int
+ep93xxuart_is_port_enabled(struct uart_port *port)
+{
+	unsigned int uiSysDevCfg;
+
+	uiSysDevCfg = inl(SYSCON_DEVCFG);
+
+	switch ((unsigned long)port->membase) {
+	case UART1_BASE:
+		uiSysDevCfg &= (unsigned int)SYSCON_DEVCFG_U1EN;
+		break;
+
+	case UART2_BASE:
+		uiSysDevCfg &= (unsigned int)SYSCON_DEVCFG_U2EN;
+		break;
+
+	case UART3_BASE:
+		uiSysDevCfg &= (unsigned int)SYSCON_DEVCFG_U3EN;
+		break;
+	}
+
+	return( uiSysDevCfg != 0 );
+}
+#endif
+
+static void
+ep93xxuart_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	unsigned int cr;
+
+	cr = UART_GET_CR(port);
+	cr &= ~UARTCR_TIE;
+	UART_PUT_CR(port, cr);
+}
+
+static void
+ep93xxuart_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	unsigned int cr;
+
+	cr = UART_GET_CR(port);
+	cr |= UARTCR_TIE;
+	UART_PUT_CR(port, cr);
+}
+
+static void
+ep93xxuart_stop_rx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_CR(port);
+	cr &= ~(UARTCR_RIE | UARTCR_RTIE);
+	UART_PUT_CR(port, cr);
+}
+
+static void
+ep93xxuart_enable_ms(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_CR(port);
+	cr |= UARTCR_MSIE;
+	UART_PUT_CR(port, cr);
+}
+
+static void
+#ifdef SUPPORT_SYSRQ
+ep93xxuart_rx_chars(struct uart_port *port, struct pt_regs *regs)
+#else
+ep93xxuart_rx_chars(struct uart_port *port)
+#endif
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int status, ch, rsr, max_count = 256;
+
+	status = UART_GET_FR(port);
+	while (UART_RX_DATA(status) && max_count--) {
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			tty->flip.work.func((void *)tty);
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				printk(KERN_WARNING "TTY_DONT_FLIP set\n");
+				return;
+			}
+		}
+
+		ch = UART_GET_CHAR(port);
+
+		*tty->flip.char_buf_ptr = ch;
+		*tty->flip.flag_buf_ptr = TTY_NORMAL;
+		port->icount.rx++;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		rsr = UART_GET_RSR(port) | UART_DUMMY_RSR_RX;
+		UART_PUT_RSR(port, 0);
+		if (rsr & UARTRSR_ANY) {
+			if (rsr & UARTRSR_BE) {
+				rsr &= ~(UARTRSR_FE | UARTRSR_PE);
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					goto ignore_char;
+			} else if (rsr & UARTRSR_PE)
+				port->icount.parity++;
+			else if (rsr & UARTRSR_FE)
+				port->icount.frame++;
+			if (rsr & UARTRSR_OE)
+				port->icount.overrun++;
+
+			rsr &= port->read_status_mask;
+
+			if (rsr & UARTRSR_BE)
+				*tty->flip.flag_buf_ptr = TTY_BREAK;
+			else if (rsr & UARTRSR_PE)
+				*tty->flip.flag_buf_ptr = TTY_PARITY;
+			else if (rsr & UARTRSR_FE)
+				*tty->flip.flag_buf_ptr = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(port, ch, regs))
+			goto ignore_char;
+
+		if ((rsr & port->ignore_status_mask) == 0) {
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+			tty->flip.count++;
+		}
+		if ((rsr & UARTRSR_OE) &&
+		    tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character
+			 */
+			*tty->flip.char_buf_ptr++ = 0;
+			*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+			tty->flip.count++;
+		}
+	ignore_char:
+		status = UART_GET_FR(port);
+	}
+	tty_flip_buffer_push(tty);
+	return;
+}
+
+static void
+ep93xxuart_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int count;
+
+	if (port->x_char) {
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		ep93xxuart_stop_tx(port, 0);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		ep93xxuart_stop_tx(port, 0);
+}
+
+static void
+ep93xxuart_modem_status(struct uart_port *port)
+{
+	struct uart_ep93xx_port *uap = (struct uart_ep93xx_port *)port;
+	unsigned int status, delta;
+
+	UART_PUT_ICR(port, 0);
+
+	status = UART_GET_FR(port) & UARTFR_MODEM_ANY;
+
+	delta = status ^ uap->old_status;
+	uap->old_status = status;
+
+	if (!delta)
+		return;
+
+	if (delta & UARTFR_DCD)
+		uart_handle_dcd_change(port, status & UARTFR_DCD);
+
+	if (delta & UARTFR_DSR)
+		port->icount.dsr++;
+
+	if (delta & UARTFR_CTS)
+		uart_handle_cts_change(port, status & UARTFR_CTS);
+
+	wake_up_interruptible(&port->info->delta_msr_wait);
+}
+
+static irqreturn_t
+ep93xxuart_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	unsigned int status, pass_counter = EP93XX_ISR_PASS_LIMIT;
+
+	spin_lock(&port->lock);
+
+	status = UART_GET_INT_STATUS(port);
+	do {
+		if (status & (UARTIIR_RTIS | UARTIIR_RIS))
+#ifdef SUPPORT_SYSRQ
+			ep93xxuart_rx_chars(port, regs);
+#else
+			ep93xxuart_rx_chars(port);
+#endif
+		if (status & UARTIIR_TIS)
+			ep93xxuart_tx_chars(port);
+		if (status & UARTIIR_MIS)
+			ep93xxuart_modem_status(port);
+
+		if (pass_counter-- == 0)
+			break;
+
+		status = UART_GET_INT_STATUS(port);
+	} while (status & (UARTIIR_RTIS | UARTIIR_RIS | UARTIIR_TIS));
+
+	spin_unlock(&port->lock);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int
+ep93xxuart_tx_empty(struct uart_port *port)
+{
+	return UART_GET_FR(port) & UARTFR_BUSY ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int
+ep93xxuart_get_mctrl(struct uart_port *port)
+{
+	unsigned int result = 0;
+	unsigned int status;
+
+	status = UART_GET_FR(port);
+	if (status & UARTFR_DCD)
+		result |= TIOCM_CAR;
+	if (status & UARTFR_DSR)
+		result |= TIOCM_DSR;
+	if (status & UARTFR_CTS)
+		result |= TIOCM_CTS;
+
+	return result;
+}
+
+static void
+ep93xxuart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	unsigned int ctrl = 0;
+
+	ctrl = UART_GET_MCR(port);
+
+#define BIT(tiocmbit, uartbit)		\
+	if (mctrl & tiocmbit)		\
+		ctrl |= uartbit;	\
+	else				\
+		ctrl &= ~uartbit
+
+	BIT(TIOCM_RTS, UARTMCR_RTS);
+	BIT(TIOCM_DTR, UARTMCR_DTR);
+	BIT(TIOCM_OUT1, UARTMCR_OUT1);
+	BIT(TIOCM_OUT2, UARTMCR_OUT2);
+	BIT(TIOCM_LOOP, UARTMCR_LOOP);
+#undef BIT
+
+	UART_PUT_MCR(ctrl, port);
+}
+
+static void
+ep93xxuart_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned long flags;
+	unsigned int lcr_h;
+
+	spin_lock_irqsave(&port->lock, flags);
+	lcr_h = UART_GET_LCRH(port);
+	if (break_state == -1)
+		lcr_h |= UARTLCR_H_BRK;
+	else
+		lcr_h &= ~UARTLCR_H_BRK;
+	UART_PUT_LCRH(port, lcr_h);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int
+ep93xxuart_startup(struct uart_port *port)
+{
+	struct uart_ep93xx_port *uap = (struct uart_ep93xx_port *)port;
+	int retval = -EINVAL;
+	char *name = 0;
+
+	/*
+	 * Enable the clocks for this port.
+	 */
+	ep93xxuart_enable_clocks(port);
+
+	/*
+	 * Get the name of this port (used only for resource allocations).
+	 */
+	switch ((unsigned long)port->membase) {
+	case UART1_BASE:
+		name = "ttyAM0";
+		break;
+	case UART2_BASE:
+		name = "ttyAM1";
+		break;
+	case UART3_BASE:
+		name = "ttyAM2";
+		break;
+	}
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(port->irq, ep93xxuart_int, 0, name, port);
+	if (retval) {
+		ep93xxuart_disable_clocks(port);
+		return retval;
+	}
+
+	/*
+	 * Allocate the memory region.
+	 */
+	if(request_mem_region(port->mapbase, UART_PORT_SIZE, name) == NULL) {
+		free_irq(port->irq, port);
+		ep93xxuart_disable_clocks(port);
+		return 1;
+	}
+
+	/*
+	 * initialise the old status of the modem signals
+	 */
+	uap->old_status = UART_GET_FR(port) & UARTFR_MODEM_ANY;
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	spin_lock_irq(&port->lock);
+	UART_PUT_CR(port, UARTCR_UARTEN | UARTCR_RIE | UARTCR_RTIE);
+	spin_unlock_irq(&port->lock);
+
+	/*
+	 * Success.
+	 */
+	return 0;
+}
+
+static void
+ep93xxuart_shutdown(struct uart_port *port)
+{
+	/*
+	 * disable all interrupts, disable the port
+	 */
+	UART_PUT_CR(port, 0);
+
+	/*
+	 * disable break condition and fifos
+	 */
+	UART_PUT_LCRH(port, UART_GET_LCRH(port) &
+		      ~(UARTLCR_H_BRK | UARTLCR_H_FEN));
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(port->irq, port);
+
+	/*
+	 * Release the memory region.
+	 */
+	release_mem_region(port->mapbase, UART_PORT_SIZE);
+
+	/*
+	 * Disable the clock.
+	 */
+	ep93xxuart_disable_clocks( port );
+}
+
+static void
+ep93xxuart_set_termios(struct uart_port *port, struct termios *termios,
+		       struct termios *old)
+{
+	unsigned int lcr_h, baud, quot;
+	unsigned long flags;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud) - 1;
+	
+	/* byte size and parity */
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr_h = UARTLCR_H_WLEN_5;
+		break;
+	case CS6:
+		lcr_h = UARTLCR_H_WLEN_6;
+		break;
+	case CS7:
+		lcr_h = UARTLCR_H_WLEN_7;
+		break;
+	default: // CS8
+		lcr_h = UARTLCR_H_WLEN_8;
+		break;
+	}
+	if (termios->c_cflag & CSTOPB)
+		lcr_h |= UARTLCR_H_STP2;
+	if (termios->c_cflag & PARENB) {
+		lcr_h |= UARTLCR_H_PEN;
+		if (!(termios->c_cflag & PARODD))
+			lcr_h |= UARTLCR_H_EPS;
+	}
+	if (port->fifosize > 1)
+		lcr_h |= UARTLCR_H_FEN;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = UARTRSR_OE;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= UARTRSR_FE | UARTRSR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= UARTRSR_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= UARTRSR_FE | UARTRSR_PE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= UARTRSR_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= UARTRSR_OE;
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_DUMMY_RSR_RX;
+
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		ep93xxuart_enable_ms(port);
+
+	UART_PUT_LCRL(port, quot & 0xff);
+	UART_PUT_LCRM(port, (quot >> 8) & 0xff);
+	UART_PUT_LCRH(port, lcr_h);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *
+ep93xxuart_type(struct uart_port *port)
+{
+	return port->type == PORT_AMBA ? "EP93XX" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'
+ */
+static void
+ep93xxuart_release_port(struct uart_port *port)
+{
+}
+
+/*
+ * Request the memory region(s) being used by 'port'
+ */
+static int
+ep93xxuart_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void
+ep93xxuart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_AMBA;
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int
+ep93xxuart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)
+		ret = -EINVAL;
+	if (ser->irq < 0 || ser->irq >= NR_IRQS)
+		ret = -EINVAL;
+	if (ser->baud_base < 9600)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops ep93xx_pops = {
+	.tx_empty	= ep93xxuart_tx_empty,
+	.set_mctrl	= ep93xxuart_set_mctrl,
+	.get_mctrl	= ep93xxuart_get_mctrl,
+	.stop_tx	= ep93xxuart_stop_tx,
+	.start_tx	= ep93xxuart_start_tx,
+	.stop_rx	= ep93xxuart_stop_rx,
+	.enable_ms	= ep93xxuart_enable_ms,
+	.break_ctl	= ep93xxuart_break_ctl,
+	.startup	= ep93xxuart_startup,
+	.shutdown	= ep93xxuart_shutdown,
+	.set_termios	= ep93xxuart_set_termios,
+	.type		= ep93xxuart_type,
+	.release_port	= ep93xxuart_release_port,
+	.request_port	= ep93xxuart_request_port,
+	.config_port	= ep93xxuart_config_port,
+	.verify_port	= ep93xxuart_verify_port,
+};
+
+static struct uart_ep93xx_port ep93xx_ports[UART_NR] = {
+	{
+		.port	= {
+			.membase	= (void *)UART1_BASE,
+			.mapbase	= HwRegToPhys(UART1_BASE),
+			.iotype		= UPIO_MEM,
+			.irq		= IRQ_UART1,
+			.uartclk	= 14745600,
+			.fifosize	= 16,
+			.ops		= &ep93xx_pops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+	},
+#if !defined(CONFIG_EP93XX_IRDA)
+	{
+		.port	= {
+			.membase	= (void *)UART2_BASE,
+			.mapbase	= HwRegToPhys(UART2_BASE),
+			.iotype		= UPIO_MEM,
+			.irq		= IRQ_UART2,
+			.uartclk	= 14745600,
+			.fifosize	= 16,
+			.ops		= &ep93xx_pops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+	},
+#endif
+#if !defined(CONFIG_ARCH_EP9301) && !defined(CONFIG_ARCH_EP9302)
+	{
+		.port	= {
+			.membase	= (void *)UART3_BASE,
+			.mapbase	= HwRegToPhys(UART3_BASE),
+			.iotype		= UPIO_MEM,
+			.irq		= IRQ_UART3,
+			.uartclk	= 14745600,
+			.fifosize	= 16,
+			.ops		= &ep93xx_pops,
+			.flags		= UPF_BOOT_AUTOCONF,
+#if !defined(CONFIG_EP93XX_IRDA)
+			.line		= 2,
+#else
+			.line		= 1,
+#endif
+		},
+	}
+#endif
+};
+
+#ifdef CONFIG_SERIAL_EP93XX_CONSOLE
+
+static void
+ep93xxuart_console_write_char(struct uart_port *port, char ch)
+{
+	unsigned int status;
+
+	do {
+		status = UART_GET_FR(port);
+	} while (!UART_TX_READY(status));
+	UART_PUT_CHAR(port, ch);
+}
+
+static void
+ep93xxuart_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_port *port = &ep93xx_ports[co->index].port;
+	unsigned int status, old_cr, old_power;
+	int i;
+
+	old_power = ep93xxuart_is_port_enabled(port);
+	if (!old_power)
+		ep93xxuart_enable_clocks(port);
+
+	/*
+	 * First save the CR then disable the interrupts
+	 */
+	old_cr = UART_GET_CR(port);
+	UART_PUT_CR(port, UARTCR_UARTEN);
+
+	/*
+	 * Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		ep93xxuart_console_write_char(port, s[i]);
+		if (s[i] == '\n')
+			ep93xxuart_console_write_char(port, '\r');
+	}
+
+	/*
+	 * Finally, wait for transmitter to become empty
+	 * and restore the TCR
+	 */
+	do {
+		status = UART_GET_FR(port);
+	} while (status & UARTFR_BUSY);
+	UART_PUT_CR(port, old_cr);
+
+	if (!old_power)
+		ep93xxuart_disable_clocks(port);
+}
+
+static void __init
+ep93xxuart_console_get_options(struct uart_port *port, int *baud, int *parity,
+			       int *bits)
+{
+	if (UART_GET_CR(port) & UARTCR_UARTEN) {
+		unsigned int lcr_h, lcr_m, lcr_l;
+
+		lcr_h = UART_GET_LCRH(port);
+
+		*parity = 'n';
+		if (lcr_h & UARTLCR_H_PEN) {
+			if (lcr_h & UARTLCR_H_EPS)
+				*parity = 'e';
+			else
+				*parity = 'o';
+		}
+
+		if ((lcr_h & 0x60) == UARTLCR_H_WLEN_7)
+			*bits = 7;
+		else
+			*bits = 8;
+
+		lcr_m = UART_GET_LCRM(port);
+		lcr_l = UART_GET_LCRL(port);
+
+		*baud = port->uartclk / (16 * ((lcr_m * 256) + lcr_l + 1));
+	}
+}
+
+static int __init
+ep93xxuart_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 57600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	port = &ep93xx_ports[co->index].port;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		ep93xxuart_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+/*
+ * The 'index' element of this field selects which UART to use for
+ * console.  For ep93xx, valid values are 0, 1, and 2.  If you set
+ * it to -1, then uart_get_console will search for the first UART
+ * which is the same as setting it to 0.
+ */
+extern struct uart_driver ep93xx_reg;
+static struct console ep93xx_console = {
+	.name		= "ttyAM",
+	.write		= ep93xxuart_console_write,
+	.device		= uart_console_device,
+	.setup		= ep93xxuart_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &ep93xx_reg,
+};
+
+static int __init
+ep93xxuart_console_init(void)
+{
+	register_console(&ep93xx_console);
+	return 0;
+}
+console_initcall(ep93xxuart_console_init);
+
+#define EP93XX_CONSOLE	&ep93xx_console
+#else
+#define EP93XX_CONSOLE	NULL
+#endif
+
+static struct uart_driver ep93xx_reg = {
+	.driver_name		= "ttyAM",
+	.dev_name		= "ttyAM",
+	.major			= SERIAL_EP93XX_MAJOR,
+	.minor			= SERIAL_EP93XX_MINOR,
+	.nr			= UART_NR,
+	.cons			= EP93XX_CONSOLE,
+};
+
+static struct resource uarts[UART_NR] = {
+	[0] = {
+		.name		= "uart1",
+		.start		= HwRegToPhys(UART1_BASE),
+		.end		= HwRegToPhys(UART1_BASE) + 0x0000ffff,
+	},
+#if !defined(CONFIG_EP93XX_IRDA)
+	[1] = {
+		.name		= "uart2",
+		.start		= HwRegToPhys(UART2_BASE),
+		.end		= HwRegToPhys(UART2_BASE) + 0x0000ffff,
+	},
+#endif
+#if !defined(CONFIG_ARCH_EP9301) && !defined(CONFIG_ARCH_EP9302)
+	[2] = {
+		.name		= "uart3",
+		.start		= HwRegToPhys(UART3_BASE),
+		.end		= HwRegToPhys(UART3_BASE) + 0x0000ffff,
+	},
+#endif
+};
+
+static int __init
+ep93xxuart_init(void)
+{
+	int ret, i;
+
+	ret = uart_register_driver(&ep93xx_reg);
+	if (ret == 0) {
+		for (i = 0; i < UART_NR; i++) {
+			request_resource(&iomem_resource, &uarts[i]);
+			uart_add_one_port(&ep93xx_reg, &ep93xx_ports[i].port);
+		}
+	}
+	return ret;
+}
+
+static void __exit ep93xxuart_exit(void)
+{
+	int i;
+
+	for (i = 0; i < UART_NR; i++)
+		uart_remove_one_port(&ep93xx_reg, &ep93xx_ports[i].port);
+	uart_unregister_driver(&ep93xx_reg);
+}
+
+module_init(ep93xxuart_init);
+module_exit(ep93xxuart_exit);
+
+MODULE_AUTHOR("ARM Ltd/Deep Blue Solutions Ltd/Cirrus Logic, Inc.");
+MODULE_DESCRIPTION("EP93xx ARM serial port driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV(SERIAL_EP93XX_MAJOR, SERIAL_EP93XX_MINOR);
diff -burN linux-2.6.8.1-orig/drivers/serial/ep93xx_eeprom.c linux-2.6.8.1/drivers/serial/ep93xx_eeprom.c
--- linux-2.6.8.1-orig/drivers/serial/ep93xx_eeprom.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/serial/ep93xx_eeprom.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,566 @@
+/******************************************************************************
+ * drivers/char/ep93xx_eeprom.c 
+ *
+ * Support for SST 25F0x0 serial flash on EDB93XX boards
+ *
+ * Copyright (C) 2006  Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/delay.h>
+
+#define NAME "ep93xx_eeprom"
+
+static int eeprom_size=0;
+static int sector_size=0;
+
+MODULE_AUTHOR("Cirrus Logic (c) 2006");
+MODULE_DESCRIPTION("CL EP93XX SST Serial Flash Driver");
+MODULE_LICENSE("GPL");
+
+static int major = 0;		/* default to dynamic major */
+MODULE_PARM(major, "i");
+MODULE_PARM_DESC(major, "Major device number");
+
+
+/*SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI SPI */
+
+
+static void
+delay(long t)
+{
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(t);
+}
+
+
+static void spi_empty_fifos(void)
+{
+    u32 tmp;
+	/*
+	 * Let TX fifo clear out.  Poll the Transmit Fifo Empty bit.
+	 */
+	while( !( inl(SSPSR) & SSPSR_TFE ) );
+
+	while( inl(SSPSR) & SSPSR_RNE )
+	{
+		tmp = inl(SSPDR);
+	}
+}
+
+#define EEPROM_CS	0x80 /* EGPIO7 == PA D7 */
+#define AUDIO_CS	0x40 /* EGPIO6 == PA D6 */
+
+static int spi_setup(void)
+{
+	u32 tmp;
+	
+	
+	tmp = inl(GPIO_PADR);
+	tmp |= EEPROM_CS;
+	outl(tmp, GPIO_PADR);
+	tmp = inl(GPIO_PADDR);
+	tmp |= EEPROM_CS;
+	outl(tmp, GPIO_PADDR);
+
+	tmp = inl(GPIO_PADR);
+	tmp |= AUDIO_CS;
+	outl(tmp, GPIO_PADR);
+	tmp = inl(GPIO_PADDR);
+	tmp |= AUDIO_CS;
+	outl(tmp, GPIO_PADDR);
+	
+		
+	/*
+	 * Disable the SSP and disable interrupts
+	 */
+	outl( 0, SSPCR1 );
+
+	/*
+	 * Clock will be 14.7 MHz divided by 4.
+	 */
+	outl( 2, SSPCPSR );
+
+	/*
+	 * Motorola format, mode 3, 8 bit.
+	 */
+
+	outl( (SSPCR0_FRF_MOTOROLA | SSPCR0_SPO | SSPCR0_SPH | SSPCR0_DSS_8BIT), SSPCR0 );
+
+	/*
+	 * Configure the device as master, reenable the device.
+	 */
+	 //                
+	outl( SSPC1_SSE , SSPCR1 );
+
+	/*
+	    SPI fifos should be empty at this point 
+	    but better make sure they really are empty
+	*/
+	spi_empty_fifos();
+
+	return 0;
+}
+
+
+
+/* longest frames possible are 8 bytes, since the fifos are 8 entries deep and
+the spi i/f is programmed for 8bit frame sizes */
+static void spi_transaction( u8 *txdat, u8 *rxdat, int len)
+{
+	int idx;
+	
+	idx=0;
+	
+	outl( 0 , SSPCR1 );
+	while(len>0)
+	{
+	// send the byte
+	    outl( txdat[idx], SSPDR );
+	    len--;
+	    idx++;
+	}
+	outl( SSPC1_SSE , SSPCR1 );
+
+	idx=0;
+	// wait for tx complete    
+	while( !( inl(SSPSR) & SSPSR_TFE ) );
+	udelay(30);    
+	// wait for rx data    
+	while( ( inl(SSPSR) & SSPSR_RNE ) )
+	{
+	    rxdat[idx]=inl(SSPDR);
+	    idx++;
+	    udelay(1);
+	}
+//	printk("spit i=%d, %02x %02x %02x %02x %02x %02x %02x %02x\n", idx, rxdat[0], rxdat[1], rxdat[2], rxdat[3], rxdat[4], rxdat[5], rxdat[6], rxdat[7] );
+}
+
+
+static void eeprom_select(void)
+{
+    u32 tmp;
+	tmp = inl(GPIO_PADR);
+	tmp &= ~EEPROM_CS;
+	outl(tmp, GPIO_PADR);
+}
+
+static void eeprom_deselect(void)
+{
+    u32 tmp;
+	tmp = inl(GPIO_PADR);
+	tmp |= EEPROM_CS;
+	outl(tmp, GPIO_PADR);
+}
+
+
+// eeprom interface-------------eeprom interface-------------eeprom interface-------------eeprom interface-------------
+
+
+
+//static void spi_transaction( u8 *txdat, u8 *rxdat, int len);
+
+
+static u16 eprom_id(void)
+{
+    u8 txdat[8];
+    u8 rxdat[8];
+    
+//    txdat[0] = EESPI_RDID;
+    txdat[0] = 0x90;
+    txdat[1]=0;
+    txdat[2]=0;
+    txdat[3]=0;
+    txdat[4]=0;
+    txdat[5]=0;
+    
+    spi_transaction( txdat, rxdat, 6);
+
+    return ( (rxdat[4] << 8) | rxdat[5] );
+}
+
+//return 1 when ready
+static int eeprom_ready(void)
+{
+    u8 txdat[2];
+    u8 rxdat[2];
+    
+    txdat[0] = 0x05;
+    txdat[1]=0;
+
+    spi_transaction( txdat, rxdat, 2);
+    
+    if(rxdat[1] & 0x01)
+	return 0;
+    
+    return 1;
+}
+
+
+static void eeprom_unprotect(void)
+{
+    u8 txdat[4];
+    u8 rxdat[4];
+    
+    txdat[0] = 0x50;
+    spi_transaction( txdat, rxdat, 1);
+
+    txdat[0] = 0x01;
+    txdat[1] = 0;
+    spi_transaction( txdat, rxdat, 2);
+}
+
+
+static void eeprom_erase(u32 adr)
+{
+    u8 txdat[4];
+    u8 rxdat[4];
+    
+    if(adr >= eeprom_size)
+	return;
+    
+    eeprom_unprotect();
+    
+    txdat[0] = 0x06;
+    spi_transaction( txdat, rxdat, 1);
+
+    txdat[0] = 0x20;
+    txdat[1] = adr >> 16;
+    txdat[2] = adr >> 8;
+    txdat[3] = adr;
+    spi_transaction( txdat, rxdat, 4);
+
+    while( !eeprom_ready() )
+    {
+	delay(1);
+    }
+}
+
+
+/* don't change this */
+#define MAXLEN 1
+/* program upto MAXLEN bytes */
+
+static int eeprom_program(u32 adr, u8 *udata, int len)
+{
+    int i;
+    u8 txdat[8];
+    u8 rxdat[8];
+
+
+    if(len>MAXLEN)
+	len = MAXLEN;
+    
+    txdat[0] = 0x06;
+    spi_transaction( txdat, rxdat, 1);
+
+    txdat[0] = 0x02;
+    txdat[1] = (adr >> 16) & 0x0ff;
+    txdat[2] = (adr >> 8) & 0x0ff;
+    txdat[3] =  adr & 0x0ff;
+    
+    for(i=0; i<len; i++)
+    {
+	txdat[4+i] = udata[i];
+    }
+    
+    spi_transaction( txdat, rxdat, 4+len);
+
+    udelay(5);
+    while( !eeprom_ready() )
+    {
+	udelay(1);
+    }
+    udelay(5);
+
+    return len;
+}
+
+
+/* read upto 4 bytes */
+
+static int eeprom_read(u32 adr, u8 *udata, int len)
+{
+    int i;
+    u8 txdat[8];
+    u8 rxdat[8];
+
+    if(len>4)
+	len = 4;
+    
+    txdat[0] = 0x03;
+    txdat[1] = (adr >> 16) & 0x0ff;
+    txdat[2] = (adr >> 8) & 0x0ff;
+    txdat[3] = adr & 0x0ff;
+    
+    txdat[4] = 0;
+    txdat[5] = 0;
+    txdat[6] = 0;
+    txdat[7] = 0;
+    spi_transaction( txdat, rxdat, 4+len);
+
+    for(i=0; i<len; i++)
+    {
+	udata[i] = rxdat[4+i];
+    }
+//    printk("erd r: %02x %02x %02x %02x\n", rxdat[4], rxdat[5], rxdat[6], rxdat[7] );
+//    printk("erd u: %02x %02x %02x %02x\n", udata[0], udata[1], udata[2], udata[3] );
+
+    return len;
+}
+
+
+static u8 *eeprom_kernel_buffer=NULL;
+
+//----------KERNEL INTERFACE-----------------KERNEL INTERFACE-----------------KERNEL INTERFACE-----------------KERNEL INTERFACE-------
+
+static ssize_t ep93xx_eeprom_write(struct file *file, const char __user *data, 
+				 size_t len, loff_t *ppos)
+{
+    int adr;
+    size_t wlen;
+    int rv;
+    int bdx;
+    
+    
+    if(len > 16384)
+	return -ENOBUFS;
+    
+    adr = (int) *ppos;
+    if(adr >= eeprom_size)
+	return -ENOSPC;
+    if( (adr + len) > eeprom_size )
+    {
+	len = eeprom_size - adr;
+    }
+
+    wlen = len;
+    bdx = 0;
+
+    copy_from_user(eeprom_kernel_buffer, data, len);
+
+    while(len > 0)
+    {						
+	rv=eeprom_program( adr, &eeprom_kernel_buffer[bdx], len );
+//	printk("eeprom_program(idx=0x%08x, &eeprom_kernel_buffer[idx], len=%d)\n", idx, rv );
+	len-=rv;
+	adr+=rv;
+	bdx+=rv;
+    }
+
+    *ppos+=wlen;
+
+//    printk("ewr wlen=%d\n", wlen );
+    return wlen;
+}
+
+static ssize_t ep93xx_eeprom_read(struct file *file, char __user *buf,
+				size_t len, loff_t *ppos)
+{
+    int adr;
+    int bdx;
+    int rv;
+    int rlen;
+    
+
+    if(len > 16384)
+	return -ENOBUFS;
+
+    if( *ppos >= eeprom_size)
+	return 0;
+		
+    if( (*ppos + len) > eeprom_size )
+    {
+	len = eeprom_size - *ppos;
+    }
+    
+    adr = *ppos;
+    bdx = 0;
+    rlen = len;
+    
+    while(len > 0)
+    {						
+	rv=eeprom_read( adr, &eeprom_kernel_buffer[bdx], len);
+//	printk("epr rv=%d\n", rv);
+	len-=rv;
+	adr+=rv;
+	bdx+=rv;
+    }	
+
+    copy_to_user(buf, eeprom_kernel_buffer, rlen);
+
+    *ppos += rlen;
+
+    return rlen;
+}
+
+
+static int ep93xx_eeprom_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	unsigned long arg)
+{
+    int i;
+    int block_size;
+    
+    block_size = eeprom_size / 4;    
+    switch(cmd)
+    {
+	case 1: 
+	    for(i=0; i<(block_size); i+=sector_size)
+	    {
+		eeprom_erase(i);
+	    }
+	break;
+
+	case 2: 
+	    for(i=(block_size); i<(2*block_size); i+=sector_size)
+	    {
+		eeprom_erase(i);
+	    }
+	break;
+
+	case 3: 
+	    for(i=(2*block_size); i<(3*block_size); i+=sector_size)
+	    {
+		eeprom_erase(i);
+	    }
+	break;
+
+	case 4: 
+	    for(i=(3*block_size); i<(4*block_size); i+=sector_size)
+	    {
+		eeprom_erase(i);
+	    }
+	break;
+
+	default:
+	break;
+    }
+
+
+    return 0;
+}
+
+
+static int ep93xx_eeprom_open(struct inode *inode, struct file *file)
+{
+
+	eeprom_select();
+//	printk("%s\n", __FUNCTION__ );
+	return 0;
+}
+
+static int ep93xx_eeprom_release(struct inode *inode, struct file *file)
+{
+	eeprom_deselect();
+//	printk("%s\n", __FUNCTION__ );
+	return 0;
+}
+
+static struct file_operations ep93xx_eeprom_fops = {
+	.owner   = THIS_MODULE,
+	.write   = ep93xx_eeprom_write,
+	.read    = ep93xx_eeprom_read,
+	.ioctl   = ep93xx_eeprom_ioctl,
+	.open    = ep93xx_eeprom_open,
+	.release = ep93xx_eeprom_release,
+};
+
+static int __init ep93xx_eeprom_init(void)
+{
+	int r=0;
+	u16 id;
+	printk(KERN_DEBUG NAME ": CL EP93XX Serial Flash Driver for SST25F0x0 and compatible devices\n");
+	
+	eeprom_kernel_buffer = kmalloc( 16384, GFP_KERNEL);
+	if(eeprom_kernel_buffer==NULL)
+	    return -1;
+	
+	spi_setup();
+
+	eeprom_select();
+	id = eprom_id();
+	eeprom_deselect();
+
+	printk("eeprom id = 0x%04x\n", id );
+	if( (id & 0xff00) != 0xbf00 )
+	{
+	    printk("this driver only supports SST25LF0x0 type serial flash memory\n");
+	    return -1;
+	}
+
+	/* not tested (25LF010)*/
+	if((id & 0x0ff) == 0x42)
+	{
+	    eeprom_size=(128*1024);
+	    sector_size=4096;
+	}
+	
+	/* this one has been tested (25LF020)*/
+	if((id & 0x0ff) == 0x43)
+	{
+	    eeprom_size=(256*1024);
+	    sector_size=4096;
+	}
+	
+	/* this one has been tested (25LF040)*/
+	if((id & 0x0ff) == 0x44)
+	{
+	    eeprom_size=(512*1024);
+	    sector_size=4096;
+	}
+
+	/* not tested (25LF080)*/
+	if((id & 0x0ff) == 0x45)
+	{
+	    eeprom_size=(1024*1024);
+	    sector_size=4096;
+	}
+	
+	printk("eeprom size = %d kbytes\n", eeprom_size / 1024 );
+	
+	r = register_chrdev(major, NAME, &ep93xx_eeprom_fops);
+	if (r < 0) {
+		printk(KERN_ERR NAME ": unable to register character device\n");
+		return r;
+	}
+	if (!major) {
+		major = r;
+		printk(KERN_DEBUG NAME ": got dynamic major %d\n", major);
+	}
+	printk("CL EP93XX Serial Flash Driver registered at major %d\n", major);
+	return 0;
+}
+
+static void __exit ep93xx_eeprom_cleanup(void)
+{
+    if(major)
+	unregister_chrdev(major, NAME);
+    kfree(eeprom_kernel_buffer);
+}
+
+module_init(ep93xx_eeprom_init);
+module_exit(ep93xx_eeprom_cleanup);
+
diff -burN linux-2.6.8.1-orig/drivers/usb/Kconfig linux-2.6.8.1/drivers/usb/Kconfig
--- linux-2.6.8.1-orig/drivers/usb/Kconfig	2004-08-14 19:54:51.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -7,7 +7,7 @@
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
 config USB
 	tristate "Support for Host-side USB"
-	depends on PCI || SA1111 || ARCH_OMAP1510 || ARCH_OMAP1610 || ARCH_LH7A404
+	depends on PCI || SA1111 || ARCH_OMAP1510 || ARCH_OMAP1610 || ARCH_LH7A404 || ARCH_EP93XX
 	---help---
 	  Universal Serial Bus (USB) is a specification for a serial bus
 	  subsystem which offers higher speeds and more features than the
diff -burN linux-2.6.8.1-orig/drivers/usb/core/message.c linux-2.6.8.1/drivers/usb/core/message.c
--- linux-2.6.8.1-orig/drivers/usb/core/message.c	2004-08-14 19:54:51.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/core/message.c	2007-01-24 13:03:31.000000000 +0900
@@ -1061,9 +1061,18 @@
 		return -EINVAL;
 	}
 
+	if ( dev->descriptor.idVendor == 0x05ac 	/* Apple */
+		&& ( dev->descriptor.idProduct & 0xff00UL ) == 0x1200 /* iPod */
+		&& interface == 0 )
+	{
+		ret = -EPIPE;
+	}
+	else {
+
 	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				   USB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,
 				   alternate, interface, NULL, 0, HZ * 5);
+	}
 
 	/* 9.4.10 says devices don't need this and are free to STALL the
 	 * request if the interface only has one alternate setting.
diff -burN linux-2.6.8.1-orig/drivers/usb/gadget/Kconfig linux-2.6.8.1/drivers/usb/gadget/Kconfig
--- linux-2.6.8.1-orig/drivers/usb/gadget/Kconfig	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/gadget/Kconfig	2007-01-24 13:03:31.000000000 +0900
@@ -100,6 +100,26 @@
 	default y if USB_ETH
 	default y if USB_G_SERIAL
 
+config USB_GADGET_EP931X
+	boolean "EP931x USB Slave"
+	depends on ARCH_EP9312 || ARCH_EP9315 || ARCH_EP9315A || ARCH_EP9307A || ARCH_EP9302A
+	select USB_GADGET_DUALSPEED
+	help
+	   Cirrus Logic EDB931X ARM boards include an Philips high 
+	   speed USB 2.0 device controller.
+                                                                                                                  
+	   It has fifteen fixed-function endpoints, as well as endpoint
+	   zero (for control transfers).
+                                                                                                                  
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "ep93xx_udc" and force all
+	   gadget drivers to also be dynamically linked.
+                                                                                                                             
+config USB_EP931X
+	tristate
+	depends on USB_GADGET_EP931X
+	default USB_GADGET
+
 config USB_GADGET_GOKU
 	boolean "Toshiba TC86C001 'Goku-S'"
 	depends on PCI
diff -burN linux-2.6.8.1-orig/drivers/usb/gadget/Makefile linux-2.6.8.1/drivers/usb/gadget/Makefile
--- linux-2.6.8.1-orig/drivers/usb/gadget/Makefile	2004-08-14 19:54:49.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/gadget/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -4,6 +4,7 @@
 obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
 obj-$(CONFIG_USB_PXA2XX)	+= pxa2xx_udc.o
+obj-$(CONFIG_USB_EP931X)	+= ep93xx_udc.o
 obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
 
 #
diff -burN linux-2.6.8.1-orig/drivers/usb/gadget/ep93xx_udc.c linux-2.6.8.1/drivers/usb/gadget/ep93xx_udc.c
--- linux-2.6.8.1-orig/drivers/usb/gadget/ep93xx_udc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/gadget/ep93xx_udc.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,4337 @@
+/*
+ * linux/drivers/usb/gadget/ep93xx_udc.c
+ * Cirrus EP93xx and ISP1581 on-chip high speed USB device controllers
+ *
+ * Based on PXA-UDC driver and previous EP93XX driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <asm/byteorder.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+#include <asm/unaligned.h>
+#include <asm/hardware.h>
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+#include "ep93xx_udc.h"
+
+
+/*-----------------------------------------------------------------------------------*/
+
+
+#ifdef gadget_debug
+#define DEBUG( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DEBUG( fmt, arg... )
+#endif
+
+/*------------------------------------------------------------------------------------*/
+
+/*
+ * This structure defines the setup packet received from the host via the
+ * control out endpoint.
+ */
+
+typedef struct
+{
+    unsigned char bmRequestType;
+    unsigned char bRequest;
+    unsigned short wValue;
+    unsigned short wIndex;
+    unsigned short wLength;
+}
+ControlTransfer;
+
+/*
+ * Function prototypes for the standard device request handling routines.
+ */
+
+static void USBGetStatus(struct ep93xx_udc *dev);
+static void USBClearFeature(struct ep93xx_udc *dev);
+static void USBSetFeature(struct ep93xx_udc *dev);
+static void USBSetAddress(struct ep93xx_udc *dev);
+static void USBGetDescriptor(struct ep93xx_udc *dev);
+static void USBGetConfiguration(struct ep93xx_udc *dev);
+static void USBSetConfiguration(struct ep93xx_udc *dev);
+static void USBGetInterface(struct ep93xx_udc *dev);
+static void USBSetInterface(struct ep93xx_udc *dev);
+static void USBReserved(struct ep93xx_udc *dev);
+
+/*
+ * An array of pointers to the USB standard device request handler Functions.
+ */
+static void (* const USBStandardDeviceRequest[])(struct ep93xx_udc *dev) =
+{
+    USBGetStatus,
+    USBClearFeature,
+    USBReserved,
+    USBSetFeature,
+    USBReserved,
+    USBSetAddress,
+    USBGetDescriptor,
+    USBReserved,
+    USBGetConfiguration,
+    USBSetConfiguration,
+    USBGetInterface,
+    USBSetInterface,
+    USBReserved
+};
+
+/*
+ * The following structure contains the persistent state of the USB interface.
+ */
+static struct
+{
+    /*
+     * Flags which describe the current state of the USB connection.
+     */
+    unsigned char ucFlags;
+
+    /*
+     * Indicates if a vendor specific setup packet has been received on the
+     * control out endpoint and is waiting to be processed.
+     */
+    unsigned char ucHaveVendorMessage;
+
+    /*
+     * The number of bytes to be sent to the control endpoint.
+     */
+    unsigned long usControlInCount;
+
+    /*
+     * The buffer of data that is being sent to the control endpoint.
+     */
+    const unsigned char *pucControlIn;
+
+    /*
+     * The buffer of data that is being received from the control endpoint.
+     */
+    ControlTransfer sControlOut;
+
+    /*
+     * The number of bytes to be sent to the bulk endpoint.
+     */
+    unsigned long usBulkInCount;
+
+    /*
+     * The number of bytes still to be read from the bulk endpoint.
+     */
+    unsigned long usBulkOutCount;
+
+    /*
+     * The buffer of data that is being sent to the bulk endpoint.
+     */
+    const unsigned char *pucBulkIn;
+
+    /*
+     * The buffer of data that is being received from the bulk endpoint.
+     */
+    unsigned char *pucBulkOut;
+
+    /*
+     * Flags which describe the current state of the USB Setup Control Out or IN.
+     */
+
+    /*1:setup control out   Set  command DataPhase    OUT PID*/
+    /*2:setup control In    Get  command DataPhase    IN PID*/
+    /*3:setup control out   Set  command StatusPhase  IN PID*/
+    /*4:setup control In    Get  command StatusPhase  OUT PID*/
+    unsigned char ucSetupFlags;
+
+    /*
+     *Flags whch describe the current speed of the USB process
+     */
+    unsigned char ucUSBSpeed;
+
+    /*
+     * The Length of Bulk Endpoint MAXPacket .
+     */
+    unsigned long  ulBulkMAXLen;
+
+    /*
+     * The Max Length of write  Endpoint Packet .
+     */
+    unsigned long  ulWriteEndpointMAXLen;
+
+}
+sUSB;
+
+/* For control responses*/
+struct usb_request                      UDC_ep0req;        
+
+/*
+ *Set the USB Chip Base Address
+ */
+volatile unsigned long *pulUSB ;
+volatile unsigned short *pulUSB16;
+volatile unsigned short *pulUSBDataPort;
+
+/*
+ *set the DMA buffer base address
+ */
+unsigned long DMAVaddress;
+unsigned short * DMAPHYaddress;
+
+/*
+ *Set the Ep931x M2M Chanel Base Address
+ */
+#ifdef USE_CHANNEL_ZERO
+volatile unsigned long *pulDMA = (unsigned long *)(ep93IOBASE+HwDMA_M2M_0);
+#else
+volatile unsigned long *pulDMA = (unsigned long *)(ep93IOBASE+HwDMA_M2M_1);
+#endif
+
+/*----------------------------------------------------------------------------------*/
+/*
+ *
+ */
+static void
+DMAOddRead(unsigned long ulEndpoint, void *pvBuffer, unsigned long ulCount)
+{
+    unsigned long ulTemp,i;
+    /*
+     *Setting the EP931x DMA control REG
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] = (DMA_M2M_CONTROL_DONE_INT_EN |
+                                      DMA_M2M_CONTROL_STALL_INT_EN|
+                                      DMA_M2M_CONTROL_NFBINT_EN|
+                                      DMA_M2M_CONTROL_BWC_FULL |
+                                      DMA_M2M_CONTROL_PW_BYTE |
+                                      DMA_M2M_CONTROL_SAH |
+                                      DMA_M2M_CONTROL_TM_HARDWARE_P2M |
+                                      DMA_PIN_CONFIG |
+                                      DMA_M2M_CONTROL_RSS_EXTERNAL_DREQ |
+                                      (5<< DMA_M2M_CONTROL_PWSC_SHIFT));
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+
+    pulDMA[HwDMA_M2M_SAR_Base0 >> 2] = 0x30000000;/*0x70000020;*/
+
+    pulDMA[HwDMA_M2M_DAR_Base0 >> 2] = DMAVaddress;
+
+    pulDMA[HwDMA_M2M_BCR0 >> 2] = ulCount;
+
+    /*
+     *enable Ep931x dma
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] |= DMA_M2M_CONTROL_ENABLE;
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+
+    /*
+     *clear int
+     */
+    ulTemp=pulUSB[HwUSBDMAIntReason >> 2] ;
+    pulUSB[HwUSBDMAIntReason >> 2] =ulTemp ;
+
+    /*
+     *Set 1581 DMA Endpoint
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_SIX_OUT;
+
+    pulUSB[HwUSBDMAEndpoint >> 2] = ulEndpoint;
+
+    /*
+     *Setting the DMA configure
+     */
+    pulUSB16[HwUSBDMAConfig >> 1] = (USB_DMACONFIG_BURST_1|
+                                     /*  USB_DMACONFIG_BURST_ALL |*/
+                                     USB_DMACONFIG_MODE_DACK |
+                                     USB_DMACONFIG_WIDTH_8);
+
+
+    /*
+     *set 1581 dma count
+     */
+    pulUSB16[HwUSBDMACount>>1] = ulCount & 0xffff;
+
+    pulUSB16[(HwUSBDMACount+2)>>1] = ulCount >> 16;
+
+    /*
+     *set 1581 dma command
+     */
+    pulUSB16[HwUSBDMACommand>>1] = USB_DMACOMMAND_GDMA_WRITE;
+
+
+    /*while(!(pulUSB[HwUSBIntReason >> 2] & USB_INT_DMA))
+    while(!(pulDMA[HwDMA_M2M_Interrupt >> 2] & DMA_M2M_INTERRUPT_DONE))*/
+    while(!(pulDMA[HwDMA_M2M_Status >> 2] & DMA_M2M_STATUS_DONE))
+    /*while(pulDMA[HwDMA_M2M_BCR0 >> 2] != 0)*/
+    {
+
+        /*       if(pulUSB[HwUSBIntReason >> 2] & USB_INT_BUS_RESET)
+                {
+                    return;
+                }
+        */
+    }
+
+
+    /*
+     *clear Setting the EP931x DMA control REG
+     */
+    pulUSB[HwUSBDMAEndpoint >> 2] = USB_ENDPOINT_SEVEN_OUT;
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+
+    pulDMA[HwDMA_M2M_Interrupt >> 2] |= pulDMA[HwDMA_M2M_Interrupt >> 2];
+
+    pulDMA[HwDMA_M2M_Control >> 2] &= ~DMA_M2M_CONTROL_ENABLE;
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+
+    /*
+     *clear Setting the 1581 DMA control REG
+     */
+    pulUSB[HwUSBIntReason >> 2] = USB_INT_DMA;
+
+    ulTemp=pulUSB[HwUSBDMAIntReason >> 2] ;
+    pulUSB[HwUSBDMAIntReason >> 2] =ulTemp ;
+
+    for (i=0;i<ulCount;i++) {
+        *(unsigned char *)(pvBuffer+i) = *( (unsigned char *)DMAPHYaddress +i );
+    }
+
+    return;
+
+
+}
+
+/*
+ *DMARead
+ */
+static void
+DMARead(unsigned long ulEndpoint, void *pvBuffer, unsigned long ulCount)
+{
+    unsigned long ulTemp,i;
+    /*
+     *Setting the EP931x DMA control REG
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] = (DMA_M2M_CONTROL_DONE_INT_EN |
+                                      DMA_M2M_CONTROL_STALL_INT_EN|
+                                      DMA_M2M_CONTROL_NFBINT_EN|
+                                      DMA_M2M_CONTROL_BWC_FULL |
+                                      DMA_M2M_CONTROL_PW_HALFWORD |
+                                      DMA_M2M_CONTROL_SAH |
+                                      DMA_M2M_CONTROL_TM_HARDWARE_P2M |
+                                      DMA_PIN_CONFIG |
+                                      DMA_M2M_CONTROL_RSS_EXTERNAL_DREQ |
+                                      (5<< DMA_M2M_CONTROL_PWSC_SHIFT));
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+
+    pulDMA[HwDMA_M2M_SAR_Base0 >> 2] = 0x30000000;;/*0x70000020;*/
+
+    pulDMA[HwDMA_M2M_DAR_Base0 >> 2] = DMAVaddress;
+
+    pulDMA[HwDMA_M2M_BCR0 >> 2] = ulCount;
+
+    /*
+     *enable Ep931x dma
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] |= DMA_M2M_CONTROL_ENABLE;
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+
+    /*
+     *clear int
+     */
+    ulTemp=pulUSB[HwUSBDMAIntReason >> 2] ;
+    pulUSB[HwUSBDMAIntReason >> 2] =ulTemp ;
+
+    /*
+     *Set 1581 DMA Endpoint
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_SIX_OUT;
+
+    pulUSB[HwUSBDMAEndpoint >> 2] = ulEndpoint;
+
+    /*
+     *
+     */
+    pulUSB16[HwUSBDMAConfig >> 1] = (USB_DMACONFIG_BURST_1|
+                                     //  USB_DMACONFIG_BURST_ALL |
+                                     USB_DMACONFIG_MODE_DACK |
+                                     USB_DMACONFIG_WIDTH_16);
+
+
+    /*
+     *set 1581 dma count
+     */
+    pulUSB16[HwUSBDMACount>>1] = ulCount & 0xffff;
+
+    pulUSB16[(HwUSBDMACount+2)>>1] = ulCount >> 16;
+
+    /*
+     *set 1581 dma command
+     */
+    pulUSB16[HwUSBDMACommand>>1] = USB_DMACOMMAND_GDMA_WRITE;
+
+
+    /*
+    while(!(pulUSB[HwUSBIntReason >> 2] & USB_INT_DMA))
+    while(!(pulDMA[HwDMA_M2M_Interrupt >> 2] & DMA_M2M_INTERRUPT_DONE))
+    */
+    while(!(pulDMA[HwDMA_M2M_Status >> 2] & DMA_M2M_STATUS_DONE))
+    /*while(pulDMA[HwDMA_M2M_BCR0 >> 2] != 0)*/
+    {
+
+        /*
+               if(pulUSB[HwUSBIntReason >> 2] & USB_INT_BUS_RESET)
+                {
+                    return;
+                }
+        */
+    }
+
+
+    /*
+     *clear Setting the EP931x DMA control REG
+     */
+    pulUSB[HwUSBDMAEndpoint >> 2] = USB_ENDPOINT_SEVEN_OUT;
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+
+    pulDMA[HwDMA_M2M_Interrupt >> 2] |= pulDMA[HwDMA_M2M_Interrupt >> 2];
+
+    pulDMA[HwDMA_M2M_Control >> 2] &= ~DMA_M2M_CONTROL_ENABLE;
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+
+    /*
+     *clear Setting the 1581 DMA control REG
+     */
+    pulUSB[HwUSBIntReason >> 2] = USB_INT_DMA;
+
+    ulTemp=pulUSB[HwUSBDMAIntReason >> 2] ;
+    pulUSB[HwUSBDMAIntReason >> 2] =ulTemp ;
+
+    for (i=0;i<ulCount;i++) {
+        *(unsigned char *)(pvBuffer+i) = *( (unsigned char *)DMAPHYaddress +i );
+    }
+
+    return;
+}
+
+/*
+ *DMAWrite 
+ */
+
+static void
+DMAWrite(unsigned long ulEndpoint,  void *pvBuffer, unsigned long ulCount)
+{
+    unsigned long ulTemp,i;
+    /*
+     *Setting the EP931x DMA control REG
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] = (DMA_M2M_CONTROL_DONE_INT_EN |
+                                      DMA_M2M_CONTROL_BWC_FULL |
+                                      DMA_M2M_CONTROL_PW_HALFWORD |
+                                      DMA_M2M_CONTROL_DAH |
+                                      DMA_M2M_CONTROL_TM_HARDWARE_M2P |
+                                      DMA_PIN_CONFIG |
+                                      DMA_M2M_CONTROL_RSS_EXTERNAL_DREQ |
+                                      (5 << DMA_M2M_CONTROL_PWSC_SHIFT));
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+    /*
+     *Setting EP931XDMA Address and count
+     */
+    for (i=0;i<ulCount;i++) {
+        *( (unsigned char *)DMAPHYaddress +i ) = *(unsigned char *)(pvBuffer+i);
+    }
+
+    pulDMA[HwDMA_M2M_SAR_Base0 >> 2] = DMAVaddress;
+
+    pulDMA[HwDMA_M2M_DAR_Base0 >> 2] =   0x70000020;
+
+    pulDMA[HwDMA_M2M_BCR0 >> 2] = ulCount;
+
+    /*
+     *enable Ep931x dma
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] |= DMA_M2M_CONTROL_ENABLE;
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+    /*
+     *clear int
+     */
+
+    /*
+     *ep93xx intrruption
+     */
+    ulTemp=pulDMA[HwDMA_M2M_Interrupt >> 2] ;
+    pulDMA[HwDMA_M2M_Interrupt >> 2]=ulTemp;
+
+    /*
+     *Resetting 1581 DMA
+     */
+    pulUSB16[HwUSBDMAConfig >> 1] = (USB_DMACONFIG_BURST_1|
+                                     USB_DMACONFIG_MODE_DACK |         /*10   both ACK low  8bit  */
+                                     USB_DMACONFIG_WIDTH_16);          /*GDMA 16bit     low  8bit  */
+
+    /*
+     *Set 1581 DMA Endpoint
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_SIX_OUT;
+    pulUSB[HwUSBDMAEndpoint >> 2] = ulEndpoint;
+
+    /*
+     *Set 1581 DMA count ,and send command
+     */
+    pulUSB16[HwUSBDMACount>>1] = ulCount & 0xffff;
+    pulUSB16[(HwUSBDMACount+2)>>1] = ulCount >> 16;
+
+    pulUSB16[HwUSBDMACommand>>1] = USB_DMACOMMAND_GDMA_READ;
+
+
+    while(!(pulDMA[HwDMA_M2M_Status >> 2] & DMA_M2M_STATUS_DONE)) {
+
+        /*       if(pulUSB[HwUSBIntReason >> 2] & USB_INT_BUS_RESET)
+                  {
+                     return;
+                  }
+         */
+    }
+
+
+
+
+    pulUSB[HwUSBDMAEndpoint >> 2] = USB_ENDPOINT_SEVEN_OUT;
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    pulDMA[HwDMA_M2M_Interrupt >> 2] |= DMA_M2M_INTERRUPT_DONE;
+
+    pulDMA[HwDMA_M2M_Control >> 2] &= ~DMA_M2M_CONTROL_ENABLE;
+
+    /*
+     *clear Setting the EP931x DMA control REG
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] = 0;
+
+    ulTemp = pulDMA[HwDMA_M2M_Interrupt >> 2];
+    pulDMA[HwDMA_M2M_Interrupt >> 2] = ulTemp;
+
+    pulDMA[HwDMA_M2M_Status >> 2] = 2000;
+
+    ulTemp=pulUSB[HwUSBDMAIntReason >> 2] ;
+    pulUSB[HwUSBDMAIntReason >> 2] =ulTemp ;
+
+
+}
+
+/*
+ *DMAOddWrite 
+ */
+
+static void
+DMAOddWrite(unsigned long ulEndpoint,  void *pvBuffer, unsigned long ulCount)
+{
+    unsigned long ulTemp,i;
+    /*
+     *Setting the EP931x DMA control REG
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] = (DMA_M2M_CONTROL_DONE_INT_EN |
+                                      DMA_M2M_CONTROL_BWC_FULL |
+                                      DMA_M2M_CONTROL_PW_BYTE |
+                                      DMA_M2M_CONTROL_DAH |
+                                      DMA_M2M_CONTROL_TM_HARDWARE_M2P |
+                                      DMA_PIN_CONFIG |
+                                      DMA_M2M_CONTROL_RSS_EXTERNAL_DREQ |
+                                      (5 << DMA_M2M_CONTROL_PWSC_SHIFT));
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+    /*
+     *Setting EP931XDMA Address and count
+     */
+    for (i=0;i<ulCount;i++) {
+        *( (unsigned char *)DMAPHYaddress +i ) = *(unsigned char *)(pvBuffer+i);
+    }
+
+    pulDMA[HwDMA_M2M_SAR_Base0 >> 2] = DMAVaddress;
+
+    pulDMA[HwDMA_M2M_DAR_Base0 >> 2] =   0x70000020;
+
+    pulDMA[HwDMA_M2M_BCR0 >> 2] = ulCount;
+
+    /*
+     *enable Ep931x dma
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] |= DMA_M2M_CONTROL_ENABLE;
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+    /*
+     *clear int
+     */
+
+    /*
+     *ep93xx intrruption
+     */
+    ulTemp=pulDMA[HwDMA_M2M_Interrupt >> 2] ;
+    pulDMA[HwDMA_M2M_Interrupt >> 2]=ulTemp;
+
+    /*
+     *Resetting 1581 DMA
+     */
+    pulUSB16[HwUSBDMAConfig >> 1] = (USB_DMACONFIG_BURST_1|
+                                      USB_DMACONFIG_MODE_DACK |         /*10   both ACK low  8bit  */
+                                      USB_DMACONFIG_WIDTH_8);             /*GDMA 16bit     low  8bit  */
+
+    /*
+     *Set 1581 DMA Endpoint
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_SIX_OUT;
+    pulUSB[HwUSBDMAEndpoint >> 2] = ulEndpoint;
+    /*
+     *Set 1581 DMA count ,and send command
+     */
+    pulUSB16[HwUSBDMACount>>1] = ulCount & 0xffff;
+    pulUSB16[(HwUSBDMACount+2)>>1] = ulCount >> 16;
+
+    pulUSB16[HwUSBDMACommand>>1] = USB_DMACOMMAND_GDMA_READ;
+
+
+    while(!(pulDMA[HwDMA_M2M_Status >> 2] & DMA_M2M_STATUS_DONE)) {
+
+        /*       if(pulUSB[HwUSBIntReason >> 2] & USB_INT_BUS_RESET)
+                  {
+                     return;
+                  }
+         */
+    }
+
+
+
+
+    pulUSB[HwUSBDMAEndpoint >> 2] = USB_ENDPOINT_SEVEN_OUT;
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    pulDMA[HwDMA_M2M_Interrupt >> 2] |= DMA_M2M_INTERRUPT_DONE;
+
+    pulDMA[HwDMA_M2M_Control >> 2] &= ~DMA_M2M_CONTROL_ENABLE;
+
+    /*
+     *clear Setting the EP931x DMA control REG
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] = 0;
+
+    ulTemp = pulDMA[HwDMA_M2M_Interrupt >> 2];
+    pulDMA[HwDMA_M2M_Interrupt >> 2] = ulTemp;
+
+    pulDMA[HwDMA_M2M_Status >> 2] = 2000;
+
+    ulTemp=pulUSB[HwUSBDMAIntReason >> 2] ;
+    pulUSB[HwUSBDMAIntReason >> 2] =ulTemp ;
+
+
+}
+
+/*
+ * USBReadEndpoint reads data from the specified endpoint.
+ */
+unsigned long
+USBReadEndpoint(unsigned long ulEndpoint, unsigned char **ppucData,
+                unsigned long *pusLength)
+{
+    unsigned long ulIdx, ulLength,ulData;
+    volatile unsigned short *pulUSB_data16;
+
+    pulUSB_data16 = pulUSBDataPort;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Read the length of the data buffer.
+     */
+    ulLength = pulUSB[HwUSBEndpointBufferLength >> 2] ;//& USB_EPBUFLEN_MASK;
+
+    /*
+     * Is there buffer space to fill with this data or should we throw the
+     * data away?
+     */
+    if(*pusLength) {
+        /*
+         * Read the data into the receive buffer.
+         */
+	for(ulIdx = 0; (ulIdx < ulLength) && (ulIdx < *pusLength); ) {
+
+            ulData =  *pulUSB_data16;
+
+            *(*ppucData)++ = ulData & 0xff;
+            ulIdx++;
+            if((ulIdx < ulLength) && (ulIdx < *pusLength)) {
+                *(*ppucData)++ = ulData >> 8;
+                ulIdx++;
+            }
+        }
+
+        /*
+         * Decrement the count of bytes to read.
+         */
+        *pusLength -= ulIdx;
+
+    } else {
+        /*
+         * Send the clear buffer command so that the endpoint can receive
+         * another packet.
+         */
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+        printk("USBReadEndpoint clear\n");
+    }
+
+    /*
+     * Return the size of the packet received.
+     */
+    return(ulLength);
+
+}
+
+/*
+ *USBReadBulkEndpoint read data in USB bulk endpoint
+ */
+unsigned long
+USBReadPPBulkEndpoint(unsigned long ulEndpoint, unsigned char *ppucData,
+                      unsigned long pusLength)
+{
+    unsigned long ulIdx, ulLength,ulData;
+    volatile unsigned short *pulUSB_data16;
+   
+
+    pulUSB_data16 = pulUSBDataPort;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Read the length of the data buffer.
+     */
+    ulLength = pulUSB[HwUSBEndpointBufferLength >> 2] ;//& USB_EPBUFLEN_MASK;
+
+    /*
+     *Is there buffer space to fill with this data or should we throw the
+     *data away?
+     */
+    if(pusLength) {
+
+
+        if(ulLength %2 ==0) {
+
+            DMARead(ulEndpoint, ppucData, ulLength);
+
+            ppucData += ulLength;
+        } else {
+            /*
+             * Read the data into the receive buffer.
+             */
+		for(ulIdx = 0; (ulIdx < ulLength) && (ulIdx < pusLength); ) {
+
+
+                	ulData =  *pulUSB_data16;
+
+
+                	*ppucData = ulData & 0xff;
+                	ppucData++;
+                	ulIdx++;
+                	if((ulIdx < ulLength) && (ulIdx < pusLength)) {
+                    		*ppucData = ulData >> 8;
+                    		ppucData++ ;
+                    		ulIdx++;
+                	}
+
+            	}
+        }
+
+        /*
+         * Decrement the count of bytes to read.
+         */
+        pusLength -= ulIdx;
+    } else {
+        	/*
+         	* Send the clear buffer command so that the endpoint can receive
+         	* another packet.
+         	*/
+		pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+        	printk("USBReadEndpoint clear\n");
+    }
+
+    /*
+     *Return the size of the packet received.
+     */
+    return(ulLength);
+}
+
+/*
+ *USBReadBulkEndpoint read data in USB bulk endpoint
+ */
+unsigned long
+USBReadBulkEndpoint(unsigned long ulEndpoint, unsigned char *ppucData,
+                    unsigned long pusLength)
+{
+    unsigned long ulIdx, ulLength;
+    volatile unsigned short *pulUSB_data16;
+#ifdef   USE_DMA_READ
+#else
+    unsigned long	ulData;
+#endif
+
+    pulUSB_data16 = pulUSBDataPort;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Read the length of the data buffer.
+     */
+    ulLength = pulUSB[HwUSBEndpointBufferLength >> 2] ;//& USB_EPBUFLEN_MASK;
+
+    /*
+     *Is there buffer space to fill with this data or should we throw the
+     *data away?
+     */
+    if(pusLength) {
+
+#ifdef   USE_DMA_READ
+        if(ulLength %2 ==0) {
+            DMARead(ulEndpoint, ppucData, ulLength);
+            ppucData += ulLength;
+        } else if(ulLength %2 ==1) {
+            DMAOddRead(ulEndpoint, ppucData, ulLength);
+            ppucData += ulLength;
+
+      }
+
+#else
+            /*
+             * Read the data into the receive buffer.
+             */
+            for(ulIdx = 0; (ulIdx < ulLength) && (ulIdx < pusLength); ) {
+
+                ulData =  *pulUSB_data16;
+
+                *ppucData = ulData & 0xff;
+                ppucData++;
+                ulIdx++;
+
+                if((ulIdx < ulLength) && (ulIdx < pusLength)) {
+                    *ppucData = ulData >> 8;
+                    ppucData++ ;
+                    ulIdx++;
+                }
+
+            }
+        
+#endif
+        /*
+         * Decrement the count of bytes to read.
+         */
+        pusLength -= ulIdx;
+    } else {
+        /*
+         * Send the clear buffer command so that the endpoint can receive
+         * another packet.
+          */
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+        printk("USBReadEndpoint clear\n");
+    }
+
+    /*
+     *Return the size of the packet received.
+     */
+    return(ulLength);
+}
+
+
+
+/*
+ * USBWriteEndpoint writes data to the specified endpoint.
+ */
+void
+USBWriteEndpoint(unsigned long ulEndpoint, const unsigned char **ppucData,
+                 unsigned long *pusLength)
+{
+    unsigned long ulIdx, ulLength, ulData;
+    volatile unsigned short *pulUSB_data16;
+
+
+    pulUSB_data16 = pulUSBDataPort;
+
+    ulLength = (*pusLength > sUSB.ulWriteEndpointMAXLen) ? sUSB.ulWriteEndpointMAXLen: *pusLength;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Write the packet length.
+     */
+    pulUSB[HwUSBEndpointBufferLength >> 2] = ulLength;
+
+    /*
+     * Write the data into the transmit buffer.
+     */
+    for(ulIdx = 0; ulIdx < ulLength; ) {
+        ulData = *(*ppucData)++;
+        ulIdx++;
+        if(ulIdx < ulLength) {
+
+            ulData |= ((unsigned long)*(*ppucData)++) << 8;
+            ulIdx++;
+        }
+
+
+        *pulUSB_data16=ulData;
+
+    }
+
+    /*
+     * Decrement the count of bytes to write.
+     */
+    *pusLength -= ulLength;
+
+}
+
+
+/*
+  * USBReadEndpoint reads data from the specified endpoint.
+  */
+unsigned long
+UDC_USBReadEndpoint(unsigned long ulEndpoint, unsigned char *ppucData,
+                unsigned long pusLength)
+{
+    unsigned long ulIdx, ulLength,ulData;
+    volatile unsigned short *pulUSB_data16;
+
+    pulUSB_data16 = pulUSBDataPort;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Read the length of the data buffer.
+     */
+    ulLength = pulUSB[HwUSBEndpointBufferLength >> 2] ;//& USB_EPBUFLEN_MASK;
+
+    /*
+     * Is there buffer space to fill with this data or should we throw the
+     * data away?
+     */
+    if(pusLength) {
+        /*
+         * Read the data into the receive buffer.
+         */
+        for(ulIdx = 0; (ulIdx < ulLength) && (ulIdx < pusLength); ) {
+
+            ulData =  *pulUSB_data16;
+
+            *(ppucData++) = ulData & 0xff;
+            ulIdx++;
+            if((ulIdx < ulLength) && (ulIdx < pusLength)) {
+                *(ppucData++) = ulData >> 8;
+                ulIdx++;
+            }
+        }
+
+        /*
+         * Decrement the count of bytes to read.
+         */
+        pusLength -= ulIdx;
+
+    } else {
+        /*
+         * Send the clear buffer command so that the endpoint can receive
+         * another packet.
+         */
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+        printk("USBReadEndpoint clear\n");
+    }
+
+    /*
+     * Return the size of the packet received.
+     */
+    return(ulLength);
+
+}
+
+
+
+/*
+ * USBWriteEndpoint writes data to the specified endpoint.
+ */
+static unsigned long 
+UDC_USBWriteEndpoint(unsigned long ulEndpoint, unsigned char *ppucData,
+                 unsigned long pusLength,unsigned long max)
+{
+    unsigned long ulIdx, ulLength, ulData;
+    volatile unsigned short *pulUSB_data16;
+
+/*	printk("usb w len=%d\n",pusLength);*/
+    pulUSB_data16 = pulUSBDataPort;
+
+    ulLength = (pusLength > max) ? max: pusLength;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Write the packet length.
+     */
+    pulUSB[HwUSBEndpointBufferLength >> 2] = ulLength;
+
+    /*
+     * Write the data into the transmit buffer.
+     */
+    for(ulIdx = 0; ulIdx < ulLength; ) {
+        ulData = (*(ppucData++));
+        ulIdx++;
+        if(ulIdx < ulLength) {
+
+            ulData |= ((unsigned long)(*(ppucData++))) << 8;
+            ulIdx++;
+        }
+
+
+        *pulUSB_data16=ulData;
+
+    }
+
+    /*
+     * Decrement the count of bytes to write.
+     */
+    return(ulLength);
+
+}
+
+/*
+ *USBDMAWriteEndpoint writes data to the specified endpoint.
+ */
+static unsigned long
+UDC_USBDMAWriteEndpoint(unsigned long ulEndpoint, const unsigned char *ppucData,
+                    unsigned long pusLength,unsigned long max)
+{
+    unsigned long ulLength;
+    
+
+    ulLength = (pusLength > max) ? max: pusLength;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Write the packet length.
+     */
+    pulUSB[HwUSBEndpointBufferLength >> 2] = ulLength;
+
+    /*
+     * Write the data into the transmit buffer.
+     */
+
+    if(ulLength %2 ==0)
+        DMAWrite(ulEndpoint, (void *)ppucData, ulLength);
+    else
+        DMAOddWrite(ulEndpoint, (void *)ppucData, ulLength);
+
+
+    /* *ppucData += ulLength;*/
+
+    /*
+     * Decrement the count of bytes to write.
+     */
+    /* *pusLength -= ulLength;*/
+
+	return ulLength;
+}
+
+
+/*
+ *USBReadBulkEndpoint read data in USB bulk endpoint
+ */
+unsigned long
+UDC_USBReadBulkEndpoint(unsigned long ulEndpoint, unsigned char *ppucData,
+                    unsigned long pusLength)
+{
+    unsigned long ulIdx, ulLength;
+    volatile unsigned short *pulUSB_data16;
+#ifdef   USE_DMA_READ
+#else
+    unsigned long	ulData;
+#endif
+    
+   
+
+    pulUSB_data16 = pulUSBDataPort;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Read the length of the data buffer.
+     */
+    ulLength = pulUSB[HwUSBEndpointBufferLength >> 2] ;//& USB_EPBUFLEN_MASK;
+    
+    /*printk("UDC_USBReadBulkEndpoint=%x",ulLength);*/
+    
+    /*
+     *Is there buffer space to fill with this data or should we throw the
+     *data away?
+     */
+    if(pusLength) {
+
+#ifdef   USE_DMA_READ
+
+        if(ulLength %2 ==0) {
+            DMARead(ulEndpoint, (void *)ppucData, ulLength);
+            ppucData += ulLength;
+        } else if(ulLength %2 ==1) {
+            DMAOddRead(ulEndpoint, (void *)ppucData, ulLength);
+            ppucData += ulLength;
+
+        }
+
+#else 
+            /*
+             * Read the data into the receive buffer.
+             */
+            for(ulIdx = 0; (ulIdx < ulLength) && (ulIdx < pusLength); ) {
+
+                ulData =  *pulUSB_data16;
+
+                *ppucData = ulData & 0xff;
+                ppucData++;
+                ulIdx++;
+
+                if((ulIdx < ulLength) && (ulIdx < pusLength)) {
+                    *ppucData = ulData >> 8;
+                    ppucData++ ;
+                    ulIdx++;
+                }
+
+            }
+        
+
+#endif
+        /*
+         * Decrement the count of bytes to read.
+         */
+        pusLength -= ulIdx;
+    } else {
+        /*
+         * Send the clear buffer command so that the endpoint can receive
+         * another packet.
+         */
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+        printk("USBReadEndpoint clear\n");
+    }
+
+    /*
+     *Return the size of the packet received.
+     */
+    return(ulLength);
+}
+
+
+
+
+
+
+/*
+ *USBDMAWriteEndpoint writes data to the specified endpoint.
+ */
+void
+USBDMAWriteEndpoint(unsigned long ulEndpoint, const unsigned char **ppucData,
+                    unsigned long *pusLength)
+{
+    unsigned long ulLength;
+    
+
+    ulLength = (*pusLength > sUSB.ulWriteEndpointMAXLen) ? sUSB.ulWriteEndpointMAXLen: *pusLength;
+
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Write the packet length.
+     */
+    pulUSB[HwUSBEndpointBufferLength >> 2] = ulLength;
+
+    /*
+     * Write the data into the transmit buffer.
+     */
+
+    if(ulLength %2 ==0)
+        DMAWrite(ulEndpoint, (void *)*ppucData, ulLength);
+    else
+        DMAOddWrite(ulEndpoint, (void *)*ppucData, ulLength);
+
+
+    *ppucData += ulLength;
+
+    /*
+     * Decrement the count of bytes to write.
+     */
+    *pusLength -= ulLength;
+
+
+}
+
+/*----------------------------------------------------------------------------------*/
+
+/*
+ * USBEnableEndpoint 
+ * Enable or Disable the Endpoint FIFO
+ */
+static void
+USBEnableEndpoint(unsigned long ulEndpoint,unsigned char bEnable)
+{
+
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Set the mode of  the endpoint .
+     */
+    if(bEnable ==1) {
+        pulUSB[HwUSBEndpointType >> 2] &= ~USB_EPTYPE_ENABLE;
+        pulUSB[HwUSBEndpointType >> 2] |= USB_EPTYPE_ENABLE;
+    } else {
+        pulUSB[HwUSBEndpointType >> 2] &= ~USB_EPTYPE_ENABLE;
+    }
+
+    return;
+
+}
+
+/*
+ * USBStallEndpoint stalls or un-stalls the specified endpoint.
+ */
+void
+USBStallEndpoint(unsigned long ulEndpoint, unsigned long bStall)
+{
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+    /*
+     * Stall or Unstall the appropriate endpoint.
+     */
+    if(bStall) {
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_STALL;
+    } else {
+        pulUSB[HwUSBEndpointControl >> 2] &= ~USB_EPCONTROL_STALL;
+        pulUSB[HwUSBEndpointType >> 2] &= ~USB_EPTYPE_ENABLE;
+        pulUSB[HwUSBEndpointType >> 2] |= USB_EPTYPE_ENABLE;
+    }
+}
+
+
+/*
+ * USBSendControl transmits a block of data back to the host via the control
+ * endpoint.
+ */
+unsigned long
+USBSendControl(const unsigned char *pucData, unsigned long ulLength)
+{
+
+    /*
+     * If a block is already being transmitted, then return a failure.
+     */
+    if(sUSB.usControlInCount) {
+        return(0);
+    }
+
+    /*
+     * Prepare to transmit this block back to the host.
+     */
+    sUSB.pucControlIn = pucData;
+    sUSB.usControlInCount = ulLength;
+
+    /*
+     * Send the first packet of this block back to the host.
+     */
+    USBWriteEndpoint(USB_ENDPOINT_CONTROL_IN, &sUSB.pucControlIn,
+                     &sUSB.usControlInCount);
+
+    /*
+     * Success.
+     */
+    return(1);
+}
+
+
+/*
+ *USBSendBulk transmits a block of data back to the host via the bulk  endpoint.
+ */
+unsigned long
+USBSendBulk(const unsigned char *pucData, unsigned long ulLength)
+{
+    /*
+     * If a block is already being transmitted, then return a failure.
+     */
+    if(sUSB.usBulkInCount) {
+        return(0);
+    }
+
+    /*
+     * Prepare to transmit this block back to the host.
+     */
+    sUSB.pucBulkIn = pucData;
+    sUSB.usBulkInCount = ulLength;
+
+    /*
+     * Send the first packet of this block back to the host.
+     */
+#ifdef   USE_DMA_WRITE
+
+    USBDMAWriteEndpoint(USB_ENDPOINT_TWO_IN, &sUSB.pucBulkIn,
+                        &sUSB.usBulkInCount);
+#else
+
+    USBWriteEndpoint(USB_ENDPOINT_TWO_IN, &sUSB.pucBulkIn,
+                     &sUSB.usBulkInCount);
+#endif
+
+    /*
+     * Success.
+     */
+    ulLength=ulLength-sUSB.usBulkInCount;
+    sUSB.usBulkInCount=0;
+
+    return(ulLength-sUSB.usBulkInCount);
+
+}
+
+/*
+ * USBReceiveBulk reads a block of data from the host via the bulk endpoint.
+ */
+#ifdef gadget_debug
+static unsigned long
+USBReceiveBulk(unsigned char *pucData, unsigned long ulLength)
+{
+    /*
+     * Prepare to read data from the host into this buffer.
+     */
+    sUSB.pucBulkOut = pucData;
+    sUSB.usBulkOutCount = ulLength;
+
+    /*
+     * Success.
+     */
+    return(1);
+}
+
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * USBGetEndpointFifoLen 
+ * Get the length of the EndpointFifo of the endpoint.
+ */
+unsigned long
+USBGetEndpointFifoLen(unsigned long ulEndpoint)
+{
+    unsigned long ulLength;
+
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+    /*
+     * Send the Validate buffer command so that the endpoint can send
+     * the packet.
+     */
+    ulLength = pulUSB[HwUSBEndpointBufferLength >> 2] & USB_EPBUFLEN_MASK;
+
+    return(ulLength);
+}
+
+
+
+/*
+ *
+ * USBClearEndpointBuffer 
+ * send the clear buffer command  so that the endpoint can receive another packet.
+ *
+ */
+static void
+USBClearEndpointBuffer(unsigned long ulEndpoint)
+{
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+   /*
+    *Send the clear buffer command so that the endpoint can receive
+    *another packet.
+    */
+    pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+
+    return;
+}
+
+
+/*
+ *
+ * USBGetEndpointStatus 
+ * Get the EndpointStatus of the endpoint.
+ */
+unsigned long 
+USBGetEndpointStatus(unsigned long ulEndpoint)
+{
+    unsigned long ulEndpointStatus;
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+
+   /*
+    * Send the Validate buffer command so that the endpoint can send
+    * the packet.
+    */
+    ulEndpointStatus = pulUSB[HwUSBEndpointControl >> 2] ;
+
+    return(ulEndpointStatus);
+}
+
+
+/*----------------------------------------------------------------------------------*/
+/*
+ *USBSlavePreInit
+ */
+void
+USBSlavePreInit(unsigned long pulUSBStartAddress)
+{
+      
+    /*
+     *Init The USB default Speed
+     */
+    sUSB.ucUSBSpeed = FullSpeed;
+
+    /*
+     * Indicate that the SoftConnect pull-up is active and that we are not
+     * configured.
+     */
+    sUSB.ucFlags = 2;
+    sUSB.ucSetupFlags = 0;
+    sUSB.usBulkInCount = 0;
+    sUSB.ulBulkMAXLen = 64;
+    sUSB.ulWriteEndpointMAXLen = 64;
+
+
+    pulUSB  = (unsigned long *)pulUSBStartAddress;
+    pulUSB16  = (unsigned short *)pulUSBStartAddress;
+    pulUSBDataPort = (unsigned short *)(pulUSBStartAddress+HwUSBEndpointData);
+
+}
+
+/*
+ *USB_DMA_init allocate the DMA uncache buffer,and clear 0
+ */
+void
+USB_DMA_init(void)
+{
+    int i;
+/*
+    DMAPHYaddress = consistent_alloc(GFP_KERNEL|GFP_DMA,4096,&DMAVaddress);
+    for(i=0;i<(4096/4);i++) {
+        *((unsigned long *)(DMAPHYaddress)+i) =0;
+
+    }
+*/
+	DMAPHYaddress = (unsigned short *)dma_alloc_coherent(NULL,4096,(void *)&DMAVaddress, 0);
+
+	for(i=0;i<(4096/4);i++) {
+        *((unsigned long *)(DMAPHYaddress)+i) =0;
+
+    }
+	
+}
+
+
+/*
+ *USBDMAinit initialize the DMA setting of EP93xx and ISp1581
+ */
+void USBDMAinit(void)
+{
+
+    unsigned long ulTemp;
+
+    pulUSB[HwUSBDMAEndpoint >> 2] = USB_DMAEP_SEVEN_OUT;/*111(7) 0(RX)     */
+
+    /*
+     *init Ep931x DMA
+     */
+    pulDMA[HwDMA_M2M_Control >> 2] = (DMA_M2M_CONTROL_DONE_INT_EN |
+                                      DMA_M2M_CONTROL_BWC_FULL |
+                                      DMA_M2M_CONTROL_PW_HALFWORD |
+                                      DMA_M2M_CONTROL_SAH |
+                                      DMA_M2M_CONTROL_TM_HARDWARE_P2M |
+                                      DMA_PIN_CONFIG |
+                                      DMA_M2M_CONTROL_RSS_EXTERNAL_DREQ |
+                                      (5 << DMA_M2M_CONTROL_PWSC_SHIFT));
+
+    ulTemp = pulDMA[HwDMA_M2M_Control >> 2];
+    mdelay(10);
+    /*printk("pulDMA[HwDMA_M2M_Control >> 2] =%x\n",ulTemp);*/
+
+
+    /*
+     *init 1581 DMA
+     */
+    pulUSB16[HwUSBDMAConfig >> 1] = (USB_DMACONFIG_BURST_1|
+                                     /* (USB_DMACONFIG_BURST_ALL |*/
+                                     USB_DMACONFIG_MODE_DACK | 
+                                     USB_DMACONFIG_WIDTH_16);  
+    ulTemp= pulUSB16[HwUSBDMAConfig >>1];
+    mdelay(10);
+    /*printk(" pulUSB[HwUSBDMAConfig >> 2]=%x\n",ulTemp);*/
+
+    /*   0(14bit) not ignor the IOREADY;
+            0(13bit) not ATA mod;
+         00(12 11 bit) udma/mdma mode0;
+         000(10 9 8bit)PIO time; 
+         0(7bit)  not disable DMA count;
+         000(6 5 4)burst[2:0] 
+    high 8bit  */
+    pulUSB16[HwUSBDMAHardware >> 1] = (USB_DMAHW_ENDIAN_NORMAL |
+                                       USB_PIN_CONFIG |
+                                       USB_DMAHW_WRITE_ACTIVE_LOW |
+                                       USB_DMAHW_READ_ACTIVE_LOW);
+    ulTemp=pulUSB16[HwUSBDMAHardware >> 1];
+    mdelay(10);
+    /*printk(" pulUSB[HwUSBDMAHardware >> 2]=%x\n",ulTemp);*/
+
+    /*
+    00(7 6 bit) 16bit little endian
+    1(5 bit) EOT    high
+    0(4 bit) GDMA slave mode
+    1(3 bit) DACK    high
+    1(2 bit) DREQ    high
+    0(1 bit) DIOW low
+    0(0 bit) DIOR low
+    */
+
+    /*
+     *1581 DMA enable int
+     */
+    pulUSB16[HwUSBDMAIntEnable >> 1]  = 0x0D00;
+
+}
+
+
+/*
+ * USBEnable configures the ISP1581 device.
+ */
+void
+USBChipEnable(void)
+{
+    /*
+     * Configure the ISP1581 and enable the SoftConnect pull-up.       
+     */
+  
+    pulUSB[HwUSBMode >> 2] = 0;
+    pulUSB[HwUSBMode >> 2] = USB_MODE_INT_ENABLE | USB_MODE_SOFT_CONNECT;
+    mdelay(1);
+    
+    /*
+     * Configure the interrupt Setting line.      
+     * EDB931x INT intput High Level valdation      
+     */
+    pulUSB[HwUSBIntConfig >> 2] = (USB_INTCONFIG_CDBGMOD_ACK |
+                                   USB_INTCONFIG_DDBGMODIN_ACK |
+                                   USB_INTCONFIG_DDBGMODOUT_ACK|0x01);
+    mdelay(1);
+    /*0x55=|0101|0101|*/
+    /*
+     * Enable the interrupts source for the bulk endpoints.      
+     */
+    pulUSB[HwUSBIntEnable >> 2] = ( USB_INT_EP2_TX | USB_INT_EP2_RX |USB_INT_HS_STATUS|
+                                    USB_INT_EP1_RX|USB_INT_EP1_TX|USB_INT_EP0_TX |
+                                    USB_INT_EP0_SETUP |USB_INT_EP0_RX|USB_INT_DMA);
+    mdelay(1);
+    /*
+     * Configure the  bulk endpoint.      
+     * Select EP2 is Bulk OUT EndPoint, EP1 is BULK IN EndPoint      
+     * Set the MaxPacketSize      
+     * Set The EndPoint Type      
+     * Enable The EndPoint      
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_ONE_OUT;
+    pulUSB[HwUSBEndpointMaxPacketSize >> 2] = 1024;
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_ONE_IN;
+    pulUSB[HwUSBEndpointMaxPacketSize >> 2] = 0;
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_TWO_IN;
+    pulUSB[HwUSBEndpointMaxPacketSize >> 2] = 1024;
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_TWO_OUT;
+    pulUSB[HwUSBEndpointMaxPacketSize >> 2] = 0;
+
+    pulUSB[HwUSBEndpointIndex >> 2]  = USB_ENDPOINT_ONE_OUT;
+    pulUSB[HwUSBEndpointType >> 2]  = (USB_EPTYPE_NO_EMPTY |
+                                       USB_EPTYPE_DOUBLE_BUFFER |USB_EPTYPE_ENABLE |
+                                       USB_EPTYPE_TYPE_BULK);
+    pulUSB[HwUSBEndpointIndex >> 2]  = USB_ENDPOINT_ONE_IN;
+    pulUSB[HwUSBEndpointType >> 2]   = 0;
+    pulUSB[HwUSBEndpointIndex >> 2]  = USB_ENDPOINT_TWO_IN;
+    pulUSB[HwUSBEndpointType >> 2]   = (USB_EPTYPE_NO_EMPTY |
+                                        USB_EPTYPE_DOUBLE_BUFFER |USB_EPTYPE_ENABLE |
+                                        USB_EPTYPE_TYPE_BULK);
+    pulUSB[HwUSBEndpointIndex >> 2]  = USB_ENDPOINT_TWO_OUT;
+    pulUSB[HwUSBEndpointType >> 2]  = 0;
+    /*
+     *Clear The Bufferof The Bulk Endpoint      
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_ONE_OUT;
+    pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_TWO_IN;
+    pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_CLEAR;
+
+    /*
+     * Enable the device and reset the device address.      
+     */
+    pulUSB[HwUSBAddress >>2] = USB_ADDRESS_DEVICE_ENABLE;
+    mdelay(10);
+
+    /*
+     *Configure USB Chip DMA part
+     */
+    USBDMAinit();
+
+
+}
+
+/*
+ * USBDisable de-configures the ISP1581 device.
+ */
+void
+USBDisable(void)
+{
+    /*
+     * Disable the interrupts for the bulk endpoints.
+     */
+    pulUSB[HwUSBIntEnable >> 2] = 0;
+
+    /*
+     * Disable the SoftConnect pull-up.
+     */
+    pulUSB[HwUSBMode >> 2] = 0;
+
+    /*
+     * Indicate that the SoftConnect pull-up is no longer active.
+     */
+    sUSB.ucFlags &= ~2;
+}
+
+/*----------------------------------------------------------------------------------*/
+
+/*
+ * USBWakeUpCs :WakeUp the ISP1581 device.
+ */
+void
+USBWakeUpCs(void)
+{
+
+    pulUSB[HwUSBMode >> 2] = USB_MODE_WAKE_UP_CS;
+
+}
+
+/*
+ * USBSoftReSet : SoftRest  the ISP1581 device.
+ */
+void
+USBSoftReSet(void)
+{
+
+    pulUSB[HwUSBMode >> 2] = USB_MODE_SOFT_RESET;
+
+}
+
+/*
+ * USBSuspendDevice : Set The ISP1581 USB Device to go suspend mode , and set the CLOCK off.
+ */
+void
+USBSuspendDevice(void)
+{
+
+    pulUSB[HwUSBMode >> 2] = USB_MODE_GO_SUSPEND ;
+
+}
+
+/*
+ * USBResumDevice : Resume the ISP1581 device.
+ */
+void
+USBResumDevice(void)
+{
+
+    pulUSB[HwUSBMode >> 2] = USB_MODE_SEND_RESUME |USB_MODE_CLOCK_ON;
+
+}
+
+/*
+ * USBSoftConnect :SoftConnect the ISP1581 device,
+ *
+ * Enables the D+ (or potentially D-) pullup.  The host will start
+ * enumerating this gadget when the pullup is active and a VBUS session
+ * is active (the link is powered).  This pullup is always enabled unless
+ * usb_gadget_disconnect() has been used to disable it.
+ */
+void
+USBSoftConnect(void)
+{
+
+    pulUSB[HwUSBMode >> 2] = pulUSB[HwUSBMode >> 2]|USB_MODE_SOFT_CONNECT;
+
+}
+
+
+/* USBSoftDisConnect - Soft Disconnect the ISP1581 device,
+ *
+ * Disables the D+ (or potentially D-) pullup, which the host may see
+ * as a disconnect (when a VBUS session is active).  Not all systems
+ * support software pullup controls.
+ *
+ * This routine may be used during the gadget driver bind() call to prevent
+ * the peripheral from ever being visible to the USB host, unless later
+ * usb_gadget_connect() is called.  For example, user mode components may
+ * need to be activated before the system can talk to hosts.
+ *
+ * Returns zero on success, else negative errno.
+ */
+void
+USBSoftDisConnect(void)
+{
+
+    pulUSB[HwUSBMode >> 2] = pulUSB[HwUSBMode >> 2]&(~USB_MODE_SOFT_CONNECT);
+
+}
+
+
+/*
+ *USBGet_frame_number  Get the Current Frame Number that the ISP1582 got
+ */
+static unsigned short
+USBGet_frame_number(void)
+{
+	unsigned short usGet_Frame_Number=0;
+	
+	usGet_Frame_Number = pulUSB16[HwUSBFrameNumber >> 1] ;
+
+	return usGet_Frame_Number;
+}
+
+/*-----------------------------------------------------------------------------------*/
+
+/* *handles USB Starndar device requests command. */
+
+/*
+ * USBGetStatus implements the USB Get_Status device request.
+ */
+static void USBGetStatus(struct ep93xx_udc *dev)
+{
+    unsigned char ucStatus[2];
+    unsigned long ulEndpoint;
+
+	printk("USBGetStatus\n");
+    /*
+     *Set the USB control process status
+     */
+    sUSB.ucSetupFlags = SETUPCOMMAND_DataPhase_INPID;
+	
+	dev->ep0state=EP0_IN_DATA_PHASE;
+
+    /*
+     * Determine how to handle this request based on the recipient.
+     */
+    /*switch(sUSB.sControlOut.bmRequestType & USB_RT_RECIPIENT_MASK) {*/
+	switch(dev->sControlOut->bRequestType & USB_RT_RECIPIENT_MASK) {
+        /*
+         * If the recipient is a device, return the state of the device's
+         * remote wakeup and self powered states.
+         */
+        case USB_RT_RECIPIENT_DEVICE: {
+            /*
+             * The player is self powered and does not support remote wakeup.
+             */
+            ucStatus[0] = USB_DEVICE_STATUS_SELF_POWERED;
+            ucStatus[1] = 0;
+
+            /*
+             * Send our response back to the host.
+             */
+            USBSendControl(ucStatus, 2);
+
+            /*
+             * We're done handling this request.
+             */
+            break;
+        }
+
+        /*
+         * If the recipient is a device interface, return a value of
+         * 0x00 as required by the USB spec.
+         */
+        case USB_RT_RECIPIENT_INTERFACE: {
+            /*
+             * The USB spec. requires a GetStatus request for an interface
+             * return a pair of zero bytes.
+             */
+            ucStatus[0] = 0;
+            ucStatus[1] = 0;
+
+            /*
+             * Send our response back to the host.
+             */
+            USBSendControl(ucStatus, 2);
+
+            /*
+             * We're done handling this request.
+             */
+            break;
+        }
+
+        /*
+         * If the recipient is an endpoint, determine whether it is stalled or
+         * not and return that information to the host.
+         */
+        case USB_RT_RECIPIENT_ENDPOINT: {
+            /*
+             * Find out which endpoint is the recipient of the request.
+             */
+            /*ulEndpoint = sUSB.sControlOut.wIndex & USB_ENDPOINT_ADDRESS_MASK;*/
+			ulEndpoint = dev->sControlOut->wIndex & USB_ENDPOINT_ADDRESS_MASK;
+
+
+            /*
+             * Determine whether the IN or the OUT endpoint is being addressed
+             * in the device request.
+             */
+            ulEndpoint *= 2;
+            /*if(sUSB.sControlOut.wIndex & USB_ENDPOINT_DIRECTION_MASK) {*/
+			if(dev->sControlOut->wIndex & USB_ENDPOINT_DIRECTION_MASK) {
+                ulEndpoint++;
+            }
+
+            /*
+             * Make sure that the specified endpoint is valid.
+             */
+            if((ulEndpoint != USB_ENDPOINT_CONTROL_OUT) &&
+               (ulEndpoint != USB_ENDPOINT_CONTROL_IN) &&
+               (ulEndpoint != USB_ENDPOINT_ONE_OUT) &&
+               (ulEndpoint != USB_ENDPOINT_TWO_IN)) {
+                /*
+                 * An invalid endpoint was specified, so stall both control
+                 * endpoints.
+                 */
+                USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+                USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+
+                /*
+                 * There is nothing further to do.
+                 */
+                return;
+            }
+
+            /*
+             * Read the endpoint status.
+             */
+            pulUSB[HwUSBEndpointIndex >> 2] = ulEndpoint;
+            ulEndpoint = pulUSB[HwUSBEndpointControl >> 2];
+
+            /*
+             * Send the endpoint's status to the host.
+             */
+            if(ulEndpoint & USB_EPCONTROL_STALL) {
+                ucStatus[0] = USB_ENDPOINT_STATUS_STALLED;
+            } else {
+                ucStatus[0] = 0;
+            }
+            ucStatus[1] = 0;
+
+            /*
+             * Send our response back to the host.
+             */
+            USBSendControl(ucStatus, 2);
+
+            /*
+             * We're done handling this request.
+             */
+            break;
+        }
+
+        /*
+         * If an invalid request is received, stall the control endpoint.
+         */
+    default: {
+            /*
+             * Stall the both control endpoints.
+             */
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+
+            /*
+              * We're done handling this request.
+              */
+            break;
+        }
+
+    }
+
+}
+
+/*
+ * USBClearFeature implements the USB Clear_Feature device request.
+ */
+/*static void USBClearFeature(void)*/
+static void USBClearFeature(struct ep93xx_udc *dev)
+{
+    unsigned long ulEndpoint;
+	
+	printk("USBClearFeature:type=%x,value=%x,index=%x",
+		dev->sControlOut->bRequestType,dev->sControlOut->wValue,
+		dev->sControlOut->wIndex );
+    /*
+     *Set the USB control process status
+     */
+    sUSB.ucSetupFlags = SETUPCOMMAND_StatusPhase_INPID;
+
+	dev->ep0state=EP0_IN_STATUS_PHASE;
+
+    /*
+     * The only feature we support is stall on an endpoint.
+     */
+    /*if(((sUSB.sControlOut.bmRequestType & USB_RT_RECIPIENT_MASK) ==*/
+    if(((dev->sControlOut->bRequestType & USB_RT_RECIPIENT_MASK) ==
+        USB_RT_RECIPIENT_ENDPOINT) &&
+       (dev->sControlOut->wValue == USB_FEATURE_ENDPOINT_STALL)) {
+        /*
+         * Compute the endpoint number.
+         */
+        ulEndpoint = (dev->sControlOut->wIndex & USB_ENDPOINT_ADDRESS_MASK) * 2;
+        if(dev->sControlOut->wIndex & USB_ENDPOINT_DIRECTION_MASK) {
+            ulEndpoint++;
+        }
+
+        /*
+         * Make sure that the specified endpoint is valid.
+         */
+        if((ulEndpoint != USB_ENDPOINT_CONTROL_OUT) &&
+           (ulEndpoint != USB_ENDPOINT_CONTROL_IN) &&
+           (ulEndpoint != USB_ENDPOINT_ONE_OUT) &&
+           (ulEndpoint != USB_ENDPOINT_TWO_IN)) {
+            /*
+             * An invalid endpoint was specified, so stall both control
+             * endpoints.
+             */
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+
+            /*
+             * There is nothing further to do.
+             */
+            return;
+        }
+
+        /*
+         * Clear the stall condition on the specified endpoint.
+         */
+        USBStallEndpoint(ulEndpoint, 0);
+
+        /*
+         * Respond to the host with an empty packet.
+         */
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_STATUS_ACK;
+
+    } else {
+        /*
+         * An unknown feature was specified, so stall both control endpoints.
+         */
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+    }
+
+}
+
+/*
+ * USBSetFeature implements the USB Set_Feature device request.
+ */
+/*static void USBSetFeature(void)*/
+static void USBSetFeature(struct ep93xx_udc *dev)
+{
+    unsigned long ulEndpoint;
+	
+	printk("USBSetFeature\n");
+    /*
+     *Set the USB control process status
+     */
+    sUSB.ucSetupFlags = SETUPCOMMAND_StatusPhase_INPID;
+
+	dev->ep0state=EP0_IN_STATUS_PHASE;
+
+    /*
+     * The only feature we support is stall on an endpoint.
+     */
+    if(((dev->sControlOut->bRequestType & USB_RT_RECIPIENT_MASK) ==
+        USB_RT_RECIPIENT_ENDPOINT) &&
+       (dev->sControlOut->wValue == USB_FEATURE_ENDPOINT_STALL)) {
+        /*
+         * Compute the endpoint number.
+         */
+        ulEndpoint = (dev->sControlOut->wIndex & USB_ENDPOINT_ADDRESS_MASK) * 2;
+        if(dev->sControlOut->wIndex & USB_ENDPOINT_DIRECTION_MASK) {
+            ulEndpoint++;
+        }
+
+        /*
+         * Make sure that the specified endpoint is valid.
+         */
+        if((ulEndpoint != USB_ENDPOINT_CONTROL_OUT) &&
+           (ulEndpoint != USB_ENDPOINT_CONTROL_IN) &&
+           (ulEndpoint != USB_ENDPOINT_ONE_OUT) &&
+           (ulEndpoint != USB_ENDPOINT_TWO_IN)) {
+            /*
+             * An invalid endpoint was specified, so stall both control
+             * endpoints.
+             */
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+
+            /*
+             * There is nothing further to do.
+             */
+            return;
+        }
+
+        /*
+         * Set the stall condition on the specified endpoint.
+         */
+        USBStallEndpoint(ulEndpoint, 1);
+    } else {
+        /*
+         * An unknown feature was specified, so stall both control endpoints.
+         */
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+    }
+
+}
+
+/*
+ * USBSetAddress implements the USB Set_Address device request.
+ */
+/*static void USBSetAddress(void)*/
+static void USBSetAddress(struct ep93xx_udc *dev)
+{
+    /*DEBUG("USBSetAddress\n");*/
+    /*
+     * Configure our UBS controller for the USB address assigned by the host.
+     */
+    pulUSB[HwUSBAddress >> 2] = (USB_ADDRESS_DEVICE_ENABLE |
+                                 dev->sControlOut->wValue);
+
+    /*
+     *Set the USB control process status
+     */
+    sUSB.ucSetupFlags = SETUPCOMMAND_StatusPhase_INPID;
+
+	dev->ep0state=EP0_IN_STATUS_PHASE;
+	dev->ep0req->length=0;
+	dev->ep0req->actual=0;
+    /*
+     * Select the appropriate endpoint.
+     */
+    pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_CONTROL_OUT;
+
+
+    /*
+     * Respond to the host with an empty packet.
+     */
+    pulUSB[HwUSBEndpointControl >> 2] = USB_EPCONTROL_STATUS_ACK|0x01;
+
+}
+
+/*
+ * USBGetDescriptor implements the USB Get_Descriptor device request.
+ */
+/*static void USBGetDescriptor(void)*/
+static void USBGetDescriptor(struct ep93xx_udc *dev)
+{
+    const unsigned char *pucDescriptor = 0;
+    unsigned long ulLength = 0;
+
+    printk("USBGetDescriptor\n");
+    /*
+     * Determine how to handle this request based on the requested descriptor.
+     */
+    switch(dev->sControlOut->wValue & USB_DESCRIPTOR_TYPE_MASK) {
+        /*
+         * The device descriptor was requested.
+         */
+    case USB_DESCRIPTOR_DEVICE: {
+            /*
+             * Prepare to return the device descriptor.
+             */
+            pucDescriptor = ucDeviceDescriptor;
+            ulLength = sizeof(ucDeviceDescriptor);
+
+            /*
+             * We're done handling this request.
+             */
+            break;
+        }
+
+        /*
+         * The configuration descriptor was requested.
+         */
+    case USB_DESCRIPTOR_CONFIGURATION: {
+            /*
+             * Prepare to return the configuration descriptor.
+             */
+            /*if(sUSB.ucUSBSpeed == FullSpeed) {*/
+			if(dev->gadget.speed == USB_SPEED_FULL){
+                pucDescriptor = ucConfigurationDescriptor;
+                ulLength = sizeof(ucConfigurationDescriptor);
+            /*} else if(sUSB.ucUSBSpeed == HighSpeed) {*/
+			} else if(dev->gadget.speed== USB_SPEED_HIGH) {
+                pucDescriptor = ucConfigurationHighDescriptor;
+                ulLength = sizeof(ucConfigurationHighDescriptor);
+            }
+
+            /*
+             * We're done handling this request.
+             */
+            break;
+        }
+
+        /*
+         * A string descriptor was requested.
+         */
+    case USB_DESCRIPTOR_STRING: {
+            /*
+             * Prepare to return the requested string.
+             */
+            switch(dev->sControlOut->wValue & USB_DESCRIPTOR_INDEX_MASK) {
+                /*
+                 * String index 0 is the language ID string.
+                 */
+            case 0x00: {
+                    pucDescriptor = ucString0;
+                    ulLength = sizeof(ucString0);
+                    break;
+                }
+
+                /*
+                  * String index 1 is the manufacturer name.
+                  */
+            case 0x01: {
+                    pucDescriptor = ucString1;
+                    ulLength = sizeof(ucString1);
+                    break;
+                }
+
+                /*
+                  * String index 2 is the product name.
+                  */
+            case 0x02: {
+                    pucDescriptor = ucString2;
+                    ulLength = sizeof(ucString2);
+                    break;
+                }
+
+                /*
+                  * String index 3 is the configuration name.
+                  */
+            case 0x03: {
+                    pucDescriptor = ucString3;
+                    ulLength = sizeof(ucString3);
+                    break;
+                }
+            }
+
+            /*
+              * We're done handling this request.
+              */
+            break;
+        }
+
+        /*
+          * An invalid request is received, so stall both control endpoints.
+          */
+    default: {
+            /*
+              * Stall both of the control endpoints.
+              */
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+
+            /*
+              * We're done handling this request.
+              */
+            return;
+        }
+    }
+
+     /*
+      * If the requested length is less than the length of the descriptor to be
+      * returned, then simply return the requested portion of the descriptor.
+      */
+    if(dev->sControlOut->wLength < ulLength) {
+        ulLength = dev->sControlOut->wLength;
+    }
+
+     /*
+      *Set the USB control process status
+      */
+    sUSB.ucSetupFlags = SETUPCOMMAND_DataPhase_INPID;
+
+	dev->ep0state=EP0_IN_DATA_PHASE;
+     /*
+      * Send the descriptor back to the host.
+      */
+    USBSendControl(pucDescriptor, ulLength);
+
+}
+
+/*
+ * USBGetConfiguration implements the USB Get_Configuration device request.
+ */
+/*static void USBGetConfiguration(void)*/
+
+static void USBGetConfiguration(struct ep93xx_udc *dev)
+{
+    unsigned char ucConfiguration = sUSB.ucFlags & 1;
+
+    printk("USBGetConfiguration\n");
+    /*
+     *Set the USB control process status
+     */
+    sUSB.ucSetupFlags = SETUPCOMMAND_DataPhase_INPID;
+
+	dev->ep0state=EP0_IN_DATA_PHASE;
+    /*
+     * Send the current configuration value back to the host.
+     */
+    USBSendControl(&ucConfiguration, 1);
+}
+
+/*
+ * USBSetConfiguration implements the USB Set_Configuration device request.
+ */
+/*static void USBSetConfiguration(void)*/
+static void USBSetConfiguration(struct ep93xx_udc *dev)
+{
+
+    /*DEBUG("USBSetConfiguration :%d\n",dev->sControlOut->wValue);*/
+    /*
+     *Set the USB control process status
+     */
+    sUSB.ucSetupFlags = SETUPCOMMAND_StatusPhase_INPID;
+
+
+	dev->ep0state=EP0_IN_STATUS_PHASE;
+    /*
+     * If the requested configuration is zero, then go into the unconfigured
+     * state.
+     */
+    if(dev->sControlOut->wValue == 0) {
+         /*
+          * Clear the global configuration flag.
+          */
+        sUSB.ucFlags &= ~1;
+
+         /*
+          * Disable the generic endpoints.
+          */
+        pulUSB[HwUSBEndpointType >> 2] &= ~USB_EPTYPE_ENABLE;
+        pulUSB[HwUSBEndpointType >> 2] &= ~USB_EPTYPE_ENABLE;
+
+         /*
+          * Respond to the host with an empty packet.
+          */
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_STATUS_ACK;
+    }
+
+     /*
+      * If the requested configuration is one, then go into the configured
+      * state.
+      */
+    else if(dev->sControlOut->wValue == 1) {
+         /*
+          * Set the global configuration flag.
+          */
+        sUSB.ucFlags |= 1;
+
+         /*
+          * Disable the generic endpoints.
+          */
+        pulUSB[HwUSBEndpointType >> 2] &= ~USB_EPTYPE_ENABLE;
+        pulUSB[HwUSBEndpointType >> 2] &= ~USB_EPTYPE_ENABLE;
+
+         /*
+          * Enable the generic contorl endpoints.
+          */
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT,0);
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_IN,0);
+
+         /*
+          * Respond to the host with an empty packet.
+          */
+        pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_STATUS_ACK;
+
+
+    }
+
+     /*
+      * If the requested configuration is anything else, then stall both of the
+      * control endpoints.
+      */
+    else {
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+    }
+
+
+}
+
+/*
+ * USBGetInterface implements the USB Get_Interface device request.
+ */
+/*static void USBGetInterface(void)*/
+static void USBGetInterface(struct ep93xx_udc *dev)
+{
+    unsigned char ucInterface = 0;
+
+	printk("USBGetInterface\n");
+     /*
+      *Set the USB control process status
+      */
+    sUSB.ucSetupFlags = SETUPCOMMAND_DataPhase_INPID;
+
+	dev->ep0state=EP0_IN_DATA_PHASE;
+     /*
+      * We only support a single interface, so the current interface is always
+      * the first one.  Send our response back to the host.
+      */
+    USBSendControl(&ucInterface, 1);
+}
+
+/*
+ * USBSetInterface implements the USB Set_Interface device request.
+ */
+/*static void USBSetInterface(void)*/
+static void USBSetInterface(struct ep93xx_udc *dev)
+{
+	printk("USBSetInterface\n");
+    /*
+     *Set the USB control process status
+     */
+    sUSB.ucSetupFlags = SETUPCOMMAND_StatusPhase_INPID;
+
+
+	dev->ep0state=EP0_IN_STATUS_PHASE;
+     /*
+      * We only support a single interface.
+      */
+    if((dev->sControlOut->wValue == 0) && (dev->sControlOut->wIndex == 0)) {
+         /*
+          * The first interface was requested, so do nothing.
+          */
+        return;
+    } else {
+         /*
+          * A non-existent interface was requested, so stall both control
+          * endpoints.
+          */
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+        USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+    }
+}
+
+/*
+ *vendor specific device or class specific device Command
+ */
+
+/*
+ * USBReserved handles device requests which are not supported by this USB
+ * device implementation.
+ */
+/*static void USBReserved(void)*/
+static void USBReserved(struct ep93xx_udc *dev)
+{
+    printk("This USB Command is not support by Our USB Device,So Stall the control pipe\n");
+     /*
+      * Stall both control endpoints.
+      */
+    USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+    USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+}
+
+
+
+/*------------------------------------------------------------------------------------*/
+/*
+ * USBISR is the interrupt handler routine for the USB.
+ */
+
+void USBISR (int irq,void * parmer,struct pt_regs *r)
+{
+    unsigned long ulIntStatus;
+    unsigned long usLength;
+    unsigned char *pucChar;
+    
+
+     /*
+      * Read the ISP1581 interrupt register.
+      */
+    ulIntStatus = pulUSB[HwUSBIntReason >> 2];
+
+     /*
+      * Clear the interrupt reason register.
+      */
+    pulUSB[HwUSBIntReason >> 2] =ulIntStatus;
+
+
+     /*
+      * Handle a hs status change.
+      */
+    if(ulIntStatus & USB_INT_HS_STATUS)
+    {
+         /*
+          * Reconfigure the ISP1581.
+          */
+        sUSB.ucUSBSpeed = HighSpeed;
+        sUSB.ulBulkMAXLen = 512;
+        USBChipEnable();
+
+         /*
+          * We're done handling the interrupts.
+          */
+    }
+
+     /*
+      * Handle a bus reset.
+      */
+    if(ulIntStatus & USB_INT_BUS_RESET)
+    {
+         /*
+          * Reconfigure the ISP1581.
+          */
+        USBChipEnable();
+
+         /*
+          *We're done handling the interrupts.
+          */
+
+    }
+
+    /*
+      *Handle an RX interrupt on the bulk out endpoint.
+      */
+    if(ulIntStatus & USB_INT_EP1_RX)
+    {
+        /*
+          *Read the data packet.
+          */
+    }
+
+    /*
+      * Handle an interrupt on the control in endpoint.
+      */
+    if(ulIntStatus & USB_INT_EP0_TX)
+    {
+
+
+        if(sUSB.usControlInCount !=0) {
+             /*
+              * Send the next packet of data to the host.
+              */
+            USBWriteEndpoint(USB_ENDPOINT_CONTROL_IN, &sUSB.pucControlIn,
+                             &sUSB.usControlInCount);
+        } else {
+            if(sUSB.ucSetupFlags==3) {
+                sUSB.ucSetupFlags=0;
+            } else if(sUSB.ucSetupFlags==2) {
+                sUSB.ucSetupFlags=4;
+
+                pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_CONTROL_IN;
+
+                pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_STATUS_ACK;
+
+            } else {
+                sUSB.ucSetupFlags=0;
+
+            }
+
+        }
+
+    }
+
+     /*
+      *Handle an interrupt from a setup packet.
+      */
+    if(ulIntStatus & USB_INT_EP0_SETUP)
+    {
+         /*
+          * Read the packet.
+          */
+        pucChar = (unsigned char *)&sUSB.sControlOut;
+        usLength = sizeof(ControlTransfer);
+        if(USBReadEndpoint(USB_ENDPOINT_SETUP, &pucChar,
+                           &usLength) != sizeof(ControlTransfer)) {
+             /*
+              * The size of the setup packet is incorrect, so stall both of the
+              * control endpoints.
+              */
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+            printk("EP0--setup   stall\n");
+        } else {
+             /*
+              * Process the command in the setup packet.
+              */
+            if(((sUSB.sControlOut.bmRequestType & USB_RT_TYPE_MASK) ==
+                USB_RT_TYPE_STANDARD) && (sUSB.sControlOut.bRequest < 16)) {
+                 /*
+                  *This is a standard request, so call the appropriate
+                  *routine.
+                  */
+               /* (*USBStandardDeviceRequest[sUSB.sControlOut.bRequest])();*/
+            } else if((sUSB.sControlOut.bmRequestType & USB_RT_TYPE_MASK) ==
+                      USB_RT_TYPE_VENDOR) {
+                 /*
+                  *This is a vendor specific request.
+                  */
+                  /*USBVendor();*/
+            } else if((sUSB.sControlOut.bmRequestType & USB_RT_TYPE_MASK) ==
+                      USB_RT_TYPE_CLASS) {
+                 /*
+                  * This is a class specific request.
+                  */
+                 /*    USBClass(parmer);   */
+            } else {
+                 /*
+                  * All other requests are treated as reserved requests.
+                  */
+                /*USBReserved(dev);*/
+            }
+        }
+
+
+    }
+
+
+     /*
+      * Handle an TX interrupt on the bulk in endpoint.
+      */
+    if(ulIntStatus & USB_INT_EP2_TX)
+    {
+    /*    P1581ep2_tx(parmer);     */
+
+    }
+
+
+}
+
+
+/*----------------------------------------------------------------------------------*/
+#define	DRIVER_VERSION	"28-6-2005"
+#define	DRIVER_DESC	"EP93xx USB Device Controller driver"
+
+static const char driver_name [] = "ep93xx_udc";/*udc= usb device control*/
+static const char ep0name [] = "ep0";
+
+#ifdef CONFIG_PROC_FS
+#define	UDC_PROC_FILE
+#endif
+
+
+#ifdef DISABLE_TEST_MODE
+/* (mode == 0) == no undocumented chip tweaks
+ * (mode & 1)  == double buffer bulk IN
+ * (mode & 2)  == double buffer bulk OUT
+ * ... so mode = 3 (or 7, 15, etc) does it for both
+ */
+static ushort fifo_mode = 0;
+MODULE_PARM (fifo_mode, "h");
+MODULE_PARM_DESC (fifo_mode, "ep93xx udc fifo mode");
+#endif
+
+static short IRQ_USB_SLAVE      =0;
+/*---------------------------------------------------------------------------------------*/
+static unsigned long 
+UDC_SendControl(struct usb_request *req)
+{
+	unsigned char 	*buf;
+	unsigned		length, count;
+
+	if((req==NULL)||(req->length==0)||(req->buf==NULL)){
+		DEBUG("UDC_SendControl error\n");
+		return 0;
+	}
+		
+	req->actual=0;
+
+	buf = req->buf + req->actual;
+
+	length = req->length - req->actual;
+	/*
+     	 * Send the first packet of this block back to the host.
+     	 */
+    	count	= UDC_USBWriteEndpoint(USB_ENDPOINT_CONTROL_IN, buf,
+                     		length,EP0_FIFO_SIZE);
+
+	/* how big will this packet be? */
+
+	req->actual += count;
+
+    return count;
+
+}
+
+static unsigned long 
+UDC_SendBulk(struct ep93xx_ep *ep,struct usb_request *req)
+{
+	unsigned char 	*buf;
+	unsigned long	length, count;
+	unsigned long 	ulEndpoint=0;
+    /*
+	if((req==NULL)||(req->length==0)||(req->buf==NULL)){
+		printk("UDC_SendBulk error\n");
+		return 0;
+	}*/
+
+	
+    ulEndpoint = ((ep->bEndpointAddress&0x80)>>7)|((ep->bEndpointAddress&0x7F)<<1);
+
+
+	/*req->actual=0;*/
+
+	buf = req->buf + req->actual;
+
+	length = req->length - req->actual;
+	/*
+     * Send the first packet of this block back to the host.
+     */
+
+#ifdef   USE_DMA_WRITE
+
+    count	= UDC_USBDMAWriteEndpoint(ulEndpoint, buf,length,/*BULK_FIFO_SIZE512*/sUSB.ulBulkMAXLen);
+#else	
+    count	= UDC_USBWriteEndpoint(ulEndpoint, buf,
+                     		length,/*BULK_FIFO_SIZE*/sUSB.ulBulkMAXLen);
+#endif
+	/* how big will this packet be? */
+	req->actual += count;
+	return count;
+
+
+}
+
+static unsigned long 
+UDC_ReceiveBulk(struct ep93xx_ep *ep,struct usb_request *req)
+{
+	unsigned char 	*buf;
+	unsigned long	length, count;
+	unsigned long 	ulEndpoint=0;
+    /*
+	if((req==NULL)||(req->length==0)||(req->buf==NULL)){
+		printk("UDC_SendBulk error\n");
+		return 0;
+	}
+    */
+	
+    ulEndpoint = ((ep->bEndpointAddress&0x80)>>7)|((ep->bEndpointAddress&0x7F)<<1);
+
+
+	/*req->actual=0;*/
+	buf = req->buf + req->actual;
+
+	length = req->length - req->actual;
+	/*
+     * Send the first packet of this block back to the host.
+     */
+    count	= UDC_USBReadBulkEndpoint(ulEndpoint, buf,length);
+
+    /*printk("rx bulk len=%x,ep=%x,req->actual=%x ,req->length=%x\n",count,ulEndpoint,req->actual, req->length);*/
+	/* how big will this packet be? */
+
+	req->actual += count;
+
+	return count;
+}
+
+/*
+ *	done - retire a request; caller blocked irqs
+ */
+static void done(struct ep93xx_ep *ep, struct ep93xx_request *req, int status)
+{
+	unsigned		stopped = ep->stopped;
+
+	list_del_init(&req->queue);
+
+	if (likely (req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN)
+		printk("complete %s req %p stat %d len %u/%u\n",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+	req->req.complete(&ep->ep, &req->req);
+	ep->stopped = stopped;
+}
+
+/*
+ * 	nuke - dequeue ALL requests
+ */
+static void nuke(struct ep93xx_ep *ep, int status)
+{
+	struct ep93xx_request  *req;
+	
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next,
+				struct ep93xx_request,
+				queue);
+		done(ep, req, status);
+	}
+	
+	if (ep->desc)
+		USBEnableEndpoint(ep->bEndpointAddress, 0);
+	else
+		printk("ep->desc is NULL\n");
+}
+
+
+/*
+ * read_fifo -  unload packet(s) from the fifo we use for usb OUT
+ * transfers and put them into the request.  caller should have made
+ * sure there's at least one packet ready.
+ *
+ * returns true if the request completed because of short packet or the
+ * request buffer having filled (and maybe overran till end-of-packet).
+ */
+static int
+read_fifo (struct ep93xx_ep *ep, struct ep93xx_request *req)
+{
+	unsigned long is_short,count;
+
+	while(req->req.length!=req->req.actual){
+
+		/*down(&ep->wait_dio_cmd);*/
+		ep->usSemStatus=1;
+        down(&ep->wait_dio_cmd);
+        ep->usSemStatus=0;
+        if(ep->usEPStop==1){
+	        ep->usEPStop=0;
+	        /*done (ep, req, 0);*/
+            /*printk("read fifo stop \n");*/
+            return 1 ;
+        }
+
+		DEBUG("bulk RX have data\n");
+		
+		disable_irq(IRQ_USB_SLAVE);
+		count = UDC_ReceiveBulk(ep,&(req->req));
+		enable_irq(IRQ_USB_SLAVE);
+
+		is_short = (count < ep->ep.maxpacket);
+        /*		
+        printk("read %s , %d bytes%s req %p %d/%d\n",
+			ep->ep.name, count,
+			is_short ? "/S" : "",
+			req, req->req.actual, req->req.length);
+        */
+		/* completion */
+		if (is_short || req->req.actual == req->req.length) {
+			done (ep, req, 0);
+			if (list_empty(&ep->queue))
+				DEBUG("irq_disable---read_fifo\n") ;
+			return 1;
+		}
+	}
+		/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+/*
+ * write to an IN endpoint fifo, as many packets as possible.
+ * irqs will use this to write the rest later.
+ * caller guarantees at least one packet buffer is ready (or a zlp).
+ */
+static int
+write_fifo (struct ep93xx_ep *ep, struct ep93xx_request *req)
+{
+	unsigned	count;
+	int		is_last=0;
+
+	/*
+	max = le16_to_cpu(ep->desc->wMaxPacketSize);
+	if(req->req.length==0xff)
+		req->req.length=36;*/
+	 
+	/*if(req->req.length==req->req.actual){
+		printk("write_fifo len =actual\n");
+		return 0;
+
+	}*/
+	up(&ep->wait_dio_cmd);
+    	
+    while(is_last==0){
+
+	/*down(&ep->wait_dio_cmd);*/
+	ep->usSemStatus=1;
+    down(&ep->wait_dio_cmd);
+    ep->usSemStatus=0;
+    if(ep->usEPStop==1){
+	    ep->usEPStop=0;
+	    /*done (ep, req, 0);*/
+        /*printk("read fifo stop \n");*/
+        return 1 ;
+    }
+	
+	disable_irq(IRQ_USB_SLAVE);
+	/*local_irq_save(flags);*/
+	count = UDC_SendBulk(ep,&(req->req));
+	enable_irq(IRQ_USB_SLAVE);
+	/* local_irq_restore(flags);*/
+	if(req->req.length==req->req.actual)
+        is_last = 1;
+
+    /*
+		printk("wrote %s %d bytes%s%s %d left %p\n",
+			ep->ep.name, count,
+			is_last ? "/L" : "", is_short ? "/S" : "",
+			req->req.length - req->req.actual, req);
+    */	
+	}
+		/* requests complete when all IN data is in the FIFO */
+	    /*	if (is_last) {*/
+		done (ep, req, 0);
+		is_last=0;
+		/*if (list_empty(&ep->queue))  {
+				printk("irq_disable\n");
+
+		}*/
+		DEBUG("write done\n");
+		return 1;
+		/*}*/
+
+		/*
+		 TODO experiment: how robust can fifo mode tweaking be?
+		 double buffering is off in the default fifo mode, which
+		 prevents TFS from being set here.
+        */
+
+	return 0;
+}
+
+
+/*
+ *ep93xx_ep_set_halt - sets the endpoint halt feature.
+ *The ISP1581 reg HwUSBEndpointControl, the bit STALL can not to halt the ISO endpoint
+ */
+static int ep93xx_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct ep93xx_ep	*ep;
+	unsigned long		flags;
+	unsigned long 		ulEndpoint;
+
+	DEBUG(" ep93xx_ep_set_halt \n");
+
+	ep = container_of(_ep, struct ep93xx_ep, ep);
+
+	if (unlikely (!_ep || (!ep->desc) || (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC))){
+		printk("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	
+	local_irq_save(flags);
+	
+	ulEndpoint	=	ep->bEndpointAddress;
+	USBStallEndpoint(ulEndpoint, value);
+	
+ 	local_irq_restore(flags);
+
+	printk("%s halt\n", _ep->name);
+	return 0;
+}
+
+
+/* for the ep93xx, these can just wrap kmalloc/kfree.  gadget drivers
+ * must still pass correctly initialized endpoints, since other controller
+ * drivers may care about how it's currently set up (dma issues etc).
+ */
+
+/*
+ * 	ep93xx_ep_alloc_request - allocate a request data structure
+ */
+static struct usb_request *
+ep93xx_ep_alloc_request (struct usb_ep *_ep, int gfp_flags)
+{
+	struct ep93xx_request   *req;
+        struct ep93xx_udc       *dev;
+        struct ep93xx_ep        *ep;
+
+	DEBUG(" ep93xx_ep_alloc_request \n");
+
+
+	ep = container_of (_ep, struct ep93xx_ep, ep);
+	
+	dev=ep->dev;
+        
+	if(dev->req_config==1){
+            enable_irq(IRQ_USB_SLAVE);
+            dev->req_config=0;
+        }
+	
+	req = kmalloc (sizeof *req, gfp_flags);
+	if (!req)
+		return 0;
+
+	memset (req, 0, sizeof *req);
+	INIT_LIST_HEAD (&req->queue);
+	return &req->req;
+}
+
+
+/*
+ * 	ep93xx_ep_free_request - deallocate a request data structure
+ */
+static void
+ep93xx_ep_free_request (struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct ep93xx_request	*req;
+
+	DEBUG(" ep93xx_ep_free_request \n");
+
+	req = container_of (_req, struct ep93xx_request, req);
+	if (!_req) {
+		printk("%s, bad rep\n", __FUNCTION__);
+		
+	}
+	
+	WARN_ON (!list_empty (&req->queue));
+	kfree(req);
+}
+
+static void *
+ep93xx_ep_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
+	dma_addr_t *dma, int gfp_flags)
+{
+	char			*retval;
+
+	DEBUG(" ep93xx_ep_alloc_buffer \n");
+	
+	retval = kmalloc (bytes, gfp_flags & ~(__GFP_DMA|__GFP_HIGHMEM));
+	if (retval)
+		*dma = virt_to_bus (retval);
+	return retval;
+}
+
+static void
+ep93xx_ep_free_buffer(struct usb_ep *_ep, void *buf, dma_addr_t dma,
+		unsigned bytes)
+{
+
+	DEBUG(" ep93xx_ep_free_buffer \n");
+	
+	kfree (buf);
+}
+
+static int ep93xx_ep_fifo_status(struct usb_ep *_ep)
+{
+	struct ep93xx_ep        *ep;
+	unsigned long 			ulEndpoint;
+	unsigned long 			ulEndpointStatus;
+
+	DEBUG(" ep93xx_ep_fifo_status \n");
+	
+	ep = container_of(_ep, struct ep93xx_ep, ep);
+	if (!_ep) {
+		printk("%s, bad ep\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+
+	ulEndpoint			=	((ep->bEndpointAddress&0x80)>>7)|((ep->bEndpointAddress&0x7F)<<1);
+	DEBUG(" ep93xx_ep_fifo_status ep=%x\n",ulEndpoint);
+	ulEndpointStatus	=	USBGetEndpointStatus(ulEndpoint);
+
+	if (ep->dev->gadget.speed == USB_SPEED_UNKNOWN
+			|| ((ulEndpointStatus&0x1) == 0))
+		return 0;
+	else
+		return USBGetEndpointFifoLen(ulEndpoint);;
+}
+
+
+static void ep93xx_ep_fifo_flush(struct usb_ep *_ep)
+{
+	struct ep93xx_ep        *ep;
+	unsigned long 			ulEndpoint;
+
+	DEBUG(" ep93xx_ep_fifo_flush \n");
+	
+	ep = container_of(_ep, struct ep93xx_ep, ep);
+	if (!_ep) {
+		printk("%s, bad ep\n", __FUNCTION__);
+		
+	}
+	
+    /*	ulEndpoint			=	ep->bEndpointAddress;*/
+    ulEndpoint  = ((ep->bEndpointAddress&0x80)>>7)|((ep->bEndpointAddress&0x7F)<<1);
+	DEBUG(" ep93xx_ep_fifo_flush ep=%x\n",ulEndpoint);
+
+	USBClearEndpointBuffer(ulEndpoint);
+}
+
+
+
+/*
+ * endpoint enable/disable
+ *
+ * we need to verify the descriptors used to enable endpoints.  since pxa2xx
+ * endpoint configurations are fixed, and are pretty much always enabled,
+ * there's not a lot to manage here.
+ *
+ * because pxa2xx can't selectively initialize bulk (or interrupt) endpoints,
+ * (resetting endpoint halt and toggle), SET_INTERFACE is unusable except
+ * for a single interface (with only the default altsetting) and for gadget
+ * drivers that don't halt endpoints (not reset by set_interface).  that also
+ * means that if you use ISO, you must violate the USB spec rule that all
+ * iso endpoints must be in non-default altsettings.
+ */
+static int ep93xx_ep_enable (struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct ep93xx_ep        *ep;
+	struct ep93xx_udc       *dev;
+	unsigned long ulEndpoint;
+
+	ep = container_of (_ep, struct ep93xx_ep, ep);
+	if (!_ep || !desc || ep->desc 
+			|| ep->bEndpointAddress != desc->bEndpointAddress
+			|| ep->fifo_size < le16_to_cpu
+						(desc->wMaxPacketSize)) {
+
+     	        /*printk("%x, %x,%x,%x,%x,%x,%x\n", __FUNCTION__,_ep,ep->desc,
+						ep->bEndpointAddress, desc->bEndpointAddress,
+						ep->fifo_size,(unsigned short)desc->wMaxPacketSize);*/
+
+		printk("%s, bad ep or descriptor\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+			&& ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+			&& desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
+		printk("%s, %s type mismatch\n", __FUNCTION__, _ep->name);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+				&& le16_to_cpu (desc->wMaxPacketSize)
+						!= /*BULK_FIFO_SIZE*/sUSB.ulBulkMAXLen)
+			|| !desc->wMaxPacketSize) {
+		printk("%s, bad %s maxpacket\n", __FUNCTION__, _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		printk("%s, bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+	ep->desc = desc;
+	ep->dma = -1;
+	ep->stopped = 0;
+	ep->pio_irqs = ep->dma_irqs = 0;
+	ep->ep.maxpacket = le16_to_cpu (desc->wMaxPacketSize);
+
+	/*
+        if(dev->req_config==1){
+            enable_irq(IRQ_USB_SLAVE);
+            dev->req_config=0;
+        }
+    */
+	/* flush fifo (mostly for OUT buffers) */
+	ep93xx_ep_fifo_flush (_ep);
+
+    ulEndpoint   =   ((ep->bEndpointAddress&0x80)>>7)|((ep->bEndpointAddress&0x7F)<<1);
+	DEBUG(" ep93xx_ep_enable ep=%x\n",ulEndpoint);
+	
+	/* ... reset halt state too, if we could ... */
+	USBEnableEndpoint(ep->bEndpointAddress, 1);
+
+	
+
+	DEBUG( "enabled %s\n", _ep->name);
+	return 0;
+}
+
+static int ep93xx_ep_disable (struct usb_ep *_ep)
+{
+	struct ep93xx_ep	*ep;
+
+	ep = container_of (_ep, struct ep93xx_ep, ep);
+	if (!_ep || !ep->desc) {
+		DEBUG("%s, %s not enabled\n", __FUNCTION__,
+			_ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+	nuke (ep, -ESHUTDOWN);
+
+	/* flush fifo (mostly for IN buffers) */
+	ep93xx_ep_fifo_flush (_ep);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	DEBUG("%s disabled\n", _ep->name);
+	return 0;
+}
+
+/* dequeue JUST ONE request */
+static int ep93xx_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct ep93xx_ep	*ep;
+	struct ep93xx_request	*req;
+	unsigned long		flags;
+	
+	DEBUG(" ep93xx_ep_dequeue \n");
+
+	ep = container_of(_ep, struct ep93xx_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		local_irq_restore(flags);
+		return -EINVAL;
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int
+ep93xx_ep_queue(struct usb_ep *_ep, struct usb_request *_req, int gfp_flags)
+{
+	struct ep93xx_request	*req;
+	struct ep93xx_ep	*ep;
+	struct ep93xx_udc	*dev;
+	unsigned long		flags;
+	unsigned long 		count=0;
+
+    /*	printk(" ep93xx_ep_queue \n");*/
+
+
+	req = container_of(_req, struct ep93xx_request, req);
+	if (unlikely (!_req || !_req->complete || !_req->buf
+			|| !list_empty(&req->queue))) {
+		printk("%s, bad params\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct ep93xx_ep, ep);
+	if (unlikely (!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		printk("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (unlikely (!dev->driver
+			|| dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		printk("%s, bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+
+	dev->ep0req		=	_req;
+	dev->epBulkReq	=	req;
+
+    /*	dev->ep=ep;*/
+	/* iso is always one packet per request, that's the only way
+	 * we can report per-packet status.  that also helps with dma.
+	 */
+	if (unlikely (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC
+			&& req->req.length > le16_to_cpu
+						(ep->desc->wMaxPacketSize)))
+		return -EMSGSIZE;
+
+
+	DEBUG("%s queue req %p, len %d buf %p,ep_Attr=%x,ep->address=%x\n",
+	     _ep->name, _req, _req->length, _req->buf,ep->bmAttributes,ep->bEndpointAddress);
+
+	local_irq_save(flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+	
+        
+	/* kickstart this i/o queue? */
+    /*	if (list_empty(&ep->queue) && !ep->stopped) {*/
+	if((ep->bmAttributes == USB_ENDPOINT_XFER_BULK)&&
+			((ep->bEndpointAddress & USB_DIR_IN) != 0)){
+			/*count = UDC_SendBulk(ep,_req);*/
+		    /*	dev->ep[3]=ep;*/
+	    local_irq_restore(flags);
+		if(write_fifo(ep,req)==1)
+			req=0;
+		count=_req->actual;
+		local_irq_save(flags);
+	}
+	else if((ep->bmAttributes == USB_ENDPOINT_XFER_BULK)&&
+			((ep->bEndpointAddress & USB_DIR_IN) == 0)){
+        	/*count = UDC_ReceiveBulk(ep,_req);*/
+		    /*	dev->ep[4]=ep;*/
+		local_irq_restore(flags);
+		if(read_fifo(ep,req)==1)
+			req=0;
+		count=_req->actual;
+		local_irq_save(flags);
+	}
+	else{
+		/*local_irq_save(flags);*/
+		count = UDC_SendControl(_req);
+		/*local_irq_restore(flags);*/
+
+	}
+    /*		printk(" ep93xx_ep_queue process:%d\n",count);*/
+    /*	}*/
+
+	/* pio or dma irq handler advances the queue. */
+
+    /*	
+    if (likely (req != 0))
+		list_add_tail(&req->queue, &ep->queue);
+	*/
+	local_irq_restore(flags);
+
+	return 0;
+}
+/*------------------------------------------------------------------------------------*/
+static struct usb_ep_ops ep93xx_ep_ops = {
+	.enable			= ep93xx_ep_enable,
+	.disable		= ep93xx_ep_disable,
+
+	.alloc_request	= ep93xx_ep_alloc_request,
+	.free_request	= ep93xx_ep_free_request,
+
+	.alloc_buffer	= ep93xx_ep_alloc_buffer,
+	.free_buffer	= ep93xx_ep_free_buffer,
+
+	.queue		    = ep93xx_ep_queue,
+	.dequeue	    = ep93xx_ep_dequeue,
+
+	.set_halt		= ep93xx_ep_set_halt,
+	.fifo_status	= ep93xx_ep_fifo_status,
+	.fifo_flush		= ep93xx_ep_fifo_flush,
+
+};
+
+static inline void ep0_idle (struct ep93xx_udc *dev)
+{
+	dev->ep0state = EP0_IDLE;
+
+}
+
+
+/*----------------------------------------------------------------------------*/
+
+/* 
+ * 	device-scoped parts of the api to the usb controller hardware
+ * 
+ */
+
+static int ep93xx_udc_get_frame(struct usb_gadget *_gadget)
+{
+	DEBUG(" ep93xx_udc_get_frame number\n");
+	
+	return USBGet_frame_number();
+}
+
+static int ep93xx_udc_wakeup(struct usb_gadget *_gadget)
+{
+	/* host may not have enabled remote wakeup */
+	DEBUG(" ep93xx_udc_wakeup\n");
+	
+	USBWakeUpCs();
+
+	return 0;
+}
+
+static int ep93xx_pullup (struct usb_gadget * sDevice, int is_on)
+{
+
+	DEBUG(" ep93xx_pullup\n");
+	
+	if(is_on==1)
+		USBSoftConnect();
+	else if(is_on==0)
+		USBSoftDisConnect();
+	else
+		return -EOPNOTSUPP;
+
+	return 0;
+
+
+}
+
+static int ep93xx_set_selfpowered(struct usb_gadget *_gadget, int value)
+{
+
+	return 0;
+}
+
+static const struct usb_gadget_ops ep93xx_udc_ops = {
+	.get_frame	 	= 	ep93xx_udc_get_frame,
+	.wakeup		 	= 	ep93xx_udc_wakeup,
+	/* current versions must always be self-powered*/
+	.set_selfpowered=	ep93xx_set_selfpowered,
+	.pullup		 =	ep93xx_pullup,
+	
+};
+
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * 	udc_disable - disable USB device controller
+ */
+static void udc_disable(struct ep93xx_udc *dev)
+{
+	USBDisable();
+	ep0_idle (dev);
+	
+	dev->gadget.speed 	= USB_SPEED_UNKNOWN;
+	dev->ep0req->length	=0;
+	dev->ep0req->buf	=NULL;
+	dev->ep0req->context=NULL;
+	dev->ep0req->zero	=1;
+
+}
+
+
+/*
+ * 	udc_reinit - initialize software state
+ */
+static void udc_reinit(struct ep93xx_udc *dev)
+{
+	u32	i;
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD (&dev->gadget.ep_list);
+	INIT_LIST_HEAD (&dev->gadget.ep0->ep_list);
+	dev->ep0state = EP0_IDLE;
+
+	/* basic endpoint records init */
+	for (i = 0; i < EP93_UDC_NUM_ENDPOINTS; i++) {
+		struct ep93xx_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		INIT_LIST_HEAD (&ep->queue);
+		ep->pio_irqs = ep->dma_irqs = 0;
+	}
+
+	/* the rest was statically initialized, and is read-only */
+}
+
+
+/*
+ * until it's enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static void udc_enable (struct ep93xx_udc *dev)
+{
+	USBChipEnable();
+	ep0_idle(dev);
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	/*USB_SPEED_FULL*/
+	dev->stats.irqs = 0;
+
+	dev->ep0req->length	=0;
+	dev->ep0req->buf	=NULL;
+	dev->ep0req->context=NULL;
+	dev->ep0req->zero	=1;
+
+}
+
+
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef UDC_PROC_FILE
+
+static const char proc_node_name [] = "driver/udc";
+
+static int
+udc_proc_read(char *page, char **start, off_t off, int count,
+		int *eof, void *_dev)
+{
+	/*char    *buf = page;*/
+	unsigned    size = count;
+	unsigned long	flags;
+
+
+	if (off != 0)
+		return 0;
+
+	local_irq_save(flags);
+
+	local_irq_restore(flags);
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_files() \
+	create_proc_read_entry(proc_node_name, 0, NULL, udc_proc_read, dev)
+#define remove_proc_files() \
+	remove_proc_entry(proc_node_name, NULL)
+
+#else	/* !UDC_PROC_FILE */
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+#endif	/* UDC_PROC_FILE */
+
+/* "function" sysfs attribute */
+static ssize_t
+show_function (struct device *_dev, char *buf)
+{
+	struct ep93xx_udc	*dev = dev_get_drvdata (_dev);
+
+	if (!dev->driver
+			|| !dev->driver->function
+			|| strlen (dev->driver->function) > PAGE_SIZE)
+		return 0;
+	return scnprintf (buf, PAGE_SIZE, "%s\n", dev->driver->function);
+}
+static DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
+
+/*-------------------------------------------------------------------------*/
+
+
+/*
+ * when a driver is successfully registered, it will receive
+ * control requests including set_configuration(), which enables
+ * non-control requests.  then usb traffic follows until a
+ * disconnect is reported.  then a host may connect again, or
+ * the driver might get unbound.
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct ep93xx_udc	*dev = the_controller;
+	int			retval;
+
+	DEBUG("EP93xx usb_gadget_register_driver \n");
+	if (!driver
+			|| ((driver->speed != USB_SPEED_FULL)&&(driver->speed != USB_SPEED_HIGH))
+			|| !driver->bind
+			|| !driver->unbind
+			|| !driver->disconnect
+			|| !driver->setup)
+		return -EINVAL;
+    DEBUG("EP93xx usb_gadget_register_driver: 1\n");	
+	if (!dev)
+		return -ENODEV;
+    DEBUG("EP93xx usb_gadget_register_driver: 2\n");
+	if (dev->driver)
+		return -EBUSY;
+
+	DEBUG("EP93xx usb_gadget_register_driver: 3\n");
+	/* first hook up the driver ... */
+	dev->driver = driver;
+	dev->gadget.dev.driver = &driver->driver;
+
+	device_add (&dev->gadget.dev);
+	DEBUG("EP93xx usb_gadget_register_driver: 4\n");
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		printk("bind to driver %s --> error %d\n",
+				driver->driver.name, retval);
+		device_del (&dev->gadget.dev);
+
+		dev->driver = 0;
+		dev->gadget.dev.driver = 0;
+		return retval;
+	}
+
+	device_create_file(dev->dev, &dev_attr_function);
+
+	/* ... then enable host detection and ep0; and we're ready
+	 * for set_configuration as well as eventual disconnect.
+	 * NOTE:  this shouldn't power up until later.
+	 */
+	printk("registered gadget driver '%s'\n", driver->driver.name);
+	udc_enable(dev);
+	/*dump_state(dev);*/
+		return 0;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+static void
+stop_activity(struct ep93xx_udc *dev, struct usb_gadget_driver *driver)
+{
+	int i;
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < EP93_UDC_NUM_ENDPOINTS; i++) {
+		struct ep93xx_ep *ep = &dev->ep[i];
+
+		ep->stopped = 1;
+		/*nuke(ep, -ESHUTDOWN);*/
+	}
+	del_timer_sync(&dev->timer);
+
+	/* report disconnect; the driver is already quiesced */
+	
+	if (driver)
+		driver->disconnect(&dev->gadget);
+
+	/* re-init driver-visible data structures */
+	udc_reinit(dev);
+}
+
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct ep93xx_udc	*dev = the_controller;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+	local_irq_disable();
+	udc_disable(dev);
+	stop_activity(dev, driver);
+	local_irq_enable();
+	
+    if(dev->ep[4].usSemStatus==1){
+        dev->ep[4].usEPStop=1;
+        up(&(dev->ep[4].wait_dio_cmd));
+        /*printk("read fifo unbind\n");*/
+    }
+    if(dev->ep[3].usSemStatus==1){
+        dev->ep[3].usEPStop=1;
+        up(&(dev->ep[3].wait_dio_cmd));
+        /*printk("read fifo unbind\n");*/
+    }
+        
+	driver->unbind(&dev->gadget);
+	dev->driver = 0;
+
+	device_del (&dev->gadget.dev);
+	device_remove_file(dev->dev, &dev_attr_function);
+
+	printk("unregistered gadget driver '%s'\n", driver->driver.name);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ *	ep93xx_udc_irq - interrupt handler
+ *
+ */
+static irqreturn_t
+ep93xx_udc_irq(int irq, void *_dev, struct pt_regs *r)
+{
+	struct ep93xx_udc	*dev = _dev;
+	int			handled;
+	
+	unsigned long ulIntStatus;
+    unsigned long usLength;
+    unsigned char *pucChar;
+
+	unsigned char 	*ucWriteBuf;
+	unsigned long	ulWriteLength, ulWriteCount;
+
+	int rc=0;
+
+	struct usb_ctrlrequest sControlOut;
+
+	dev->stats.irqs++;
+	handled = 0;
+	
+ 	/*
+     	* Read the ISP1581 interrupt register.
+     	*/
+    	ulIntStatus = pulUSB[HwUSBIntReason >> 2];
+
+    	/*
+     	* Clear the interrupt reason register.
+     	*/
+    	pulUSB[HwUSBIntReason >> 2] =ulIntStatus;
+
+	
+
+	/* SUSpend Interrupt Request */
+		
+	/* RESume Interrupt Request */
+		
+	/*
+     * Handle a hs status change.
+     */
+	if(ulIntStatus & USB_INT_HS_STATUS)
+	{
+    	/*
+      	 * Reconfigure the ISP1581.
+      	 */
+        	printk("The USB bus is high speed\n");
+
+    		sUSB.ucUSBSpeed = HighSpeed;
+    		sUSB.ulBulkMAXLen = 512;
+
+
+		dev->gadget.speed = USB_SPEED_HIGH;
+		memset(&dev->stats, 0, sizeof dev->stats);
+    		USBChipEnable();
+		handled = 1;
+    	/*
+      	 * We're done handling the interrupts.
+      	 */
+	}
+
+
+	/* ReSeT Interrupt Request - USB reset */
+
+	/*
+  	 * Handle a bus reset.
+  	 */
+	if(ulIntStatus & USB_INT_BUS_RESET)
+	{
+		sUSB.ulBulkMAXLen =64;
+                sUSB.ucUSBSpeed = FullSpeed;
+
+	    	if(dev->ep[4].usSemStatus==1){
+            		dev->ep[4].usEPStop=1;
+			dev->ep[4].usSemStatus=0;
+            		up(&(dev->ep[4].wait_dio_cmd));
+	            	/*printk("read fifo unbind\n");*/
+        	}
+        	
+		if(dev->ep[3].usSemStatus==1){
+            		dev->ep[3].usEPStop=1;
+			dev->ep[3].usSemStatus=0;
+            		up(&(dev->ep[3].wait_dio_cmd));
+            		/*printk("read fifo unbind\n");*/
+        	}
+
+		printk("\nThe USB dev is connected to USB host \n");
+    	/*
+      	 * Reconfigure the ISP1581.
+      	 */
+    		USBChipEnable();
+
+		dev->gadget.speed = USB_SPEED_FULL;
+		memset(&dev->stats, 0, sizeof dev->stats);
+		handled = 1;
+		/*
+      	 *We're done handling the interrupts.
+      	 */
+
+	}
+
+
+    /*
+     *Handle an RX interrupt on the bulk out endpoint.
+     */
+    if(ulIntStatus & USB_INT_EP1_RX)
+    {
+        /*
+         *Read the data packet.
+         */
+        DEBUG("INT bulk Rx \n");
+		up(&(dev->ep[4].wait_dio_cmd));
+    }
+
+
+ 	/*
+     * Handle an interrupt on the control in endpoint.
+     */
+    if(ulIntStatus & USB_INT_EP0_TX)
+    {
+
+		DEBUG("INT EP0 Tx \n");
+	
+
+		if(dev->ep0req==NULL){
+			printk("EP0 Tx parmer error\n");
+			return 0;
+		}
+		
+		ucWriteBuf = dev->ep0req->buf + dev->ep0req->actual;
+
+		ulWriteLength = dev->ep0req->length - dev->ep0req->actual;
+
+		if(ulWriteLength!=0) {
+            /*
+             * Send the next packet of data to the host.
+             */
+   		    ulWriteCount	= UDC_USBWriteEndpoint(USB_ENDPOINT_CONTROL_IN, ucWriteBuf,
+                     			ulWriteLength,EP0_FIFO_SIZE);
+			dev->ep0req->actual += ulWriteCount;
+        } 
+		else {
+            if(dev->ep0state==EP0_IN_STATUS_PHASE) {
+            
+				dev->ep0state=EP0_IDLE;
+				
+            } else if(dev->ep0state==EP0_IN_DATA_PHASE) {
+                
+				dev->ep0state=EP0_OUT_STATUS_PHASE;
+
+                pulUSB[HwUSBEndpointIndex >> 2] = USB_ENDPOINT_CONTROL_IN;
+
+                pulUSB[HwUSBEndpointControl >> 2] |= USB_EPCONTROL_STATUS_ACK;
+
+            } else {
+                
+				dev->ep0state=EP0_IDLE;
+
+            }
+
+        }
+    }
+
+
+
+ 	/*
+     *Handle an interrupt from a setup packet.
+     */
+    if(ulIntStatus & USB_INT_EP0_SETUP)
+    {
+		dev->ep[0].pio_irqs++;
+		DEBUG("INT SEtup\n");
+		/*
+         * Read the packet.
+         */
+        pucChar = (unsigned char *)&sControlOut;
+        usLength = sizeof(struct usb_ctrlrequest);
+        if(USBReadEndpoint(USB_ENDPOINT_SETUP, &pucChar,
+                           &usLength) != sizeof(struct usb_ctrlrequest)) {
+            /*
+             * The size of the setup packet is incorrect, so stall both of the
+             * control endpoints.
+             */
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_OUT, 1);
+            USBStallEndpoint(USB_ENDPOINT_CONTROL_IN, 1);
+            printk("EP0--setup   stall\n");
+        } else {
+        	dev->sControlOut=&sControlOut;
+           
+            /* Process the command in the setup packet.*/
+          
+   
+            
+			if (dev->sControlOut->bRequestType & USB_DIR_IN)
+				dev->ep0state = EP0_IN_DATA_PHASE;
+			else
+				dev->ep0state = EP0_IN_STATUS_PHASE;
+			
+            if(dev->sControlOut->bRequest==USB_REQ_SET_ADDRESS)
+				USBSetAddress(dev);
+            else if(dev->sControlOut->bRequest==USB_REQ_GET_STATUS)
+				USBGetStatus(dev);
+		    else if(dev->sControlOut->bRequest==USB_REQ_CLEAR_FEATURE)
+				USBClearFeature(dev);
+		    else if(dev->sControlOut->bRequest==USB_REQ_SET_FEATURE)
+				USBSetFeature(dev);
+   			else if(dev->sControlOut->bRequest==USB_REQ_SET_DESCRIPTOR)
+				USBReserved(dev);
+			else{
+		 		rc=dev->driver->setup(&dev->gadget,dev->sControlOut);
+				if(rc==(256+999)){
+					if(dev->sControlOut->bRequest==USB_REQ_SET_CONFIGURATION){
+						/*
+						   give the fsg main thread timne to process Handle_porcess()
+						   do_set_config and do_set_interface
+						 */
+						disable_irq(IRQ_USB_SLAVE);
+						dev->req_config=1;
+						USBSetConfiguration(dev);
+						/*enable_irq(IRQ_USB_SLAVE);*/
+					}
+            		else if(dev->sControlOut->bRequest==USB_REQ_SET_INTERFACE)
+						USBSetInterface(dev);
+				}
+			}
+			DEBUG("EP0--setup   finished\n");
+        }
+
+
+    }
+
+    /*
+     * Handle an TX interrupt on the bulk in endpoint.
+     */
+    if(ulIntStatus & USB_INT_EP2_TX)
+    {
+        if(dev->epBulkReq->req.actual!=dev->epBulkReq->req.length){
+			DEBUG("int bulk Tx\n");
+			up(&(dev->ep[3].wait_dio_cmd));
+        }
+	/*	else	DEBUG("INT bulk Tx no work \n");*/
+
+    }
+
+
+		
+
+	/* we could also ask for 1 msec SOF (SIR) interrupts */
+
+	
+	
+	DEBUG(" USB Slave int\n");
+	return IRQ_HANDLED;
+}
+
+
+static void nop_release (struct device *dev)
+{
+	printk("%s %s\n", __FUNCTION__, dev->bus_id);
+}
+
+/*
+ * this uses load-time allocation and initialization (instead of
+ * doing it at run-time) to save code, eliminate fault paths, and
+ * be more obviously correct.
+ */
+static struct ep93xx_udc memory = {
+	.gadget = {
+		.ops		= &ep93xx_udc_ops,
+		.ep0		= &memory.ep[0].ep,
+		.name		= driver_name,
+		.dev = {
+			.bus_id		= "gadget",
+			.release	= nop_release,
+		},
+	},
+
+	/* control setup endpoint */
+	.ep[0] = {
+		.ep = {
+			.name			= ep0name,
+			.ops			= &ep93xx_ep_ops,
+			.maxpacket		= EP0_FIFO_SIZE,
+		},
+		.dev				= &memory,
+		.bEndpointAddress		=USB_ENDPOINT_SETUP,
+	},
+	
+	/* control in endpoint */
+	.ep[1] = {
+		.ep = {
+			.name		= "ep0in-control",
+			.ops		= &ep93xx_ep_ops,
+			.maxpacket	= EP0_FIFO_SIZE,
+		},
+		.dev		= &memory,
+		.bEndpointAddress = USB_ENDPOINT_CONTROL_IN,
+		
+
+	},
+
+	/* control out endpoint */
+	
+	.ep[2] = {
+		.ep = {
+			.name		= "ep0out-control",
+			.ops		= &ep93xx_ep_ops,
+			.maxpacket	= EP0_FIFO_SIZE,
+		},
+		.dev		= &memory,
+		.bEndpointAddress = USB_ENDPOINT_CONTROL_OUT,
+		
+
+	},
+	/* bulk group of endpoints */
+	.ep[3] = {
+		.ep = {
+			.name		= "ep2in-bulk",
+			.ops		= &ep93xx_ep_ops,
+			.maxpacket	= BULK_FIFO_SIZE,
+		},
+		.dev		= &memory,
+		.fifo_size	= BULK_FIFO_SIZE,
+		.bEndpointAddress = 0x80|2,/*USB_ENDPOINT_TWO_IN,*/
+		.bmAttributes	= USB_ENDPOINT_XFER_BULK,
+
+	},
+
+	.ep[4] = {
+		.ep = {
+			.name		= "ep1out-bulk",
+			.ops		= &ep93xx_ep_ops,
+			.maxpacket	= BULK_FIFO_SIZE,
+		},
+		.dev		= &memory,
+		.fifo_size	= BULK_FIFO_SIZE,
+		.bEndpointAddress = 0x00|1,/*USB_ENDPOINT_ONE_OUT,*/
+		.bmAttributes	= USB_ENDPOINT_XFER_BULK,
+
+	},
+	
+	.ep[5] = {
+		.ep = {
+			.name		= "ep3in-int",
+			.ops		= &ep93xx_ep_ops,
+			.maxpacket	= INT_FIFO_SIZE,
+		},
+		.dev		= &memory,
+		.fifo_size	= INT_FIFO_SIZE,
+		.bEndpointAddress =  0x80|3,/*USB_ENDPOINT_THREE_IN,*/
+		.bmAttributes	= USB_ENDPOINT_XFER_INT,
+
+	},	
+
+
+};
+
+
+
+
+
+/*-------------------------------------------------------------------------*/
+
+unsigned long  *pulUSBStartAdress_32,ulUSBPhyBaseAddress,ulSMCBase;
+#ifdef gadget_debug
+    	static short major			=3;
+    	static short minor			=0;
+#endif
+
+	static short cs   			=7;
+
+#if (defined(CONFIG_ARCH_EP9315A) || defined(CONFIG_ARCH_EP9307A) || defined(CONFIG_ARCH_EP9302A))
+       	static short irq                        =0;
+#else
+	static short irq			=1;
+#endif
+
+
+/*
+ *SelectCS select cs of the system  EDP931x
+ *0 sucess
+ *1 faile
+ *   ulUSBPhyBaseAddress : the Physical Base Address of the USB Slave board
+ *   ulSMCBase       : the SMC      Base Address of the USB Slave board
+ */
+
+unsigned long
+SelectCS(short sCS)
+{
+
+    if(sCS==0) {
+        ulUSBPhyBaseAddress = 0x00000000;
+        ulSMCBase = 0x00;
+    } else if(sCS==1) {
+        ulUSBPhyBaseAddress = 0x10000000;
+        ulSMCBase = 0x04;
+    } else if(sCS==2) {
+        ulUSBPhyBaseAddress = 0x20000000;
+        ulSMCBase = 0x08;
+    } else if(sCS==3) {
+        ulUSBPhyBaseAddress = 0x30000000;
+        ulSMCBase = 0x0C;
+    } else if(sCS==6) {
+        ulUSBPhyBaseAddress = 0x60000000;
+        ulSMCBase = 0x18;
+    } else if(sCS==7) {
+        ulUSBPhyBaseAddress = 0x70000000;
+        ulSMCBase = 0x1C;
+    } else {
+        ulUSBPhyBaseAddress = 0;
+        ulSMCBase = 0;
+        return 1;
+    }
+
+    return(0);
+}
+
+/*
+ *initDmaDevice init the EP931x system register
+ */
+void initDmaDevice(void)
+{
+    unsigned long uiPWRCNT,uiDEVCFG;
+
+    uiPWRCNT = inl(SYSCON_PWRCNT);
+    uiPWRCNT |= SYSCON_PWRCNT_DMA_M2MCH1;
+    outl( uiPWRCNT, SYSCON_PWRCNT );
+
+    uiPWRCNT = inl(SYSCON_PWRCNT);
+    
+    uiDEVCFG = inl(SYSCON_DEVCFG);
+    uiDEVCFG |=SYSCON_DEVCFG_D1onG;
+    SysconSetLocked( SYSCON_DEVCFG, uiDEVCFG );
+
+    uiDEVCFG = inl(SYSCON_DEVCFG);
+   
+}
+
+/*
+ * GetUSBVirAdress  get the USB Slave Board vir adress.
+ */
+unsigned long
+GetUSBVirAdress(void)
+{
+    unsigned long  map_usb_Phy_To_Vir,USB_PHY_ADDR;
+
+    USB_PHY_ADDR = ulUSBPhyBaseAddress;
+    map_usb_Phy_To_Vir = (unsigned long)ioremap(USB_PHY_ADDR, USB_WINDOW_SIZE);
+
+    if (!map_usb_Phy_To_Vir) {
+        printk("failed to USV Slave driver ioremap\n");
+        return -EIO;
+    }
+    return(map_usb_Phy_To_Vir);
+}
+
+/*
+ *SelectCS select irq of the system  EDP931x
+ *return the system irq number
+ *return o show fail
+ */
+
+short
+SelectIRQ(short usIrq)
+{
+    short  ulUSBSlaveISRNumber;
+
+    if(usIrq==0)
+        ulUSBSlaveISRNumber = (short)IRQ_EXT0;
+    else if(usIrq==1)
+        ulUSBSlaveISRNumber = (short)IRQ_EXT1;
+    else if(usIrq==2)
+        ulUSBSlaveISRNumber = (short)IRQ_EXT2;
+    else
+        ulUSBSlaveISRNumber = 0;
+
+    return(ulUSBSlaveISRNumber);
+}
+
+/*
+ * TestUSBChipID  test the USB Slave Board chip ID
+ *  return 1 is right ,0 is error
+ */
+
+static int
+TestUSBChipID(unsigned long ul_map_usb_Phy_To_Vir)
+{
+
+    unsigned long ulChipID1,ulUSBSlaveChipIDVersion;
+
+    pulUSBStartAdress_32 =( unsigned long *)ul_map_usb_Phy_To_Vir;
+    ulChipID1 = pulUSBStartAdress_32[HwUSBChipID>>2];
+    printk(" USB Device Controller Chip ID :%x",(unsigned short)ulChipID1);
+    if ( (ulChipID1 & USB_CHIPID_ID_MASK) == USB_CHIPID_ID) {
+        ulUSBSlaveChipIDVersion = (ulChipID1&USB_CHIPID_VERSION_MASK);
+        printk(" Version :%x\n",(unsigned short)ulUSBSlaveChipIDVersion);
+        return (1);
+    }
+
+    printk(" test chipID is wrong\n Are you sure the USB2 Slave Daughter Board Link on EDB931X?\n");
+    return (0);
+
+}
+
+
+/*
+ * USBEnable configures the ISP1581 device and the EDB931x HW.
+ * Return 1 sucess,0 error.
+ */
+
+unsigned char
+USBEnable(void)
+{
+    volatile unsigned long *pulSMC7Value;
+    unsigned long pulUSBStartAdress;
+    /*
+     *  SMC7 Base address 0x8008_001c
+     *  mmu map the adress  0x8000_0000 to 0xFF00_0000(Based on cirrus_linux1.41)
+     *  USB Slave Board link to EDB931x SMC ,and use CS7
+     */
+    pulSMC7Value =  (unsigned long *)(IO_BASE_VIRT+0x00080000+ulSMCBase);
+
+    /*
+     *Configure the EDB931X SMC
+     *USB Slave Chip be linked on  the SMC(cs7) 0x8008001c
+     *Configure the USB chip select for 16-bit access.
+     */
+    *pulSMC7Value=0x1000ffe0;
+
+    /*
+     *Get the virual address of USB Slave Board
+     */
+    pulUSBStartAdress=GetUSBVirAdress();
+
+    /*
+     *Test the USB Slave Board Chip ID,So That just the Board is or not linked to EDB931x
+     */
+    if(TestUSBChipID(pulUSBStartAdress)==0) {
+        return 0;
+    }
+
+    /*
+     *Configure the USB Slave Status
+     */
+    USBSlavePreInit(pulUSBStartAdress);
+
+    /*
+     *Configure the USB DMA
+     */
+    USB_DMA_init();
+    initDmaDevice();
+
+
+    /*
+     *Configure the USB Slave chip HW
+     */
+    USBChipEnable();
+
+
+
+    return(1);
+
+}
+
+/*
+ * Init The EDB931x USB2.0  Slave Daughter Board Module
+ * Return 0 sucess
+ */
+
+static int init_edb931xusb(void)
+{
+    /*short  sUSBSlaveISRNumber;*/
+    DEBUG(KERN_ALERT " USB Slave board will use dev_major: %hd\n", major);
+    DEBUG(KERN_ALERT " USB Slave board will use dev_minor: %hd\n", minor);
+    DEBUG(KERN_ALERT " USB Slave board will use cs: %hd\n", cs);
+    DEBUG(KERN_ALERT " USB Slave board will use extern INT: %hd\n", irq);
+
+    if(SelectCS(cs) !=0) {
+        printk("failed to select cs of USV Slave driver\n");
+        return -EIO;
+    }
+    if(USBEnable() == 0) {
+        return -EIO;
+    }
+
+    IRQ_USB_SLAVE = SelectIRQ(irq);
+    if (IRQ_USB_SLAVE==0) {
+        printk("failed to select irq of USV Slave driver:%d\n",IRQ_USB_SLAVE);
+        return -EIO;
+    }
+
+	
+    DEBUG(" The USB Slave Module init sucess\n");
+    return 0;
+
+}
+
+
+/*
+ * Clear The EDB931x USB2.0  Slave Daughter Board Module
+ */
+static void cleanup_edb931x_usb(void)
+{
+    unsigned long ulmap_usb_Phy_To_Vir;
+    /*short  sUSBSlaveISRNumber;*/
+    /*
+     *clear the ioremap
+     */
+    ulmap_usb_Phy_To_Vir = (unsigned long)pulUSBStartAdress_32 ;
+    iounmap((void *)ulmap_usb_Phy_To_Vir);
+
+    DEBUG("The USB Slave Module uninstall sucess\n");
+}
+
+
+/*-----------------------------------------------------------------------------------*/
+
+/*
+ * 	probe - binds to the platform device
+ */
+
+static int ep93xx_udc_probe(struct device *_dev)
+{
+	struct ep93xx_udc *dev = &memory;
+	int retval;
+	
+
+
+	if(init_edb931xusb()!=0)
+		return -EBUSY;
+	DEBUG("the ep93xx_udc_probe begin\n");
+
+	/* other non-static parts of init*/ 
+	dev->dev = _dev;
+	dev->mach = _dev->platform_data;
+
+	/*init the udc EP0requestion*/
+	dev->ep0req		=	&UDC_ep0req;
+	
+	/*timer*/
+	init_timer(&dev->timer);
+	/*dev->timer.function = udc_watchdog;*/
+	dev->timer.data = (unsigned long) dev;
+
+
+	device_initialize(&dev->gadget.dev);
+	dev->gadget.dev.parent = _dev;
+	dev->gadget.dev.dma_mask = _dev->dma_mask;
+
+	dev->gadget.is_dualspeed= 1;
+
+	/*sem*/
+	sema_init(&(dev->ep[3].wait_dio_cmd), 0);
+	sema_init(&(dev->ep[4].wait_dio_cmd), 0);
+	dev->ep[4].usSemStatus=0;
+    dev->ep[3].usSemStatus=0;
+    dev->ep[4].usEPStop=0;
+    dev->ep[3].usEPStop=0;
+
+
+	the_controller = dev;
+	dev_set_drvdata(_dev, dev);
+
+	udc_disable(dev);
+	udc_reinit(dev);
+
+	retval = request_irq(IRQ_USB_SLAVE, ep93xx_udc_irq,
+			SA_INTERRUPT, driver_name, dev);
+	if (retval != 0) {
+		printk(KERN_ERR "%s: can't get irq %i, err %d\n",
+			driver_name, IRQ_USB_SLAVE, retval);
+		return -EBUSY;
+	}
+	
+	dev->got_irq = 1;
+	dev->req_config=0;
+
+	create_proc_files();
+
+	return 0;
+}
+
+
+static int ep93xx_udc_remove(struct device *_dev)
+{
+	struct ep93xx_udc *dev = _dev->driver_data;
+
+	
+	cleanup_edb931x_usb();
+	udc_disable(dev);
+	remove_proc_files();
+	usb_gadget_unregister_driver(dev->driver);
+
+	if (dev->got_irq) {
+		free_irq(IRQ_USB_SLAVE, dev);
+		dev->got_irq = 0;
+	}
+		
+	dev_set_drvdata(_dev, 0);
+	the_controller = 0;
+	return 0;
+}
+
+static struct device_driver udc_driver = {
+        .name           = "ep93xx-udc",
+        .bus            = &platform_bus_type,
+        .probe          = ep93xx_udc_probe,
+        .remove         = ep93xx_udc_remove,
+                                                                                                                             
+        // FIXME power management support
+        // .suspend = ... disable UDC
+        // .resume = ... re-enable UDC
+};
+
+
+/*-----------------------------------------------------------------------------------*/
+static int __init ep931x_usb2_init(void)
+{
+	printk(KERN_INFO "%s: version %s\n", driver_name, DRIVER_VERSION);
+	return driver_register(&udc_driver);
+
+}
+module_init(ep931x_usb2_init);
+
+static void __exit ep931x_usb2_exit(void)
+{
+	driver_unregister(&udc_driver);
+
+}
+module_exit(ep931x_usb2_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Shrek");
+MODULE_LICENSE("GPL");
+
diff -burN linux-2.6.8.1-orig/drivers/usb/gadget/ep93xx_udc.h linux-2.6.8.1/drivers/usb/gadget/ep93xx_udc.h
--- linux-2.6.8.1-orig/drivers/usb/gadget/ep93xx_udc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/gadget/ep93xx_udc.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1160 @@
+/*
+ * linux/drivers/usb/gadget/ep93xx_udc.h
+ * Cirruss EP93xx and ISP1581 on-chip high  speed USB device controller
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_USB_GADGET_EP931X_H
+#define __LINUX_USB_GADGET_EP931X_H
+
+#include <linux/types.h>
+
+/*-------------------------------------------------------------------------*/
+
+
+struct ep93xx_udc;
+
+struct ep93xx_ep {
+	struct usb_ep		                    ep;
+	struct ep93xx_udc			            *dev;
+
+	const struct usb_endpoint_descriptor	*desc;
+	struct list_head			            queue;
+	unsigned long				            pio_irqs;
+	unsigned long				            dma_irqs;
+	short					                dma; 
+	unsigned short 						usSemStatus;
+	unsigned short 						usEPStop;
+	unsigned short				            fifo_size;
+	u8					                    bEndpointAddress;
+	u8					                    bmAttributes;
+
+	unsigned				stopped : 1;
+	unsigned				dma_fixup : 1;
+	struct semaphore                wait_dio_cmd;						 
+
+};
+
+struct ep93xx_request {
+	struct usb_request			req;
+	struct list_head			queue;
+};
+
+enum ep0_state { 
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_IN_STATUS_PHASE,
+	EP0_OUT_STATUS_PHASE,
+	EP0_END_XFER,
+	EP0_STALL,
+};
+
+#define EP0_FIFO_SIZE	        ((unsigned)64)
+/*#define BULK_FIFO_SIZE	((unsigned)64)*/
+#define BULK_FIFO_SIZE          ((unsigned)512)
+
+#define ISO_FIFO_SIZE	        ((unsigned)256)
+#define INT_FIFO_SIZE	        ((unsigned)8)
+
+struct udc_stats {
+	struct ep0stats {
+		unsigned long		ops;
+		unsigned long		bytes;
+	} read, write;
+	unsigned long			irqs;
+};
+
+
+#define	EP93_UDC_NUM_ENDPOINTS	6/*setup ,control in/out,bulk in/out,int in*/
+
+struct ep93xx_udc {
+	struct usb_gadget			gadget;
+	struct usb_gadget_driver	*driver;
+	struct usb_ctrlrequest		*sControlOut;
+	struct usb_request			*ep0req;	// For control responses
+	struct ep93xx_request		*epBulkReq;	// For control responses
+
+	enum ep0_state				ep0state;
+	struct udc_stats			stats;
+	unsigned				    got_irq : 1,
+						        got_disc : 1,
+						        has_cfr : 1,
+						        req_pending : 1,
+						        req_std : 1,
+						        req_config : 1;
+
+#define start_watchdog(dev) mod_timer(&dev->timer, jiffies + (HZ/200))
+	struct timer_list			timer;
+
+	struct device				*dev;
+	struct ep93xx_udc_mach_info	*mach;
+	u64					        dma_mask;
+	struct ep93xx_ep			ep [EP93_UDC_NUM_ENDPOINTS];
+};
+
+/*-------------------------------------------------------------------------*/
+
+static struct ep93xx_udc *the_controller;
+
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Debugging support vanishes in non-debug builds.  DBG_NORMAL should be
+ * mostly silent during normal use/testing, with no timing side-effects.
+ */
+#define DBG_NORMAL	1	/* error paths, device state transitions */
+#define DBG_VERBOSE	2	/* add some success path trace info */
+#define DBG_NOISY	3	/* ... even more: request level */
+#define DBG_VERY_NOISY	4	/* ... even more: packet level */
+
+
+#define DBG(lvl, stuff...) do{if ((lvl) <= UDC_DEBUG) DMSG(stuff);}while(0)
+
+#define WARN(stuff...) printk(KERN_WARNING "udc: " stuff)
+#define INFO(stuff...) printk(KERN_INFO "udc: " stuff)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*--------------------------------------------------------------------------------*/
+/*
+  * Defines for the USB specification and the Philips ISP1581 USB controller.
+  *
+  * Copyright (c) 2004 Cirrus Logic, Inc.
+  */
+
+/*
+  *USB2.0  Slave Based on EDB931x
+  *default Use the CS7
+  * 
+  *USB2.0 SLAVE Memory Space
+  */
+
+#define ep93IOBASE                IO_BASE_VIRT
+#define USB_WINDOW_ADDR           0x70000000
+#define USB_WINDOW_SIZE           0x1000
+
+/*
+  *USB2.0  Slave Based on EDB931x
+  *Use the extern INT1
+  */
+//#define USBSlaveISRNumber    IRQ_EXT1
+
+
+/*
+  *USB2.0  Slave Based on EDB931x
+  *We support USB Mass Storage Class,Bulk Only protocol
+  */
+#define CLASS_MASS_STORAGE 		0x08
+#define SUBCLASS_SCSI   		0x06
+#define PROTOCOL_BULK   		0x50
+
+
+/*
+  *USB2.0  Slave Based on EDB931x
+  *We use ISP1581 as USB Slave Controller
+  *We use ISP1581 EP1out as OUT Endpoint , EP2in as IN Endpoint
+  */
+#define  USBSlaveBulkOutEndPoint   	USB_ENDPOINT_ONE_OUT
+
+#define  USBSlaveBulkInEndPoint     USB_ENDPOINT_TWO_IN
+
+
+
+/*---------------------------------------------------------------------------------*/
+
+/****************************************************************************/
+
+/*
+  * USB2_slave_hw.H - Defines for the USB specification and the Philips ISP1581 USB
+  *         controller.
+  *
+  * Copyright (c) 2004 Cirrus Logic, Inc.
+  */
+
+/****************************************************************************/
+
+/*
+  * The following defines are specific the the Philips ISP1581 USB controller.
+  */
+
+
+/*
+  * The offsets of the individual registers in the ISP1581 USB controller.
+  */
+#define HwUSBAddress                            0x00000000
+#define HwUSBEndpointMaxPacketSize              0x00000004
+#define HwUSBEndpointType                       0x00000008
+#define HwUSBMode                               0x0000000c
+#define HwUSBIntConfig                          0x00000010
+#define HwUSBIntEnable                          0x00000014
+#define HwUSBIntReason                          0x00000018
+#define HwUSBEndpointBufferLength               0x0000001c
+#define HwUSBEndpointData                       0x00000020
+#define HwUSBEndpointShortPacket                0x00000024
+#define HwUSBEndpointControl                    0x00000028
+#define HwUSBEndpointIndex                      0x0000002c
+#define HwUSBDMACommand                         0x00000030
+#define HwUSBDMACount                           0x00000034
+#define HwUSBDMAConfig                          0x00000038
+#define HwUSBDMAHardware                        0x0000003c
+#define HwUSBDMAIntReason                       0x00000050
+#define HwUSBDMAIntEnable                       0x00000054
+#define HwUSBDMAEndpoint                        0x00000058
+#define HwUSBDMAStrobeTiming                    0x00000060
+#define HwUSBChipID                             0x00000070
+#define HwUSBFrameNumber                        0x00000074
+#define HwUSBScratch                            0x00000078
+#define HwUSBUnlock                             0x0000007c
+#define HwUSBTest                               0x00000084
+
+/*
+  * Definitions of the bit fields in the Address register.
+  */
+#define USB_ADDRESS_DEVICE_ENABLE               0x00000080
+#define USB_ADDRESS_DEVICE_ADDR_MASK            0x0000007f
+#define USB_ADDRESS_DEVICE_ADDR_SHIFT           0
+
+/*
+  * Definitions of the bit fields in the EndpointMaxPacketSize register.
+  */
+#define USB_EPMAXPACKET_NTRANS_MASK             0x00001800
+#define USB_EPMAXPACKET_NTRANS_ONE              0x00000000
+#define USB_EPMAXPACKET_NTRANS_TWO              0x00000800
+#define USB_EPMAXPACKET_NTRANS_THREE            0x00001000
+#define USB_EPMAXPACKET_FIFO_SIZE_MASK          0x000007ff
+#define USB_EPMAXPACKET_FIFO_SIZE_SHIFT         0
+
+/*
+  * Definitions of the bit fields in the EndpointType register.
+  */
+#define USB_EPTYPE_NO_EMPTY                     0x00000010
+#define USB_EPTYPE_ENABLE                       0x00000008
+#define USB_EPTYPE_DOUBLE_BUFFER                0x00000004
+#define USB_EPTYPE_TYPE_MASK                    0x00000003
+#define USB_EPTYPE_TYPE_CONTROL                 0x00000000
+#define USB_EPTYPE_TYPE_ISOCHRONOUS             0x00000001
+#define USB_EPTYPE_TYPE_BULK                    0x00000002
+#define USB_EPTYPE_TYPE_INTERRUPT               0x00000003
+
+/*
+  * Definitions of the bit fields in the Mode register.
+  */
+#define USB_MODE_CLOCK_ON                       0x00000080
+#define USB_MODE_SEND_RESUME                    0x00000040
+#define USB_MODE_GO_SUSPEND                     0x00000020
+#define USB_MODE_SOFT_RESET                     0x00000010
+#define USB_MODE_INT_ENABLE                     0x00000008
+#define USB_MODE_WAKE_UP_CS                     0x00000004
+#define USB_MODE_SOFT_CONNECT                   0x00000001
+
+/*
+  * Definitions of the bit fields in the IntConfig register.
+  */
+#define USB_INTCONFIG_CDBGMOD_MASK              0x000000c0
+#define USB_INTCONFIG_CDBGMOD_ALL               0x00000000
+#define USB_INTCONFIG_CDBGMOD_ACK               0x00000040
+#define USB_INTCONFIG_CDBGMOD_ACK_1NAK          0x00000080
+#define USB_INTCONFIG_DDBGMODIN_MASK            0x00000030
+#define USB_INTCONFIG_DDBGMODIN_ALL             0x00000000
+#define USB_INTCONFIG_DDBGMODIN_ACK             0x00000010
+#define USB_INTCONFIG_DDBGMODIN_ACK_1NAK        0x00000020
+#define USB_INTCONFIG_DDBGMODOUT_MASK           0x0000000c
+#define USB_INTCONFIG_DDBGMODOUT_ALL            0x00000000
+#define USB_INTCONFIG_DDBGMODOUT_ACK            0x00000004
+#define USB_INTCONFIG_DDBGMODOUT_ACK_1NAK       0x00000008
+#define USB_INTCONFIG_INTLVL                    0x00000002
+#define USB_INTCONFIG_INTPOL                    0x00000001
+
+/*
+  * Definitions of the bit fields in the IntEnable and IntReason registers.
+  */
+#define USB_INT_EP7_TX                          0x02000000
+#define USB_INT_EP7_RX                          0x01000000
+#define USB_INT_EP6_TX                          0x00800000
+#define USB_INT_EP6_RX                          0x00400000
+#define USB_INT_EP5_TX                          0x00200000
+#define USB_INT_EP5_RX                          0x00100000
+#define USB_INT_EP4_TX                          0x00080000
+#define USB_INT_EP4_RX                          0x00040000
+#define USB_INT_EP3_TX                          0x00020000
+#define USB_INT_EP3_RX                          0x00010000
+#define USB_INT_EP2_TX                          0x00008000
+#define USB_INT_EP2_RX                          0x00004000
+#define USB_INT_EP1_TX                          0x00002000
+#define USB_INT_EP1_RX                          0x00001000
+#define USB_INT_EP0_TX                          0x00000800
+#define USB_INT_EP0_RX                          0x00000400
+#define USB_INT_EP0_SETUP                       0x00000100
+#define USB_INT_DMA                             0x00000040
+#define USB_INT_HS_STATUS                       0x00000020
+#define USB_INT_RESUME                          0x00000010
+#define USB_INT_SUSPEND                         0x00000008
+#define USB_INT_PSEUDO_SOF                      0x00000004
+#define USB_INT_SOF                             0x00000002
+#define USB_INT_BUS_RESET                       0x00000001
+
+/*
+  * Definitions of the bit fields in the EndpointBufferLength register.
+  */
+#define USB_EPBUFLEN_MASK                       0x0000ffff
+#define USB_EPBUFLEN_SHIFT                      0
+
+/*
+  * Definitions of the bit fields in the EndpointData register.
+  */
+#define USB_EPDATA_MASK                         0x0000ffff
+#define USB_EPDATA_SHIFT                        0
+
+/*
+  * Definitions of the bit fields in the EndpointShortPacket register.
+  */
+
+/* This register is reserved.*/
+
+/*
+  * Definitions of the bit fields in the EndpointControl register.
+  */
+#define USB_EPCONTROL_CLEAR                     0x00000010
+#define USB_EPCONTROL_VALIDATE                  0x00000008
+#define USB_EPCONTROL_STATUS_ACK                0x00000002
+#define USB_EPCONTROL_STALL                     0x00000001
+
+/*
+  * Definitions of the bit fields in the EndpointIndex register.
+  */
+#define USB_ENDPOINT_CONTROL_OUT                0x00000000
+#define USB_ENDPOINT_CONTROL_IN                 0x00000001
+#define USB_ENDPOINT_ONE_OUT                    0x00000002
+#define USB_ENDPOINT_ONE_IN                     0x00000003
+#define USB_ENDPOINT_TWO_OUT                    0x00000004
+#define USB_ENDPOINT_TWO_IN                     0x00000005
+#define USB_ENDPOINT_THREE_OUT                  0x00000006
+#define USB_ENDPOINT_THREE_IN                   0x00000007
+#define USB_ENDPOINT_FOUR_OUT                   0x00000008
+#define USB_ENDPOINT_FOUR_IN                    0x00000009
+#define USB_ENDPOINT_FIVE_OUT                   0x0000000a
+#define USB_ENDPOINT_FIVE_IN                    0x0000000b
+#define USB_ENDPOINT_SIX_OUT                    0x0000000c
+#define USB_ENDPOINT_SIX_IN                     0x0000000d
+#define USB_ENDPOINT_SEVEN_OUT                  0x0000000e
+#define USB_ENDPOINT_SEVEN_IN                   0x0000000f
+#define USB_ENDPOINT_SETUP                      0x00000020
+
+/*
+  * Definitions of the bit fields in the DMACommand register.
+  */
+#define USB_DMACOMMAND_MASK                     0x000000ff
+#define USB_DMACOMMAND_GDMA_READ                0x00000000
+#define USB_DMACOMMAND_GDMA_WRITE               0x00000001
+#define USB_DMACOMMAND_UDMA_READ                0x00000002
+#define USB_DMACOMMAND_UDMA_WRITE               0x00000003
+#define USB_DMACOMMAND_PIO_READ                 0x00000004
+#define USB_DMACOMMAND_PIO_WRITE                0x00000005
+#define USB_DMACOMMAND_MDMA_READ                0x00000006
+#define USB_DMACOMMAND_MDMA_WRITE               0x00000007
+#define USB_DMACOMMAND_READ_1F0                 0x0000000a
+#define USB_DMACOMMAND_POLL_BSY                 0x0000000b
+#define USB_DMACOMMAND_READ_TASK_FILE           0x0000000c
+#define USB_DMACOMMAND_VALIDATE_BUFFER          0x0000000e
+#define USB_DMACOMMAND_CLEAR_BUFFER             0x0000000f
+#define USB_DMACOMMAND_RESTART                  0x00000010
+#define USB_DMACOMMAND_RESET_DMA                0x00000011
+#define USB_DMACOMMAND_MDMA_STOP                0x00000012
+
+/*
+  * Definitions of the bit fields in the DMACount register.
+  */
+#define USB_DMACOUNT_MASK                       0xffffffff
+#define USB_DMACOUNT_SHIFT                      0
+
+/*
+  * Definitions of the bit fields in the DMAConfig register.
+  */
+#define USB_DMACONFIG_IGNORE_IORDY              0x00004000
+#define USB_DMACONFIG_ATA_MODE                  0x00002000
+#define USB_DMACONFIG_DMA_MODE_MASK             0x00001800
+#define USB_DMACONFIG_DMA_MODE_0                0x00000000
+#define USB_DMACONFIG_DMA_MODE_1                0x00000800
+#define USB_DMACONFIG_DMA_MODE_2                0x00001000
+#define USB_DMACONFIG_DMA_MODE_3                0x00001800
+#define USB_DMACONFIG_PIO_MODE_MASK             0x00000700
+#define USB_DMACONFIG_PIO_MODE_0                0x00000000
+#define USB_DMACONFIG_PIO_MODE_1                0x00000100
+#define USB_DMACONFIG_PIO_MODE_2                0x00000200
+#define USB_DMACONFIG_PIO_MODE_3                0x00000300
+#define USB_DMACONFIG_PIO_MODE_4                0x00000400
+#define USB_DMACONFIG_DIS_XFER_CNT              0x00000080
+#define USB_DMACONFIG_BURST_MASK                0x00000070
+#define USB_DMACONFIG_BURST_ALL                 0x00000000
+#define USB_DMACONFIG_BURST_1                   0x00000010
+#define USB_DMACONFIG_BURST_2                   0x00000020
+#define USB_DMACONFIG_BURST_4                   0x00000030
+#define USB_DMACONFIG_BURST_8                   0x00000040
+#define USB_DMACONFIG_BURST_12                  0x00000050
+#define USB_DMACONFIG_BURST_16                  0x00000060
+#define USB_DMACONFIG_BURST_32                  0x00000070
+#define USB_DMACONFIG_MODE_MASK                 0x0000000c
+#define USB_DMACONFIG_MODE_DIOR_DIOW            0x00000000
+#define USB_DMACONFIG_MODE_DIOR_DACK            0x00000004
+#define USB_DMACONFIG_MODE_DACK                 0x00000008
+#define USB_DMACONFIG_WIDTH_MASK                0x00000001
+#define USB_DMACONFIG_WIDTH_8                   0x00000000
+#define USB_DMACONFIG_WIDTH_16                  0x00000001
+
+/*
+  * Definitions of the bit fields in the DMAHardware register.
+  */
+#define USB_DMAHW_ENDIAN_MASK                   0x000000c0
+#define USB_DMAHW_ENDIAN_NORMAL                 0x00000000
+#define USB_DMAHW_ENDIAN_SWAP                   0x00000040
+#define USB_DMAHW_EOT_MASK                      0x00000020
+#define USB_DMAHW_EOT_ACTIVE_LOW                0x00000000
+#define USB_DMAHW_EOT_ACTIVE_HIGH               0x00000020
+#define USB_DMAHW_MASTER                        0x00000010
+#define USB_DMAHW_ACK_MASK                      0x00000008
+#define USB_DMAHW_ACK_ACTIVE_LOW                0x00000000
+#define USB_DMAHW_ACK_ACTIVE_HIGH               0x00000008
+#define USB_DMAHW_DREQ_MASK                     0x00000004
+#define USB_DMAHW_DREQ_ACTIVE_LOW               0x00000000
+#define USB_DMAHW_DREQ_ACTIVE_HIGH              0x00000004
+#define USB_DMAHW_WRITE_MASK                    0x00000002
+#define USB_DMAHW_WRITE_ACTIVE_LOW              0x00000000
+#define USB_DMAHW_WRITE_ACTIVE_HIGH             0x00000002
+#define USB_DMAHW_READ_MASK                     0x00000001
+#define USB_DMAHW_READ_ACTIVE_LOW               0x00000000
+#define USB_DMAHW_READ_ACTIVE_HIGH              0x00000001
+
+/*
+  * Definitions of the bit fields in the DMAIntReason and DMAIntEnable
+  * registers.
+  */
+#define USB_DMAINT_ODD                          0x00001000
+#define USB_DMAINT_EXT_EOT                      0x00000800
+#define USB_DMAINT_INT_EOT                      0x00000400
+#define USB_DMAINT_INTRQ_PENDING                0x00000200
+#define USB_DMAINT_XFER_OK                      0x00000100
+#define USB_DMAINT_1F0_WF_E                     0x00000080
+#define USB_DMAINT_1F0_WF_F                     0x00000040
+#define USB_DMAINT_1F0_RF_E                     0x00000020
+#define USB_DMAINT_1F0_RF_F                     0x00000010
+#define USB_DMAINT_BSY_DONE                     0x00000008
+#define USB_DMAINT_TF_RD_DONE                   0x00000004
+#define USB_DMAINT_CMD_INTRQ_OK                 0x00000002
+
+/*
+  * Definitions of the bit fields in the DMAEndpoint register.
+  */
+#define USB_DMAEP_CONTROL_OUT                   0x00000000
+#define USB_DMAEP_CONTROL_IN                    0x00000001
+#define USB_DMAEP_ONE_OUT                       0x00000002
+#define USB_DMAEP_ONE_IN                        0x00000003
+#define USB_DMAEP_TWO_OUT                       0x00000004
+#define USB_DMAEP_TWO_IN                        0x00000005
+#define USB_DMAEP_THREE_OUT                     0x00000006
+#define USB_DMAEP_THREE_IN                      0x00000007
+#define USB_DMAEP_FOUR_OUT                      0x00000008
+#define USB_DMAEP_FOUR_IN                       0x00000009
+#define USB_DMAEP_FIVE_OUT                      0x0000000a
+#define USB_DMAEP_FIVE_IN                       0x0000000b
+#define USB_DMAEP_SIX_OUT                       0x0000000c
+#define USB_DMAEP_SIX_IN                        0x0000000d
+#define USB_DMAEP_SEVEN_OUT                     0x0000000e
+#define USB_DMAEP_SEVEN_IN                      0x0000000f
+
+/*
+  * Definitions of the bit fields in the DMAStrobeTiming register.
+  */
+#define USB_DMASTROBE_COUNT_MASK                0x0000001f
+
+/*
+  * Definitions of the bit fields in the ChipID register.
+  */
+#define USB_CHIPID_ID_MASK                      0x00ffff00
+#define USB_CHIPID_ID                           0x00158100
+#define USB_CHIPID_VERSION_MASK                 0x000000ff
+#define UBS_CHIPID_VERSION                      0x00000051
+
+/*
+  * Definitions of the bit fields in the FrameNumber register.
+  */
+#define USB_FRAMENUM_MICRONUM_MASK              0x00003800
+#define USB_FRAMENUM_MICRONUM_SHIFT             11
+#define USB_FRAMENUM_NUM_MASK                   0x000007ff
+#define USB_FRAMENUM_NUM_SHIFT                  0
+
+/*
+  * Definitions of the bit fields in the Test register.
+  */
+#define USB_TEST_FORCEHS                        0x00000080
+#define USB_TEST_FORCEFS                        0x00000010
+#define USB_TEST_PRBS                           0x00000008
+#define USB_TEST_KSTATE                         0x00000004
+#define USB_TEST_JSTATE                         0x00000002
+#define USB_TEST_SE0_NAK                        0x00000001
+
+/*---------------------------------------------------------------------------------*/
+
+
+/*
+  * USB2_slave_dma_hw.H - Defines for the USB specification and the Philips ISP1581 USB
+  *         controller.
+  *
+  * Copyright (c) 2004 Cirrus Logic, Inc.
+  *
+  */
+
+/****************************************************************************/
+
+
+/*
+  *mmu map the adress 
+  *0x8000_0000-------0xFF00_0000
+  *(cirrus_linux1.4.1)
+  *we need to get the DMA register startaddress
+  */
+
+/*
+  *DMA Channel Base Address
+  */
+#define HwDMA_M2P_0                              0x00000000
+#define HwDMA_M2P_1                              0x00000040
+#define HwDMA_M2P_2                              0x00000080
+#define HwDMA_M2P_3                              0x000000c0
+#define HwDMA_M2M_0                              0x00000100
+#define HwDMA_M2M_1                              0x00000140
+#define HwDMA_M2P_5                              0x00000200
+#define HwDMA_M2P_4                              0x00000240
+#define HwDMA_M2P_7                              0x00000280
+#define HwDMA_M2P_6                              0x000002c0
+#define HwDMA_M2P_9                              0x00000300
+#define HwDMA_M2P_8                              0x00000340
+#define HwDMAChannelArb                        0x00000380
+#define HwDMAGlobalInt                            0x000003c0
+
+/*
+  *DMA Channal REG
+  */
+#define HwDMA_M2M_Control                       0x00000000
+#define HwDMA_M2M_Interrupt                     0x00000004
+#define HwDMA_M2M_Status                        0x0000000c
+#define HwDMA_M2M_BCR0                          0x00000010
+#define HwDMA_M2M_BCR1                          0x00000014
+#define HwDMA_M2M_SAR_Base0                     0x00000018
+#define HwDMA_M2M_SAR_Base1                     0x0000001c
+#define HwDMA_M2M_SAR_Current0                  0x00000024
+#define HwDMA_M2M_SAR_Current1                  0x00000028
+#define HwDMA_M2M_DAR_Base0                     0x0000002c
+#define HwDMA_M2M_DAR_Base1                     0x00000030
+#define HwDMA_M2M_DAR_Current0                  0x00000034
+#define HwDMA_M2M_DAR_Current1                  0x0000003c
+
+/*
+  *DMA REG Value
+  */
+#define DMA_M2M_CONTROL_STALL_INT_EN            0x00000001
+#define DMA_M2M_CONTROL_SCT                     0x00000002
+#define DMA_M2M_CONTROL_DONE_INT_EN             0x00000004
+#define DMA_M2M_CONTROL_ENABLE                  0x00000008
+#define DMA_M2M_CONTROL_START                   0x00000010
+#define DMA_M2M_CONTROL_BWC_MASK                0x000001e0
+#define DMA_M2M_CONTROL_BWC_FULL                0x00000000
+#define DMA_M2M_CONTROL_BWC_16                  0x00000020
+#define DMA_M2M_CONTROL_BWC_32                  0x000000a0
+#define DMA_M2M_CONTROL_BWC_64                  0x000000c0
+#define DMA_M2M_CONTROL_BWC_128                 0x000000e0
+#define DMA_M2M_CONTROL_BWC_256                 0x00000100
+#define DMA_M2M_CONTROL_BWC_512                 0x00000120
+#define DMA_M2M_CONTROL_BWC_1024                0x00000140
+#define DMA_M2M_CONTROL_BWC_2048                0x00000160
+#define DMA_M2M_CONTROL_BWC_4096                0x00000180
+#define DMA_M2M_CONTROL_BWC_8192                0x000001a0
+#define DMA_M2M_CONTROL_BWC_16384               0x000001c0
+#define DMA_M2M_CONTROL_BWC_32768               0x000001e0
+#define DMA_M2M_CONTROL_PW_MASK                 0x00000600
+#define DMA_M2M_CONTROL_PW_BYTE                 0x00000000
+#define DMA_M2M_CONTROL_PW_HALFWORD             0x00000200
+#define DMA_M2M_CONTROL_PW_WORD                 0x00000400
+#define DMA_M2M_CONTROL_DAH                     0x00000800
+#define DMA_M2M_CONTROL_SAH                     0x00001000
+#define DMA_M2M_CONTROL_TM_MASK                 0x00006000
+#define DMA_M2M_CONTROL_TM_SOFTWARE             0x00000000
+#define DMA_M2M_CONTROL_TM_HARDWARE_M2P         0x00002000
+#define DMA_M2M_CONTROL_TM_HARDWARE_P2M         0x00004000
+#define DMA_M2M_CONTROL_ETDP_MASK               0x00018000
+#define DMA_M2M_CONTROL_ETDP_ACTIVE_LOW_EOT     0x00000000
+#define DMA_M2M_CONTROL_ETDP_ACTIVE_HIGH_EOT    0x00008000
+#define DMA_M2M_CONTROL_ETDP_ACTIVE_LOW_TC      0x00010000
+#define DMA_M2M_CONTROL_ETDP_ACTIVE_HIGH_TC     0x00018000
+#define DMA_M2M_CONTROL_DACK_ACTIVE_HIGH        0x00020000
+#define DMA_M2M_CONTROL_DREQP_MASK              0x00180000
+#define DMA_M2M_CONTROL_DREQP_LEVEL_LOW         0x00000000
+#define DMA_M2M_CONTROL_DREQP_LEVEL_HIGH        0x00080000
+#define DMA_M2M_CONTROL_DREQP_EDGE_LOW          0x00100000
+#define DMA_M2M_CONTROL_DREQP_EDGE_HIGH         0x00180000
+#define DMA_M2M_CONTROL_NFBINT_EN               0x00200000
+#define DMA_M2M_CONTROL_RSS_MASK                0x00c00000
+#define DMA_M2M_CONTROL_RSS_EXTERNAL_DREQ       0x00000000
+#define DMA_M2M_CONTROL_RSS_SSPRX               0x00400000
+#define DMA_M2M_CONTROL_RSS_SSPTX               0x00800000
+#define DMA_M2M_CONTROL_RSS_IDE                 0x00c00000
+#define DMA_M2M_CONTROL_NO_HDSK                 0x01000000
+#define DMA_M2M_CONTROL_PWSC_MASK               0xfe000000
+#define DMA_M2M_CONTROL_PWSC_SHIFT              25
+
+#define DMA_M2M_INTERRUPT_STALL                 0x00000001
+#define DMA_M2M_INTERRUPT_DONE                  0x00000002
+#define DMA_M2M_INTERRUPT_NFB                   0x00000004
+
+#define DMA_M2M_STATUS_STALL                    0x00000001
+#define DMA_M2M_STATUS_CONTROL_STATE_MASK       0x0000000e
+#define DMA_M2M_STATUS_CONTROL_IDLE             0x00000000
+#define DMA_M2M_STATUS_CONTROL_STALL            0x00000002
+#define DMA_M2M_STATUS_CONTROL_MEM_RD           0x00000004
+#define DMA_M2M_STATUS_CONTROL_MEM_WR           0x00000006
+#define DMA_M2M_STATUS_CONTROL_BWC_WAIT         0x00000008
+#define DMA_M2M_STATUS_BUFFER_STATE_MASK        0x00000030
+#define DMA_M2M_STATUS_BUFFER_NO                0x00000000
+#define DMA_M2M_STATUS_BUFFER_ON                0x00000010
+#define DMA_M2M_STATUS_BUFFER_NEXT              0x00000020
+#define DMA_M2M_STATUS_DONE                     0x00000040
+#define DMA_M2M_STATUS_TCS_MASK                 0x00000180
+#define DMA_M2M_STATUS_TCS_NEITHER              0x00000000
+#define DMA_M2M_STATUS_TCS_BUF0                 0x00000080
+#define DMA_M2M_STATUS_TCS_BUF1                 0x00000100
+#define DMA_M2M_STATUS_TCS_BOTH                 0x00000180
+#define DMA_M2M_STATUS_EOTS_MASK                0x00000600
+#define DMA_M2M_STATUS_EOTS_NEITHER             0x00000000
+#define DMA_M2M_STATUS_EOTS_BUF0                0x00000200
+#define DMA_M2M_STATUS_EOTS_BUF1                0x00000400
+#define DMA_M2M_STATUS_EOTS_BOTH                0x00000600
+#define DMA_M2M_STATUS_NFB                      0x00000800
+#define DMA_M2M_STATUS_NB                       0x00001000
+#define DMA_M2M_STATUS_DREQS                    0x00002000
+
+#define DMA_M2M_BRC_MASK                        0x0000ffff
+#define DMA_M2M_BRC_SHIFT                       0
+
+#define DMA_M2M_SAR_MASK                        0xffffffff
+#define DMA_M2M_SAR_SHIFT                       0
+
+#define DMA_M2M_DAR_MASK                        0xffffffff
+#define DMA_M2M_DAR_SHIFT                       0
+
+#define DMA_M2M_SAR_CURRENT_MASK                0xffffffff
+#define DMA_M2M_SAR_CURRENT_SHIFT               0
+
+#define DMA_M2M_DAR_CURRENT_MASK                0xffffffff
+#define DMA_M2M_DAR_CURRENT_SHIFT               0
+
+#define DMA_INT_M2P_1                           0x00000001
+#define DMA_INT_M2P_0                           0x00000002
+#define DMA_INT_M2P_3                           0x00000004
+#define DMA_INT_M2P_2                           0x00000008
+#define DMA_INT_M2P_5                           0x00000010
+#define DMA_INT_M2P_4                           0x00000020
+#define DMA_INT_M2P_7                           0x00000040
+#define DMA_INT_M2P_6                           0x00000080
+#define DMA_INT_M2P_9                           0x00000100
+#define DMA_INT_M2P_8                           0x00000200
+#define DMA_INT_M2M_0                           0x00000400
+#define DMA_INT_M2M_1                           0x00000800
+
+#define DMA_ARB_CHARB                           0x00000001
+
+
+/*---------------------------------------------------------------------------------*/
+
+/*
+  *
+  * USB2_slave.H - Defines for the USB specification and the Philips ISP1581 USB
+  *         controller.
+  *
+  * Copyright (c) 2004 Cirrus Logic, Inc.
+  */
+
+/****************************************************************************/
+
+/****************************************************************************/
+
+/*
+  * The following defines are specific the USB standard version 2.0.
+  */
+
+/****************************************************************************/
+
+/*
+  * Definitions of the bit fields in the bmRequestType field of a setup packet.
+  */
+#define USB_RT_DEVICE_TO_HOST                   0x80
+#define USB_RT_TYPE_MASK                        0x60
+#define USB_RT_TYPE_STANDARD                    0x00
+#define USB_RT_TYPE_CLASS                       0x20
+#define USB_RT_TYPE_VENDOR                      0x40
+#define USB_RT_RECIPIENT_MASK                   0x1F
+#define USB_RT_RECIPIENT_DEVICE                 0x00
+#define USB_RT_RECIPIENT_INTERFACE              0x01
+#define USB_RT_RECIPIENT_ENDPOINT               0x02
+
+/*
+  * Definitions of the bit fields in the wIndex field of setup packets where the
+  * wIndex field is used to specify a endpoint (i.e. Clear_Feature, Get_Status,
+  * and Set_Feature).
+  */
+#define USB_ENDPOINT_DIRECTION_MASK             0x0080
+#define USB_ENDPOINT_ADDRESS_MASK               0x000F
+
+/*
+  * Definitions of the features that can be specified in the wValue field of a
+  * Clear_Feature or Set_Feature setup packet.
+  */
+#define USB_FEATURE_ENDPOINT_STALL              0x0000
+#define USB_FEATURE_REMOTE_WAKEUP               0x0001
+#define USB_FEATURE_POWER_D0                    0x0002
+#define USB_FEATURE_POWER_D1                    0x0003
+#define USB_FEATURE_POWER_D2                    0x0004
+#define USB_FEATURE_POWER_D3                    0x0005
+
+/*
+  * Definitions of the wValue field for a Get_Descriptor setup packet.
+  */
+#define USB_DESCRIPTOR_TYPE_MASK                   0xFF00
+#define USB_DESCRIPTOR_DEVICE                       0x0100
+#define USB_DESCRIPTOR_CONFIGURATION               0x0200
+#define USB_DESCRIPTOR_STRING                       0x0300
+#define USB_DESCRIPTOR_INTERFACE                    0x0400
+#define USB_DESCRIPTOR_ENDPOINT                     0x0500
+
+#define USB_DESCRIPTOR_DEVICE_QUALIFIER        0x0600
+#define USB_DESCRIPTOR_OTHER_SPEED_CONFIGURATION 0x0700
+#define USB_DESCRIPTIO_Interface_Power_Descriptor  0x0800
+
+#define USB_Manufacturer_String_Descriptor          0x0103
+#define USB_Product_String_Descriptor               0x0203
+#define USB_Config_String_Descriptor      0x0102
+
+#define USB_DESCRIPTOR_INDEX_MASK                  0x00FF
+
+/*
+  * Definitions of the device status returned for a Get_Status setup packet.
+  */
+#define USB_DEVICE_STATUS_SELF_POWERED            0x01
+#define USB_DEVICE_STATUS_REMOTE_WAKEUP         0x02
+
+/*
+  * Definitions of the endpoint status returned for a Get_Status setup packet.
+  */
+#define USB_ENDPOINT_STATUS_STALLED             0x01
+
+
+/*
+  * Definitions of the USB device Test mode
+  */
+#define  TEST_J                                   1
+#define  TEST_K                                   2
+#define  TEST_SE0_NAK                            3
+#define  TEST_PACKET                             4
+#define  TEST_FORCE_ENABLE                      5
+
+/*
+  * Definitions of the status of The USB Device
+  */
+#define FSM_DEV_POWERED  0
+#define FSM_DEV_DEFAULT  1
+#define FSM_DEV_ADDRESS  2
+#define FSM_DEV_CONFIGURED 3
+
+
+
+/*********************************************************************************/
+
+/*
+  *The USB Control process
+  */
+
+/*********************************************************************************/
+
+/*
+  *Setup control process status
+  */
+#define SETUPCOMMAND_DataPhase_OUTPID      1    /*1:setup control out  Set  command  DataPhase    OUT PID*/
+#define SETUPCOMMAND_DataPhase_INPID         2  /*2:setup control In   Get  command  DataPhase    IN PID*/
+#define SETUPCOMMAND_StatusPhase_INPID      3   /*3:setup control out  Set  command  StatusPhase  IN PID*/
+#define SETUPCOMMAND_StatusPhase_OUTPID   4     /*4:setup control In   Get  command  StatusPhase  OUT PID*/
+#define SETUPCOMMAND_STATUS_DEFAULT        0
+
+/*
+  *USB Speed
+  */
+#define HighSpeed  2
+#define FullSpeed   1
+#define LowSpeed   0
+
+/*
+  *default languale is 0409--- english
+  */
+#define DEF_LANG 0x0409
+
+
+/****************************************************************************/
+
+/*
+  * This is the device descriptor for the  USB Mass Storage Device  See the USB
+  * specification for the definition of this descriptor.
+  */
+
+/****************************************************************************/
+static const unsigned char ucDeviceDescriptor[] =
+    {
+        0x12,                               /* bLength*/
+        0x01,                               /*bDescriptorType*/
+        0x00, 0x02,                         /*bcdUSB*/
+        0x00,                               /*bDeviceClass*/
+        0x00,                               /*bDeviceSubClass*/
+        0x00,                               /*bDeviceProtocol*/
+        0x40,                               /*bMaxPacketSize0*/
+        0x29, 0x04,                         /*idVendor*/
+        0x02, 0x07,                         /*idProduct*/
+        0x02, 0x00,                         /* bcdDevice*/
+        0x01,                               /*iManufacturer*/
+        0x02,                               /*iProduct*/
+        0x00,                               /*iSerial Number*/
+        0x01                                /*bNumConfigurations*/
+    };
+
+
+/****************************************************************************/
+
+/*
+  * This is the configuration descriptor for the  USB Mass Storage Device Full Speed. 
+  * See the USB specification for the definition of this descriptor.
+  */
+
+/****************************************************************************/
+static const unsigned char ucConfigurationDescriptor[] =
+    {
+        /*
+          * The configuration descriptor structure.
+          */
+        0x09,                               /* bLength*/
+        0x02,                               /* bDescriptorType*/
+        0x20, 0x00,                         /* wTotalLength*/
+        0x01,                               /* bNumInterfaces*/
+        0x01,                               /* bConfigurationValue*/
+        0x03,                               /* iConfiguration*/
+        0x80,                               /* bmAttributes*/
+        0x01,                               /* MaxPower*/
+
+        /*
+          * The interface descriptor structure.
+          */
+        0x09,                               /* bLength*/
+        0x04,                               /* bDescriptorType*/
+        0x00,                               /*bInterfaceNumber*/
+        0x00,                               /* bAlternateSetting*/
+        0x02,                               /* bNumEndpoints*/
+        0x08,                               /* bInterfaceClass       MASS STORAGE*/
+        0x06,                               /* bInterfaceSubClass   SCSI*/
+        0x50,                               /* bInterfaceProtocol     BULK-ONLY*/
+        0x00,                               /* iInterface*/
+
+        /*
+          * The endpoint descriptor structure.
+          */
+        0x07,                               /* bLength*/
+        0x05,                               /* bDescriptorType*/
+        0x82,                               /* bEndpointAddress  IN---EP2IN*/
+        0x02,                               /* bmAttributes*/
+        0x40, 0x00,                         /* wMaxPacketSize*/
+        0x00,                               /* bInterval*/
+
+        /*
+          * The endpoint descriptor structure.
+          */
+        0x07,                               /* bLength */
+        0x05,                               /* bDescriptorType*/
+        0x01,                               /* bEndpointAddress  OUT--EP1OUT*/
+        0x02,                               /* bmAttributes*/
+        0x40, 0x00,                         /* wMaxPacketSize*/
+        0x00                                /* bInterval*/
+    };
+
+/****************************************************************************/
+
+/*
+  * This is the configuration descriptor for the  USB Mass Storage Device High Speed. 
+  * See the USB specification for the definition of this descriptor.
+  */
+
+/****************************************************************************/
+static const unsigned char ucConfigurationHighDescriptor[] =
+    {
+        /*
+          * The configuration descriptor structure.
+          */
+        0x09,                               /* bLength*/
+        0x02,                               /* bDescriptorType*/
+        0x20, 0x00,                         /* wTotalLength*/
+        0x01,                               /* bNumInterfaces*/
+        0x01,                               /* bConfigurationValue*/
+        0x03,                               /* iConfiguration*/
+        0x80,                               /* bmAttributes*/
+        0x01,                               /* MaxPower*/
+
+        /*
+          * The interface descriptor structure.
+          */
+        0x09,                               /* bLength*/
+        0x04,                               /* bDescriptorType*/
+        0x00,                               /* bInterfaceNumber*/
+        0x00,                               /* bAlternateSetting*/
+        0x02,                               /* bNumEndpoints*/
+        0x08,                               /* bInterfaceClass       MASS STORAGE*/
+        0x06,                               /* bInterfaceSubClass   SCSI*/
+        0x50,                               /* bInterfaceProtocol     BULK-ONLY*/
+        0x00,                               /* iInterface*/
+
+        /*
+          * The endpoint descriptor structure.
+          */
+        0x07,                               /* bLength*/
+        0x05,                               /* bDescriptorType*/
+        0x82,                               /* bEndpointAddress  IN---EP2IN*/
+        0x02,                               /* bmAttributes*/
+        0x00,0x02,                          /* wMaxPacketSize*/
+        0x00,                               /* bInterval*/
+
+        /*
+          * The endpoint descriptor structure.
+          */
+        0x07,                               /* bLength*/
+        0x05,                               /* bDescriptorType*/
+        0x01,                               /* bEndpointAddress  OUT--EP1OUT*/
+        0x02,                               /* bmAttributes*/
+        0x00,0x02,                          /* wMaxPacketSize*/
+        0x00                                /* bInterval*/
+    };
+
+/****************************************************************************/
+
+/*
+  * String descriptor 0 for the  USB Mass Storage Device.  This defines the
+  * languages supported by the string descriptors.  See the USB specification
+  * for the definition of this descriptor.
+  */
+
+/****************************************************************************/
+static const unsigned char ucString0[] =
+    {
+        0x04,                               /* bLength*/
+        0x03,                               /* bDescriptorType*/
+        0x09, 0x04                          /* wLANGID[0] -> US English*/
+    };
+
+/****************************************************************************/
+
+/*
+  * String descriptor 1 for the  USB Mass Storage Device.  This defines the
+  * manufacturer of the player.  See the USB specification for the definition
+  * of this descriptor.
+  */
+
+/****************************************************************************/
+static const unsigned char ucString1[] =
+    {
+        0x26,                               /* bLength*/
+        0x03,                               /* bDescriptorType*/
+        'C', 0x00,                          /* wString[]*/
+        'i', 0x00,
+        'r', 0x00,
+        'r', 0x00,
+        'u', 0x00,
+        's', 0x00,
+        ' ', 0x00,
+        'L', 0x00,
+        'o', 0x00,
+        'g', 0x00,
+        'i', 0x00,
+        'c', 0x00,
+        ',', 0x00,
+        ' ', 0x00,
+        'I', 0x00,
+        'n', 0x00,
+        'c', 0x00,
+        '.', 0x00
+    };
+
+/****************************************************************************/
+ 
+/*
+  * String descriptor 2 for the USB Mass Storage Device.  This defines the
+  * product description of the player.  See the USB specification for the
+  * definition of this descriptor.
+  */
+
+/****************************************************************************/
+static const unsigned char ucString2[] =
+    {
+        0x46,                               /* bLength*/
+        0x03,                               /* bDescriptorType*/
+        'C', 0x00,                          /* wString[]*/
+        'i', 0x00,
+        'r', 0x00,
+        'r', 0x00,
+        'u', 0x00,
+        's', 0x00,
+        ' ', 0x00,
+        'L', 0x00,
+        'o', 0x00,
+        'g', 0x00,
+        'i', 0x00,
+        'c', 0x00,
+        ' ', 0x00,
+        'U', 0x00,
+        'S', 0x00,
+        'B', 0x00,
+        'T', 0x00,
+        'o', 0x00,
+        'A', 0x00,
+        'T', 0x00,
+        'A', 0x00,
+        ' ', 0x00,
+        'H', 0x00,
+        'a', 0x00,
+        'r', 0x00,
+        'd', 0x00,
+        ' ', 0x00,
+        ' ', 0x00,
+        'D', 0x00,
+        'i', 0x00,
+        's', 0x00,
+        'k', 0x00,
+        ' ', 0x00,
+        ' ', 0x00
+    };
+
+/****************************************************************************/
+
+/*
+  * String descriptor 3 for the USB Mass Storage Device.  This defines the
+  * configuration description of the player.  See the USB specification for the
+  * definition of this descriptor.
+  */
+
+/****************************************************************************/
+static const unsigned char ucString3[] =
+    {
+        0x2c,                               /* bLength*/
+        0x03,                               /* bDescriptorType*/
+        'D', 0x00,                          /* wString[]*/
+        'e', 0x00,
+        'f', 0x00,
+        'a', 0x00,
+        'u', 0x00,
+        'l', 0x00,
+        't', 0x00,
+        ' ', 0x00,
+        'C', 0x00,
+        'o', 0x00,
+        'n', 0x00,
+        'f', 0x00,
+        'i', 0x00,
+        'g', 0x00,
+        'u', 0x00,
+        'r', 0x00,
+        'a', 0x00,
+        't', 0x00,
+        'i', 0x00,
+        'o', 0x00,
+        'n', 0x00
+    };
+
+/*-----------------------------------------------------------------------------------*/
+//****************************************************************************
+//
+// USB2_slave_dma.H - Defines for the USB specification and the Philips ISP1581 USB
+//         controller.
+//
+// Copyright (c) 2004 Cirrus Logic, Inc.
+//
+//****************************************************************************
+
+
+//
+//Ep931X DMA Channel base address
+//M2M0
+//M2M1
+//
+
+//#define USE_CHANNEL_ZERO
+#define HwDMAM2M0BaseAddress				(ep93IOBASE+HwDMA_M2M_0)
+#define HwDMAM2M1BaseAddress				(ep93IOBASE+HwDMA_M2M_1)
+
+//
+//Definitions of using DMA to read or write
+//
+
+#define USE_DMA_READ
+#define USE_DMA_WRITE
+
+//
+//Definitions of the DMA host and slave pin
+//
+#define ACTIVE_HIGH
+
+#ifdef ACTIVE_HIGH
+#define DMA_PIN_CONFIG DMA_M2M_CONTROL_ETDP_ACTIVE_HIGH_TC | \
+                       DMA_M2M_CONTROL_DACK_ACTIVE_HIGH | \
+                       DMA_M2M_CONTROL_DREQP_LEVEL_HIGH
+#define USB_PIN_CONFIG USB_DMAHW_EOT_ACTIVE_HIGH | \
+                       USB_DMAHW_ACK_ACTIVE_HIGH | \
+                       USB_DMAHW_DREQ_ACTIVE_HIGH
+#else
+#define DMA_PIN_CONFIG DMA_M2M_CONTROL_ETDP_ACTIVE_LOW_TC | \
+                       DMA_M2M_CONTROL_DREQP_LEVEL_LOW
+#define USB_PIN_CONFIG USB_DMAHW_EOT_ACTIVE_LOW | \
+                       USB_DMAHW_ACK_ACTIVE_LOW | \
+                       USB_DMAHW_DREQ_ACTIVE_LOW
+#endif
+
+
+/*---------------------------------------------------------------------------------------*/
+
+
+
+
+
+/*---------------------------------------------------------------------------------*/
+
+#endif /* __LINUX_USB_GADGET_EP931X_H */
diff -burN linux-2.6.8.1-orig/drivers/usb/gadget/file_storage.c linux-2.6.8.1/drivers/usb/gadget/file_storage.c
--- linux-2.6.8.1-orig/drivers/usb/gadget/file_storage.c	2004-08-14 19:56:22.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/gadget/file_storage.c	2007-01-24 13:03:31.000000000 +0900
@@ -3225,6 +3225,11 @@
 			bh = &fsg->buffhds[i];
 			num_active += bh->inreq_busy + bh->outreq_busy;
 		}
+		
+		#ifdef CONFIG_ARCH_EP9315A
+        num_active=0;
+        #endif
+            
 		if (num_active == 0)
 			break;
 		if (sleep_thread(fsg))
@@ -3708,6 +3713,10 @@
 			mod_data.release = __constant_cpu_to_le16(0x0307);
 		else if (gadget_is_omap(fsg->gadget))
 			mod_data.release = __constant_cpu_to_le16(0x0308);
+
+		else if (gadget_is_ep93xx(fsg->gadget))
+			mod_data.release = __constant_cpu_to_le16(0x0309);
+
 		else {
 			WARN(fsg, "controller '%s' not recognized\n",
 				fsg->gadget->name);
diff -burN linux-2.6.8.1-orig/drivers/usb/gadget/gadget_chips.h linux-2.6.8.1/drivers/usb/gadget/gadget_chips.h
--- linux-2.6.8.1-orig/drivers/usb/gadget/gadget_chips.h	2004-08-14 19:54:46.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/gadget/gadget_chips.h	2007-01-24 13:03:31.000000000 +0900
@@ -38,6 +38,12 @@
 #define	gadget_is_sh(g)		0
 #endif
 
+#ifdef CONFIG_USB_GADGET_EP931X
+#define	gadget_is_ep93xx(g)	!strcmp("ep93xx_udc", (g)->name)
+#else
+#define	gadget_is_ep93xx(g)	0
+#endif
+
 #ifdef CONFIG_USB_GADGET_SA1100
 #define	gadget_is_sa1100(g)	!strcmp("sa1100_udc", (g)->name)
 #else
diff -burN linux-2.6.8.1-orig/drivers/usb/host/ohci-ep93xx.c linux-2.6.8.1/drivers/usb/host/ohci-ep93xx.c
--- linux-2.6.8.1-orig/drivers/usb/host/ohci-ep93xx.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/host/ohci-ep93xx.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,414 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * Bus Glue for EP93XX USB Controller
+ *
+ * Based on ohci-lh7a404 driver and previous EP93XX driver.
+ *
+ *
+ * This file is licensed under the GPL.
+ */
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/arch/hardware.h>
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+static void ep93xx_start_hc(struct platform_device *pdev)
+{
+#if defined(CONFIG_ARCH_EDB9315)
+	unsigned int uiPBDR, uiPBDDR;
+#endif
+
+	pr_debug("Starting EP93XX OHCI USB Controller\n");
+     
+	/*
+	 * Configure the power sense and control lines.  Place the USB
+	 * host controller in reset.
+	 */
+#if defined(CONFIG_ARCH_EDB9315)
+	/*
+	 * For EDB9315 boards, turn on USB by clearing EGPIO9 (Port B, Bit 1).
+	 */
+	uiPBDR = inl(GPIO_PBDR) & 0xfd;
+	outl(uiPBDR, GPIO_PBDR );
+
+	uiPBDDR = inl(GPIO_PBDDR) | 0x02;
+	outl(uiPBDDR, GPIO_PBDDR );
+#endif
+
+	/*
+	 * Now, carefully enable the USB clock, and take
+	 * the USB host controller out of reset.
+	 */
+	writel(readl((void *)SYSCON_PWRCNT) | SYSCON_PWRCNT_USHEN,(void *)SYSCON_PWRCNT);
+}
+
+static void ep93xx_stop_hc(struct platform_device *pdev)
+{
+#if defined(CONFIG_ARCH_EDB9315)
+	unsigned int uiPBDR;
+#endif
+
+	pr_debug("Stopping EP93XX OHCI USB Controller\n");
+
+	/* Shut down the USB block */
+	writel(readl((void *)SYSCON_PWRCNT) & (~SYSCON_PWRCNT_USHEN),(void *)SYSCON_PWRCNT);
+
+#if defined(CONFIG_ARCH_EDB9315)
+	/*
+	 * For EDB9315 boards, turn off USB by setting EGPIO9 (Port B, Bit 1).
+	 */
+	uiPBDR = inl(GPIO_PBDR) | 0x02;
+	outl(uiPBDR, GPIO_PBDR );
+#endif 
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+
+static irqreturn_t usb_hcd_ep93xx_hcim_irq (int irq, void *__hcd,
+					     struct pt_regs * r)
+{
+	struct usb_hcd *hcd = __hcd;
+
+	return usb_hcd_irq(irq, hcd, r);
+}
+
+/*-------------------------------------------------------------------------*/
+
+void usb_hcd_ep93xx_remove (struct usb_hcd *, struct platform_device *);
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_hcd_ep93xx_probe - initialize EP93XX HCD
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_hcd_ep93xx_probe (const struct hc_driver *driver,
+			  struct usb_hcd **hcd_out,
+			  struct platform_device *pdev)
+{
+	int retval;
+	struct usb_hcd *hcd = 0;
+	struct resource *res;
+	unsigned int *addr = NULL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!res)
+		return -ENODEV;        
+
+	if (!request_mem_region(res->start,
+				res->end
+				- res->start + 1, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		return -EBUSY;
+	}
+	
+	
+	ep93xx_start_hc(pdev);
+	
+	addr = (unsigned int*) HwRegToVirt(res->start);
+
+	if (!addr) {
+		pr_debug("bad USB address or remap");
+		retval = -ENOMEM;
+		goto err1;
+	}
+	
+	hcd = driver->hcd_alloc();
+	if (hcd == NULL){
+		pr_debug ("hcd_alloc failed");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	hcd->driver = (struct hc_driver *) driver;
+	hcd->description = driver->description;
+	hcd->irq = platform_get_irq(pdev, 0);
+	hcd->regs = addr;
+	hcd->self.controller = &pdev->dev;
+
+	retval = hcd_buffer_create (hcd);
+	if (retval != 0) {
+		pr_debug("pool alloc fail");
+		goto err1;
+	}
+
+	retval = request_irq(hcd->irq, usb_hcd_ep93xx_hcim_irq, SA_INTERRUPT,
+			     hcd->description, hcd);
+	if (retval != 0) {
+		pr_debug("request_irq failed");
+		retval = -EBUSY;
+		goto err2;
+	}
+
+	pr_debug ("%s (EP93XX) at 0x%p, irq %d",
+	          hcd->description, hcd->regs, hcd->irq);
+
+	usb_bus_init(&hcd->self);
+
+	hcd->self.op = &usb_hcd_operations;
+	hcd->self.hcpriv = (void *) hcd;
+	hcd->self.bus_name = "ep93xx_usb";
+	hcd->product_desc = "EP93XX OHCI";
+
+	INIT_LIST_HEAD(&hcd->dev_list);
+
+	usb_register_bus(&hcd->self);
+
+	if ((retval = driver->start(hcd)) < 0)
+	{
+		usb_hcd_ep93xx_remove(hcd, pdev);
+		return retval;
+	}
+
+	*hcd_out = hcd;
+	return 0;
+
+ err2:
+	hcd_buffer_destroy(hcd);
+	if (hcd)
+		driver->hcd_free(hcd);
+ err1:
+	ep93xx_stop_hc(pdev);
+	release_mem_region(res->start,
+		       res->end
+		       - res->start + 1);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_ep93xx_remove - shutdown processing for EP93XX HCD
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_ep93xx_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_hcd_ep93xx_remove (struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	void *base;
+	struct resource* res;
+
+	pr_debug ("remove: %s, state %x", hcd->self.bus_name, hcd->state);
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (in_interrupt())
+		BUG();
+
+	hcd->state = USB_STATE_QUIESCING;
+
+	pr_debug ("%s: roothub graceful disconnect", hcd->self.bus_name);
+	usb_disconnect(&hcd->self.root_hub);
+
+	hcd->driver->stop(hcd);
+	hcd->state = USB_STATE_HALT;
+
+	free_irq(hcd->irq, hcd);
+	hcd_buffer_destroy(hcd);
+
+	usb_deregister_bus(&hcd->self);
+
+	base = hcd->regs;
+	hcd->driver->hcd_free(hcd);
+
+	ep93xx_stop_hc(pdev);
+	
+	release_mem_region(res->start,
+			   res->end
+			   - res->start + 1);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+ohci_ep93xx_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
+
+	ohci_dbg(ohci, "ohci_ep93xx_start, ohci:%p", ohci);
+			
+	ohci->hcca = dma_alloc_coherent(hcd->self.controller,
+					sizeof *ohci->hcca, &ohci->hcca_dma, 0);
+
+	/*ohci->hcca = dma_alloc_coherent (NULL,
+	  sizeof *ohci->hcca, &ohci->hcca_dma, 0);*/
+
+	if (!ohci->hcca)
+		return -ENOMEM;
+
+	ohci_dbg(ohci, "ohci_ep93xx_start, ohci->hcca:%p",
+			ohci->hcca);
+
+	memset(ohci->hcca, 0, sizeof(struct ohci_hcca));
+
+	if ((ret = ohci_mem_init(ohci)) < 0) {
+		ohci_stop(hcd);
+		return ret;
+	}
+	ohci->regs = hcd->regs;
+
+	if (hc_reset(ohci) < 0) {
+		ohci_stop(hcd);
+		return -ENODEV;
+	}
+
+	if (hc_start(ohci) < 0) {
+		err("can't start %s", ohci->hcd.self.bus_name);
+		ohci_stop(hcd);
+		return -EBUSY;
+	}
+
+	create_debug_files(ohci);
+
+#ifdef	DEBUG
+	ohci_dump(ohci, 1);
+#endif /*DEBUG*/
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_ep93xx_hc_driver = {
+	.description =		hcd_name,
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_ep93xx_start,
+#ifdef	CONFIG_PM
+	/* suspend:		ohci_ep93xx_suspend,  -- tbd */
+	/* resume:		ohci_ep93xx_resume,   -- tbd */
+#endif /*CONFIG_PM*/
+	.stop =			ohci_stop,
+
+	/*
+	 * memory lifecycle (except per-request)
+	 */
+	.hcd_alloc =		ohci_hcd_alloc,
+	.hcd_free =		ohci_hcd_free,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_ep93xx_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = NULL;
+	int ret;
+
+	pr_debug ("In ohci_hcd_ep93xx_drv_probe");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_hcd_ep93xx_probe(&ohci_ep93xx_hc_driver, &hcd, pdev);
+
+	if (ret == 0)
+		dev_set_drvdata(dev, hcd);
+
+	return ret;
+}
+
+static int ohci_hcd_ep93xx_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	usb_hcd_ep93xx_remove(hcd, pdev);
+	dev_set_drvdata(dev, NULL);
+	return 0;
+}
+	/*TBD*/
+/*static int ohci_hcd_ep93xx_drv_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	return 0;
+}
+static int ohci_hcd_ep93xx_drv_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+
+	return 0;
+}
+*/
+
+static struct device_driver ohci_hcd_ep93xx_driver = {
+	.name		= "ep93xxusb",
+	.bus		= &platform_bus_type,
+	.probe		= ohci_hcd_ep93xx_drv_probe,
+	.remove		= ohci_hcd_ep93xx_drv_remove,
+	/*.suspend	= ohci_hcd_ep93xx_drv_suspend, */
+	/*.resume	= ohci_hcd_ep93xx_drv_resume, */
+};
+
+static int __init ohci_hcd_ep93xx_init (void)
+{
+        int retval;
+
+	pr_debug(DRIVER_INFO " (EP93XX_USB)");
+	pr_debug("block sizes: ed %d td %d\n",
+		 sizeof(struct ed), sizeof(struct td));
+
+	retval = driver_register(&ohci_hcd_ep93xx_driver);
+
+	return retval;
+}
+
+static void __exit ohci_hcd_ep93xx_cleanup (void)
+{
+	driver_unregister(&ohci_hcd_ep93xx_driver);
+}
+
+module_init(ohci_hcd_ep93xx_init);
+module_exit(ohci_hcd_ep93xx_cleanup);
diff -burN linux-2.6.8.1-orig/drivers/usb/host/ohci-hcd.c linux-2.6.8.1/drivers/usb/host/ohci-hcd.c
--- linux-2.6.8.1-orig/drivers/usb/host/ohci-hcd.c	2004-08-14 19:54:48.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/host/ohci-hcd.c	2007-01-24 13:03:31.000000000 +0900
@@ -809,10 +809,15 @@
 #include "ohci-lh7a404.c"
 #endif
 
+#ifdef CONFIG_ARCH_EP93XX
+#include "ohci-ep93xx.c"
+#endif
+
 #if !(defined(CONFIG_PCI) \
       || defined(CONFIG_SA1111) \
       || defined(CONFIG_ARCH_OMAP) \
       || defined (CONFIG_ARCH_LH7A404) \
+      || defined (CONFIG_ARCH_EP93XX) \
 	)
 #error "missing bus glue for ohci-hcd"
 #endif
diff -burN linux-2.6.8.1-orig/drivers/usb/host/ohci-hub.c linux-2.6.8.1/drivers/usb/host/ohci-hub.c
--- linux-2.6.8.1-orig/drivers/usb/host/ohci-hub.c	2004-08-14 19:54:50.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/host/ohci-hub.c	2007-01-24 13:03:31.000000000 +0900
@@ -326,8 +326,34 @@
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		ports, i, changed = 0, length = 1;
 	int		can_suspend = 1;
+	unsigned int	uiPADR;
+
+/*  This specific device has a HW issue.  The kenwood device has 2 types
+*   1 - Low end unit has 1 USB Port, but 2 are enabled
+*   2 - Mid end unit has 2 USB Ports with both enabled
+*
+*   Since the HW is set wrong we need to determine wether or not
+*   We are the Low Unit and physically tell the OHCI-HUB 
+*   that there is only 1 port available to setup.  If we do not
+*   then the driver freaks out and tries to enable a port that is 
+*   physically not there.  So if Low end unit, tell this function there is only
+*   1 port by checking GPIO 1 to see if HIGH or LOW.
+*
+*  GPIO1 HIGH - Low End Kenwood Unit - ports = 1
+*  GPIO1 LOW  - Mid End Kenwood Unit - ports = Normal ops
+*
+*/
+	uiPADR = inl(GPIO_PADR);
+
+	if ( uiPADR & 0x02  ){
+		ports = 1;
+	}
+	else{
+		ports = 2;
+	}
+
+	//ports = roothub_a (ohci) & RH_A_NDP; 
 
-	ports = roothub_a (ohci) & RH_A_NDP; 
 	if (ports > MAX_ROOT_PORTS) {
 		if (!HCD_IS_RUNNING(ohci->hcd.state))
 			return -ESHUTDOWN;
diff -burN linux-2.6.8.1-orig/drivers/usb/input/hid-core.c linux-2.6.8.1/drivers/usb/input/hid-core.c
--- linux-2.6.8.1-orig/drivers/usb/input/hid-core.c	2004-08-14 19:55:33.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/input/hid-core.c	2007-01-24 13:03:31.000000000 +0900
@@ -827,14 +827,6 @@
 	for (n = 0; n < count; n++) {
 
 		if (HID_MAIN_ITEM_VARIABLE & field->flags) {
-
-			if (field->flags & HID_MAIN_ITEM_RELATIVE) {
-				if (!value[n])
-					continue;
-			} else {
-				if (value[n] == field->value[n])
-					continue;
-			}	
 			hid_process_event(hid, field, &field->usage[n], value[n], regs);
 			continue;
 		}
@@ -1165,27 +1157,43 @@
 {
 	struct hid_device *hid = urb->context;
 	unsigned long flags;
-
-	if (urb->status)
-		warn("ctrl urb status %d received", urb->status);
+	int unplug = 0;
 
 	spin_lock_irqsave(&hid->ctrllock, flags);
 
+	switch (urb->status ) {
+		case 0: /* success */
+
 	if (hid->ctrl[hid->ctrltail].dir == USB_DIR_IN) 
 		hid_input_report(hid->ctrl[hid->ctrltail].report->type, urb, regs);
+		break;
 
+		case -ESHUTDOWN:	/* unplug */
+		case -EILSEQ:		/* unplug timectrl on uhci */
+			unplug = 1;
+		case -ENOENT:
+		case -EPIPE:		/* report not available */
+		break;
+		default:			/* error */
+			warn("ctrl urb status %d received", urb->status );
+	}
+
+	if ( unplug )
+		hid->ctrltail = hid->ctrlhead;
+	else
 	hid->ctrltail = (hid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);
 
 	if (hid->ctrlhead != hid->ctrltail) {
-		hid_submit_ctrl(hid);
+		if ( hid_submit_ctrl(hid) ) {
+			clear_bit(HID_CTRL_RUNNING, &hid->iofl );
+			wake_up(&hid->wait);
+		}
 		spin_unlock_irqrestore(&hid->ctrllock, flags);
 		return;
 	}
 
 	clear_bit(HID_CTRL_RUNNING, &hid->iofl);
-
 	spin_unlock_irqrestore(&hid->ctrllock, flags);
-
 	wake_up(&hid->wait);
 }
 
@@ -1197,6 +1205,9 @@
 	if ((hid->quirks & HID_QUIRK_NOGET) && dir == USB_DIR_IN)
 		return;
 
+	if ((hid->quirks & HID_QUIRK_IPOD ) && dir == USB_DIR_IN)
+		return;
+
 	if (hid->urbout && dir == USB_DIR_OUT && report->type == HID_OUTPUT_REPORT) {
 
 		spin_lock_irqsave(&hid->outlock, flags);
@@ -1211,7 +1222,8 @@
 		hid->outhead = head;
 
 		if (!test_and_set_bit(HID_OUT_RUNNING, &hid->iofl))
-			hid_submit_out(hid);
+			if ( hid_submit_out(hid) )
+				clear_bit(HID_OUT_RUNNING, &hid->iofl);
 
 		spin_unlock_irqrestore(&hid->outlock, flags);
 		return;
@@ -1230,7 +1242,8 @@
 	hid->ctrlhead = head;
 
 	if (!test_and_set_bit(HID_CTRL_RUNNING, &hid->iofl))
-		hid_submit_ctrl(hid);
+		if ( hid_submit_ctrl(hid) )
+			clear_bit(HID_CTRL_RUNNING, &hid->iofl);
 
 	spin_unlock_irqrestore(&hid->ctrllock, flags);
 }
@@ -1309,9 +1322,17 @@
 	 * bugfree devices and will cause a worst-case extra delay of
 	 * 1ms for buggy ones.
 	 */
-	usb_control_msg(hid->dev, usb_sndctrlpipe(hid->dev, 0),
-			HID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, (1 << 8),
-			hid->ifnum, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+
+	if (hid->quirks != HID_QUIRK_IPOD)
+		usb_control_msg( hid->dev,
+						 usb_sndctrlpipe(hid->dev, 0),
+						 HID_REQ_SET_IDLE,
+						 USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+						 (1 << 8),
+						 hid->ifnum,
+						 NULL,
+						 0,
+						 HZ * USB_CTRL_SET_TIMEOUT );
 
 	report_enum = hid->report_enum + HID_INPUT_REPORT;
 	list = report_enum->report_list.next;
@@ -1343,15 +1364,23 @@
 	if (err)
 		warn("timeout initializing reports\n");
 
+	if ( hid->quirks != HID_QUIRK_IPOD ) {
 	report_enum = hid->report_enum + HID_INPUT_REPORT;
 	list = report_enum->report_list.next;
 	while (list != &report_enum->report_list) {
 		report = (struct hid_report *) list;
-		usb_control_msg(hid->dev, usb_sndctrlpipe(hid->dev, 0),
-			HID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, report->id,
-			hid->ifnum, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+			usb_control_msg(hid->dev, 
+							usb_sndctrlpipe(hid->dev, 0),
+							HID_REQ_SET_IDLE,
+							USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+							report->id,
+							hid->ifnum,
+							NULL,
+							0,
+							HZ * USB_CTRL_SET_TIMEOUT);
 		list = list->next;
 	}
+	}
 }
 
 #define USB_VENDOR_ID_WACOM		0x056a
@@ -1439,6 +1468,15 @@
 #define USB_DEVICE_ID_1_PHIDGETSERVO_20	0x8101
 #define USB_DEVICE_ID_4_PHIDGETSERVO_20	0x8104
 
+#define USB_VENDOR_ID_APPLE				0x05ac
+#define USB_DEVICE_ID_APPLE_IPOD_5TH	0x1209
+#define USB_DEVICE_ID_APPLE_IPOD_NANO_1TH	0x120A
+#define USB_DEVICE_ID_APPLE_IPOD_NANO_2TH	0x1260
+
+#define MASK_USB_DEVICE_ID_APPLE_IPOD	0x1200UL
+
+
+
 static struct hid_blacklist {
 	__u16 idVendor;
 	__u16 idProduct;
@@ -1521,6 +1559,10 @@
 	{ USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RUMBLEPAD, HID_QUIRK_BADPAD },
 	{ USB_VENDOR_ID_TOPMAX, USB_DEVICE_ID_TOPMAX_COBRAPAD, HID_QUIRK_BADPAD },
 
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IPOD_5TH, HID_QUIRK_IPOD }, 
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IPOD_NANO_1TH, HID_QUIRK_IPOD },
+	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IPOD_NANO_2TH, HID_QUIRK_IPOD },
+
 	{ 0, 0 }
 };
 
@@ -1560,6 +1602,14 @@
 	char *buf, *rdesc;
 	int n;
 
+	if ( dev->descriptor.idVendor == USB_VENDOR_ID_APPLE
+		&& ( dev->descriptor.idProduct & MASK_USB_DEVICE_ID_APPLE_IPOD ) == 0x1200 ) {
+
+		printk("configureing apple ipod...\n");
+		quirks = HID_QUIRK_IPOD;
+	}
+	else {	
+
 	for (n = 0; hid_blacklist[n].idVendor; n++)
 		if ((hid_blacklist[n].idVendor == dev->descriptor.idVendor) &&
 			(hid_blacklist[n].idProduct == dev->descriptor.idProduct))
@@ -1567,6 +1617,7 @@
 
 	if (quirks & HID_QUIRK_IGNORE)
 		return NULL;
+	}
 
 	if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) && ((!interface->desc.bNumEndpoints) ||
 		usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {
diff -burN linux-2.6.8.1-orig/drivers/usb/input/hid.h linux-2.6.8.1/drivers/usb/input/hid.h
--- linux-2.6.8.1-orig/drivers/usb/input/hid.h	2004-08-14 19:54:46.000000000 +0900
+++ linux-2.6.8.1/drivers/usb/input/hid.h	2007-01-24 13:03:31.000000000 +0900
@@ -211,6 +211,7 @@
 #define HID_QUIRK_2WHEEL_MOUSE_HACK_BACK	0x080
 #define HID_QUIRK_2WHEEL_MOUSE_HACK_EXTRA	0x100
 #define HID_QUIRK_2WHEEL_MOUSE_HACK_ON		0x200
+#define HID_QUIRK_IPOD				0x400
 
 /*
  * This is the global environment of the parser. This information is
diff -burN linux-2.6.8.1-orig/drivers/video/Kconfig linux-2.6.8.1/drivers/video/Kconfig
--- linux-2.6.8.1-orig/drivers/video/Kconfig	2004-08-14 19:54:47.000000000 +0900
+++ linux-2.6.8.1/drivers/video/Kconfig	2007-01-15 12:17:44.000000000 +0900
@@ -80,6 +80,81 @@
 	bool "CLPS711X LCD support"
 	depends on FB && ARM && ARCH_CLPS711X
 
+config FB_EP93XX
+	bool "EP93xx frame buffer support"
+	depends on FB && EP93XX_FRAMEBUFFER
+	help
+	  This is the frame buffer device driver for the internal raster engine
+	  on certain members of the EP93xx family.
+
+choice
+	prompt "EP93xx frame buffer display"
+	default FB_EP93XX_KENWOOD_LCD
+	depends on FB && FB_EP93XX
+	help
+	  The default display type to be used by the frame buffer driver.
+
+config FB_EP93XX_CRT
+	bool "CRT display"
+	help
+	  Use a VGA monitor connected to the board.
+
+config FB_EP93XX_LCD
+	bool "LCD display"
+	help
+	  Use the Philips LB064V02 640x480 LCD connected to the board.
+
+config FB_EP93XX_NTSC
+	bool "NTSC display"
+	help
+	  Use the Conexant CX25871 to display on a NTSC television connected to
+	  the board.
+	 
+config FB_EP93XX_PAL
+	bool "PAL display"
+	help
+	  Use the Conexant CX25871 to display on a PAL television connected to
+	  the board.
+
+config FB_EP93XX_KENWOOD_LCD
+	bool  "KENWOOD LCD display"
+	help
+		Use the KENWOOD 508x234 LCD connected to the board.
+
+endchoice
+
+choice
+	prompt "EP93xx frame buffer depth"
+	default FB_EP93XX_16BPP
+	depends on FB && FB_EP93XX
+	help
+	  The default display depth to be used by the frame buffer driver.
+
+config FB_EP93XX_8BPP
+	bool "8bpp pseudo color"
+	help
+	  A frame buffer with a 256 entry palette of 18bpp colors (6bpp per
+	  color element).
+
+config FB_EP93XX_16BPP
+	bool "16bpp true color"
+	help
+	  A frame buffer with 5bpp for red, 6bpp for green, and 5bpp for blue.
+
+endchoice
+
+config FB_EP93XX_NTSC_OVERSCAN
+	bool "    EP93xx NTSC overscan"
+	depends on FB_EP93XX_NTSC
+	default false
+	help
+	  Determines how the frame buffer image is mapped into the visible area
+	  of the television.  If overscan is enabled, then the image will span
+	  from bevel to bevel on the television, and parts of the image will be
+	  hidden behind the bevel.  If overscan is disabled, then the image
+	  will be contained entirely within the bevel of the television, with a
+	  small black border between the image and the bevel.
+
 config FB_SA1100
 	bool "SA-1100 LCD support"
 	depends on FB && ARM && ARCH_SA1100
@@ -1002,5 +1077,9 @@
 	source "drivers/video/logo/Kconfig"
 endif
 
+if FB
+	source "drivers/video/bootsplash/Kconfig"
+endif
+
 endmenu
 
diff -burN linux-2.6.8.1-orig/drivers/video/Kconfig.orig linux-2.6.8.1/drivers/video/Kconfig.orig
--- linux-2.6.8.1-orig/drivers/video/Kconfig.orig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/Kconfig.orig	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1077 @@
+#
+# Video configuration
+#
+
+menu "Graphics support"
+
+config FB
+	bool "Support for frame buffer devices"
+	---help---
+	  The frame buffer device provides an abstraction for the graphics
+	  hardware. It represents the frame buffer of some video hardware and
+	  allows application software to access the graphics hardware through
+	  a well-defined interface, so the software doesn't need to know
+	  anything about the low-level (hardware register) stuff.
+
+	  Frame buffer devices work identically across the different
+	  architectures supported by Linux and make the implementation of
+	  application programs easier and more portable; at this point, an X
+	  server exists which uses the frame buffer device exclusively.
+	  On several non-X86 architectures, the frame buffer device is the
+	  only way to use the graphics hardware.
+
+	  The device is accessed through special device nodes, usually located
+	  in the /dev directory, i.e. /dev/fb*.
+
+	  You need an utility program called fbset to make full use of frame
+	  buffer devices. Please read <file:Documentation/fb/framebuffer.txt>
+	  and the Framebuffer-HOWTO at
+	  <http://www.tahallah.demon.co.uk/programming/prog.html> for more
+	  information.
+
+	  Say Y here and to the driver for your graphics board below if you
+	  are compiling a kernel for a non-x86 architecture.
+
+	  If you are compiling for the x86 architecture, you can say Y if you
+	  want to play with it, but it is not essential. Please note that
+	  running graphical applications that directly touch the hardware
+	  (e.g. an accelerated X server) and that are not frame buffer
+	  device-aware may cause unexpected results. If unsure, say N.
+
+config FB_CIRRUS
+	tristate "Cirrus Logic support"
+	depends on FB && (ZORRO || PCI)
+	---help---
+	  This enables support for Cirrus Logic GD542x/543x based boards on
+	  Amiga: SD64, Piccolo, Picasso II/II+, Picasso IV, or EGS Spectrum.
+
+	  If you have a PCI-based system, this enables support for these
+	  chips: GD-543x, GD-544x, GD-5480.
+
+	  Please read the file <file:Documentation/fb/cirrusfb.txt>.
+
+	  Say N unless you have such a graphics board or plan to get one
+	  before you next recompile the kernel.
+
+config FB_PM2
+	tristate "Permedia2 support"
+	depends on FB && ((AMIGA && BROKEN) || PCI)
+	help
+	  This is the frame buffer device driver for the Permedia2 AGP frame
+	  buffer card from ASK, aka `Graphic Blaster Exxtreme'.  There is a
+	  product page at
+	  <http://www.ask.com.hk/product/Permedia%202/permedia2.htm>.
+
+config FB_PM2_FIFO_DISCONNECT
+	bool "enable FIFO disconnect feature"
+	depends on FB_PM2 && PCI
+	help
+	  Support the Permedia2 FIFO disconnect feature (see CONFIG_FB_PM2).
+
+config FB_ACORN
+	bool "Acorn VIDC support"
+	depends on FB && ARM && ARCH_ACORN
+	help
+	  This is the frame buffer device driver for the Acorn VIDC graphics
+	  hardware found in Acorn RISC PCs and other ARM-based machines.  If
+	  unsure, say N.
+
+config FB_CLPS711X
+	bool "CLPS711X LCD support"
+	depends on FB && ARM && ARCH_CLPS711X
+
+config FB_EP93XX
+	bool "EP93xx frame buffer support"
+	depends on FB && EP93XX_FRAMEBUFFER
+	help
+	  This is the frame buffer device driver for the internal raster engine
+	  on certain members of the EP93xx family.
+
+choice
+	prompt "EP93xx frame buffer display"
+	default FB_EP93XX_LCD
+	depends on FB && FB_EP93XX
+	help
+	  The default display type to be used by the frame buffer driver.
+
+config FB_EP93XX_CRT
+	bool "CRT display"
+	help
+	  Use a VGA monitor connected to the board.
+
+config FB_EP93XX_LCD
+	bool "LCD display"
+	help
+	  Use the Philips LB064V02 640x480 LCD connected to the board.
+
+config FB_EP93XX_NTSC
+	bool "NTSC display"
+	help
+	  Use the Conexant CX25871 to display on a NTSC television connected to
+	  the board.
+	 
+config FB_EP93XX_PAL
+	bool "PAL display"
+	help
+	  Use the Conexant CX25871 to display on a PAL television connected to
+	  the board.
+
+
+endchoice
+
+choice
+	prompt "EP93xx frame buffer depth"
+	default FB_EP93XX_16BPP
+	depends on FB && FB_EP93XX
+	help
+	  The default display depth to be used by the frame buffer driver.
+
+config FB_EP93XX_8BPP
+	bool "8bpp pseudo color"
+	help
+	  A frame buffer with a 256 entry palette of 18bpp colors (6bpp per
+	  color element).
+
+config FB_EP93XX_16BPP
+	bool "16bpp true color"
+	help
+	  A frame buffer with 5bpp for red, 6bpp for green, and 5bpp for blue.
+
+endchoice
+
+config FB_EP93XX_NTSC_OVERSCAN
+	bool "    EP93xx NTSC overscan"
+	depends on FB_EP93XX_NTSC
+	default false
+	help
+	  Determines how the frame buffer image is mapped into the visible area
+	  of the television.  If overscan is enabled, then the image will span
+	  from bevel to bevel on the television, and parts of the image will be
+	  hidden behind the bevel.  If overscan is disabled, then the image
+	  will be contained entirely within the bevel of the television, with a
+	  small black border between the image and the bevel.
+
+config FB_SA1100
+	bool "SA-1100 LCD support"
+	depends on FB && ARM && ARCH_SA1100
+	help
+	  This is a framebuffer device for the SA-1100 LCD Controller.
+	  See <http://www.linux-fbdev.org/> for information on framebuffer
+	  devices.
+
+	  If you plan to use the LCD display with your SA-1100 system, say
+	  Y here.
+
+config FB_CYBER2000
+	tristate "CyberPro 2000/2010/5000 support"
+	depends on FB && PCI && (BROKEN || !SPARC64)
+	help
+	  This enables support for the Integraphics CyberPro 20x0 and 5000
+	  VGA chips used in the Rebel.com Netwinder and other machines.
+	  Say Y if you have a NetWinder or a graphics card containing this
+	  device, otherwise say N.
+
+config FB_APOLLO
+	bool
+	depends on FB && APOLLO
+	default y
+
+config FB_Q40
+	bool
+	depends on FB && Q40
+	default y
+
+config FB_AMIGA
+	tristate "Amiga native chipset support"
+	depends on FB && AMIGA
+	help
+	  This is the frame buffer device driver for the builtin graphics
+	  chipset found in Amigas.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called amifb.
+
+config FB_AMIGA_OCS
+	bool "Amiga OCS chipset support"
+	depends on FB_AMIGA
+	help
+	  This enables support for the original Agnus and Denise video chips,
+	  found in the Amiga 1000 and most A500's and A2000's. If you intend
+	  to run Linux on any of these systems, say Y; otherwise say N.
+
+config FB_AMIGA_ECS
+	bool "Amiga ECS chipset support"
+	depends on FB_AMIGA
+	help
+	  This enables support for the Enhanced Chip Set, found in later
+	  A500's, later A2000's, the A600, the A3000, the A3000T and CDTV. If
+	  you intend to run Linux on any of these systems, say Y; otherwise
+	  say N.
+
+config FB_AMIGA_AGA
+	bool "Amiga AGA chipset support"
+	depends on FB_AMIGA
+	help
+	  This enables support for the Advanced Graphics Architecture (also
+	  known as the AGA or AA) Chip Set, found in the A1200, A4000, A4000T
+	  and CD32. If you intend to run Linux on any of these systems, say Y;
+	  otherwise say N.
+
+config FB_CYBER
+	tristate "Amiga CyberVision 64 support"
+	depends on FB && ZORRO && BROKEN
+	help
+	  This enables support for the Cybervision 64 graphics card from
+	  Phase5. Please note that its use is not all that intuitive (i.e. if
+	  you have any questions, be sure to ask!). Say N unless you have a
+	  Cybervision 64 or plan to get one before you next recompile the
+	  kernel. Please note that this driver DOES NOT support the
+	  Cybervision 64/3D card, as they use incompatible video chips.
+
+config FB_VIRGE
+	bool "Amiga CyberVision 64/3D support "
+	depends on FB && ZORRO && BROKEN
+	help
+	  This enables support for the Cybervision 64/3D graphics card from
+	  Phase5. Please note that its use is not all that intuitive (i.e. if
+	  you have any questions, be sure to ask!). Say N unless you have a
+	  Cybervision 64/3D or plan to get one before you next recompile the
+	  kernel. Please note that this driver DOES NOT support the older
+	  Cybervision 64 card, as they use incompatible video chips.
+
+config FB_RETINAZ3
+	tristate "Amiga Retina Z3 support"
+	depends on FB && ZORRO && BROKEN
+	help
+	  This enables support for the Retina Z3 graphics card. Say N unless
+	  you have a Retina Z3 or plan to get one before you next recompile
+	  the kernel.
+
+config FB_FM2
+	bool "Amiga FrameMaster II/Rainbow II support"
+	depends on FB && ZORRO
+	help
+	  This is the frame buffer device driver for the Amiga FrameMaster
+	  card from BSC (exhibited 1992 but not shipped as a CBM product).
+
+config FB_ATARI
+	bool "Atari native chipset support"
+	depends on FB && ATARI && BROKEN
+	help
+	  This is the frame buffer device driver for the builtin graphics
+	  chipset found in Ataris.
+
+config FB_OF
+	bool "Open Firmware frame buffer device support"
+	depends on FB && (PPC64 || PPC_OF)
+	help
+	  Say Y if you want support with Open Firmware for your graphics
+	  board.
+
+config FB_CONTROL
+	bool "Apple \"control\" display support"
+	depends on FB && PPC_PMAC
+	help
+	  This driver supports a frame buffer for the graphics adapter in the
+	  Power Macintosh 7300 and others.
+
+config FB_PLATINUM
+	bool "Apple \"platinum\" display support"
+	depends on FB && PPC_PMAC
+	help
+	  This driver supports a frame buffer for the "platinum" graphics
+	  adapter in some Power Macintoshes.
+
+config FB_VALKYRIE
+	bool "Apple \"valkyrie\" display support"
+	depends on FB && (MAC || PPC_PMAC)
+	help
+	  This driver supports a frame buffer for the "valkyrie" graphics
+	  adapter in some Power Macintoshes.
+
+config FB_CT65550
+	bool "Chips 65550 display support"
+	depends on FB && PPC
+	help
+	  This is the frame buffer device driver for the Chips & Technologies
+	  65550 graphics chip in PowerBooks.
+
+config FB_ASILIANT
+	bool "Chips 69000 display support"
+	depends on FB && PCI
+
+config FB_IMSTT
+	bool "IMS Twin Turbo display support"
+	depends on FB && PCI
+	help
+	  The IMS Twin Turbo is a PCI-based frame buffer card bundled with
+	  many Macintosh and compatible computers.
+
+config FB_S3TRIO
+	bool "S3 Trio display support"
+	depends on FB && PPC && BROKEN
+	help
+	  If you have a S3 Trio say Y. Say N for S3 Virge.
+
+config FB_VGA16
+	tristate "VGA 16-color graphics support"
+	depends on FB && (X86 || PPC)
+	help
+	  This is the frame buffer device driver for VGA 16 color graphic
+	  cards. Say Y if you have such a card.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vga16fb.
+
+config FB_STI
+	tristate "HP STI frame buffer device support"
+	depends on FB && PARISC
+	default y
+	---help---
+	  STI refers to the HP "Standard Text Interface" which is a set of
+	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
+	  Enabling this option will implement the linux framebuffer device
+	  using calls to the STI BIOS routines for initialisation.
+	
+	  If you enable this option, you will get a planar framebuffer device
+	  /dev/fb which will work on the most common HP graphic cards of the
+	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
+	  HCRX, HCRX24, CRX, CRX24 and VisEG series.
+
+	  It is safe to enable this option, so you should probably say "Y".
+
+config FB_MAC
+	bool "Generic Macintosh display support"
+	depends on FB && MAC
+
+#      bool '  Apple DAFB display support' CONFIG_FB_DAFB
+config FB_HP300
+	bool
+	depends on FB && HP300
+	default y
+
+config FB_TGA
+	tristate "TGA framebuffer support"
+	depends on FB && ALPHA
+	help
+	  This is the frame buffer device driver for generic TGA graphic
+	  cards. Say Y if you have one of those.
+
+config FB_VESA
+	bool "VESA VGA graphics support"
+	depends on FB && (X86 || X86_64)
+	help
+	  This is the frame buffer device driver for generic VESA 2.0
+	  compliant graphic cards. The older VESA 1.2 cards are not supported.
+	  You will get a boot time penguin logo at no additional cost. Please
+	  read <file:Documentation/fb/vesafb.txt>. If unsure, say Y.
+
+config VIDEO_SELECT
+	bool
+	depends on FB_VESA
+	default y
+
+config FB_HGA
+	tristate "Hercules mono graphics support"
+	depends on FB && X86
+	help
+	  Say Y here if you have a Hercules mono graphics card.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hgafb.
+
+	  As this card technology is 15 years old, most people will answer N
+	  here.
+
+config FB_HGA_ACCEL
+	bool "Hercules mono Acceleration functions (EXPERIMENTAL)"
+	depends on FB_HGA && EXPERIMENTAL
+	---help---
+	This will compile the Hercules mono graphics with
+	acceleration functions.
+
+
+config VIDEO_SELECT
+	bool
+	depends on FB && X86
+	default y
+
+config FB_SGIVW
+	tristate "SGI Visual Workstation framebuffer support"
+	depends on FB && X86_VISWS
+	help
+	  SGI Visual Workstation support for framebuffer graphics.
+
+config FB_GBE
+	bool "SGI Graphics Backend frame buffer support"
+	depends on FB && (SGI_IP32 || X86_VISWS)
+ 	help
+	  This is the frame buffer device driver for SGI Graphics Backend.
+	  This chip is used in SGI O2 and Visual Workstation 320/540.
+
+config FB_GBE_MEM
+	int "Video memory size in MB"
+	depends on FB_GBE
+	default 8
+	help
+	  This is the amount of memory reserved for the framebuffer,
+	  which can be any value between 1MB and 8MB.
+
+config BUS_I2C
+	bool
+	depends on FB && VISWS
+	default y
+
+config FB_SUN3
+	bool "Sun3 framebuffer support"
+	depends on FB && (SUN3 || SUN3X) && BROKEN
+
+config FB_BW2
+	bool "BWtwo support"
+	depends on FB && ((SPARC32 || SPARC64) && FB_SBUS || (SUN3 || SUN3X) && FB_SUN3)
+	help
+	  This is the frame buffer device driver for the BWtwo frame buffer.
+
+config FB_CG3
+	bool "CGthree support"
+	depends on FB && ((SPARC32 || SPARC64) && FB_SBUS || (SUN3 || SUN3X) && FB_SUN3)
+	help
+	  This is the frame buffer device driver for the CGthree frame buffer.
+
+config FB_CG6
+	bool "CGsix (GX,TurboGX) support"
+	depends on FB && ((SPARC32 || SPARC64) && FB_SBUS || (SUN3 || SUN3X) && FB_SUN3)
+	help
+	  This is the frame buffer device driver for the CGsix (GX, TurboGX)
+	  frame buffer.
+
+config FB_PVR2
+	tristate "NEC PowerVR 2 display support"
+	depends on FB && SH_DREAMCAST
+	---help---
+	  Say Y here if you have a PowerVR 2 card in your box.  If you plan to
+	  run linux on your Dreamcast, you will have to say Y here.
+	  This driver may or may not work on other PowerVR 2 cards, but is
+	  totally untested.  Use at your own risk.  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called pvr2fb.
+
+	  You can pass several parameters to the driver at boot time or at
+	  module load time.  The parameters look like "video=pvr2:XXX", where
+	  the meaning of XXX can be found at the end of the main source file
+	  (<file:drivers/video/pvr2fb.c>). Please see the file
+	  <file:Documentation/fb/pvr2fb.txt>.
+
+config FB_E1355
+	bool "Epson 1355 framebuffer support"
+	depends on FB && SUPERH
+	help
+	  Build in support for the SED1355 Epson Research Embedded RAMDAC
+	  LCD/CRT Controller (since redesignated as the S1D13505) as a
+	  framebuffer.  Product specs at
+	  <http://www.erd.epson.com/vdc/html/products.htm>.
+
+config E1355_REG_BASE
+	hex "Register Base Address"
+	depends on FB_E1355
+	default "a8000000"
+	help
+	  Epson SED1355/S1D13505 LCD/CRT controller register base address.
+	  See the manuals at
+	  <http://www.erd.epson.com/vdc/html/contents/S1D13505.htm> for
+	  discussion.
+
+config E1355_FB_BASE
+	hex "Framebuffer Base Address"
+	depends on FB_E1355
+	default "a8200000"
+	help
+	  Epson SED1355/S1D13505 LCD/CRT controller memory base address.  See
+	  the manuals at
+	  <http://www.erd.epson.com/vdc/html/contents/S1D13505.htm> for
+	  discussion.
+
+config FB_RIVA
+	tristate "nVidia Riva support"
+	depends on FB && PCI
+	select I2C_ALGOBIT if FB_RIVA_I2C
+	select I2C if FB_RIVA_I2C
+	help
+	  This driver supports graphics boards with the nVidia Riva/Geforce
+	  chips.
+	  Say Y if you have such a graphics board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called rivafb.
+
+config FB_RIVA_I2C
+       bool "Enable DDC Support"
+       depends on FB_RIVA
+       help
+	  This enables I2C support for nVidia Chipsets.  This is used
+	  only for getting EDID information from the attached display
+	  allowing for robust video mode handling and switching.
+
+	  Because fbdev-2.6 requires that drivers must be able to
+	  independently validate video mode parameters, you should say Y
+	  here.
+
+config FB_RIVA_DEBUG
+	bool "Lots of debug output from Riva(nVidia) driver"
+	depends on FB_RIVA
+	default n
+	help
+	  Say Y here if you want the Riva driver to output all sorts
+	  of debugging informations to provide to the maintainer when
+	  something goes wrong.
+
+config FB_I810
+	tristate "Intel 810/815 support (EXPERIMENTAL)"
+	depends on FB && AGP && AGP_INTEL && EXPERIMENTAL && PCI	
+	help
+	  This driver supports the on-board graphics built in to the Intel 810 
+          and 815 chipsets.  Say Y if you have and plan to use such a board.
+
+          To compile this driver as a module, choose M here: the
+	  module will be called i810fb.
+
+          For more information, please read 
+	  <file:Documentation/fb/intel810.txt>
+
+config FB_I810_GTF
+	bool "use VESA Generalized Timing Formula"
+	depends on FB_I810
+	help
+	  If you say Y, then the VESA standard, Generalized Timing Formula 
+          or GTF, will be used to calculate the required video timing values
+	  per video mode.  Since the GTF allows nondiscrete timings 
+          (nondiscrete being a range of values as opposed to discrete being a
+          set of values), you'll be able to use any combination of horizontal 
+	  and vertical resolutions, and vertical refresh rates without having
+	  to specify your own timing parameters.  This is especially useful
+	  to maximize the performance of an aging display, or if you just 
+          have a display with nonstandard dimensions. A VESA compliant 
+	  monitor is recommended, but can still work with non-compliant ones.
+	  If you need or want this, then select this option. The timings may 
+	  not be compliant with Intel's recommended values. Use at your own 
+	  risk.
+
+          If you say N, the driver will revert to discrete video timings 
+	  using a set recommended by Intel in their documentation.
+  
+          If unsure, say N.
+
+config FB_MATROX
+	tristate "Matrox acceleration"
+	depends on FB && PCI
+	---help---
+	  Say Y here if you have a Matrox Millennium, Matrox Millennium II,
+	  Matrox Mystique, Matrox Mystique 220, Matrox Productiva G100, Matrox
+	  Mystique G200, Matrox Millennium G200, Matrox Marvel G200 video,
+	  Matrox G400, G450 or G550 card in your box.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called matroxfb.
+
+	  You can pass several parameters to the driver at boot time or at
+	  module load time. The parameters look like "video=matrox:XXX", and
+	  are described in <file:Documentation/fb/matroxfb.txt>.
+
+config FB_MATROX_MILLENIUM
+	bool "Millennium I/II support"
+	depends on FB_MATROX
+	help
+	  Say Y here if you have a Matrox Millennium or Matrox Millennium II
+	  video card. If you select "Advanced lowlevel driver options" below,
+	  you should check 4 bpp packed pixel, 8 bpp packed pixel, 16 bpp
+	  packed pixel, 24 bpp packed pixel and 32 bpp packed pixel. You can
+	  also use font widths different from 8.
+
+config FB_MATROX_MYSTIQUE
+	bool "Mystique support"
+	depends on FB_MATROX
+	help
+	  Say Y here if you have a Matrox Mystique or Matrox Mystique 220
+	  video card. If you select "Advanced lowlevel driver options" below,
+	  you should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp
+	  packed pixel and 32 bpp packed pixel. You can also use font widths
+	  different from 8.
+
+config FB_MATROX_G450
+	bool "G100/G200/G400/G450/G550 support"
+	depends on FB_MATROX
+	---help---
+	  Say Y here if you have a Matrox G100, G200, G400, G450 or G550 based
+	  video card. If you select "Advanced lowlevel driver options", you
+	  should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp packed
+	  pixel and 32 bpp packed pixel. You can also use font widths
+	  different from 8.
+
+	  If you need support for G400 secondary head, you must first say Y to
+	  "I2C support" and "I2C bit-banging support" in the character devices
+	  section, and then to "Matrox I2C support" and "G400 second head
+	  support" here in the framebuffer section. G450/G550 secondary head
+	  and digital output are supported without additional modules.
+
+	  The driver starts in monitor mode. You must use the matroxset tool 
+	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
+	  swap primary and secondary head outputs, or to change output mode.  
+	  Secondary head driver always start in 640x480 resolution and you 
+	  must use fbset to change it.
+
+	  Do not forget that second head supports only 16 and 32 bpp
+	  packed pixels, so it is a good idea to compile them into the kernel
+	  too. You can use only some font widths, as the driver uses generic
+	  painting procedures (the secondary head does not use acceleration
+	  engine).
+
+	  G450/G550 hardware can display TV picture only from secondary CRTC,
+	  and it performs no scaling, so picture must have 525 or 625 lines.
+
+config FB_MATROX_G100A
+	bool "G100/G200/G400 support"
+	depends on FB_MATROX && !FB_MATROX_G450
+	---help---
+	  Say Y here if you have a Matrox G100, G200 or G400 based
+	  video card. If you select "Advanced lowlevel driver options", you
+	  should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp packed
+	  pixel and 32 bpp packed pixel. You can also use font widths
+	  different from 8.
+
+	  If you need support for G400 secondary head, you must first say Y to
+	  "I2C support" and "I2C bit-banging support" in the character devices
+	  section, and then to "Matrox I2C support" and "G400 second head
+	  support" here in the framebuffer section.
+
+config FB_MATROX_G100
+	bool
+	depends on FB_MATROX && (FB_MATROX_G450 || FB_MATROX_G100A)
+	default y
+
+config FB_MATROX_I2C
+	tristate "Matrox I2C support"
+	depends on FB_MATROX && I2C
+	select I2C_ALGOBIT
+	---help---
+	  This drivers creates I2C buses which are needed for accessing the
+	  DDC (I2C) bus present on all Matroxes, an I2C bus which
+	  interconnects Matrox optional devices, like MGA-TVO on G200 and
+	  G400, and the secondary head DDC bus, present on G400 only.
+
+	  You can say Y or M here if you want to experiment with monitor
+	  detection code. You must say Y or M here if you want to use either
+	  second head of G400 or MGA-TVO on G200 or G400.
+
+	  If you compile it as module, it will create a module named
+	  i2c-matroxfb.
+
+config FB_MATROX_MAVEN
+	tristate "G400 second head support"
+	depends on FB_MATROX_G100 && FB_MATROX_I2C
+	---help---
+	  WARNING !!! This support does not work with G450 !!!
+
+	  Say Y or M here if you want to use a secondary head (meaning two
+	  monitors in parallel) on G400 or MGA-TVO add-on on G200. Secondary
+	  head is not compatible with accelerated XFree 3.3.x SVGA servers -
+	  secondary head output is blanked while you are in X. With XFree
+	  3.9.17 preview you can use both heads if you use SVGA over fbdev or
+	  the fbdev driver on first head and the fbdev driver on second head.
+
+	  If you compile it as module, two modules are created,
+	  matroxfb_crtc2 and matroxfb_maven. Matroxfb_maven is needed for
+	  both G200 and G400, matroxfb_crtc2 is needed only by G400. You must
+	  also load i2c-matroxfb to get it to run.
+
+	  The driver starts in monitor mode and you must use the matroxset
+	  tool (available at
+	  <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to switch it to
+	  PAL or NTSC or to swap primary and secondary head outputs.
+	  Secondary head driver also always start in 640x480 resolution, you
+	  must use fbset to change it.
+
+	  Also do not forget that second head supports only 16 and 32 bpp
+	  packed pixels, so it is a good idea to compile them into the kernel
+	  too.  You can use only some font widths, as the driver uses generic
+	  painting procedures (the secondary head does not use acceleration
+	  engine).
+
+config FB_MATROX_MULTIHEAD
+	bool "Multihead support"
+	depends on FB_MATROX
+	---help---
+	  Say Y here if you have more than one (supported) Matrox device in
+	  your computer and you want to use all of them for different monitors
+	  ("multihead"). If you have only one device, you should say N because
+	  the driver compiled with Y is larger and a bit slower, especially on
+	  ia32 (ix86).
+
+	  If you said M to "Matrox unified accelerated driver" and N here, you
+	  will still be able to use several Matrox devices simultaneously:
+	  insert several instances of the module matroxfb into the kernel
+	  with insmod, supplying the parameter "dev=N" where N is 0, 1, etc.
+	  for the different Matrox devices. This method is slightly faster but
+	  uses 40 KB of kernel memory per Matrox card.
+
+	  There is no need for enabling 'Matrox multihead support' if you have
+	  only one Matrox card in the box.
+
+config FB_RADEON_OLD
+	tristate "ATI Radeon display support (Old driver)"
+	depends on FB && PCI
+	help
+	  Choose this option if you want to use an ATI Radeon graphics card as
+	  a framebuffer device.  There are both PCI and AGP versions.  You
+	  don't need to choose this to run the Radeon in plain VGA mode.
+	  There is a product page at
+	  <http://www.ati.com/na/pages/products/pc/radeon32/index.html>.
+
+config FB_RADEON
+	tristate "ATI Radeon display support"
+	depends on FB && PCI
+	select I2C_ALGOBIT if FB_RADEON_I2C
+	select I2C if FB_RADEON_I2C
+	help
+	  Choose this option if you want to use an ATI Radeon graphics card as
+	  a framebuffer device.  There are both PCI and AGP versions.  You
+	  don't need to choose this to run the Radeon in plain VGA mode.
+
+	  If you say Y here and want DDC/I2C support you must first say Y to
+	  "I2C support" and "I2C bit-banging support" in the character devices
+	  section.
+
+	  If you say M here then "I2C support" and "I2C bit-banging support" 
+	  can be build either as modules or built-in.
+
+	  There is a product page at
+	  <http://www.ati.com/na/pages/products/pc/radeon32/index.html>.
+
+config FB_RADEON_I2C
+	bool "DDC/I2C for ATI Radeon support"
+	depends on FB_RADEON
+	default y
+	help
+	  Say Y here if you want DDC/I2C support for your Radeon board. 
+
+config FB_RADEON_DEBUG
+	bool "Lots of debug output from Radeon driver"
+	depends on FB_RADEON
+	default n
+	help
+	  Say Y here if you want the Radeon driver to output all sorts
+	  of debugging informations to provide to the maintainer when
+	  something goes wrong.
+
+config FB_ATY128
+	tristate "ATI Rage128 display support"
+	depends on FB && PCI
+	help
+	  This driver supports graphics boards with the ATI Rage128 chips.
+	  Say Y if you have such a graphics board and read
+	  <file:Documentation/fb/aty128fb.txt>.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called aty128fb.
+
+config FB_ATY
+	tristate "ATI Mach64 display support" if PCI || ATARI
+	depends on FB
+	help
+	  This driver supports graphics boards with the ATI Mach64 chips.
+	  Say Y if you have such a graphics board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called atyfb.
+
+config FB_ATY_CT
+	bool "Mach64 CT/VT/GT/LT (incl. 3D RAGE) support"
+	depends on PCI && FB_ATY
+	default y if SPARC64 && FB_PCI
+	help
+	  Say Y here to support use of ATI's 64-bit Rage boards (or other
+	  boards based on the Mach64 CT, VT, GT, and LT chipsets) as a
+	  framebuffer device.  The ATI product support page for these boards
+	  is at <http://support.ati.com/products/pc/mach64/>.
+
+config FB_ATY_GX
+	bool "Mach64 GX support" if PCI
+	depends on FB_ATY
+	default y if ATARI
+	help
+	  Say Y here to support use of the ATI Mach64 Graphics Expression
+	  board (or other boards based on the Mach64 GX chipset) as a
+	  framebuffer device.  The ATI product support page for these boards
+	  is at
+	  <http://support.ati.com/products/pc/mach64/graphics_xpression.html>.
+
+config FB_ATY_XL_INIT
+	bool "  Rage XL No-BIOS Init support" if FB_ATY_CT
+	depends on FB_ATY
+	help
+	  Say Y here to support booting a Rage XL without BIOS support.
+
+config FB_SIS
+	tristate "SiS acceleration"
+	depends on FB && PCI
+	help
+	  This is the frame buffer device driver for the SiS 300, 315 and
+	  330 series VGA chipsets. Specs available at http://www.sis.com
+
+	  To compile this driver as a module, choose M here; the module
+	  will be called sisfb.
+
+config FB_SIS_300
+	bool "SiS 300 series support"
+	depends on FB_SIS
+	help
+	  Say Y here to support use of the SiS 300/305, 540, 630 and 730.
+
+config FB_SIS_315
+	bool "SiS 315/330 series support"
+	depends on FB_SIS
+	help
+	  Say Y here to support use of the SiS 315 and 330 series
+	  (315/H/PRO, 55x, 650, 651, 740, 330, 661, 741, 760).
+
+config FB_NEOMAGIC
+	tristate "NeoMagic display support"
+	depends on FB && PCI
+	help
+	  This driver supports notebooks with NeoMagic PCI chips.
+	  Say Y if you have such a graphics card. 
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called neofb.
+
+config FB_KYRO
+	tristate "IMG Kyro support"
+	depends on FB && PCI
+	help
+	  Say Y here if you have a STG4000 / Kyro / PowerVR 3 based
+	  graphics board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called kyrofb.
+
+config FB_3DFX
+	tristate "3Dfx Banshee/Voodoo3 display support"
+	depends on FB && PCI
+	help
+	  This driver supports graphics boards with the 3Dfx Banshee/Voodoo3
+	  chips. Say Y if you have such a graphics board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tdfxfb.
+
+config FB_3DFX_ACCEL
+	bool "3Dfx Banshee/Voodoo3 Acceleration functions (EXPERIMENTAL)"
+	depends on FB_3DFX && EXPERIMENTAL
+	---help---
+	This will compile the 3Dfx Banshee/Voodoo3 frame buffer device
+	with acceleration functions.
+
+
+config FB_VOODOO1
+	tristate "3Dfx Voodoo Graphics (sst1) support"
+	depends on FB && PCI
+	---help---
+	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
+	  Voodoo2 (cvg) based graphics card.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sstfb.
+
+	  WARNING: Do not use any application that uses the 3D engine
+	  (namely glide) while using this driver.
+	  Please read the file Documentation/fb/README-sstfb.txt for supported
+	  options and other important info  support.
+
+config FB_TRIDENT
+	tristate "Trident support"
+	depends on FB && PCI
+	---help---
+	  This driver is supposed to support graphics boards with the
+	  Trident CyberXXXX/Image/CyberBlade chips mostly found in laptops
+	  but also on some motherboards. For more information, read
+	  <file:Documentation/fb/tridentfb.txt>
+
+	  Say Y if you have such a graphics board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tridentfb.
+
+config FB_TRIDENT_ACCEL
+	bool "Trident Acceleration functions (EXPERIMENTAL)"
+	depends on FB_TRIDENT && EXPERIMENTAL
+	---help---
+	This will compile the Trident frame buffer device with
+	acceleration functions.
+
+
+config FB_PM3
+	tristate "Permedia3 support"
+	depends on FB && PCI && BROKEN
+	help
+	  This is the frame buffer device driver for the 3DLabs Permedia3
+	  chipset, used in Formac ProFormance III, 3DLabs Oxygen VX1 &
+	  similar boards, 3DLabs Permedia3 Create!, Appian Jeronimo 2000
+	  and maybe other boards.
+
+config FB_SBUS
+	bool "SBUS and UPA framebuffers"
+	depends on FB && (SPARC32 || SPARC64)
+	help
+	  Say Y if you want support for SBUS or UPA based frame buffer device.
+
+config FB_FFB
+	bool "Creator/Creator3D/Elite3D support"
+	depends on FB_SBUS && SPARC64
+	help
+	  This is the frame buffer device driver for the Creator, Creator3D,
+	  and Elite3D graphics boards.
+
+config FB_TCX
+	bool "TCX (SS4/SS5 only) support"
+	depends on FB_SBUS
+	help
+	  This is the frame buffer device driver for the TCX 24/8bit frame
+	  buffer.
+
+config FB_CG14
+	bool "CGfourteen (SX) support"
+	depends on FB_SBUS
+	help
+	  This is the frame buffer device driver for the CGfourteen frame
+	  buffer on Desktop SPARCsystems with the SX graphics option.
+
+config FB_P9100
+	bool "P9100 (Sparcbook 3 only) support"
+	depends on FB_SBUS
+	help
+	  This is the frame buffer device driver for the P9100 card
+	  supported on Sparcbook 3 machines.
+
+config FB_LEO
+	bool "Leo (ZX) support"
+	depends on FB_SBUS
+	help
+	  This is the frame buffer device driver for the SBUS-based Sun ZX
+	  (leo) frame buffer cards.
+
+config FB_PCI
+	bool "PCI framebuffers"
+	depends on FB && PCI && (SPARC64 || SPARC32)
+
+config FB_IGA
+	bool "IGA 168x display support"
+	depends on SPARC32 && FB_PCI
+	help
+	  This is the framebuffer device for the INTERGRAPHICS 1680 and
+	  successor frame buffer cards.
+
+config FB_HIT
+	tristate "HD64461 Frame Buffer support"
+	depends on FB && HD64461
+	help
+	  This is the frame buffer device driver for the Hitachi HD64461 LCD
+	  frame buffer card.
+
+config FB_PMAG_BA
+	bool "PMAG-BA TURBOchannel framebuffer support"
+	depends on FB && DECSTATION && TC
+	help
+	  Say Y here to directly support the on-board PMAG-BA framebuffer in
+	  the 5000/1xx versions of the DECstation.  There is a page dedicated
+	  to Linux on DECstations at <http://decstation.unix-ag.org/>.
+
+config FB_PMAGB_B
+	bool "PMAGB-B TURBOchannel framebuffer spport"
+	depends on FB && DECSTATION && TC
+	help
+	  Say Y here to directly support the on-board PMAGB-B framebuffer in
+	  the 5000/1xx versions of the DECstation.  There is a page dedicated
+	  to Linux on DECstations at <http://decstation.unix-ag.org/>.
+
+config FB_MAXINE
+	bool "Maxine (Personal DECstation) onboard framebuffer spport"
+	depends on FB && DECSTATION && TC
+	help
+	  Say Y here to directly support the on-board framebuffer in the
+	  Maxine (5000/20, /25, /33) version of the DECstation.  There is a
+	  page dedicated to Linux on DECstations at <http://decstation.unix-ag.org/>.
+
+config FB_TX3912
+	bool "TMPTX3912/PR31700 frame buffer support"
+	depends on FB && NINO
+	help
+	  The TX3912 is a Toshiba RISC processor based on the MIPS 3900 core
+	  see <http://www.toshiba.com/taec/components/Generic/risc/tx3912.htm>.
+
+	  Say Y here to enable kernel support for the on-board framebuffer.
+
+config FB_68328
+	bool "Motorola 68328 native frame buffer support"
+	depends on (M68328 || M68EZ328 || M68VZ328)
+	help
+	  Say Y here if you want to support the built-in frame buffer of
+	  the Motorola 68328 CPU family.
+
+config FB_PXA
+	tristate "PXA LCD framebuffer support"
+	depends on FB && ARCH_PXA
+	---help---
+	  Frame buffer driver for the built-in LCD controller in the Intel
+	  PXA2x0 processor.
+
+	  This driver is also available as a module ( = code which can be
+	  inserted and removed from the running kernel whenever you want). The
+	  module will be called vfb. If you want to compile it as a module,
+	  say M here and read <file:Documentation/modules.txt>.
+
+	  If unsure, say N.
+
+config FB_PXA_PARAMETERS
+	bool "PXA LCD command line parameters"
+	default n
+	depends on FB_PXA
+	---help---
+	  Enable the use of kernel command line or module parameters
+	  to configure the physical properties of the LCD panel when
+	  using the PXA LCD driver.
+
+	  This option allows you to override the panel parameters
+	  supplied by the platform in order to support multiple
+	  different models of flatpanel. If you will only be using a
+	  single model of flatpanel then you can safely leave this
+	  option disabled.
+
+	  Documentation/fb/pxafb.txt describes the available parameters.
+
+config FB_VIRTUAL
+	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
+	depends on FB
+	---help---
+	  This is a `virtual' frame buffer device. It operates on a chunk of
+	  unswappable kernel memory instead of on the memory of a graphics
+	  board. This means you cannot see any output sent to this frame
+	  buffer device, while it does consume precious memory. The main use
+	  of this frame buffer device is testing and debugging the frame
+	  buffer subsystem. Do NOT enable it for normal systems! To protect
+	  the innocent, it has to be enabled explicitly at boot time using the
+	  kernel option `video=vfb:'.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vfb.
+
+	  If unsure, say N.
+if VT
+	source "drivers/video/console/Kconfig"
+endif
+
+if FB || SGI_NEWPORT_CONSOLE
+	source "drivers/video/logo/Kconfig"
+endif
+
+endmenu
+
diff -burN linux-2.6.8.1-orig/drivers/video/Makefile linux-2.6.8.1/drivers/video/Makefile
--- linux-2.6.8.1-orig/drivers/video/Makefile	2004-08-14 19:54:50.000000000 +0900
+++ linux-2.6.8.1/drivers/video/Makefile	2007-01-24 13:19:57.000000000 +0900
@@ -6,6 +6,7 @@
 
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
+obj-$(CONFIG_BOOTSPLASH)	  += bootsplash/
 
 obj-$(CONFIG_FB)                  += fbmem.o fbmon.o fbcmap.o fbsysfs.o modedb.o softcursor.o
 # Only include macmodes.o if we have FB support and are PPC
@@ -29,6 +30,7 @@
 obj-$(CONFIG_FB_VALKYRIE)         += valkyriefb.o macmodes.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_CT65550)          += chipsfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_EP93XX)           += ep93xxfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_CYBER)            += cyberfb.o
 obj-$(CONFIG_FB_CYBER2000)        += cyber2000fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_GBE)              += gbefb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
diff -burN linux-2.6.8.1-orig/drivers/video/bootsplash/Kconfig linux-2.6.8.1/drivers/video/bootsplash/Kconfig
--- linux-2.6.8.1-orig/drivers/video/bootsplash/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/bootsplash/Kconfig	2007-01-24 13:19:57.000000000 +0900
@@ -0,0 +1,17 @@
+#
+# Bootsplash configuration
+#
+
+menu "Bootsplash configuration"
+
+config BOOTSPLASH
+	bool "Bootup splash screen"
+	depends on FRAMEBUFFER_CONSOLE=y && (REGPARM=n || X86_64 || !X86) && BLK_DEV_INITRD=y
+	default n
+        ---help---
+          This option enables the Linux bootsplash screen. For more 
+          information on the bootsplash screen have a look at 
+          http://www.bootsplash.org/.
+          If you are unsure, say N
+endmenu
+
diff -burN linux-2.6.8.1-orig/drivers/video/bootsplash/Makefile linux-2.6.8.1/drivers/video/bootsplash/Makefile
--- linux-2.6.8.1-orig/drivers/video/bootsplash/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/bootsplash/Makefile	2007-01-24 13:19:57.000000000 +0900
@@ -0,0 +1,5 @@
+# Makefile for the Linux bootsplash
+
+obj-$(CONFIG_BOOTSPLASH)		+= bootsplash.o
+obj-$(CONFIG_BOOTSPLASH)		+= decode-jpg.o
+obj-$(CONFIG_BOOTSPLASH)		+= render.o
diff -burN linux-2.6.8.1-orig/drivers/video/bootsplash/bootsplash.c linux-2.6.8.1/drivers/video/bootsplash/bootsplash.c
--- linux-2.6.8.1-orig/drivers/video/bootsplash/bootsplash.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/bootsplash/bootsplash.c	2007-01-24 13:19:57.000000000 +0900
@@ -0,0 +1,988 @@
+/* 
+ *           linux/drivers/video/bootsplash/bootsplash.c - 
+ *                 splash screen handling functions.
+ *	
+ *	(w) 2001-2003 by Volker Poplawski, <volker@poplawski.de>,
+ * 		    Stefan Reinauer, <stepan@suse.de>,
+ * 		    Steffen Winterfeldt, <snwint@suse.de>,
+ *                  Michael Schroeder <mls@suse.de>
+ * 		    
+ *        Ideas & SuSE screen work by Ken Wimer, <wimer@suse.de>
+ *
+ *  32 and 24bpp support & bugfixes by Michal Januszewski <spock@gentoo.org>
+ *
+ *  For more information on this code check http://www.bootsplash.org/
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/vt_kern.h>
+#include <linux/vmalloc.h>
+#include <linux/unistd.h>
+#include <linux/syscalls.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "../console/fbcon.h"
+#include "bootsplash.h"
+#include "decode-jpg.h"
+
+#define SPLASH_VERSION "3.1.4-2004/02/19-spock-0.1"
+
+/* These errors have to match fbcon-jpegdec.h */
+static unsigned char *jpg_errors[] = {
+	"no SOI found", 
+	"not 8 bit", 
+	"height mismatch", 
+	"width mismatch",
+	"bad width or height", 
+	"too many COMPPs", 
+	"illegal HV", 
+	"quant table selector",
+	"picture is not YCBCR 221111",
+	"unknow CID in scan",
+	"dct not sequential",
+	"wrong marker",
+	"no EOI",
+	"bad tables",
+	"depth mismatch"
+};
+
+static struct jpeg_decdata *decdata = 0; /* private decoder data */
+
+static int splash_registered = 0;
+static int splash_usesilent = 0;	/* shall we display the silentjpeg? */
+int splash_default = 0xf01;
+
+static int splash_check_jpeg(unsigned char *jpeg, int width, int height, int depth, struct fb_info *info);
+
+static int __init splash_setup(char *options)
+{
+	if(!strncmp("silent", options, 6)) {
+		printk(KERN_INFO "bootsplash: silent mode.\n");
+		splash_usesilent = 1;
+		/* skip "silent," */
+		if (strlen(options) == 6)
+			return 0;
+		options += 7;
+	}
+	if(!strncmp("verbose", options, 7)) {
+		printk(KERN_INFO "bootsplash: verbose mode.\n");
+		splash_usesilent = 0;
+		return 0;
+	}
+	splash_default = simple_strtoul(options, NULL, 0);
+	return 0;
+}
+
+__setup("splash=", splash_setup);
+
+
+static int splash_hasinter(unsigned char *buf, int num)
+{
+    unsigned char *bufend = buf + num * 12;
+    while(buf < bufend) {
+	if (buf[1] > 127)		/* inter? */
+	    return 1;
+	buf += buf[3] > 127 ? 24 : 12;	/* blend? */
+    }
+    return 0;
+}
+
+static int boxextract(unsigned char *buf, unsigned short *dp, unsigned char *cols, int *blendp)
+{
+    dp[0] = buf[0] | buf[1] << 8;
+    dp[1] = buf[2] | buf[3] << 8;
+    dp[2] = buf[4] | buf[5] << 8;
+    dp[3] = buf[6] | buf[7] << 8;
+    *(unsigned int *)(cols + 0) =
+	*(unsigned int *)(cols + 4) =
+	*(unsigned int *)(cols + 8) =
+	*(unsigned int *)(cols + 12) = *(unsigned int *)(buf + 8);
+    if (dp[1] > 32767) {
+	dp[1] = ~dp[1];
+	*(unsigned int *)(cols + 4) = *(unsigned int *)(buf + 12);
+	*(unsigned int *)(cols + 8) = *(unsigned int *)(buf + 16);
+	*(unsigned int *)(cols + 12) = *(unsigned int *)(buf + 20);
+	*blendp = 1;
+	return 24;
+    }
+    return 12;
+}
+
+static void boxit(unsigned char *pic, int bytes, unsigned char *buf, int num, int percent, int overpaint, int bpp, struct fb_info *info)
+{
+    int x, y, i, p, doblend, r, g, b, a, add;
+    unsigned short data1[4];
+    unsigned char cols1[16];
+    unsigned short data2[4];
+    unsigned char cols2[16];
+    unsigned char *bufend;
+	u8 *picp;
+    unsigned int stipple[32], sti, stin, stinn, stixs, stixe, stiys, stiye;
+    int xs, xe, ys, ye, xo, yo;
+    int rlen,glen,blen;
+	
+    if (num == 0)
+	return;
+    bufend = buf + num * 12;
+    stipple[0] = 0xffffffff;
+    stin = 1;
+    stinn = 0;
+    stixs = stixe = 0;
+    stiys = stiye = 0;
+    while(buf < bufend) {
+	doblend = 0;
+	buf += boxextract(buf, data1, cols1, &doblend);
+	if (data1[0] == 32767 && data1[1] == 32767) {
+	    /* box stipple */
+	    if (stinn == 32)
+		continue;
+	    if (stinn == 0) {
+		stixs = data1[2];
+		stixe = data1[3];
+		stiys = stiye = 0;
+	    } else if (stinn == 4) {
+		stiys = data1[2];
+		stiye = data1[3];
+	    }
+	    stipple[stinn++] = (cols1[ 0] << 24) | (cols1[ 1] << 16) | (cols1[ 2] << 8) | cols1[ 3] ;
+	    stipple[stinn++] = (cols1[ 4] << 24) | (cols1[ 5] << 16) | (cols1[ 6] << 8) | cols1[ 7] ;
+	    stipple[stinn++] = (cols1[ 8] << 24) | (cols1[ 9] << 16) | (cols1[10] << 8) | cols1[11] ;
+	    stipple[stinn++] = (cols1[12] << 24) | (cols1[13] << 16) | (cols1[14] << 8) | cols1[15] ;
+	    stin = stinn;
+	    continue;
+	}
+	stinn = 0;
+	if (data1[0] > 32767)
+	    buf += boxextract(buf, data2, cols2, &doblend);
+	if (data1[0] == 32767 && data1[1] == 32766) {
+	    /* box copy */
+	    i = 12 * (short)data1[3];
+	    doblend = 0;
+	    i += boxextract(buf + i, data1, cols1, &doblend);
+	    if (data1[0] > 32767)
+		boxextract(buf + i, data2, cols2, &doblend);
+	}
+	if (data1[0] == 32767)
+	    continue;
+	if (data1[2] > 32767) {
+	    if (overpaint)
+		continue;
+	    data1[2] = ~data1[2];
+	}
+	if (data1[3] > 32767) {
+	    if (percent == 65536)
+		continue;
+	    data1[3] = ~data1[3];
+	}
+	if (data1[0] > 32767) {
+	    data1[0] = ~data1[0];
+	    for (i = 0; i < 4; i++)
+		data1[i] = (data1[i] * (65536 - percent) + data2[i] * percent) >> 16;
+	    for (i = 0; i < 16; i++)
+		cols1[i] = (cols1[i] * (65536 - percent) + cols2[i] * percent) >> 16;
+	}
+	*(unsigned int *)cols2 = *(unsigned int *)cols1;
+	a = cols2[3];
+	if (a == 0 && !doblend)
+	    continue;
+
+	if (stixs >= 32768) {
+	    xo = xs = (stixs ^ 65535) + data1[0];
+	    xe = stixe ? stixe + data1[0] : data1[2];
+	} else if (stixe >= 32768) {
+	    xs = stixs ? data1[2] - stixs : data1[0];
+	    xe = data1[2] - (stixe ^ 65535);
+	    xo = xe + 1;
+	} else {
+	    xo = xs = stixs;
+	    xe = stixe ? stixe : data1[2];
+	}
+	if (stiys >= 32768) {
+	    yo = ys = (stiys ^ 65535) + data1[1];
+	    ye = stiye ? stiye + data1[1] : data1[3];
+	} else if (stiye >= 32768) {
+	    ys = stiys ? data1[3] - stiys : data1[1];
+	    ye = data1[3] - (stiye ^ 65535);
+	    yo = ye + 1;
+	} else {
+	    yo = ys = stiys;
+	    ye = stiye ? stiye : data1[3];
+	}
+	xo = 32 - (xo & 31);
+	yo = stin - (yo % stin);
+	if (xs < data1[0])
+	    xs = data1[0];
+	if (xe > data1[2])
+	    xe = data1[2];
+	if (ys < data1[1])
+	    ys = data1[1];
+	if (ye > data1[3])
+	    ye = data1[3];
+
+	if (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+		blen = glen = rlen = min(min(info->var.red.length,info->var.green.length),info->var.blue.length);
+	} else {
+		rlen = info->var.red.length;
+		glen = info->var.green.length;
+		blen = info->var.blue.length;
+	}
+
+	for (y = ys; y <= ye; y++) {
+		sti = stipple[(y + yo) % stin];
+		x = (xs + xo) & 31;
+		if (x)
+			sti = (sti << x) | (sti >> (32 - x));
+		if (doblend) {
+			if ((p = data1[3] - data1[1]) != 0)
+				p = ((y - data1[1]) << 16) / p;
+			for (i = 0; i < 8; i++)
+				cols2[i + 8] = (cols1[i] * (65536 - p) + cols1[i + 8] * p) >> 16;
+		}
+		add = (xs & 1);
+		add ^= (add ^ y) & 1 ? 1 : 3;		/* 2x2 ordered dithering */
+
+		picp = pic + xs * (bpp >> 3) + y * bytes;
+		for (x = xs; x <= xe; x++) {
+			if (!(sti & 0x80000000)) {
+				sti <<= 1;
+				picp += (bpp >> 3);
+				add ^= 3;
+				continue;
+			}
+			sti = (sti << 1) | 1;
+			if (doblend) {
+				if ((p = data1[2] - data1[0]) != 0)
+					p = ((x - data1[0]) << 16) / p;
+				for (i = 0; i < 4; i++)
+					cols2[i] = (cols2[i + 8] * (65536 - p) + cols2[i + 12] * p) >> 16;
+				a = cols2[3];
+			}
+			r = cols2[0];
+			g = cols2[1];
+			b = cols2[2];
+				
+			if (a != 255) {
+			
+				if (bpp == 16) { 
+					i = *(u16*)picp;
+				} else if (bpp == 24) {
+					i = *(u32*)picp & 0xffffff;
+				} else if (bpp == 32) {
+					i = *(u32*)picp;
+				} else {
+					i = *(u32*)picp & ((2 << bpp)-1);
+				}
+
+				r = (( (i >> info->var.red.offset & ((1 << rlen)-1)) 
+				      << (8 - rlen)) * (255 - a) + r * a) / 255;
+				g = (( (i >> info->var.green.offset & ((1 << glen)-1)) 
+				      << (8 - glen)) * (255 - a) + g * a) / 255;
+				b = (( (i >> info->var.blue.offset & ((1 << blen)-1)) 
+				      << (8 - blen)) * (255 - a) + b * a) / 255;
+			}
+
+#define CLAMP(x) ((x) >= 256 ? 255 : (x))
+		
+			r = CLAMP(r + add*2+1) >> (8 - rlen);
+			g = CLAMP(g + add) >> (8 - glen);
+			b = CLAMP(b + add*2+1) >> (8 - blen);
+
+			i = (r << info->var.red.offset) |
+		 	    (g << info->var.green.offset) |
+			    (b << info->var.blue.offset);
+
+			if (bpp == 16) {
+				*(u16*)picp = i;
+				picp += 2;
+			} else if (bpp == 24) {
+#ifdef __LITTLE_ENDIAN
+				*(u16*)picp = i & 0xffff;
+				picp[2] = (i >> 16) & 0xff;
+#else
+				*(u16*)picp = (i >> 8) & 0xffff;
+				picp[2] = i & 0xff;
+#endif
+				picp += 3;
+			} else if (bpp == 32) {
+				*(u32*)picp = i;
+				picp += 4;
+			}	
+			
+			add ^= 3;
+		}
+	}
+    }
+}
+
+static int splash_check_jpeg(unsigned char *jpeg, int width, int height, int depth, struct fb_info *info)
+{
+    int size, err;
+    unsigned char *mem;
+
+    size = ((width + 15) & ~15) * ((height + 15) & ~15) * (depth >> 3);
+    mem = vmalloc(size);
+    if (!mem) {
+	printk(KERN_INFO "bootsplash: no memory for decoded picture.\n");
+	return -1;
+    }
+    
+    if (!decdata)
+	decdata = vmalloc(sizeof(*decdata));
+    if ((err = jpeg_decode(jpeg, mem, ((width + 15) & ~15), ((height + 15) & ~15), depth, decdata, info)))
+	  printk(KERN_INFO "bootsplash: error while decompressing picture: %s (%d)\n",jpg_errors[err - 1], err);
+    vfree(mem);
+    return err ? -1 : 0;
+}
+
+static void splash_free(struct vc_data *vc, struct fb_info *info)
+{
+    if (!vc->vc_splash_data)
+	return;
+    if (info->silent_screen_base)
+	    info->screen_base = info->silent_screen_base;
+    info->silent_screen_base = 0;
+    if (vc->vc_splash_data->splash_silentjpeg)
+	    vfree(vc->vc_splash_data->splash_sboxes);
+    vfree(vc->vc_splash_data);
+    vc->vc_splash_data = 0;
+    info->splash_data = 0;
+}
+
+static int splash_mkpenguin(struct splash_data *data, int pxo, int pyo, int pwi, int phe, int pr, int pg, int pb)
+{
+    unsigned char *buf;
+    int i;
+
+    if (pwi ==0 || phe == 0)
+	return 0;
+    buf = (unsigned char *)data + sizeof(*data);
+    pwi += pxo - 1;
+    phe += pyo - 1;
+    *buf++ = pxo;
+    *buf++ = pxo >> 8;
+    *buf++ = pyo;
+    *buf++ = pyo >> 8;
+    *buf++ = pwi;
+    *buf++ = pwi >> 8;
+    *buf++ = phe;
+    *buf++ = phe >> 8;
+    *buf++ = pr;
+    *buf++ = pg;
+    *buf++ = pb;
+    *buf++ = 0;
+    for (i = 0; i < 12; i++, buf++)
+	*buf = buf[-12];
+    buf[-24] ^= 0xff;
+    buf[-23] ^= 0xff;
+    buf[-1] = 0xff;
+    return 2;
+}
+
+static const int splash_offsets[3][16] = {
+    /* len, unit, size, state, fgcol, col, xo, yo, wi, he
+       boxcnt, ssize, sboxcnt, percent, overok, palcnt */
+    /* V1 */
+    {   20,   -1,   16,    -1,    -1,  -1,  8, 10, 12, 14,
+           -1,    -1,      -1,      -1,     -1,     -1 },
+    /* V2 */
+    {   35,    8,   12,     9,    10,  11, 16, 18, 20, 22,
+           -1,    -1,      -1,      -1,     -1,     -1 },
+    /* V3 */
+    {   38,    8,   12,     9,    10,  11, 16, 18, 20, 22,
+           24,    28,      32,      34,     36,     37 },
+};
+
+#define SPLASH_OFF_LEN     offsets[0]
+#define SPLASH_OFF_UNIT    offsets[1]
+#define SPLASH_OFF_SIZE    offsets[2]
+#define SPLASH_OFF_STATE   offsets[3]
+#define SPLASH_OFF_FGCOL   offsets[4]
+#define SPLASH_OFF_COL     offsets[5]
+#define SPLASH_OFF_XO      offsets[6]
+#define SPLASH_OFF_YO      offsets[7]
+#define SPLASH_OFF_WI      offsets[8]
+#define SPLASH_OFF_HE      offsets[9]
+#define SPLASH_OFF_BOXCNT  offsets[10]
+#define SPLASH_OFF_SSIZE   offsets[11]
+#define SPLASH_OFF_SBOXCNT offsets[12]
+#define SPLASH_OFF_PERCENT offsets[13]
+#define SPLASH_OFF_OVEROK  offsets[14]
+#define SPLASH_OFF_PALCNT  offsets[15]
+
+static inline int splash_getb(unsigned char *pos, int off)
+{
+    return off == -1 ? 0 : pos[off];
+}
+
+static inline int splash_gets(unsigned char *pos, int off)
+{
+    return off == -1 ? 0 : pos[off] | pos[off + 1] << 8;
+}
+
+static inline int splash_geti(unsigned char *pos, int off)
+{
+    return off == -1 ? 0 :
+           pos[off] | pos[off + 1] << 8 | pos[off + 2] << 16 | pos[off + 3] << 24;
+}
+
+static int splash_getraw(unsigned char *start, unsigned char *end)
+{
+    unsigned char *ndata;
+    int version;
+    int splash_size;
+    int unit;
+    int width, height;
+    int silentsize;
+    int boxcnt;
+    int sboxcnt;
+    int palcnt;
+    int i, len;
+    const int *offsets;
+    struct vc_data *vc;
+    struct fb_info *info;
+    struct splash_data *sd;
+
+    printk(KERN_INFO "bootsplash %s: looking for picture...", SPLASH_VERSION);
+
+    for (ndata = start; ndata < end; ndata++) {
+	if (ndata[0] != 'B' || ndata[1] != 'O' || ndata[2] != 'O' || ndata[3] != 'T')
+	    continue;
+	if (ndata[4] != 'S' || ndata[5] != 'P' || ndata[6] != 'L' || ndata[7] < '1' || ndata[7] > '3')
+	    continue;
+	printk(".");
+	version = ndata[7] - '0';
+	offsets = splash_offsets[version - 1];
+	len = SPLASH_OFF_LEN;
+	unit = splash_getb(ndata, SPLASH_OFF_UNIT);
+	if (unit >= MAX_NR_CONSOLES)
+	    continue;
+	if (unit) {
+		acquire_console_sem();
+		vc_allocate(unit);
+		release_console_sem();
+	}
+	vc = vc_cons[unit].d;
+	info = registered_fb[(int)con2fb_map[unit]];
+	width = info->var.xres;
+	height = info->var.yres;
+	splash_size = splash_geti(ndata, SPLASH_OFF_SIZE);
+	if (splash_size == (int)0xffffffff && version > 1) {
+	    printk(" found, updating values.\n");
+	    if ((sd = vc->vc_splash_data) != 0) {
+		i = splash_getb(ndata, SPLASH_OFF_STATE);
+		if (i != 255)
+		    sd->splash_state = i;
+		i = splash_getb(ndata, SPLASH_OFF_FGCOL);
+		if (i != 255)
+		    sd->splash_fg_color = i;
+		i = splash_getb(ndata, SPLASH_OFF_COL);
+		if (i != 255)
+		    sd->splash_color = i;
+	    }
+	    return unit;
+	}
+	if (splash_size == 0) {
+	    printk(" found, freeing memory.\n");
+	    if (vc->vc_splash_data)
+		splash_free(vc, info);
+	    return unit;
+	}
+	boxcnt = splash_gets(ndata, SPLASH_OFF_BOXCNT);
+	palcnt = 3 * splash_getb(ndata, SPLASH_OFF_PALCNT);
+	if (ndata + len + splash_size > end) {
+	    printk(" found, but truncated!\n");
+	    return -1;
+	}
+	if (!jpeg_check_size(ndata + len + boxcnt * 12 + palcnt, width, height)) {
+	    ndata += len + splash_size - 1;
+	    continue;
+	}
+	if (splash_check_jpeg(ndata + len + boxcnt * 12 + palcnt, width, height, info->var.bits_per_pixel, info))
+	    return -1;
+	silentsize = splash_geti(ndata, SPLASH_OFF_SSIZE);
+	if (silentsize)
+	    printk(" silentjpeg size %d bytes,", silentsize);
+	if (silentsize >= splash_size) {
+	    printk(" bigger than splashsize!\n");
+	    return -1;
+	}
+	splash_size -= silentsize;
+	if (!splash_usesilent)
+	    silentsize = 0;
+	else if (height * 2 * info->fix.line_length > info->fix.smem_len) {
+	    printk(" does not fit into framebuffer.\n");
+	    silentsize = 0;
+	}
+	sboxcnt = splash_gets(ndata, SPLASH_OFF_SBOXCNT);
+	if (silentsize) {
+	    unsigned char *simage = ndata + len + splash_size + 12 * sboxcnt;
+	    if (!jpeg_check_size(simage, width, height) ||
+		splash_check_jpeg(simage, width, height, info->var.bits_per_pixel, info)) {
+		    printk(" error in silent jpeg.\n");
+		    silentsize = 0;
+		}
+	}
+	if (vc->vc_splash_data)
+	    splash_free(vc, info);
+	vc->vc_splash_data = sd = vmalloc(sizeof(*sd) + splash_size + (version < 3 ? 2 * 12 : 0));
+	if (!sd)
+	    break;
+	sd->splash_silentjpeg = 0;
+	sd->splash_sboxes = 0;
+	sd->splash_sboxcount = 0;
+	if (silentsize) {
+	    sd->splash_silentjpeg = vmalloc(silentsize);
+	    if (sd->splash_silentjpeg) {
+		memcpy(sd->splash_silentjpeg, ndata + len + splash_size, silentsize);
+		sd->splash_sboxes = vc->vc_splash_data->splash_silentjpeg;
+		sd->splash_silentjpeg += 12 * sboxcnt;
+		sd->splash_sboxcount = sboxcnt;
+	    }
+	}
+	sd->splash_state = splash_getb(ndata, SPLASH_OFF_STATE);
+	sd->splash_fg_color = splash_getb(ndata, SPLASH_OFF_FGCOL);
+	sd->splash_color = splash_getb(ndata, SPLASH_OFF_COL);
+	sd->splash_overpaintok = splash_getb(ndata, SPLASH_OFF_OVEROK);
+	sd->splash_text_xo = splash_gets(ndata, SPLASH_OFF_XO);
+	sd->splash_text_yo = splash_gets(ndata, SPLASH_OFF_YO);
+	sd->splash_text_wi = splash_gets(ndata, SPLASH_OFF_WI);
+	sd->splash_text_he = splash_gets(ndata, SPLASH_OFF_HE);
+	sd->splash_percent = splash_gets(ndata, SPLASH_OFF_PERCENT);
+	if (version == 1) {
+	    sd->splash_text_xo *= 8;
+	    sd->splash_text_wi *= 8;
+	    sd->splash_text_yo *= 16;
+	    sd->splash_text_he *= 16;
+	    sd->splash_color    = (splash_default >> 8) & 0x0f;
+	    sd->splash_fg_color = (splash_default >> 4) & 0x0f;
+	    sd->splash_state    = splash_default & 1;
+	}
+	if (sd->splash_text_xo + sd->splash_text_wi > width || sd->splash_text_yo + sd->splash_text_he > height) {
+	    splash_free(vc, info);
+	    printk(" found, but has oversized text area!\n");
+	    return -1;
+	}
+	if (!vc_cons[unit].d) {
+	    splash_free(vc, info);
+	    printk(" found, but framebuffer can't handle it!\n");
+	    return -1;
+	}
+	printk(" found (%dx%d, %d bytes, v%d).\n", width, height, splash_size, version);
+	if (version == 1) {
+	    printk(KERN_WARNING "bootsplash: Using deprecated v1 header. Updating your splash utility recommended.\n");
+	    printk(KERN_INFO    "bootsplash: Find the latest version at http://www.bootsplash.org/\n");
+	}
+
+	/* fake penguin box for older formats */
+	if (version == 1)
+	    boxcnt = splash_mkpenguin(sd, sd->splash_text_xo + 10, sd->splash_text_yo + 10, sd->splash_text_wi - 20, sd->splash_text_he - 20, 0xf0, 0xf0, 0xf0);
+	else if (version == 2)
+	    boxcnt = splash_mkpenguin(sd, splash_gets(ndata, 24), splash_gets(ndata, 26), splash_gets(ndata, 28), splash_gets(ndata, 30), splash_getb(ndata, 32), splash_getb(ndata, 33), splash_getb(ndata, 34));
+
+	memcpy((char *)sd + sizeof(*sd) + (version < 3 ? boxcnt * 12 : 0), ndata + len, splash_size);
+	sd->splash_boxcount = boxcnt;
+	sd->splash_boxes = (unsigned char *)sd + sizeof(*sd);
+	sd->splash_palette = sd->splash_boxes + boxcnt * 12;
+	sd->splash_jpeg = sd->splash_palette + palcnt;
+	sd->splash_palcnt = palcnt / 3;
+	sd->splash_dosilent = sd->splash_silentjpeg != 0;
+	return unit;
+    }
+    printk(" no good signature found.\n");
+    return -1;
+}
+
+int splash_verbose(void) 
+{
+    struct vc_data *vc;
+    struct fb_info *info;
+
+    if (!splash_usesilent)
+        return 0;
+
+    vc = vc_cons[0].d;
+
+    if (!vc || !vc->vc_splash_data || !vc->vc_splash_data->splash_state)
+	return 0;
+    if (fg_console != vc->vc_num)
+	return 0;
+    if (!vc->vc_splash_data->splash_silentjpeg || !vc->vc_splash_data->splash_dosilent)
+	return 0;
+    vc->vc_splash_data->splash_dosilent = 0;
+    info = registered_fb[(int)con2fb_map[0]];
+    if (!info->silent_screen_base)
+	return 0;
+    splashcopy(info->silent_screen_base, info->screen_base, info->var.yres, info->var.xres, info->fix.line_length, info->fix.line_length, info->var.bits_per_pixel);
+    info->screen_base = info->silent_screen_base;
+    info->silent_screen_base = 0;
+    return 1;
+}
+
+static void splash_off(struct fb_info *info)
+{
+	if (info->silent_screen_base)
+		info->screen_base = info->silent_screen_base;
+	info->silent_screen_base = 0;
+	info->splash_data = 0;
+	if (info->splash_pic)
+		vfree(info->splash_pic);
+	info->splash_pic = 0;
+	info->splash_pic_size = 0;
+}
+
+int splash_prepare(struct vc_data *vc, struct fb_info *info)
+{
+	int err;
+        int width, height, depth, size, sbytes;
+
+	if (!vc->vc_splash_data || !vc->vc_splash_data->splash_state) {
+		if (decdata)
+			vfree(decdata);
+		decdata = 0;
+		splash_off(info);
+		return -1;
+	}
+
+        width = info->var.xres;
+        height = info->var.yres;
+        depth = info->var.bits_per_pixel;
+
+	sbytes = ((width + 15) & ~15) * (depth >> 3);
+	size = sbytes * ((height + 15) & ~15);
+	if (size != info->splash_pic_size)
+		splash_off(info);
+	if (!info->splash_pic)
+		info->splash_pic = vmalloc(size);
+
+	if (!info->splash_pic) {
+		printk(KERN_INFO "bootsplash: not enough memory.\n");
+		splash_off(info);
+		return -3;
+	}
+
+	if (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+	
+		u16 red[240], green[240], blue[240];
+		int i;
+	
+		struct fb_cmap cmap = {
+			.start = 16,
+			.len = (1 << min(min(info->var.red.length, info->var.green.length), info->var.blue.length)) - 16,
+			.red = red,
+			.green = green,
+			.blue = blue,
+			.transp = NULL
+		};
+	
+		for (i = 0; i < cmap.len; i++) {
+			red[i] = green[i] = blue[i] = (0xffff * i)/(cmap.len-1);
+		}
+		
+		fb_set_cmap(&cmap,info);
+	}
+
+	if (!decdata)
+		decdata = vmalloc(sizeof(*decdata));
+
+	if (vc->vc_splash_data->splash_silentjpeg && vc->vc_splash_data->splash_dosilent) {
+		/* fill area after framebuffer with other jpeg */
+		if ((err = jpeg_decode(vc->vc_splash_data->splash_silentjpeg, info->splash_pic, 
+			 ((width + 15) & ~15), ((height + 15) & ~15), depth, decdata, info))) {
+			printk(KERN_INFO "bootsplash: error while decompressing silent picture: %s (%d)\n", jpg_errors[err - 1], err);
+			if (info->silent_screen_base)
+				info->screen_base = info->silent_screen_base;
+			vc->vc_splash_data->splash_dosilent = 0;
+		} else {
+			if (vc->vc_splash_data->splash_sboxcount)
+				boxit(info->splash_pic, sbytes, vc->vc_splash_data->splash_sboxes, 
+					vc->vc_splash_data->splash_sboxcount, vc->vc_splash_data->splash_percent, 0, info->var.bits_per_pixel, info);
+
+			if (!info->silent_screen_base)
+				info->silent_screen_base = info->screen_base;
+			splashcopy(info->silent_screen_base, info->splash_pic, info->var.yres, info->var.xres, info->fix.line_length, sbytes, info->var.bits_per_pixel);
+			info->screen_base = info->silent_screen_base + info->fix.line_length * info->var.yres;
+		}
+	} else if (info->silent_screen_base)
+		info->screen_base = info->silent_screen_base;
+
+	if ((err = jpeg_decode(vc->vc_splash_data->splash_jpeg, info->splash_pic, 
+		 ((width + 15) & ~15), ((height + 15) & ~15), depth, decdata, info))) {
+		printk(KERN_INFO "bootsplash: error while decompressing picture: %s (%d) .\n", jpg_errors[err - 1], err);
+		splash_off(info);
+		return -4;
+	}
+	info->splash_pic_size = size;
+	info->splash_bytes = sbytes;
+	if (vc->vc_splash_data->splash_boxcount)
+		boxit(info->splash_pic, sbytes, vc->vc_splash_data->splash_boxes, vc->vc_splash_data->splash_boxcount, vc->vc_splash_data->splash_percent, 0, info->var.bits_per_pixel, info);
+	if (vc->vc_splash_data->splash_state)
+		info->splash_data = vc->vc_splash_data;
+	else
+		splash_off(info);
+	return 0;
+}
+
+
+#ifdef CONFIG_PROC_FS
+
+#include <linux/proc_fs.h>
+
+static int splash_read_proc(char *buffer, char **start, off_t offset, int size,
+			int *eof, void *data);
+static int splash_write_proc(struct file *file, const char *buffer,
+			unsigned long count, void *data);
+static int splash_status(struct vc_data *vc);
+static int splash_recolor(struct vc_data *vc);
+static int splash_proc_register(void);
+
+static struct proc_dir_entry *proc_splash;
+
+static int splash_recolor(struct vc_data *vc)
+{
+	if (!vc->vc_splash_data)
+	    return -1;
+	if (!vc->vc_splash_data->splash_state)
+	    return 0;
+	con_remap_def_color(vc->vc_num, vc->vc_splash_data->splash_color << 4 | vc->vc_splash_data->splash_fg_color);
+	if (fg_console == vc->vc_num) {
+		update_region(fg_console,
+			      vc->vc_origin + vc->vc_size_row * vc->vc_top,
+			      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2); /* FIXME? */
+	}
+	return 0;
+}
+
+static int splash_status(struct vc_data *vc)
+{
+	struct fb_info *info;
+	printk(KERN_INFO "bootsplash: status on console %d changed to %s\n", vc->vc_num, vc->vc_splash_data && vc->vc_splash_data->splash_state ? "on" : "off");
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	if (fg_console == vc->vc_num)
+		splash_prepare(vc, info);
+	if (vc->vc_splash_data && vc->vc_splash_data->splash_state) {
+		con_remap_def_color(vc->vc_num, vc->vc_splash_data->splash_color << 4 | vc->vc_splash_data->splash_fg_color);
+		acquire_console_sem();
+		/* vc_resize also calls con_switch which resets yscroll */
+		vc_resize(vc->vc_num, vc->vc_splash_data->splash_text_wi / vc->vc_font.width, vc->vc_splash_data->splash_text_he / vc->vc_font.height);
+		if (fg_console == vc->vc_num) {
+			update_region(fg_console,
+				      vc->vc_origin + vc->vc_size_row * vc->vc_top,
+				      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2);
+			splash_clear_margins(vc->vc_splash_data, vc, info, 0);
+		}
+		release_console_sem();
+	} else {
+	  	/* Switch bootsplash off */
+		con_remap_def_color(vc->vc_num, 0x07);
+		acquire_console_sem();
+		vc_resize(vc->vc_num, info->var.xres / vc->vc_font.width, info->var.yres / vc->vc_font.height);
+		release_console_sem();
+	}
+	return 0;
+}
+
+static int splash_read_proc(char *buffer, char **start, off_t offset, int size,
+			int *eof, void *data)
+{
+	int len = 0;
+	off_t begin = 0;
+	struct vc_data *vc = vc_cons[0].d;
+	struct fb_info *info = registered_fb[(int)con2fb_map[0]];
+	int color = vc->vc_splash_data ? vc->vc_splash_data->splash_color << 4 |
+			vc->vc_splash_data->splash_fg_color : splash_default >> 4;
+	int status = vc->vc_splash_data ? vc->vc_splash_data->splash_state & 1 : 0;
+	len += sprintf(buffer + len, "Splash screen v%s (0x%02x, %dx%d%s): %s\n",
+		        SPLASH_VERSION, color, info->var.xres, info->var.yres,
+			(vc->vc_splash_data ?  vc->vc_splash_data->splash_dosilent : 0)? ", silent" : "",
+					status ? "on" : "off");
+	if (offset >= begin + len)
+		return 0;
+
+	*start = buffer + (begin - offset);
+
+	return (size < begin + len - offset ? size : begin + len - offset);
+}
+
+static int splash_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+        int new, unit;
+	struct vc_data *vc;
+	
+	if (!buffer || !splash_default)
+		return count;
+
+	if (!strncmp(buffer, "show", 4) || !strncmp(buffer, "hide", 4)) {
+		int pe, oldpe;
+
+		vc = vc_cons[0].d;
+		if (buffer[4] == ' ' && buffer[5] == 'p')
+			pe = 0;
+		else if (buffer[4] == '\n')
+			pe = 65535;
+		else
+			pe = simple_strtoul(buffer + 5, NULL, 0);
+		if (pe < 0)
+			pe = 0;
+		if (pe > 65535)
+			pe = 65535;
+		if (*buffer == 'h')
+			pe = 65535 - pe;
+		pe += pe > 32767;
+		if (vc->vc_splash_data && vc->vc_splash_data->splash_percent != pe) {
+			struct fb_info *info;
+
+			oldpe = vc->vc_splash_data->splash_percent;
+			vc->vc_splash_data->splash_percent = pe;
+			if (fg_console != 0 || !vc->vc_splash_data->splash_state)
+			    return count;
+			info = registered_fb[(int) con2fb_map[vc->vc_num]];
+			if (!vc->vc_splash_data->splash_overpaintok || pe == 65536 || pe < oldpe) {
+				if (splash_hasinter(vc->vc_splash_data->splash_boxes, vc->vc_splash_data->splash_boxcount))
+					splash_status(vc);
+				else
+					splash_prepare(vc, info);
+			} else {
+				if (vc->vc_splash_data->splash_silentjpeg && vc->vc_splash_data->splash_dosilent && info->silent_screen_base)
+					boxit(info->silent_screen_base, info->fix.line_length, vc->vc_splash_data->splash_sboxes, vc->vc_splash_data->splash_sboxcount, vc->vc_splash_data->splash_percent, 1, info->var.bits_per_pixel, info);
+				boxit(info->screen_base, info->fix.line_length, vc->vc_splash_data->splash_boxes, vc->vc_splash_data->splash_boxcount, vc->vc_splash_data->splash_percent, 1, info->var.bits_per_pixel, info);
+			}
+		}
+		return count;
+	}
+	if (!strncmp(buffer,"silent\n",7) || !strncmp(buffer,"verbose\n",8)) {
+		vc = vc_cons[0].d;
+		if (vc->vc_splash_data && vc->vc_splash_data->splash_silentjpeg) {
+		    if (vc->vc_splash_data->splash_dosilent != (buffer[0] == 's')) {
+			vc->vc_splash_data->splash_dosilent = buffer[0] == 's';
+			splash_status(vc);
+		    }
+		}
+		return count;
+	}
+	if (!strncmp(buffer,"freesilent\n",11)) {
+		vc = vc_cons[0].d;
+		if (vc->vc_splash_data && vc->vc_splash_data->splash_silentjpeg) {
+		    printk(KERN_INFO "bootsplash: freeing silent jpeg\n");
+		    vc->vc_splash_data->splash_silentjpeg = 0;
+		    vfree(vc->vc_splash_data->splash_sboxes);
+		    vc->vc_splash_data->splash_sboxes = 0;
+		    vc->vc_splash_data->splash_sboxcount = 0;
+		    if (vc->vc_splash_data->splash_dosilent)
+			splash_status(vc);
+		    vc->vc_splash_data->splash_dosilent = 0;
+		}
+		return count;
+	}
+
+	if (!strncmp(buffer, "BOOTSPL", 7)) {
+	    unit = splash_getraw((unsigned char *)buffer, (unsigned char *)buffer + count);
+	    if (unit >= 0) {
+		vc = vc_cons[unit].d;
+		splash_status(vc);
+	    }
+	    return count;
+	}
+	vc = vc_cons[0].d;
+	if (!vc->vc_splash_data)
+		return count;
+	if (buffer[0] == 't') {
+	        vc->vc_splash_data->splash_state ^= 1;
+		splash_status(vc);
+		return count;
+	}
+	new = simple_strtoul(buffer, NULL, 0);
+	if (new > 1) {
+		/* expert user */
+		vc->vc_splash_data->splash_color    = new >> 8 & 0xff;
+		vc->vc_splash_data->splash_fg_color = new >> 4 & 0x0f;
+	}
+	if ((new & 1) == vc->vc_splash_data->splash_state)
+		splash_recolor(vc);
+	else {
+		vc->vc_splash_data->splash_state = new & 1;
+		splash_status(vc);
+	}
+	return count;
+}
+
+static int splash_proc_register(void)
+{
+	if ((proc_splash = create_proc_entry("splash", 0, 0))) {
+		proc_splash->read_proc = splash_read_proc;
+		proc_splash->write_proc = splash_write_proc;
+		return 0;
+	}
+	return 1;
+}
+
+# if 0
+static int splash_proc_unregister(void)
+{
+	if (proc_splash)
+		remove_proc_entry("splash", 0);
+	return 0;
+}
+# endif
+#endif	/* CONFIG_PROC_FS */
+
+void splash_init(void)
+{
+	struct fb_info *info;
+	struct vc_data *vc;
+	int isramfs = 1;
+	int fd;
+	int len;
+	int max_len = 1024*1024*2;
+	char *mem;
+
+	if (splash_registered)
+		return;
+	vc = vc_cons[0].d;
+	info = registered_fb[0];
+	if (!vc || !info)
+		return;
+#ifdef CONFIG_PROC_FS
+	splash_proc_register();
+#endif
+	splash_registered = 1;
+	if (vc->vc_splash_data)
+		return;
+	if ((fd = sys_open("/bootsplash", O_RDONLY, 0)) < 0) {
+		isramfs = 0;
+		fd = sys_open("/initrd.image", O_RDONLY, 0);
+	}
+	if (fd < 0)
+		return;
+	if ((len = (int)sys_lseek(fd, (off_t)0, 2)) <= 0) {
+		sys_close(fd);
+		return;
+	}
+	/* Don't look for more than the last 2MB */
+	if (len > max_len) {
+		printk( KERN_INFO "bootsplash: scanning last %dMB of initrd for signature\n",
+				max_len>>20);
+		sys_lseek(fd, (off_t)(len - max_len), 0);
+		len = max_len;
+	} else {
+		sys_lseek(fd, (off_t)0, 0);
+	}
+
+	mem = vmalloc(len);
+	if (mem) {
+		if ((int)sys_read(fd, mem, len) == len && splash_getraw((unsigned char *)mem, (unsigned char *)mem + len) == 0 && vc->vc_splash_data)
+			vc->vc_splash_data->splash_state = splash_default & 1;
+		vfree(mem);
+	}
+	sys_close(fd);
+	if (isramfs)
+		sys_unlink("/bootsplash");
+	return;
+}
+
diff -burN linux-2.6.8.1-orig/drivers/video/bootsplash/bootsplash.h linux-2.6.8.1/drivers/video/bootsplash/bootsplash.h
--- linux-2.6.8.1-orig/drivers/video/bootsplash/bootsplash.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/bootsplash/bootsplash.h	2007-01-24 13:19:57.000000000 +0900
@@ -0,0 +1,44 @@
+/* 
+ *    linux/drivers/video/bootsplash/bootsplash.h - splash screen definition.
+ *	
+ *	(w) 2001-2003 by Volker Poplawski, <volker@poplawski.de>
+ * 		    Stefan Reinauer, <stepan@suse.de>
+ * 		    
+ * 		    
+ * 	idea and SuSE screen work by Ken Wimer, <wimer@suse.de>
+ */
+
+#ifndef __BOOTSPLASH_H
+#define __BOOTSPLASH_H
+
+struct fb_info;
+
+/* splash.c */
+extern int splash_prepare(struct vc_data *, struct fb_info *);
+extern void splash_init(void);
+
+/* splash_render.c */
+extern void splash_putcs(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			const unsigned short *s, int count, int ypos, int xpos);
+extern void splash_putc(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int c, int ypos, int xpos);
+extern void splashcopy(u8 *dst, u8 *src, int height, int width, int dstbytes, int srcbytes, int bpp);
+extern void splash_clear(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy,
+			int sx, int height, int width);
+extern void splash_bmove(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy, 
+			int sx, int dy, int dx, int height, int width);
+extern void splash_clear_margins(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int bottom_only);
+extern void splash_cursor(struct splash_data *sd, struct fb_info *info, struct fb_cursor *cursor);
+extern void splash_bmove_redraw(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int y, int sx, int dx, int width);
+extern void splash_blank(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int blank);
+
+/* vt.c */
+extern void con_remap_def_color(int currcons, int new_color);
+
+extern void acquire_console_sem(void);
+extern void release_console_sem(void);
+
+#endif
diff -burN linux-2.6.8.1-orig/drivers/video/bootsplash/decode-jpg.c linux-2.6.8.1/drivers/video/bootsplash/decode-jpg.c
--- linux-2.6.8.1-orig/drivers/video/bootsplash/decode-jpg.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/bootsplash/decode-jpg.c	2007-01-24 13:19:57.000000000 +0900
@@ -0,0 +1,917 @@
+/* 
+ *    linux/drivers/video/bootsplash/decode-jpg.c - a tiny jpeg decoder.
+ *      
+ *      (w) August 2001 by Michael Schroeder, <mls@suse.de>
+ *                  
+ */
+
+#include <linux/fb.h>
+#include <linux/config.h>
+#include <linux/string.h>
+#include <asm/byteorder.h>
+
+#include "decode-jpg.h"
+
+#define ISHIFT 11
+
+#define IFIX(a) ((int)((a) * (1 << ISHIFT) + .5))
+#define IMULT(a, b) (((a) * (b)) >> ISHIFT)
+#define ITOINT(a) ((a) >> ISHIFT)
+
+#ifndef __P
+# define __P(x) x
+#endif
+
+/* special markers */
+#define M_BADHUFF	-1
+#define M_EOF		0x80
+
+struct in {
+	unsigned char *p;
+	unsigned int bits;
+	int left;
+	int marker;
+
+	int (*func) __P((void *));
+	void *data;
+};
+
+/*********************************/
+struct dec_hufftbl;
+struct enc_hufftbl;
+
+union hufftblp {
+	struct dec_hufftbl *dhuff;
+	struct enc_hufftbl *ehuff;
+};
+
+struct scan {
+	int dc;			/* old dc value */
+
+	union hufftblp hudc;
+	union hufftblp huac;
+	int next;		/* when to switch to next scan */
+
+	int cid;		/* component id */
+	int hv;			/* horiz/vert, copied from comp */
+	int tq;			/* quant tbl, copied from comp */
+};
+
+/*********************************/
+
+#define DECBITS 10		/* seems to be the optimum */
+
+struct dec_hufftbl {
+	int maxcode[17];
+	int valptr[16];
+	unsigned char vals[256];
+	unsigned int llvals[1 << DECBITS];
+};
+
+static void decode_mcus __P((struct in *, int *, int, struct scan *, int *));
+static int dec_readmarker __P((struct in *));
+static void dec_makehuff __P((struct dec_hufftbl *, int *, unsigned char *));
+
+static void setinput __P((struct in *, unsigned char *));
+/*********************************/
+
+#undef PREC
+#define PREC int
+
+static void idctqtab __P((unsigned char *, PREC *));
+static void idct __P((int *, int *, PREC *, PREC, int));
+static void scaleidctqtab __P((PREC *, PREC));
+
+/*********************************/
+
+static void initcol __P((PREC[][64]));
+
+static void col221111 __P((int *, unsigned char *, int, struct fb_info *));
+
+/*********************************/
+
+#define M_SOI	0xd8
+#define M_APP0	0xe0
+#define M_DQT	0xdb
+#define M_SOF0	0xc0
+#define M_DHT   0xc4
+#define M_DRI	0xdd
+#define M_SOS	0xda
+#define M_RST0	0xd0
+#define M_EOI	0xd9
+#define M_COM	0xfe
+
+static unsigned char *datap;
+
+static int getbyte(void)
+{
+	return *datap++;
+}
+
+static int getword(void)
+{
+	int c1, c2;
+	c1 = *datap++;
+	c2 = *datap++;
+	return c1 << 8 | c2;
+}
+
+struct comp {
+	int cid;
+	int hv;
+	int tq;
+};
+
+#define MAXCOMP 4
+struct jpginfo {
+	int nc;			/* number of components */
+	int ns;			/* number of scans */
+	int dri;		/* restart interval */
+	int nm;			/* mcus til next marker */
+	int rm;			/* next restart marker */
+};
+
+static struct jpginfo info;
+static struct comp comps[MAXCOMP];
+
+static struct scan dscans[MAXCOMP];
+
+static unsigned char quant[4][64];
+
+static struct dec_hufftbl dhuff[4];
+
+#define dec_huffdc (dhuff + 0)
+#define dec_huffac (dhuff + 2)
+
+static struct in in;
+
+static int readtables(int till)
+{
+	int m, l, i, j, lq, pq, tq;
+	int tc, th, tt;
+
+	for (;;) {
+		if (getbyte() != 0xff)
+			return -1;
+		if ((m = getbyte()) == till)
+			break;
+
+		switch (m) {
+		case 0xc2:
+			return 0;
+
+		case M_DQT:
+			lq = getword();
+			while (lq > 2) {
+				pq = getbyte();
+				tq = pq & 15;
+				if (tq > 3)
+					return -1;
+				pq >>= 4;
+				if (pq != 0)
+					return -1;
+				for (i = 0; i < 64; i++)
+					quant[tq][i] = getbyte();
+				lq -= 64 + 1;
+			}
+			break;
+
+		case M_DHT:
+			l = getword();
+			while (l > 2) {
+				int hufflen[16], k;
+				unsigned char huffvals[256];
+
+				tc = getbyte();
+				th = tc & 15;
+				tc >>= 4;
+				tt = tc * 2 + th;
+				if (tc > 1 || th > 1)
+					return -1;
+				for (i = 0; i < 16; i++)
+					hufflen[i] = getbyte();
+				l -= 1 + 16;
+				k = 0;
+				for (i = 0; i < 16; i++) {
+					for (j = 0; j < hufflen[i]; j++)
+						huffvals[k++] = getbyte();
+					l -= hufflen[i];
+				}
+				dec_makehuff(dhuff + tt, hufflen,
+					     huffvals);
+			}
+			break;
+
+		case M_DRI:
+			l = getword();
+			info.dri = getword();
+			break;
+
+		default:
+			l = getword();
+			while (l-- > 2)
+				getbyte();
+			break;
+		}
+	}
+	return 0;
+}
+
+static void dec_initscans(void)
+{
+	int i;
+
+	info.nm = info.dri + 1;
+	info.rm = M_RST0;
+	for (i = 0; i < info.ns; i++)
+		dscans[i].dc = 0;
+}
+
+static int dec_checkmarker(void)
+{
+	int i;
+
+	if (dec_readmarker(&in) != info.rm)
+		return -1;
+	info.nm = info.dri;
+	info.rm = (info.rm + 1) & ~0x08;
+	for (i = 0; i < info.ns; i++)
+		dscans[i].dc = 0;
+	return 0;
+}
+
+int jpeg_check_size(unsigned char *buf, int width, int height)
+{
+  	datap = buf;
+	getbyte(); 
+	getbyte(); 
+	readtables(M_SOF0);
+	getword();
+	getbyte();
+        if (height != getword() || width != getword())
+		return 0;
+        return 1;
+}
+
+int jpeg_decode(buf, pic, width, height, depth, decdata, fbinfo)
+unsigned char *buf, *pic;
+int width, height, depth;
+struct jpeg_decdata *decdata;
+struct fb_info *fbinfo;
+{
+	int i, j, m, tac, tdc;
+	int mcusx, mcusy, mx, my;
+	int max[6];
+
+	if (!decdata)
+		return -1;
+	datap = buf;
+	if (getbyte() != 0xff)
+		return ERR_NO_SOI;
+	if (getbyte() != M_SOI)
+		return ERR_NO_SOI;
+	if (readtables(M_SOF0))
+		return ERR_BAD_TABLES;
+	getword();
+	i = getbyte();
+	if (i != 8)
+		return ERR_NOT_8BIT;
+	if (((getword() + 15) & ~15) != height)
+		return ERR_HEIGHT_MISMATCH;
+	if (((getword() + 15) & ~15) != width)
+		return ERR_WIDTH_MISMATCH;
+	if ((height & 15) || (width & 15))
+		return ERR_BAD_WIDTH_OR_HEIGHT;
+	info.nc = getbyte();
+	if (info.nc > MAXCOMP)
+		return ERR_TOO_MANY_COMPPS;
+	for (i = 0; i < info.nc; i++) {
+		int h, v;
+		comps[i].cid = getbyte();
+		comps[i].hv = getbyte();
+		v = comps[i].hv & 15;
+		h = comps[i].hv >> 4;
+		comps[i].tq = getbyte();
+		if (h > 3 || v > 3)
+			return ERR_ILLEGAL_HV;
+		if (comps[i].tq > 3)
+			return ERR_QUANT_TABLE_SELECTOR;
+	}
+	if (readtables(M_SOS))
+		return ERR_BAD_TABLES;
+	getword();
+	info.ns = getbyte();
+	if (info.ns != 3)
+		return ERR_NOT_YCBCR_221111;
+	for (i = 0; i < 3; i++) {
+		dscans[i].cid = getbyte();
+		tdc = getbyte();
+		tac = tdc & 15;
+		tdc >>= 4;
+		if (tdc > 1 || tac > 1)
+			return ERR_QUANT_TABLE_SELECTOR;
+		for (j = 0; j < info.nc; j++)
+			if (comps[j].cid == dscans[i].cid)
+				break;
+		if (j == info.nc)
+			return ERR_UNKNOWN_CID_IN_SCAN;
+		dscans[i].hv = comps[j].hv;
+		dscans[i].tq = comps[j].tq;
+		dscans[i].hudc.dhuff = dec_huffdc + tdc;
+		dscans[i].huac.dhuff = dec_huffac + tac;
+	}
+	
+	i = getbyte();
+	j = getbyte();
+	m = getbyte();
+	
+	if (i != 0 || j != 63 || m != 0)
+		return ERR_NOT_SEQUENTIAL_DCT;
+	
+	if (dscans[0].cid != 1 || dscans[1].cid != 2 || dscans[2].cid != 3)
+		return ERR_NOT_YCBCR_221111;
+
+	if (dscans[0].hv != 0x22 || dscans[1].hv != 0x11 || dscans[2].hv != 0x11)
+		return ERR_NOT_YCBCR_221111;
+
+	mcusx = width >> 4;
+	mcusy = height >> 4;
+
+
+	idctqtab(quant[dscans[0].tq], decdata->dquant[0]);
+	idctqtab(quant[dscans[1].tq], decdata->dquant[1]);
+	idctqtab(quant[dscans[2].tq], decdata->dquant[2]);
+	initcol(decdata->dquant);
+	setinput(&in, datap);
+
+#if 0
+	/* landing zone */
+	img[len] = 0;
+	img[len + 1] = 0xff;
+	img[len + 2] = M_EOF;
+#endif
+
+	dec_initscans();
+
+	dscans[0].next = 6 - 4;
+	dscans[1].next = 6 - 4 - 1;
+	dscans[2].next = 6 - 4 - 1 - 1;	/* 411 encoding */
+	for (my = 0; my < mcusy; my++) {
+		for (mx = 0; mx < mcusx; mx++) {
+			if (info.dri && !--info.nm)
+				if (dec_checkmarker())
+					return ERR_WRONG_MARKER;
+			
+			decode_mcus(&in, decdata->dcts, 6, dscans, max);
+			idct(decdata->dcts, decdata->out, decdata->dquant[0], IFIX(128.5), max[0]);
+			idct(decdata->dcts + 64, decdata->out + 64, decdata->dquant[0], IFIX(128.5), max[1]);
+			idct(decdata->dcts + 128, decdata->out + 128, decdata->dquant[0], IFIX(128.5), max[2]);
+			idct(decdata->dcts + 192, decdata->out + 192, decdata->dquant[0], IFIX(128.5), max[3]);
+			idct(decdata->dcts + 256, decdata->out + 256, decdata->dquant[1], IFIX(0.5), max[4]);
+			idct(decdata->dcts + 320, decdata->out + 320, decdata->dquant[2], IFIX(0.5), max[5]);
+
+			if (fbinfo->var.bits_per_pixel != 32 && fbinfo->var.bits_per_pixel != 24 && 
+			    fbinfo->var.bits_per_pixel != 16) {
+				return ERR_DEPTH_MISMATCH;
+			} else {
+				col221111(decdata->out, pic + (my * 16 * mcusx + mx) * 16 * (fbinfo->var.bits_per_pixel >> 3),
+					  mcusx * 16 * (fbinfo->var.bits_per_pixel >> 3), fbinfo);
+			}
+		}
+	}
+	
+	m = dec_readmarker(&in);
+	if (m != M_EOI)
+		return ERR_NO_EOI;
+
+	return 0;
+}
+
+/****************************************************************/
+/**************       huffman decoder             ***************/
+/****************************************************************/
+
+static int fillbits __P((struct in *, int, unsigned int));
+static int dec_rec2
+__P((struct in *, struct dec_hufftbl *, int *, int, int));
+
+static void setinput(in, p)
+struct in *in;
+unsigned char *p;
+{
+	in->p = p;
+	in->left = 0;
+	in->bits = 0;
+	in->marker = 0;
+}
+
+static int fillbits(in, le, bi)
+struct in *in;
+int le;
+unsigned int bi;
+{
+	int b, m;
+
+	if (in->marker) {
+		if (le <= 16)
+			in->bits = bi << 16, le += 16;
+		return le;
+	}
+	while (le <= 24) {
+		b = *in->p++;
+		if (b == 0xff && (m = *in->p++) != 0) {
+			if (m == M_EOF) {
+				if (in->func && (m = in->func(in->data)) == 0)
+					continue;
+			}
+			in->marker = m;
+			if (le <= 16)
+				bi = bi << 16, le += 16;
+			break;
+		}
+		bi = bi << 8 | b;
+		le += 8;
+	}
+	in->bits = bi;		/* tmp... 2 return values needed */
+	return le;
+}
+
+static int dec_readmarker(in)
+struct in *in;
+{
+	int m;
+
+	in->left = fillbits(in, in->left, in->bits);
+	if ((m = in->marker) == 0)
+		return 0;
+	in->left = 0;
+	in->marker = 0;
+	return m;
+}
+
+#define LEBI_DCL	int le, bi
+#define LEBI_GET(in)	(le = in->left, bi = in->bits)
+#define LEBI_PUT(in)	(in->left = le, in->bits = bi)
+
+#define GETBITS(in, n) (					\
+  (le < (n) ? le = fillbits(in, le, bi), bi = in->bits : 0),	\
+  (le -= (n)),							\
+  bi >> le & ((1 << (n)) - 1)					\
+)
+
+#define UNGETBITS(in, n) (	\
+  le += (n)			\
+)
+
+
+static int dec_rec2(in, hu, runp, c, i)
+struct in *in;
+struct dec_hufftbl *hu;
+int *runp;
+int c, i;
+{
+	LEBI_DCL;
+
+	LEBI_GET(in);
+	if (i) {
+		UNGETBITS(in, i & 127);
+		*runp = i >> 8 & 15;
+		i >>= 16;
+	} else {
+		for (i = DECBITS; (c = ((c << 1) | GETBITS(in, 1))) >= (hu->maxcode[i]); i++);
+		if (i >= 16) {
+			in->marker = M_BADHUFF;
+			return 0;
+		}
+		i = hu->vals[hu->valptr[i] + c - hu->maxcode[i - 1] * 2];
+		*runp = i >> 4;
+		i &= 15;
+	}
+	if (i == 0) {		/* sigh, 0xf0 is 11 bit */
+		LEBI_PUT(in);
+		return 0;
+	}
+	/* receive part */
+	c = GETBITS(in, i);
+	if (c < (1 << (i - 1)))
+		c += (-1 << i) + 1;
+	LEBI_PUT(in);
+	return c;
+}
+
+#define DEC_REC(in, hu, r, i)	 (	\
+  r = GETBITS(in, DECBITS),		\
+  i = hu->llvals[r],			\
+  i & 128 ?				\
+    (					\
+      UNGETBITS(in, i & 127),		\
+      r = i >> 8 & 15,			\
+      i >> 16				\
+    )					\
+  :					\
+    (					\
+      LEBI_PUT(in),			\
+      i = dec_rec2(in, hu, &r, r, i),	\
+      LEBI_GET(in),			\
+      i					\
+    )					\
+)
+
+static void decode_mcus(in, dct, n, sc, maxp)
+struct in *in;
+int *dct;
+int n;
+struct scan *sc;
+int *maxp;
+{
+	struct dec_hufftbl *hu;
+	int i, r, t;
+	LEBI_DCL;
+
+	memset(dct, 0, n * 64 * sizeof(*dct));
+	LEBI_GET(in);
+	while (n-- > 0) {
+		hu = sc->hudc.dhuff;
+		*dct++ = (sc->dc += DEC_REC(in, hu, r, t));
+
+		hu = sc->huac.dhuff;
+		i = 63;
+		while (i > 0) {
+			t = DEC_REC(in, hu, r, t);
+			if (t == 0 && r == 0) {
+				dct += i;
+				break;
+			}
+			dct += r;
+			*dct++ = t;
+			i -= r + 1;
+		}
+		*maxp++ = 64 - i;
+		if (n == sc->next)
+			sc++;
+	}
+	LEBI_PUT(in);
+}
+
+static void dec_makehuff(hu, hufflen, huffvals)
+struct dec_hufftbl *hu;
+int *hufflen;
+unsigned char *huffvals;
+{
+	int code, k, i, j, d, x, c, v;
+	for (i = 0; i < (1 << DECBITS); i++)
+		hu->llvals[i] = 0;
+
+/*
+ * llvals layout:
+ *
+ * value v already known, run r, backup u bits:
+ *  vvvvvvvvvvvvvvvv 0000 rrrr 1 uuuuuuu
+ * value unknown, size b bits, run r, backup u bits:
+ *  000000000000bbbb 0000 rrrr 0 uuuuuuu
+ * value and size unknown:
+ *  0000000000000000 0000 0000 0 0000000
+ */
+	code = 0;
+	k = 0;
+	for (i = 0; i < 16; i++, code <<= 1) {	/* sizes */
+		hu->valptr[i] = k;
+		for (j = 0; j < hufflen[i]; j++) {
+			hu->vals[k] = *huffvals++;
+			if (i < DECBITS) {
+				c = code << (DECBITS - 1 - i);
+				v = hu->vals[k] & 0x0f;	/* size */
+				for (d = 1 << (DECBITS - 1 - i); --d >= 0;) {
+					if (v + i < DECBITS) {	/* both fit in table */
+						x = d >> (DECBITS - 1 - v -
+							  i);
+						if (v && x < (1 << (v - 1)))
+							x += (-1 << v) + 1;
+						x = x << 16 | (hu-> vals[k] & 0xf0) << 4 |
+							(DECBITS - (i + 1 + v)) | 128;
+					} else
+						x = v << 16 | (hu-> vals[k] & 0xf0) << 4 |
+						        (DECBITS - (i + 1));
+					hu->llvals[c | d] = x;
+				}
+			}
+			code++;
+			k++;
+		}
+		hu->maxcode[i] = code;
+	}
+	hu->maxcode[16] = 0x20000;	/* always terminate decode */
+}
+
+/****************************************************************/
+/**************             idct                  ***************/
+/****************************************************************/
+
+#define ONE ((PREC)IFIX(1.))
+#define S2  ((PREC)IFIX(0.382683432))
+#define C2  ((PREC)IFIX(0.923879532))
+#define C4  ((PREC)IFIX(0.707106781))
+
+#define S22 ((PREC)IFIX(2 * 0.382683432))
+#define C22 ((PREC)IFIX(2 * 0.923879532))
+#define IC4 ((PREC)IFIX(1 / 0.707106781))
+
+#define C3IC1 ((PREC)IFIX(0.847759065))	/* c3/c1 */
+#define C5IC1 ((PREC)IFIX(0.566454497))	/* c5/c1 */
+#define C7IC1 ((PREC)IFIX(0.198912367))	/* c7/c1 */
+
+#define XPP(a,b) (t = a + b, b = a - b, a = t)
+#define XMP(a,b) (t = a - b, b = a + b, a = t)
+#define XPM(a,b) (t = a + b, b = b - a, a = t)
+
+#define ROT(a,b,s,c) (	t = IMULT(a + b, s),	\
+			a = IMULT(a, c - s) + t,	\
+			b = IMULT(b, c + s) - t)
+
+#define IDCT		\
+(			\
+  XPP(t0, t1),		\
+  XMP(t2, t3),		\
+  t2 = IMULT(t2, IC4) - t3,	\
+  XPP(t0, t3),		\
+  XPP(t1, t2),		\
+  XMP(t4, t7),		\
+  XPP(t5, t6),		\
+  XMP(t5, t7),		\
+  t5 = IMULT(t5, IC4),	\
+  ROT(t4, t6, S22, C22),\
+  t6 -= t7,		\
+  t5 -= t6,		\
+  t4 -= t5,		\
+  XPP(t0, t7),		\
+  XPP(t1, t6),		\
+  XPP(t2, t5),		\
+  XPP(t3, t4)		\
+)
+
+static unsigned char zig2[64] = {
+	0, 2, 3, 9, 10, 20, 21, 35,
+	14, 16, 25, 31, 39, 46, 50, 57,
+	5, 7, 12, 18, 23, 33, 37, 48,
+	27, 29, 41, 44, 52, 55, 59, 62,
+	15, 26, 30, 40, 45, 51, 56, 58,
+	1, 4, 8, 11, 19, 22, 34, 36,
+	28, 42, 43, 53, 54, 60, 61, 63,
+	6, 13, 17, 24, 32, 38, 47, 49
+};
+
+void idct(in, out, quant, off, max)
+int *in;
+int *out;
+PREC *quant;
+PREC off;
+int max;
+{
+	PREC t0, t1, t2, t3, t4, t5, t6, t7, t;
+	PREC tmp[64], *tmpp;
+	int i, j;
+	unsigned char *zig2p;
+
+	t0 = off;
+	if (max == 1) {
+		t0 += in[0] * quant[0];
+		for (i = 0; i < 64; i++)
+			out[i] = ITOINT(t0);
+		return;
+	}
+	zig2p = zig2;
+	tmpp = tmp;
+	for (i = 0; i < 8; i++) {
+		j = *zig2p++;
+		t0 += in[j] * quant[j];
+		j = *zig2p++;
+		t5 = in[j] * quant[j];
+		j = *zig2p++;
+		t2 = in[j] * quant[j];
+		j = *zig2p++;
+		t7 = in[j] * quant[j];
+		j = *zig2p++;
+		t1 = in[j] * quant[j];
+		j = *zig2p++;
+		t4 = in[j] * quant[j];
+		j = *zig2p++;
+		t3 = in[j] * quant[j];
+		j = *zig2p++;
+		t6 = in[j] * quant[j];
+		IDCT;
+		tmpp[0 * 8] = t0;
+		tmpp[1 * 8] = t1;
+		tmpp[2 * 8] = t2;
+		tmpp[3 * 8] = t3;
+		tmpp[4 * 8] = t4;
+		tmpp[5 * 8] = t5;
+		tmpp[6 * 8] = t6;
+		tmpp[7 * 8] = t7;
+		tmpp++;
+		t0 = 0;
+	}
+	for (i = 0; i < 8; i++) {
+		t0 = tmp[8 * i + 0];
+		t1 = tmp[8 * i + 1];
+		t2 = tmp[8 * i + 2];
+		t3 = tmp[8 * i + 3];
+		t4 = tmp[8 * i + 4];
+		t5 = tmp[8 * i + 5];
+		t6 = tmp[8 * i + 6];
+		t7 = tmp[8 * i + 7];
+		IDCT;
+		out[8 * i + 0] = ITOINT(t0);
+		out[8 * i + 1] = ITOINT(t1);
+		out[8 * i + 2] = ITOINT(t2);
+		out[8 * i + 3] = ITOINT(t3);
+		out[8 * i + 4] = ITOINT(t4);
+		out[8 * i + 5] = ITOINT(t5);
+		out[8 * i + 6] = ITOINT(t6);
+		out[8 * i + 7] = ITOINT(t7);
+	}
+}
+
+static unsigned char zig[64] = {
+	0, 1, 5, 6, 14, 15, 27, 28,
+	2, 4, 7, 13, 16, 26, 29, 42,
+	3, 8, 12, 17, 25, 30, 41, 43,
+	9, 11, 18, 24, 31, 40, 44, 53,
+	10, 19, 23, 32, 39, 45, 52, 54,
+	20, 22, 33, 38, 46, 51, 55, 60,
+	21, 34, 37, 47, 50, 56, 59, 61,
+	35, 36, 48, 49, 57, 58, 62, 63
+};
+
+static PREC aaidct[8] = {
+	IFIX(0.3535533906), IFIX(0.4903926402),
+	IFIX(0.4619397663), IFIX(0.4157348062),
+	IFIX(0.3535533906), IFIX(0.2777851165),
+	IFIX(0.1913417162), IFIX(0.0975451610)
+};
+
+
+static void idctqtab(qin, qout)
+unsigned char *qin;
+PREC *qout;
+{
+	int i, j;
+
+	for (i = 0; i < 8; i++)
+		for (j = 0; j < 8; j++)
+			qout[zig[i * 8 + j]] = qin[zig[i * 8 + j]] * 
+			  			IMULT(aaidct[i], aaidct[j]);
+}
+
+static void scaleidctqtab(q, sc)
+PREC *q;
+PREC sc;
+{
+	int i;
+
+	for (i = 0; i < 64; i++)
+		q[i] = IMULT(q[i], sc);
+}
+
+/****************************************************************/
+/**************          color decoder            ***************/
+/****************************************************************/
+
+#define ROUND
+
+/*
+ * YCbCr Color transformation:
+ *
+ * y:0..255   Cb:-128..127   Cr:-128..127
+ *
+ *      R = Y                + 1.40200 * Cr
+ *      G = Y - 0.34414 * Cb - 0.71414 * Cr
+ *      B = Y + 1.77200 * Cb
+ *
+ * =>
+ *      Cr *= 1.40200;
+ *      Cb *= 1.77200;
+ *      Cg = 0.19421 * Cb + .50937 * Cr;
+ *      R = Y + Cr;
+ *      G = Y - Cg;
+ *      B = Y + Cb;
+ *
+ * =>
+ *      Cg = (50 * Cb + 130 * Cr + 128) >> 8;
+ */
+
+static void initcol(q)
+PREC q[][64];
+{
+	scaleidctqtab(q[1], IFIX(1.77200));
+	scaleidctqtab(q[2], IFIX(1.40200));
+}
+
+/* This is optimized for the stupid sun SUNWspro compiler. */
+#define STORECLAMP(a,x)				\
+(						\
+  (a) = (x),					\
+  (unsigned int)(x) >= 256 ? 			\
+    ((a) = (x) < 0 ? 0 : 255)			\
+  :						\
+    0						\
+)
+
+#define CLAMP(x) ((unsigned int)(x) >= 256 ? ((x) < 0 ? 0 : 255) : (x))
+
+#ifdef ROUND
+
+#define CBCRCG(yin, xin)			\
+(						\
+  cb = outc[0 +yin*8+xin],			\
+  cr = outc[64+yin*8+xin],			\
+  cg = (50 * cb + 130 * cr + 128) >> 8		\
+)
+
+#else
+
+#define CBCRCG(yin, xin)			\
+(						\
+  cb = outc[0 +yin*8+xin],			\
+  cr = outc[64+yin*8+xin],			\
+  cg = (3 * cb + 8 * cr) >> 4			\
+)
+
+#endif
+
+static void PIC(int yin, int xin, u8 *p, int xout, int add, int cr, int cg, int cb, struct fb_info *info, int *outy)
+{									
+	int y, r, g, b, corr = 0;
+	int rlen, glen, blen;
+
+	if (info->var.bits_per_pixel == 16)
+		corr = add * 2 + 1;
+	else
+		add = 0;
+		
+	y = outy[(yin) * 8 + xin];
+		
+	if (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+		blen = glen = rlen = min(min(info->var.red.length,info->var.green.length),info->var.blue.length);
+	} else {
+		rlen = info->var.red.length;
+		glen = info->var.green.length;
+		blen = info->var.blue.length;
+	}
+	
+	r = CLAMP(y + cr + corr) >> (8 - rlen);	
+	g = CLAMP(y - cg + add) >> (8 - glen); 	
+	b = CLAMP(y + cb + corr) >> (8 - blen);	
+
+	y = (r << info->var.red.offset) | 
+	    (g << info->var.green.offset) |
+	    (b << info->var.blue.offset);
+
+	if (info->var.bits_per_pixel == 32) {
+		*(u32*)(&p[(xout) * 4]) = y;
+	} else if (info->var.bits_per_pixel == 24) { 
+#ifdef __LITTLE_ENDIAN
+		p[(xout) * 3 + 0] = y & 0xff;
+		p[(xout) * 3 + 1] = (y >> 8) & 0xff;
+		p[(xout) * 3 + 2] = (y >> 16) & 0xff;
+#else
+		p[(xout) * 3 + 0] = (y >> 16) & 0xff;
+		p[(xout) * 3 + 1] = (y >> 8) & 0xff;
+		p[(xout) * 3 + 2] = y & 0xff;
+#endif
+	} else if (info->var.bits_per_pixel == 16) { 
+		*(u16*)(&p[(xout) * 2]) = y;
+	}  
+}
+
+static void col221111(out, pic, width, fbinfo)
+int *out;
+unsigned char *pic;
+int width;
+struct fb_info *fbinfo;
+{
+	int i, j, k;
+	unsigned char *pic0, *pic1;
+	int *outy, *outc;
+	int cr, cg, cb;
+
+	pic0 = pic;
+	pic1 = pic + width;
+	outy = out;
+	outc = out + 64 * 4;
+	for (i = 2; i > 0; i--) {
+		for (j = 4; j > 0; j--) {
+			for (k = 0; k < 8; k++) {
+				CBCRCG(0, k);
+				PIC(k / 4 * 8 + 0, (k & 3) * 2 + 0, pic0, k * 2 + 0, 3, cr, cg, cb, fbinfo, outy);
+				PIC(k / 4 * 8 + 0, (k & 3) * 2 + 1, pic0, k * 2 + 1, 0, cr, cg, cb, fbinfo, outy);
+				PIC(k / 4 * 8 + 1, (k & 3) * 2 + 0, pic1, k * 2 + 0, 1, cr, cg, cb, fbinfo, outy);
+				PIC(k / 4 * 8 + 1, (k & 3) * 2 + 1, pic1, k * 2 + 1, 2, cr, cg, cb, fbinfo, outy);
+			}
+			outc += 8;
+			outy += 16;
+			pic0 += 2 * width;
+			pic1 += 2 * width;
+		}
+		outy += 64 * 2 - 16 * 4;
+	}
+}
diff -burN linux-2.6.8.1-orig/drivers/video/bootsplash/decode-jpg.h linux-2.6.8.1/drivers/video/bootsplash/decode-jpg.h
--- linux-2.6.8.1-orig/drivers/video/bootsplash/decode-jpg.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/bootsplash/decode-jpg.h	2007-01-24 13:19:57.000000000 +0900
@@ -0,0 +1,35 @@
+/*
+ *    linux/drivers/video/bootsplash/decode-jpg.h - a tiny jpeg decoder.
+ *
+ *      (w) August 2001 by Michael Schroeder, <mls@suse.de>
+ */
+
+#ifndef __DECODE_JPG_H
+#define __DECODE_JPG_H
+
+#define ERR_NO_SOI 1
+#define ERR_NOT_8BIT 2
+#define ERR_HEIGHT_MISMATCH 3
+#define ERR_WIDTH_MISMATCH 4
+#define ERR_BAD_WIDTH_OR_HEIGHT 5
+#define ERR_TOO_MANY_COMPPS 6
+#define ERR_ILLEGAL_HV 7
+#define ERR_QUANT_TABLE_SELECTOR 8
+#define ERR_NOT_YCBCR_221111 9
+#define ERR_UNKNOWN_CID_IN_SCAN 10
+#define ERR_NOT_SEQUENTIAL_DCT 11
+#define ERR_WRONG_MARKER 12
+#define ERR_NO_EOI 13
+#define ERR_BAD_TABLES 14
+#define ERR_DEPTH_MISMATCH 15
+
+struct jpeg_decdata {
+	int dcts[6 * 64 + 16];
+	int out[64 * 6];
+	int dquant[3][64];
+};
+
+extern int jpeg_decode(unsigned char *, unsigned char *, int, int, int, struct jpeg_decdata *, struct fb_info *);
+extern int jpeg_check_size(unsigned char *, int, int);
+
+#endif
diff -burN linux-2.6.8.1-orig/drivers/video/bootsplash/render.c linux-2.6.8.1/drivers/video/bootsplash/render.c
--- linux-2.6.8.1-orig/drivers/video/bootsplash/render.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/bootsplash/render.c	2007-01-24 13:19:57.000000000 +0900
@@ -0,0 +1,523 @@
+/* 
+ *    linux/drivers/video/bootsplash/render.c - splash screen render functions.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/vt_kern.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "../console/fbcon.h"
+#include "bootsplash.h"
+
+void splash_putcs(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			const unsigned short *s, int count, int ypos, int xpos)
+{
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int fgshift = (vc->vc_hi_font_mask) ? 9 : 8;
+	u8 *src;
+        u8 *dst, *splashsrc;
+	unsigned int d, x, y;
+	u32 dd, fgx, bgx;
+	u16 c = scr_readw(s);
+
+	int bytespp = (info->var.bits_per_pixel >> 3);
+	int fg_color, bg_color, transparent;
+
+	fg_color = attr_fgcol(fgshift, c);
+        bg_color = attr_bgcol(bgshift, c);
+	
+	transparent = sd->splash_color == bg_color;
+	
+	xpos = xpos * vc->vc_font.width + sd->splash_text_xo;
+	ypos = ypos * vc->vc_font.height + sd->splash_text_yo;
+        
+	splashsrc = (u8 *)(info->splash_pic + ypos * info->splash_bytes + xpos * bytespp);
+        dst = (u8 *)(info->screen_base + ypos * info->fix.line_length + xpos * bytespp);
+
+	fgx = ((u32 *)info->pseudo_palette)[fg_color];
+/*	if (transparent && sd->splash_color == 15) {
+	    if (fgx == 0xffea)
+		fgx = 0xfe4a;
+	    else if (fgx == 0x57ea)
+		fgx = 0x0540;
+	    else if (fgx == 0xffff)
+		fgx = 0x52aa;
+	}
+*/	bgx = ((u32 *)info->pseudo_palette)[bg_color];
+	d = 0;
+
+	while (count--) {
+		c = scr_readw(s++);
+		src = vc->vc_font.data + (c & charmask) * vc->vc_font.height * ((vc->vc_font.width + 7) >> 3);
+
+	    	for (y = 0; y < vc->vc_font.height; y++) {
+			switch (info->var.bits_per_pixel) {
+	
+			case 32:
+				for (x = 0; x < vc->vc_font.width; x++) {
+	
+					if ((x & 7) == 0)
+						d = *src++;
+					if (d & 0x80)
+						dd = fgx;
+					else
+						dd = transparent ? *(u32 *)splashsrc : bgx;
+					
+					d <<= 1;
+					splashsrc += 4;
+					fb_writel(dd, dst);
+					dst += 4;
+				}
+				break;
+			case 24:
+				for (x = 0; x < vc->vc_font.width; x++) {
+	
+					if ((x & 7) == 0)
+						d = *src++;
+					if (d & 0x80)
+						dd = fgx;
+					else
+						dd = transparent ? (*(u32 *)splashsrc & 0xffffff) : bgx;
+					
+					d <<= 1;
+					splashsrc += 3;
+#ifdef __LITTLE_ENDIAN
+					fb_writew(dd & 0xffff, dst);
+					dst += 2;
+					fb_writeb((dd >> 16), dst);
+#else
+					fb_writew(dd >> 8, dst);
+					dst += 2;
+					fb_writeb(dd & 0xff, dst);
+#endif
+
+					dst++;
+				}
+				break;
+			case 16:
+				for (x = 0; x < vc->vc_font.width; x += 2) {
+			    		if ((x & 7) == 0)
+						d = *src++;
+		    			if (d & 0x80)
+#ifdef __LITTLE_ENDIAN
+						dd = fgx;
+			    		else
+						dd = transparent ? *(u16 *)splashsrc : bgx;
+#else
+						dd = fgx << 16;
+			    		else
+						dd = (transparent ? *(u16 *)splashsrc : bgx) << 16;
+#endif
+			    		splashsrc += 2;
+			 		if (d & 0x40)
+#ifdef __LITTLE_ENDIAN
+						dd |= fgx << 16;
+		    			else
+						dd |= (transparent ? *(u16 *)splashsrc : bgx) << 16;
+#else
+						dd |= fgx;
+		    			else
+						dd |= transparent ? *(u16 *)splashsrc : bgx;
+#endif
+					splashsrc += 2;
+					d <<= 2;
+					fb_writel(dd, dst);
+					dst += 4;
+				}
+				break;
+			}
+
+			dst += info->fix.line_length - vc->vc_font.width * bytespp;
+			splashsrc += info->splash_bytes - vc->vc_font.width * bytespp;
+	    	}
+
+		dst -= info->fix.line_length * vc->vc_font.height - vc->vc_font.width * bytespp;
+		splashsrc -= info->splash_bytes * vc->vc_font.height - vc->vc_font.width * bytespp;
+	}
+}
+
+static void splash_renderc(struct splash_data *sd, struct fb_info *info, int fg_color, int bg_color, u8 *src, int ypos, int xpos, int height, int width)
+{
+	int transparent = sd->splash_color == bg_color;
+	u32 dd, fgx, bgx;
+	u8 *dst, *splashsrc;
+	unsigned int d, x, y;
+
+	int bytespp = (info->var.bits_per_pixel >> 3);
+
+	if (ypos * info->splash_bytes + xpos * bytespp > info->splash_pic_size)
+		return;
+	
+	splashsrc = (u8 *)(info->splash_pic + ypos * info->splash_bytes + xpos * bytespp);
+	dst = (u8 *)(info->screen_base + ypos * info->fix.line_length + xpos * bytespp);
+	fgx = ((u32 *)info->pseudo_palette)[fg_color];
+
+	/*	if (transparent && sd->splash_color == 15) {
+		if (fgx == 0xffea)
+			fgx = 0xfe4a;
+		else if (fgx == 0x57ea)
+			fgx = 0x0540;
+		else if (fgx == 0xffff)
+			fgx = 0x52aa;
+	}*/
+	
+	bgx = ((u32 *)info->pseudo_palette)[bg_color];
+	d = 0;
+	
+	for (y = 0; y < height; y++) {
+
+		switch (info->var.bits_per_pixel)
+		{
+		case 32:
+			for (x = 0; x < width; x++) {
+	
+				if ((x & 7) == 0)
+					d = *src++;
+				if (d & 0x80)
+					dd = fgx;
+				else
+					dd = transparent ? *(u32 *)splashsrc : bgx;
+
+				d <<= 1;						
+				splashsrc += 4;
+				fb_writel(dd, dst);
+				dst += 4;
+			}
+			break;
+		case 24:
+			for (x = 0; x < width; x++) {
+	
+				if ((x & 7) == 0)
+					d = *src++;
+				if (d & 0x80)
+					dd = fgx;
+				else
+					dd = transparent ? (*(u32 *)splashsrc & 0xffffff) : bgx;
+				
+				d <<= 1;
+				splashsrc += 3;
+#ifdef __LITTLE_ENDIAN
+				fb_writew(dd & 0xffff, dst);
+				dst += 2;
+				fb_writeb((dd >> 16), dst);
+#else
+				fb_writew(dd >> 8, dst);
+				dst += 2;
+				fb_writeb(dd & 0xff, dst);
+#endif
+				dst++;
+			}
+			break;
+		case 16:
+			for (x = 0; x < width; x += 2) {
+	
+				if ((x & 7) == 0)
+					d = *src++;
+				if (d & 0x80)
+#ifdef __LITTLE_ENDIAN
+					dd = fgx;
+				else
+					dd = transparent ? *(u16 *)splashsrc : bgx;
+#else
+					dd = fgx << 16;
+				else
+					dd = (transparent ? *(u16 *)splashsrc : bgx) << 16;
+#endif
+				splashsrc += 2;
+				if (d & 0x40)
+#ifdef __LITTLE_ENDIAN
+					dd |= fgx << 16;
+				else
+					dd |= (transparent ? *(u16 *)splashsrc : bgx) << 16;
+#else
+					dd |= fgx;
+				else
+					dd |= transparent ? *(u16 *)splashsrc : bgx;
+#endif
+				splashsrc += 2;
+				d <<= 2;
+				fb_writel(dd, dst);
+				dst += 4;
+			}
+			break;
+		}
+		
+		dst += info->fix.line_length - width * bytespp;
+		splashsrc += info->splash_bytes - width * bytespp;
+	}
+}
+
+void splash_putc(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+                      int c, int ypos, int xpos)
+{
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int fgshift = (vc->vc_hi_font_mask) ? 9 : 8;
+	u8 *src = vc->vc_font.data + (c & charmask) * vc->vc_font.height * ((vc->vc_font.width + 7) >> 3);
+	xpos = xpos * vc->vc_font.width + sd->splash_text_xo;
+	ypos = ypos * vc->vc_font.height + sd->splash_text_yo;
+	splash_renderc(sd, info, attr_fgcol(fgshift, c), attr_bgcol(bgshift, c), src, ypos, xpos, vc->vc_font.height, vc->vc_font.width);
+}
+
+void splashcopy(u8 *dst, u8 *src, int height, int width, int dstbytes, int srcbytes, int bpp)
+{
+	int i;
+
+	while (height-- > 0) {
+		u32 *p = (u32 *)dst;
+		u32 *q = (u32 *)src;
+
+		switch (bpp) {
+	
+		case 32:
+			for (i=0; i < width; i++)
+				fb_writel(*q++,p++);
+			break;	
+		case 24:	
+			for (i=0; i < (width*3/4); i++)
+				fb_writel(*q++,p++);
+			if ((width*3) % 4) {
+				if (width & 2) {
+					fb_writeb(*(u8*)q,(u8*)p);
+				} else if (width & 1) {
+					fb_writew(*(u16*)q,(u16*)p);
+					fb_writeb(*(u8*)((u32)q+2),(u8*)((u32)p+2));
+				}
+			}
+			break;
+		case 16:
+			for (i=0; i < width/4; i++) {
+				fb_writel(*q++,p++);
+				fb_writel(*q++,p++);
+			}
+			if (width & 2)
+				fb_writel(*q++,p++);
+			if (width & 1)
+				fb_writew(*(u16*)q,(u16*)p);
+			break;
+		}
+
+		dst += dstbytes;
+		src += srcbytes;
+	}
+
+}
+
+static void splashset(u8 *dst, int height, int width, int dstbytes, u32 bgx, int bpp) {
+	int i;
+	
+	if (bpp == 16)
+		bgx |= bgx << 16;
+	else if (bpp == 8) {
+		bgx |= bgx << 8;
+		bgx |= bgx << 16;
+	}
+	
+	while (height-- > 0) {
+		u8 *p = dst;
+		
+		switch (bpp) {
+		
+		case 32:
+			for (i=0; i < width; i++) {
+				fb_writel(bgx, p);
+				p += 4;
+			}
+			break;
+		case 24:	
+			for (i=0; i < width; i++) {
+#ifdef __LITTLE_ENDIAN
+				fb_writew((bgx & 0xffff),(u16*)p);
+				p += 2;
+				fb_writeb((bgx >> 16),p++);
+#else
+				fb_writew((bgx >> 8),(u16*)p);
+				p += 2;
+				fb_writeb((bgx & 0xff),p++);
+#endif
+			}
+		case 16:
+			for (i=0; i < width/4; i++) {
+				fb_writel(bgx,p); p += 4;
+				fb_writel(bgx,p); p += 4;
+			}
+			if (width & 2) {
+				fb_writel(bgx,p); 
+				p += 4;
+			}
+			if (width & 1)
+				fb_writew(bgx,(u16*)p);
+			break;
+		}		
+		dst += dstbytes;
+	}
+}
+
+static void splashfill(struct fb_info *info, int sy, int sx, int height, int width) {
+	splashcopy((u8 *)(info->screen_base + sy * info->fix.line_length + sx * (info->var.bits_per_pixel >> 3)), 
+		   (u8 *)(info->splash_pic + sy * info->splash_bytes + sx * (info->var.bits_per_pixel >> 3)), 
+		   height, width, info->fix.line_length, info->splash_bytes, info->var.bits_per_pixel);
+}
+
+void splash_clear(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy,
+			int sx, int height, int width)
+{
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int bg_color = attr_bgcol_ec(bgshift, vc);
+	int transparent = sd->splash_color == bg_color;
+	u32 bgx;
+	u8 *dst;
+
+	sy = sy * vc->vc_font.height + sd->splash_text_yo;
+	sx = sx * vc->vc_font.width + sd->splash_text_xo;
+	height *= vc->vc_font.height;
+	width *= vc->vc_font.width;
+
+	if (transparent) {
+		splashfill(info, sy, sx, height, width);
+		return;
+	}
+
+	dst = (u8 *)(info->screen_base + sy * info->fix.line_length + sx * (info->var.bits_per_pixel >> 3));
+	bgx = ((u32 *)info->pseudo_palette)[bg_color];
+	splashset(dst, height, width, info->fix.line_length, bgx, info->var.bits_per_pixel);
+}
+
+void splash_bmove(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy, 
+		int sx, int dy, int dx, int height, int width)
+{
+	struct fb_copyarea area;
+
+	area.sx = sx * vc->vc_font.width;
+	area.sy = sy * vc->vc_font.height;
+	area.dx = dx * vc->vc_font.width;
+	area.dy = dy * vc->vc_font.height;
+	area.sx += sd->splash_text_xo;
+	area.sy += sd->splash_text_yo;
+	area.dx += sd->splash_text_xo;
+	area.dy += sd->splash_text_yo;
+	area.height = height * vc->vc_font.height;
+	area.width = width * vc->vc_font.width;
+
+	info->fbops->fb_copyarea(info, &area);
+}
+
+void splash_clear_margins(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+				int bottom_only)
+{
+	unsigned int tw = vc->vc_cols*vc->vc_font.width;
+	unsigned int th = vc->vc_rows*vc->vc_font.height;
+	
+	if (!bottom_only) {
+		/* top margin */
+		splashfill(info, 0, 0, sd->splash_text_yo, info->var.xres);
+		/* left margin */
+		splashfill(info, sd->splash_text_yo, 0, th, sd->splash_text_xo);
+		/* right margin */
+		splashfill(info, sd->splash_text_yo, sd->splash_text_xo + tw, th, info->var.xres - sd->splash_text_xo - tw);
+
+	}
+	splashfill(info, sd->splash_text_yo + th, 0, info->var.yres - sd->splash_text_yo - th, info->var.xres);
+}
+
+void splash_cursor(struct splash_data *sd, struct fb_info *info, struct fb_cursor *cursor)
+{
+	int i;
+	unsigned int dsize, s_pitch;
+	
+	if (cursor->set & FB_CUR_SETSIZE) {
+                info->cursor.image.height = cursor->image.height;
+                info->cursor.image.width = cursor->image.width;
+        }
+        if (cursor->set & FB_CUR_SETPOS) {
+                info->cursor.image.dx = cursor->image.dx;
+                info->cursor.image.dy = cursor->image.dy;
+        }
+        if (cursor->set & FB_CUR_SETHOT)
+                info->cursor.hot = cursor->hot;
+        if (cursor->set & FB_CUR_SETCMAP) {
+                if (cursor->image.depth == 1) {
+                        info->cursor.image.bg_color = cursor->image.bg_color;
+                        info->cursor.image.fg_color = cursor->image.fg_color;
+                } else {
+                        if (cursor->image.cmap.len)
+                                fb_copy_cmap(&cursor->image.cmap, &info->cursor.image.cmap);
+                }
+                info->cursor.image.depth = cursor->image.depth;
+        }
+	s_pitch = (info->cursor.image.width + 7) >> 3;
+        dsize = s_pitch * info->cursor.image.height;
+        if (info->cursor.enable) {
+                switch (info->cursor.rop) {
+                case ROP_XOR:
+                        for (i = 0; i < dsize; i++)
+                                info->fb_cursordata[i] = cursor->image.data[i] ^ info->cursor.mask[i];
+                        break;
+                case ROP_COPY:
+                default:
+                        for (i = 0; i < dsize; i++)
+                                info->fb_cursordata[i] = cursor->image.data[i] & info->cursor.mask[i];
+                        break;
+                }
+        } else if (info->fb_cursordata != cursor->image.data)
+                memcpy(info->fb_cursordata, cursor->image.data, dsize);
+	info->cursor.image.data = info->fb_cursordata;
+	splash_renderc(sd, info, info->cursor.image.fg_color, info->cursor.image.bg_color, (u8 *)info->fb_cursordata, info->cursor.image.dy + sd->splash_text_yo, info->cursor.image.dx + sd->splash_text_xo, info->cursor.image.height, info->cursor.image.width);
+}
+
+void splash_bmove_redraw(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int y, int sx, int dx, int width)
+{
+	unsigned short *d = (unsigned short *) (vc->vc_origin + vc->vc_size_row * y + dx * 2);
+	unsigned short *s = d + (dx - sx);
+	unsigned short *start = d;
+	unsigned short *ls = d;
+	unsigned short *le = d + width;
+	unsigned short c;
+	int x = dx;
+	unsigned short attr = 1;
+
+	do {
+		c = scr_readw(d);
+		if (attr != (c & 0xff00)) {
+			attr = c & 0xff00;
+			if (d > start) {
+				splash_putcs(sd, vc, info, start, d - start, y, x);
+				x += d - start;
+				start = d;
+			}
+		}
+		if (s >= ls && s < le && c == scr_readw(s)) {
+			if (d > start) {
+				splash_putcs(sd, vc, info, start, d - start, y, x);
+				x += d - start + 1;
+				start = d + 1;
+			} else {
+				x++;
+				start++;
+			}
+		}
+		s++;
+		d++;
+	} while (d < le);
+	if (d > start)
+		splash_putcs(sd, vc, info, start, d - start, y, x);
+}
+
+void splash_blank(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int blank)
+{
+	if (blank) {
+		if (info->silent_screen_base)
+		    splashset((u8 *)info->silent_screen_base, info->var.yres, info->var.xres, info->fix.line_length, 0, info->var.bits_per_pixel);
+		splashset((u8 *)info->screen_base, info->var.yres, info->var.xres, info->fix.line_length, 0, info->var.bits_per_pixel);
+	} else {
+		if (info->silent_screen_base)
+			splash_prepare(vc, info);
+		update_screen(vc->vc_num);
+		splash_clear_margins(vc->vc_splash_data, vc, info, 0);
+	}
+}
diff -burN linux-2.6.8.1-orig/drivers/video/console/fbcon.c linux-2.6.8.1/drivers/video/console/fbcon.c
--- linux-2.6.8.1-orig/drivers/video/console/fbcon.c	2004-08-14 19:55:47.000000000 +0900
+++ linux-2.6.8.1/drivers/video/console/fbcon.c	2007-01-24 13:19:57.000000000 +0900
@@ -93,6 +93,9 @@
 #endif
 
 #include "fbcon.h"
+#ifdef CONFIG_BOOTSPLASH
+#include "../bootsplash/bootsplash.h"
+#endif
 
 #ifdef FBCONDEBUG
 #  define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
@@ -210,8 +213,16 @@
 	    info->cursor.rop == ROP_COPY || !vc || !CON_IS_VISIBLE(vc)
 	    || registered_fb[(int) con2fb_map[vc->vc_num]] != info)
 		return;
+
 	acquire_console_sem();
 	info->cursor.enable ^= 1;
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_cursor(info->splash_data, info, &info->cursor);
+		release_console_sem();
+		return;
+	}
+#endif
 	info->fbops->fb_cursor(info, &info->cursor);
 	release_console_sem();
 }
@@ -410,6 +421,14 @@
 {
 	struct fb_copyarea area;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_bmove(info->splash_data, vc, info, 
+				sy, sx, dy, dx, height, width);
+		return;
+	}
+#endif
+
 	area.sx = sx * vc->vc_font.width;
 	area.sy = sy * vc->vc_font.height;
 	area.dx = dx * vc->vc_font.width;
@@ -426,6 +445,13 @@
 	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
 	struct fb_fillrect region;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_clear(info->splash_data, vc, info,
+				 sy, sx, height, width);
+		return;
+	}
+#endif
 	region.color = attr_bgcol_ec(bgshift, vc);
 	region.dx = sx * vc->vc_font.width;
 	region.dy = sy * vc->vc_font.height;
@@ -458,6 +484,12 @@
 	struct fb_image image;
 	u8 *src, *dst;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_putcs(info->splash_data, vc, info, s, count, yy, xx);
+		return;
+	}
+#endif
 	image.fg_color = attr_fgcol((vc->vc_hi_font_mask) ? 9 : 8,
 				    scr_readw(s));
 	image.bg_color = attr_bgcol((vc->vc_hi_font_mask) ? 13 : 12,
@@ -526,6 +558,13 @@
 	unsigned int bs = info->var.yres - bh;
 	struct fb_fillrect region;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+	 	splash_clear_margins(info->splash_data, vc, info, bottom_only);
+		return;
+	}
+#endif
+
 	region.color = attr_bgcol_ec(bgshift, vc);
 	region.rop = ROP_COPY;
 
@@ -622,6 +661,7 @@
 
 	cols = info->var.xres / vc->vc_font.width;
 	rows = info->var.yres / vc->vc_font.height;
+
 	vc_resize(vc->vc_num, cols, rows);
 
 	DPRINTK("mode:   %s\n", info->fix.id);
@@ -711,7 +751,7 @@
 	struct vc_data **default_mode = vc->vc_display_fg;
 	struct display *t, *p = &fb_display[vc->vc_num];
 	int display_fg = (*default_mode)->vc_num;
-	int logo = 1, new_rows, new_cols, rows, cols, charcnt = 256;
+	int logo = 0, new_rows, new_cols, rows, cols, charcnt = 256;
 	unsigned short *save = NULL, *r, *q;
 	int cap = info->flags;
 
@@ -750,6 +790,13 @@
 	rows = vc->vc_rows;
 	new_cols = info->var.xres / vc->vc_font.width;
 	new_rows = info->var.yres / vc->vc_font.height;
+#ifdef CONFIG_BOOTSPLASH
+	if (vc->vc_splash_data && vc->vc_splash_data->splash_state) {
+		new_cols = vc->vc_splash_data->splash_text_wi / vc->vc_font.width;
+		new_rows = vc->vc_splash_data->splash_text_he / vc->vc_font.height;
+		logo = 0;
+	}
+#endif
 	vc_resize(vc->vc_num, new_cols, new_rows);
 	/*
 	 * We must always set the mode. The mode of the previous console
@@ -843,6 +890,12 @@
 		}
 	}
 
+#ifdef CONFIG_BOOTSPLASH
+	if(vc->vc_splash_data && vc->vc_splash_data->splash_state) {
+		con_remap_def_color(vc->vc_num, vc->vc_splash_data->splash_color << 4 | vc->vc_splash_data->splash_fg_color);
+	}
+#endif 
+
 	if (vc->vc_num == display_fg && softback_buf) {
 		int l = fbcon_softback_size / vc->vc_size_row;
 		if (l > 5)
@@ -948,6 +1001,13 @@
 	if (vt_cons[vc->vc_num]->vc_mode != KD_TEXT)
 		return;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_putc(info->splash_data, vc, info, c, ypos, xpos);
+		return;
+	}
+#endif
+
 	image.dx = xpos * vc->vc_font.width;
 	image.dy = real_y(p, ypos) * vc->vc_font.height;
 	image.width = vc->vc_font.width;
@@ -1025,6 +1085,12 @@
 		if (info->cursor.rop == ROP_XOR) {
 			info->cursor.enable = 0;
 			info->cursor.rop = ROP_COPY;
+#ifdef CONFIG_BOOTSPLASH
+			if (info->splash_data) {
+				splash_cursor(info->splash_data, info, &cursor);
+				break;
+			}
+#endif
 			info->fbops->fb_cursor(info, &cursor);
 		}	
 		break;
@@ -1101,6 +1167,13 @@
 				mask[i++] = 0xff;
 		}
         	info->cursor.rop = ROP_XOR;
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			splash_cursor(info->splash_data, info, &cursor);
+			vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+			break;
+		}
+#endif
 		info->fbops->fb_cursor(info, &cursor);
 		vbl_cursor_cnt = CURSOR_DRAW_DELAY;
 		break;
@@ -1540,6 +1613,10 @@
 			fbcon_softback_note(vc, t, count);
 		if (logo_shown >= 0)
 			goto redraw_up;
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data)
+			goto redraw_up;
+#endif
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
 			accel_bmove(vc, info, t + count, 0, t, 0,
@@ -1625,6 +1702,10 @@
 	case SM_DOWN:
 		if (count > vc->vc_rows)	/* Maximum realistic size */
 			count = vc->vc_rows;
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data)
+			goto redraw_up;
+#endif
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
 			accel_bmove(vc, info, t, 0, t + count, 0,
@@ -1767,6 +1848,15 @@
 		}
 		return;
 	}
+	
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data && sy == dy && height == 1) {
+		/* must use slower redraw bmove to keep background pic intact */
+		splash_bmove_redraw(info->splash_data, vc, info, sy, sx, dx, width);
+		return;
+	}
+#endif
+
 	accel_bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,
 			height, width);
 }
@@ -1849,6 +1939,10 @@
 	struct display *p = &fb_display[vc->vc_num];
 	int i;
 
+#ifdef CONFIG_BOOTSPLASH
+	splash_prepare(vc, info);
+#endif
+
 	if (softback_top) {
 		int l = fbcon_softback_size / vc->vc_size_row;
 		if (softback_lines)
@@ -1966,6 +2060,12 @@
 	fbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);
 
 	if (!info->fbops->fb_blank) {
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			splash_blank(info->splash_data, vc, info, blank);
+			return 0;
+		}
+#endif
 		if (blank) {
 			unsigned short oldc;
 			u_int height;
@@ -2134,9 +2234,16 @@
 	}
 
 	if (resize) {
+ 		u32 xres = info->var.xres, yres = info->var.yres;
 		/* reset wrap/pan */
 		info->var.xoffset = info->var.yoffset = p->yscroll = 0;
-		vc_resize(vc->vc_num, info->var.xres / w, info->var.yres / h);
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			xres = info->splash_data->splash_text_wi;
+			yres = info->splash_data->splash_text_he;
+		}
+#endif
+		vc_resize(vc->vc_num, xres / w, yres / h);
 		if (CON_IS_VISIBLE(vc) && softback_buf) {
 			int l = fbcon_softback_size / vc->vc_size_row;
 			if (l > 5)
@@ -2310,6 +2417,42 @@
 	else
 		palette_cmap.len = 16;
 	palette_cmap.start = 0;
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+
+		u16 red[256], green[256], blue[256];
+		u32 col;
+		int minlen = min(min(info->var.red.length, info->var.green.length), info->var.blue.length);
+		int h;
+
+		struct fb_cmap cmap = {
+			.start = 0,
+			.len = (1 << minlen),
+			.red = red,
+			.green = green,
+			.blue = blue,
+			.transp = NULL
+		};
+
+		for (i = 0; i < cmap.len; i++) {
+			red[i] = green[i] = blue[i] = (0xffff * i)/(cmap.len-1);
+		}
+
+		h = fb_set_cmap(&cmap,info);
+
+		for (j = i = 0; i < 16; i++) {
+			k = table[i];
+                       
+			col = ((vc->vc_palette[j++]  >> (8-minlen)) << info->var.red.offset);
+			col |= ((vc->vc_palette[j++] >> (8-minlen)) << info->var.green.offset);
+			col |= ((vc->vc_palette[j++] >> (8-minlen)) << info->var.blue.offset);
+
+			((u32 *)info->pseudo_palette)[k] = col;
+		}
+
+		return h;
+	} else
+#endif
 	return fb_set_cmap(&palette_cmap, info);
 }
 
@@ -2618,6 +2761,11 @@
 	}
 	for (i = first_fb_vc; i <= last_fb_vc; i++)
 		con2fb_map[i] = info_idx;
+
+#ifdef CONFIG_BOOTSPLASH
+	splash_init();
+#endif
+
 	err = take_over_console(&fb_con, first_fb_vc, last_fb_vc,
 				fbcon_is_default);
 	if (err) {
diff -burN linux-2.6.8.1-orig/drivers/video/console/fbcon.h linux-2.6.8.1/drivers/video/console/fbcon.h
--- linux-2.6.8.1-orig/drivers/video/console/fbcon.h	2004-08-14 19:55:48.000000000 +0900
+++ linux-2.6.8.1/drivers/video/console/fbcon.h	2007-01-24 13:19:57.000000000 +0900
@@ -23,6 +23,34 @@
     *    low-level frame buffer device
     */
 
+#ifdef CONFIG_BOOTSPLASH
+struct splash_data {
+    int splash_state;			/* show splash? */
+    int splash_color;			/* transparent color */
+    int splash_fg_color;		/* foreground color */
+    int splash_width;			/* width of image */
+    int splash_height;			/* height of image */
+    int splash_text_xo;			/* text area origin */
+    int splash_text_yo;
+    int splash_text_wi;			/* text area size */ 
+    int splash_text_he;
+    int splash_showtext;		/* silent/verbose mode */
+    int splash_boxcount;
+    int splash_percent;
+    int splash_overpaintok;		/* is it ok to overpaint boxes */
+    int splash_palcnt;
+    char *oldscreen_base;		/* pointer to top of virtual screen */
+    unsigned char *splash_boxes;
+    unsigned char *splash_jpeg;		/* jpeg */
+    unsigned char *splash_palette;	/* palette for 8-bit */
+
+    int splash_dosilent;		/* show silent jpeg */
+    unsigned char *splash_silentjpeg;
+    unsigned char *splash_sboxes;
+    int splash_sboxcount;
+};
+#endif
+
 struct display {
     /* Filled in by the frame buffer device */
     u_short inverse;                /* != 0 text black on white as default */
diff -burN linux-2.6.8.1-orig/drivers/video/ep93xxfb.c linux-2.6.8.1/drivers/video/ep93xxfb.c
--- linux-2.6.8.1-orig/drivers/video/ep93xxfb.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/drivers/video/ep93xxfb.c	2007-01-15 12:17:44.000000000 +0900
@@ -0,0 +1,1636 @@
+/*
+ * linux/drivers/video/ep93xxfb.c -- Frame buffer device for the EP93xx
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/reboot.h>
+#include <video/ep93xxfb.h>
+#include <asm/arch/cx25871.h>
+#include <asm/uaccess.h>
+
+dma_addr_t fb_phys;
+#define devicename				"ep93xxfb"
+
+static  int
+ep93xxfb_ioctl(struct inode *inode, struct file *file,
+               unsigned int cmd, unsigned long arg, struct fb_info *info);
+
+
+#ifdef CONFIG_FB_EP93XX_8BPP
+        #define BITS_PER_PIXEL 8
+        #define BYTES_PER_PIXEL 1
+        #define PIXEL_MASK 3
+        #define PIXEL_SHIFT 2
+        #define PIXEL_FORMAT 0x00040000
+#endif
+                                                                                                                             
+#ifdef CONFIG_FB_EP93XX_16BPP
+       #define BITS_PER_PIXEL 16
+       #define BYTES_PER_PIXEL 2
+       #define PIXEL_MASK 1
+       #define PIXEL_SHIFT 1
+       #define PIXEL_FORMAT 0x00080000
+#endif
+
+
+static unsigned long
+isqrt(unsigned long a)
+{
+        unsigned long rem = 0;
+        unsigned long root = 0;
+        int i;
+                                                                                                                             
+        for (i = 0; i < 16; i++) {
+                root <<= 1;
+                rem = ((rem << 2) + (a >> 30));
+                a <<= 2;
+                root++;
+                if (root <= rem) {
+                        rem -= root;
+                        root++;
+                } else
+                        root--;
+        }
+        return root >> 1;
+}
+
+
+
+struct ep93xxfb_videotimings
+{
+	const char *name;
+	void (*configure)(struct fb_info *info);
+	void (*on)(struct fb_info *info);
+	void (*off)(struct fb_info *info);
+
+	unsigned long hres;
+	unsigned long hfp;
+	unsigned long hsync;
+	unsigned long hbp;
+
+	unsigned long vres;
+	unsigned long vfp;
+	unsigned long vsync;
+	unsigned long vbp;
+
+	unsigned long refresh;
+	unsigned long width;
+	unsigned long height;
+
+	unsigned long clk_src:1;
+	unsigned long clk_edge:1;
+	unsigned long pol_blank:1;
+	unsigned long pol_hsync:1;
+	unsigned long pol_vsync:1;
+};
+
+#define POL_HIGH				1
+#define POL_LOW					0
+#define EDGE_RISING				1
+#define EDGE_FALLING				0
+#define CLK_INTERNAL				1
+#define CLK_EXTERNAL				0
+
+#define GPIO_DR					GPIO_PGDR
+#define GPIO_DDR				GPIO_PGDDR
+#define GPIO_CLK				(1 << 0)
+#define GPIO_DAT				(1 << 1)
+#define DELAY_USEC				2
+#define READ_TIMEOUT				100
+
+
+#define EE_DELAY_USEC			2
+#define EE_READ_TIMEOUT			100
+#define CX25871_DEV_ADDRESS		0x88
+
+
+#define GPIOG_EEDAT 2
+#define GPIOG_EECLK 1
+
+static int
+write_reg(unsigned char ucRegAddr, unsigned char ucRegValue)
+{
+  	unsigned long uiVal, uiDDR;
+	unsigned char ucData, ucIdx, ucBit;
+	unsigned long ulTimeout;
+
+	uiVal = inl(GPIO_PGDR);
+	uiDDR = inl(GPIO_PGDDR);
+
+	uiVal |= (GPIOG_EEDAT | GPIOG_EECLK);
+	outl( uiVal, GPIO_PGDR );
+
+	udelay( EE_DELAY_USEC );
+
+	uiDDR |= (GPIOG_EEDAT | GPIOG_EECLK);
+	outl( uiDDR, GPIO_PGDDR );
+
+	udelay( EE_DELAY_USEC );
+
+	uiVal &= ~GPIOG_EEDAT;
+	outl( uiVal, GPIO_PGDR );
+
+	udelay( EE_DELAY_USEC );
+
+	uiVal &= ~GPIOG_EECLK;
+	outl( uiVal, GPIO_PGDR );
+
+	udelay( EE_DELAY_USEC );
+
+	for (ucIdx = 0; ucIdx < 3; ucIdx++) {
+		if (ucIdx == 0)
+			ucData = (unsigned char)CX25871_DEV_ADDRESS;
+		else if (ucIdx == 1)
+			ucData = ucRegAddr;
+		else
+			ucData = ucRegValue;
+
+	        for (ucBit = 0; ucBit < 8; ucBit++) {
+			if (ucData & 0x80)
+				uiVal |= GPIOG_EEDAT;
+			else
+				uiVal &= ~GPIOG_EEDAT;
+			outl( uiVal, GPIO_PGDR );
+
+			udelay( EE_DELAY_USEC );
+
+			outl( (uiVal | GPIOG_EECLK), GPIO_PGDR );
+
+			udelay( EE_DELAY_USEC );
+
+			outl( uiVal, GPIO_PGDR );
+
+			udelay( EE_DELAY_USEC );
+
+			ucData <<= 1;
+		}
+
+		uiDDR &= ~GPIOG_EEDAT;
+		outl( uiDDR, GPIO_PGDDR );
+
+		udelay( EE_DELAY_USEC );
+
+		outl( (uiVal | GPIOG_EECLK), GPIO_PGDR );
+
+		udelay( EE_DELAY_USEC );
+
+		ulTimeout = 0;
+		while ( inl(GPIO_PGDR) & GPIOG_EEDAT ) {
+			udelay( EE_DELAY_USEC );
+			ulTimeout++;
+			if (ulTimeout > EE_READ_TIMEOUT )
+				return 1;
+		}
+
+		outl( uiVal, GPIO_PGDR );
+
+		udelay( EE_DELAY_USEC );
+
+		uiDDR |= GPIOG_EEDAT;
+		outl( uiDDR, GPIO_PGDDR );
+		udelay( EE_DELAY_USEC );
+	}
+
+	uiVal &= ~GPIOG_EEDAT;
+	outl( uiVal, GPIO_PGDR );
+
+	udelay( EE_DELAY_USEC );
+
+	uiVal |= GPIOG_EECLK;
+	outl( uiVal, GPIO_PGDR );
+
+	udelay( EE_DELAY_USEC );
+
+	uiVal |= GPIOG_EEDAT;
+	outl( uiVal, GPIO_PGDR );
+
+	udelay( EE_DELAY_USEC );
+
+
+	return 0;
+}
+
+static void
+philips_lb064v02_on(struct fb_info *info)
+{
+	outl(inl(GPIO_PADDR) | 2, GPIO_PADDR);
+	outl(inl(GPIO_PADR) | 2, GPIO_PADR);
+}
+
+static void
+philips_lb064v02_off(struct fb_info *info)
+{
+	outl(inl(GPIO_PADR) & ~2, GPIO_PADR);
+}
+
+static int
+conexant_cx25871_reboot(struct notifier_block *this, unsigned long event,
+			void *x)
+{
+	switch (event) {
+	case SYS_HALT:
+	case SYS_POWER_OFF:
+	case SYS_RESTART:
+		write_reg(0xba, 0x80); //0x88
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static struct notifier_block conexant_cx25871_notifier = {
+	conexant_cx25871_reboot,
+	NULL,
+	5
+};
+
+static void
+conexant_cx25871_configure_ntsc(struct fb_info *info)
+{
+	write_reg(0xb8, 0x00);
+       	write_reg(0xBA, CX25871_REGxBA_SLAVER | CX25871_REGxBA_DACOFF);     
+        write_reg(0xC6, (CX25871_REGxC6_INMODE_MASK & 0x3));
+	write_reg(0xC4, CX25871_REGxC4_EN_OUT);
+	write_reg(0x32, 0);
+	write_reg(0xBA, CX25871_REGxBA_SLAVER );
+
+	register_reboot_notifier(&conexant_cx25871_notifier);
+}
+
+static void
+conexant_cx25871_configure_pal(struct fb_info *info)
+{
+	write_reg(0xb8, 0x01);
+       	write_reg(0xBA, CX25871_REGxBA_SLAVER | CX25871_REGxBA_DACOFF);     
+        write_reg(0xC6, (CX25871_REGxC6_INMODE_MASK & 0x3));
+	write_reg(0xC4, CX25871_REGxC4_EN_OUT);
+	write_reg(0x32, 0);
+	write_reg(0xBA, CX25871_REGxBA_SLAVER );
+
+	register_reboot_notifier(&conexant_cx25871_notifier);
+}
+
+
+
+static void
+conexant_cx25871_overscan_configure(struct fb_info *info)
+{
+	write_reg(0xb8, 0x00);
+	write_reg(0xba, 0x30);
+	write_reg(0x34, 0x9b);
+	write_reg(0x36, 0xc0);
+	write_reg(0xc8, 0x92);
+	write_reg(0xca, 0xd3);
+	write_reg(0xcc, 0xd3);
+	write_reg(0xd8, 0x60);
+	write_reg(0x38, 0x00);
+	write_reg(0x76, 0x10);
+	write_reg(0x78, 0x80);
+	write_reg(0x7a, 0x72);
+	write_reg(0x7c, 0x82);
+	write_reg(0x7e, 0x42);
+	write_reg(0x80, 0xF5);
+	write_reg(0x82, 0x13);
+	write_reg(0x84, 0xF2);
+	write_reg(0x86, 0x26);
+	write_reg(0x88, 0x00);
+	write_reg(0x8a, 0x08);
+	write_reg(0x8c, 0x77);
+	write_reg(0x8e, 0x03);
+	write_reg(0x90, 0x0D);
+	write_reg(0x92, 0x24);
+	write_reg(0x94, 0xE0);
+	write_reg(0x96, 0x06);
+	write_reg(0x98, 0x00);
+	write_reg(0x9a, 0x10);
+	write_reg(0x9c, 0x68);
+	write_reg(0x9e, 0xDA);
+	write_reg(0xa0, 0x0A);
+	write_reg(0xa2, 0x0A);
+	write_reg(0xa4, 0xE5);
+	write_reg(0xa6, 0x77);
+	write_reg(0xa8, 0xC2);
+	write_reg(0xaa, 0x8A);
+	write_reg(0xac, 0x9A);
+	write_reg(0xae, 0x12);
+	write_reg(0xb0, 0x99);
+	write_reg(0xb2, 0x86);
+	write_reg(0xb4, 0x25);
+	write_reg(0xb6, 0x00);
+	write_reg(0xbc, 0x00);
+	write_reg(0xbe, 0x00);
+	write_reg(0xc0, 0x00);
+	write_reg(0xc2, 0x00);
+	mdelay(1);
+	write_reg(0x6c, 0xc4);
+	write_reg(0xc6, 0x03);
+	write_reg(0xc4, 0x01);
+	write_reg(0x32, 0x00);
+	register_reboot_notifier(&conexant_cx25871_notifier);
+}
+
+static void
+conexant_cx25871_on(struct fb_info *info)
+{
+	write_reg(0xba, 0x20);
+}
+
+static void
+conexant_cx25871_off(struct fb_info *info)
+{
+	write_reg(0xba, 0x30);
+}
+
+static struct ep93xxfb_videotimings modedb[] = {
+#if defined(CONFIG_FB_EP93XX_KENWOOD_LCD)
+	[0] = {
+		.name =		"508x234",
+		.hres =		508,
+		.hfp =		 10,
+		.hsync =	45,
+		.hbp =		47,
+		.vres =		234,
+		.vfp =		9,
+		.vsync =	3,
+		.vbp =		17,
+		.refresh =	60,
+		.width =	300,
+		.height =	230,
+		.clk_src =	CLK_INTERNAL,
+//		.clk_src =	CLK_EXTERNAL,
+		.clk_edge =	EDGE_RISING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_LOW,
+		.pol_vsync =	POL_LOW,
+	},
+#else
+	[0] = {
+		.name =		"CRT-640x480",
+		.hres =		640,
+		.hfp =		16,
+		.hsync =	96,
+		.hbp =		48,
+		.vres =		480,
+		.vfp =		10,
+		.vsync =	2,
+		.vbp =		33,
+		.refresh =	60,
+		.width =	300,
+		.height =	230,
+		.clk_src =	CLK_INTERNAL,
+		.clk_edge =	EDGE_RISING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_LOW,
+		.pol_vsync =	POL_LOW,
+	},
+#endif
+	[1] = {
+		.name =		"CRT-800x600",
+		.hres =		800,
+		.hfp =		40,
+		.hsync =	128,
+		.hbp =		88,
+		.vres =		600,
+		.vfp =		1,
+		.vsync =	4,
+		.vbp =		23,
+		.refresh =	60,
+		.width =	300,
+		.height =	230,
+		.clk_src =	CLK_INTERNAL,
+		.clk_edge =	EDGE_RISING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_HIGH,
+		.pol_vsync =	POL_HIGH,
+	},
+	[2] = {
+		.name =		"CRT-1024x768",
+		.hres =		1024,
+		.hfp =		24,
+		.hsync =	136,
+		.hbp =		160,
+		.vres =		768,
+		.vfp =		3,
+		.vsync =	6,
+		.vbp =		29,
+		.refresh =	60,
+		.width =	300,
+		.height =	230,
+		.clk_src =	CLK_INTERNAL,
+		.clk_edge =	EDGE_RISING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_LOW,
+		.pol_vsync =	POL_LOW,
+	},
+	[3] = {
+		.name =		"CRT-1280x1024",
+		.hres =		1280,
+		.hfp =		48,
+		.hsync =	112,
+		.hbp =		120,
+		.vres =		1024,
+		.vfp =		1,
+		.vsync =	3,
+		.vbp =		38,
+		.refresh =	60,
+		.width =	300,
+		.height =	230,
+		.clk_src =	CLK_INTERNAL,
+		.clk_edge =	EDGE_RISING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_HIGH,
+		.pol_vsync =	POL_HIGH,
+	},
+	[4] = {
+		.name =		"Philips-LB064V02",
+		.on =		philips_lb064v02_on,
+		.off =		philips_lb064v02_off,
+		.hres =		640,
+		.hfp =		24,
+		.hsync =	96,
+		.hbp =		40,
+		.vres =		480,
+		.vfp =		10,
+		.vsync =	2,
+		.vbp =		33,
+		.refresh =	60,
+		.width =	132,
+		.height =	100,
+		.clk_src =	CLK_INTERNAL,
+		.clk_edge =	EDGE_FALLING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_LOW,
+		.pol_vsync =	POL_LOW,
+	},
+	[5] = {
+		.name =		"Conexant-CX25871-NTSC",
+		.configure =	conexant_cx25871_configure_ntsc,
+		.on =		conexant_cx25871_on,
+		.off =		conexant_cx25871_off,
+		.hres =		640,
+		.hfp =		16,
+		.hsync =	4,
+		.hbp =		124,
+		.vres =		480,
+		.vfp =		45,
+		.vsync =	2,
+		.vbp =		73,
+		.refresh =	35466,
+		.width =	300,
+		.height =	230,
+		.clk_src =	CLK_EXTERNAL,
+		.clk_edge =	EDGE_FALLING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_LOW,
+		.pol_vsync =	POL_LOW,
+	},
+	[6] = {
+		.name =		"Conexant-CX25871-overscan",
+		.configure =	conexant_cx25871_overscan_configure,
+		.on =		conexant_cx25871_on,
+		.off =		conexant_cx25871_off,
+		.hres =		640,
+		.hfp =		15,
+		.hsync =	4,
+		.hbp =		117,
+		.vres =		480,
+		.vfp =		9,
+		.vsync =	2,
+		.vbp =		34,
+		.refresh =	40950,
+		.width =	300,
+		.height =	230,
+		.clk_src =	CLK_EXTERNAL,
+		.clk_edge =	EDGE_FALLING,
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_LOW,
+		.pol_vsync =	POL_LOW,
+	},
+	[7] = {
+		.name =		"Conexant-CX25871-PAL",
+		.configure =	conexant_cx25871_configure_pal,
+		.on =		conexant_cx25871_on,
+		.off =		conexant_cx25871_off,
+		.hres =		640,
+		.hfp =		50, //50
+		.hsync =	4,//4 
+		.hbp =		250, //250
+		.vres =		480,
+		.vfp =		50,
+		.vsync =	2,
+		.vbp =		93,
+		.refresh =	35466,
+		.width =	320, //300
+		.height =	240, //230
+		.clk_src =	CLK_EXTERNAL,
+		.clk_edge =	EDGE_FALLING, 
+		.pol_blank =	POL_LOW,
+		.pol_hsync =	POL_LOW,
+		.pol_vsync =	POL_LOW,
+	},
+};
+
+
+#if defined(CONFIG_KW_WQVGA)
+#define DEFAULT_MODE 0
+#else
+#if defined(CONFIG_FB_EP93XX_CRT)
+#define DEFAULT_MODE 0 
+#elif defined(CONFIG_FB_EP93XX_LCD)
+#define DEFAULT_MODE 4
+#elif defined(CONFIG_FB_EP93XX_PAL)
+#define DEFAULT_MODE 7
+#elif defined(CONFIG_FB_EP93XX_NTSC)
+#ifdef CONFIG_FB_EP93XX_NTSC_OVERSCAN
+#define DEFAULT_MODE 6
+#else
+#define DEFAULT_MODE 5
+#endif
+#else
+#define DEFAULT_MODE 0
+#endif
+#endif
+
+#if defined(CONFIG_FB_EP93XX_8BPP)
+#define DEFAULT_BPP  8
+#elif defined(CONFIG_FB_EP93XX_16BPP)
+#define DEFAULT_BPP 16
+#else
+#define DEFAULT_BPP 16
+#endif
+
+
+static unsigned int pseudo_palette[256];
+
+
+#ifdef MODULE
+static char *modestr = 0;
+#endif
+static int mode = DEFAULT_MODE;
+static int bpp = DEFAULT_BPP;
+
+#define ep93xxfb_outl(value, reg)				\
+	{							\
+		outl(RASTER_SWLOCK_VALUE, RASTER_SWLOCK);	\
+		outl(value, reg);				\
+	}
+	
+	
+	
+
+
+
+static DECLARE_WAIT_QUEUE_HEAD(ep93xxfb_wait_in);
+
+static irqreturn_t
+ep93xxfb_irq_handler(int i, void *blah, struct pt_regs *regs)
+{
+        outl(0x00000000, BLOCKCTRL);
+                                                                                
+        wake_up_interruptible(&ep93xxfb_wait_in);
+        
+        return IRQ_HANDLED; 
+
+}
+
+static void
+ep93xxfb_wait(void)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	add_wait_queue(&ep93xxfb_wait_in, &wait);
+	current->state = TASK_INTERRUPTIBLE;
+	while (inl(BLOCKCTRL) & 0x00000001) {
+		schedule();
+		current->state = TASK_INTERRUPTIBLE;
+	}
+	remove_wait_queue(&ep93xxfb_wait_in, &wait);
+	current->state = TASK_RUNNING;
+}
+
+
+
+static int
+ep93xxfb_line(struct fb_info *info,  struct ep93xx_line *line)
+{
+        unsigned long value = 0;
+        long dx, dy, count, xinc, yinc, xval, yval, incr;
+        
+                                                                                                                       
+        if ((line->x1 >= info->var.xres) ||
+            (line->x2 >= info->var.xres) ||
+            (line->y1 >= info->var.yres) ||
+            (line->y2 >= info->var.yres))
+                return -EFAULT;
+                                                                                                                             
+        dx = line->x2 - line->x1;
+        if (dx < 0) {
+                value |= 0x00000020;
+                dx *= -1;
+        }
+        dy = line->y2 - line->y1;
+        if (dy < 0) {
+                value |= 0x00000040;
+                dy *= -1;
+        }
+        if (line->flags & LINE_PRECISE) {
+                count = isqrt(((dy * dy) + (dx * dx)) * 4096);
+                xinc = (4095 * 64 * dx) / count;
+                yinc = (4095 * 64 * dy) / count;
+                xval = 2048;
+                yval = 2048;
+                count = 0;
+                while (dx || dy) {
+                        incr = 0;
+                        xval -= xinc;
+                        if (xval <= 0) {
+                                   xval += 4096;
+                                dx--;
+                                incr = 1;
+                        }
+                        yval -= yinc;
+                        if (yval <= 0) {
+                                yval += 4096;
+                                dy--;
+                                incr = 1;
+                        }
+                        count += incr;
+                }
+        } else {
+                if (dx == dy) {
+                        xinc = 4095;
+                        yinc = 4095;
+                        count = dx;
+                } else if (dx < dy) {
+                        xinc = (dx * 4095) / dy;
+                        yinc = 4095;
+                        count = dy;
+                } else {
+                        xinc = 4095;
+                        yinc = (dy * 4095) / dx;
+                        count = dx;
+                }
+        }
+                                                                                                                             
+        outl(0x08000800, LINEINIT);
+        if (line->flags & LINE_PATTERN)
+                outl(line->pattern, LINEPATTRN);
+        else
+                outl(0x000fffff, LINEPATTRN);
+        outl(fb_phys + (line->y1 *(info->var.xres * BYTES_PER_PIXEL)) +
+             ((line->x1 * BYTES_PER_PIXEL) & ~PIXEL_MASK), BLKDSTSTRT);
+        outl(((line->x1 & PIXEL_MASK) * BITS_PER_PIXEL) |
+             ((((line->x1 + dx - 1) & PIXEL_MASK) *
+               BITS_PER_PIXEL) << 16), DESTPIXELSTRT);
+        outl((info->var.xres * BYTES_PER_PIXEL)/ 4, DESTLINELENGTH);
+        outl(line->fgcolor, BLOCKMASK);
+        outl(line->bgcolor, BACKGROUND);
+        outl((yinc << 16) | xinc, LINEINC);
+        outl(count & 0xfff, BLKDESTWIDTH);
+        outl(0, BLKDESTHEIGHT);
+        value |= (line->flags & LINE_BACKGROUND) ? 0x00004000 : 0;
+        outl(value | PIXEL_FORMAT | 0x00000013, BLOCKCTRL);
+        ep93xxfb_wait();                                                                                                                    
+        return 0;
+}
+
+
+static int
+ep93xxfb_fill(struct fb_info *info, struct ep93xx_fill *fill)
+{
+        
+  
+        if ((fill->dx >= info->var.xres) ||
+            (fill->dy >= info->var.yres))
+                return -EFAULT;
+                                                                                                                             
+        if ((fill->dx + fill->width - 1) >= info->var.xres)
+                fill->width = info->var.xres - fill->dx;
+        if ((fill->dy + fill->height - 1) >= info->var.yres)
+                fill->height = info->var.yres - fill->dy;
+                                                                                                                             
+        outl(fb_phys + (fill->dy *(info->var.xres * BYTES_PER_PIXEL)) +
+             ((fill->dx * BYTES_PER_PIXEL) & ~PIXEL_MASK), BLKDSTSTRT);
+        outl(((fill->dx & PIXEL_MASK) * BITS_PER_PIXEL) |
+             ((((fill->dx + fill->width - 1) & PIXEL_MASK) *
+               BITS_PER_PIXEL) << 16), DESTPIXELSTRT);
+        outl((info->var.xres * BYTES_PER_PIXEL)/ 4, DESTLINELENGTH);
+        outl(((fill->dx + fill->width - 1) >> PIXEL_SHIFT) -
+             (fill->dx >> PIXEL_SHIFT), BLKDESTWIDTH);
+        outl(fill->height - 1, BLKDESTHEIGHT);
+        outl(fill->color, BLOCKMASK);
+        outl(PIXEL_FORMAT | 0x0000000b, BLOCKCTRL);
+      
+        ep93xxfb_wait();
+                                                                                                                             
+        return 0;
+}
+
+
+static unsigned char pucBlitBuf[4096];
+
+static int
+ep93xxfb_blit(struct fb_info *info, struct ep93xx_blit *blit)
+{
+        unsigned long value = 0, size, dx1, dx2, dy1, sx1, sx2, sy1;
+        
+                                                                                                                          
+        if ((blit->dx >= info->var.xres) ||
+            (blit->dy >= info->var.yres) ||
+            ((blit->dx + blit->width - 1) >= info->var.xres) ||
+            ((blit->dy + blit->height - 1) >= info->var.yres))
+                return -EFAULT;
+                                                                                                                             
+        value = blit->flags & (BLIT_TRANSPARENT | BLIT_MASK_MASK |
+                               BLIT_DEST_MASK | BLIT_1BPP_SOURCE);
+                                                                                                                             
+        if ((blit->flags & BLIT_SOURCE_MASK) == BLIT_SOURCE_MEMORY) {
+                if (blit->flags & BLIT_1BPP_SOURCE) {
+                        size = blit->swidth * blit->height / 8;
+                        if (size <= 4096)
+                                copy_from_user(pucBlitBuf, blit->data, size);
+                        else {
+                                for (size = blit->height; size; ) {
+                                        blit->height = 32768 / blit->swidth;
+                                        if (blit->height > size)
+                                                blit->height = size;
+                                        ep93xxfb_blit(info, blit);
+                                        blit->dy += blit->height;
+                                        blit->data += blit->swidth *
+                                                      blit->height / 8;
+                                        size -= blit->height;
+                                }
+                                return 0;
+                        }
+                        if (blit->flags & BLIT_TRANSPARENT)
+                                value ^= 0x00004000;
+                        outl(0x00000007, SRCPIXELSTRT);
+                        outl(blit->swidth >> 5, SRCLINELENGTH);
+                        outl((blit->width - 1) >> 5, BLKSRCWIDTH);
+                        outl(blit->bgcolor, BACKGROUND);
+                } else {
+                        size = blit->swidth * blit->height * BYTES_PER_PIXEL;
+                        if (size <= 4096)
+                                copy_from_user(pucBlitBuf, blit->data, size);
+                        else {
+                                for (size = blit->height; size; ) {
+                                        blit->height = 4096 / BYTES_PER_PIXEL /
+                                                       blit->swidth;
+                                        if (blit->height > size)
+                                                blit->height = size;
+                                        ep93xxfb_blit(info,blit);
+                                        blit->dy += blit->height;
+                                        blit->data += blit->swidth *
+                                                      blit->height *
+                                                      BYTES_PER_PIXEL;
+                                        size -= blit->height;
+                                }
+                                return 0;
+                        }
+                        outl(0x00000000, SRCPIXELSTRT);
+                        outl(blit->swidth >> PIXEL_SHIFT, SRCLINELENGTH);
+                        outl((blit->width - 1) >> PIXEL_SHIFT, BLKSRCWIDTH);
+                }
+                outl(virt_to_phys(pucBlitBuf), BLKSRCSTRT);
+                dx1 = blit->dx;
+                dy1 = blit->dy;
+                dx2 = blit->dx + blit->width - 1;
+        } else {					//SOURCE_SCREEN
+                if ((blit->sx >= info->var.xres) ||
+                    (blit->sy >= info->var.yres) ||
+                    ((blit->sx + blit->width - 1) >= info->var.xres) ||
+                    ((blit->sy + blit->height - 1) >= info->var.yres))
+                        return -EFAULT;
+                                                                                                                             
+                if ((blit->dy == blit->sy) && (blit->dx == blit->sx))
+                        return 0;
+                                                                                                                             
+                if ((blit->dy == blit->sy) &&
+                    (blit->dx > blit->sx) &&
+                    (blit->dx < (blit->sx + blit->width - 1))) {
+                        dx1 = blit->dx + blit->width - 1;
+                        dx2 = blit->dx;
+                        sx1 = blit->sx + blit->width - 1;
+                        sx2 = blit->sx;
+                        value |= 0x000000a0;
+                } else {
+                        dx1 = blit->dx;
+                        dx2 = blit->dx + blit->width - 1;
+                        sx1 = blit->sx;
+                        sx2 = blit->sx + blit->width - 1;
+                }
+                                                                                                                             
+                if (blit->dy <= blit->sy) {
+                        dy1 = blit->dy;
+                        sy1 = blit->sy;
+                } else {
+                        dy1 = blit->dy + blit->height - 1;
+                        sy1 = blit->sy + blit->height - 1;
+                        value |= 0x00000140;
+                }
+                                                                                                                             
+                outl(((sx1 & PIXEL_MASK) * BITS_PER_PIXEL) |
+                     (((sx2 & PIXEL_MASK) * BITS_PER_PIXEL) << 16),
+                     SRCPIXELSTRT);
+		     
+                outl(fb_phys + (sy1 *(info->var.xres * BYTES_PER_PIXEL)) +
+                     ((sx1 * BYTES_PER_PIXEL) & ~PIXEL_MASK), BLKSRCSTRT);
+
+		     
+                outl((info->var.xres * BYTES_PER_PIXEL)/ 4, SRCLINELENGTH);
+                 if (sx1 < sx2)
+                        outl((sx2 >> PIXEL_SHIFT) - (sx1 >> PIXEL_SHIFT),
+                             BLKSRCWIDTH);
+                else
+                        outl((sx1 >> PIXEL_SHIFT) - (sx2 >> PIXEL_SHIFT),
+                             BLKSRCWIDTH);
+        }
+                                                                                                                             
+        outl(((dx1 & PIXEL_MASK) * BITS_PER_PIXEL) |
+             (((dx2 & PIXEL_MASK) * BITS_PER_PIXEL) << 16), DESTPIXELSTRT);
+        outl(fb_phys + (dy1 *(info->var.xres * BYTES_PER_PIXEL)) +
+              ((dx1 * BYTES_PER_PIXEL) & ~PIXEL_MASK), BLKDSTSTRT);
+
+        outl((info->var.xres * BYTES_PER_PIXEL)/ 4, DESTLINELENGTH);
+        if (dx1 < dx2)
+                outl((dx2 >> PIXEL_SHIFT) - (dx1 >> PIXEL_SHIFT),
+                     BLKDESTWIDTH);
+        else
+                outl((dx1 >> PIXEL_SHIFT) - (dx2 >> PIXEL_SHIFT),
+                     BLKDESTWIDTH);
+        outl(blit->height - 1, BLKDESTHEIGHT);
+        outl(blit->fgcolor, BLOCKMASK);
+        outl(blit->transcolor, TRANSPATTRN);
+        outl(value | PIXEL_FORMAT | 0x00000003, BLOCKCTRL);
+        ep93xxfb_wait();                                                                                                           
+        return 0;
+}
+
+
+
+static int
+ep93xxfb_cursor(struct fb_info *info, struct ep93xx_cursor *cursor)
+{
+#ifdef CONFIG_FB_EP93XX_KENWOOD_LCD 
+
+	static unsigned long cursor_data[64][4];
+//	static unsigned long cursor_data_off[64][4];
+
+	unsigned long data[64 * 4];
+	long i, j, x, y, save;
+      
+//	if (cursor->flags & CURSOR_OFF) {
+//	}
+	 
+	if ( cursor->flags & CURSOR_SETSHAPE ) {
+		copy_from_user(data, cursor->data, cursor->width * cursor->height/4);
+ 
+		save = inl(CURSORXYLOC);
+		for ( y = 0, i = 0; y < cursor->height; y++ ) {
+			for (x = 0, j = 0; x < cursor->width; x += 16, j++ )
+				cursor_data[y][j] = data[i++];
+		}
+
+		outl(virt_to_phys(cursor_data), CURSOR_ADR_START);
+		outl(virt_to_phys(cursor_data), CURSOR_ADR_RESET);
+		outl(0x00000300 | ((cursor->height - 1) << 2) |
+		     ((cursor->width - 1) >> 4), CURSORSIZE);
+		outl(save, CURSORXYLOC);
+
+	}
+
+	if (cursor->flags & CURSOR_SETCOLOR) {
+		outl(cursor->color1, CURSORCOLOR1);
+		outl(cursor->color2, CURSORCOLOR2);
+		outl(cursor->blinkcolor1, CURSORBLINK1);
+		outl(cursor->blinkcolor2, CURSORBLINK2);
+
+                }
+
+	if (cursor->flags & CURSOR_BLINK) {
+		if (cursor->blinkrate)
+			outl(0x00000100 | cursor->blinkrate, CURSORBLINK);
+		else
+			outl(0x000000ff, CURSORBLINK);
+                }
+
+	if (cursor->flags & CURSOR_MOVE) {
+		if(cursor->flags & CURSOR_OFF){
+			x = (inl(HACTIVESTRTSTOP) & 0x000003ff) + 64;
+			y = (inl(VACTIVESTRTSTOP) & 0x000003ff) + 64;
+			outl((inl(CURSORXYLOC) & 0x8000) | (y << 16) | x, CURSORXYLOC);
+		}
+		else{
+			x = (inl(HACTIVESTRTSTOP) & 0x000003ff) - cursor->dx - 2;
+			y = (inl(VACTIVESTRTSTOP) & 0x000003ff) - cursor->dy;
+			outl((inl(CURSORXYLOC) & 0x8000) | (y << 16) | x, CURSORXYLOC);
+		}
+                }
+
+
+	if (cursor->flags & CURSOR_ON){
+
+		outl(virt_to_phys(cursor_data), CURSOR_ADR_START);
+		outl(virt_to_phys(cursor_data), CURSOR_ADR_RESET);
+		outl(inl(CURSORXYLOC) | 0x00008000, CURSORXYLOC);
+	}
+        
+#else
+	static unsigned long cursor_data[64][4];
+	unsigned long data[64 * 4];
+	long i, x, y, save;
+       
+
+	if (cursor->flags & CURSOR_OFF)
+		outl(inl(CURSORXYLOC) & ~0x00008000, CURSORXYLOC);
+
+	if (cursor->flags & CURSOR_SETSHAPE) {
+		copy_from_user(data, cursor->data,
+			       cursor->width * cursor->height / 4);
+
+		save = inl(CURSORXYLOC);
+		outl(save & ~0x00008000, CURSORXYLOC);
+
+		for (y = 0, i = 0; y < cursor->height; y++) {
+			for (x = 0; x < cursor->width; x += 16)
+				cursor_data[y][x] = data[i++];
+		}
+
+		outl(virt_to_phys(cursor_data), CURSOR_ADR_START);
+		outl(virt_to_phys(cursor_data), CURSOR_ADR_RESET);
+		outl(0x00000300 | ((cursor->height - 1) << 2) |
+		     ((cursor->width - 1) >> 4), CURSORSIZE);
+		outl(save, CURSORXYLOC);
+	}
+
+	if (cursor->flags & CURSOR_SETCOLOR) {
+		outl(cursor->color1, CURSORCOLOR1);
+		outl(cursor->color2, CURSORCOLOR2);
+		outl(cursor->blinkcolor1, CURSORBLINK1);
+		outl(cursor->blinkcolor2, CURSORBLINK2);
+	}
+
+	if (cursor->flags & CURSOR_BLINK) {
+		if (cursor->blinkrate)
+			outl(0x00000100 | cursor->blinkrate, CURSORBLINK);
+		else
+			outl(0x000000ff, CURSORBLINK);
+	}
+
+	if (cursor->flags & CURSOR_MOVE) {
+			x = (inl(HACTIVESTRTSTOP) & 0x000003ff) - cursor->dx - 2;
+			y = (inl(VACTIVESTRTSTOP) & 0x000003ff) - cursor->dy;
+			outl((inl(CURSORXYLOC) & 0x8000) | (y << 16) | x, CURSORXYLOC);
+		}
+
+	if (cursor->flags & CURSOR_ON)
+		outl(inl(CURSORXYLOC) | 0x00008000, CURSORXYLOC);
+	
+#endif
+		
+	return 0;
+
+}
+
+				
+static inline void
+ep93xxfb_palette_write(u_int regno, u_int red, u_int green,
+                       u_int blue, u_int trans)
+{
+    unsigned int cont, i, pal;
+                                                                                                                             
+    pal = ((red & 0xFF00) << 8) | (green & 0xFF00) | ((blue & 0xFF00) >> 8);
+                                                                                                                             
+    pseudo_palette[regno] = pal;
+                                                                                                                             
+    outl( pal, (COLOR_LUT+(regno<<2)) );
+                                                                                                                             
+    cont = inl(LUTCONT);
+                                                                                                                             
+    if ((cont&LUTCONT_STAT && cont&LUTCONT_RAM1) ||
+        (!(cont&LUTCONT_STAT) && !(cont&LUTCONT_RAM1)))
+    {
+                                                                                                                             
+        for (i=0; i< 256; i++)  // Update inactive LUT
+        {
+            outl( pseudo_palette[i], (COLOR_LUT+(i<<2)) );
+        }
+        // Switch active LUTs next frame
+        outl( cont ^ LUTCONT_RAM1, LUTCONT );
+    }
+}
+
+	
+
+static int
+ep93xxfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,
+		   unsigned transp, struct fb_info *info)
+{
+ 
+ #define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+                                                                                                                             
+        switch (info->fix.visual) {
+        case FB_VISUAL_PSEUDOCOLOR:
+                ep93xxfb_palette_write(regno, red, green, blue, transp);
+                break;
+        case FB_VISUAL_TRUECOLOR:
+                if (regno >= 16)
+                        return 1;
+                                                                                                                             
+                red = CNVT_TOHW(red, info->var.red.length);
+                green = CNVT_TOHW(green, info->var.green.length);
+                blue = CNVT_TOHW(blue, info->var.blue.length);
+                transp = CNVT_TOHW(transp, info->var.transp.length);
+                ((u32 *) (info->pseudo_palette))[regno] =
+                                (red << info->var.red.offset) |
+                                (green << info->var.green.offset) |
+                                (blue << info->var.blue.offset) |
+                                (transp << info->var.transp.offset);
+                break;
+        case FB_VISUAL_DIRECTCOLOR:
+                red = CNVT_TOHW(red, 8);
+                green = CNVT_TOHW(green, 8);
+                blue = CNVT_TOHW(blue, 8);
+                transp = CNVT_TOHW(transp, 8);
+                break;
+        }
+#undef CNVT_TOHW
+
+      return 0;
+ 
+}
+
+static int
+ep93xxfb_blank(int blank_mode, struct fb_info *info)
+{
+	unsigned long attribs;
+
+	attribs = inl(VIDEOATTRIBS);
+#ifdef CONFIG_EP93XX_SDCS0
+	attribs |= 0 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+#ifdef CONFIG_EP93XX_SDCS1
+	attribs |= 1 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+#ifdef CONFIG_EP93XX_SDCS2
+	attribs |= 2 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+#ifdef CONFIG_EP93XX_SDCS3
+	attribs |= 3 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+
+	if (blank_mode) {
+		if (modedb[mode].off)
+			(modedb[mode].off)(info);
+		ep93xxfb_outl(attribs & ~(VIDEOATTRIBS_DATAEN |
+					  VIDEOATTRIBS_SYNCEN |
+					  VIDEOATTRIBS_PCLKEN |
+					  VIDEOATTRIBS_EN),
+		     VIDEOATTRIBS);
+	} else {
+		if (modedb[mode].clk_src == CLK_INTERNAL)
+			attribs |= VIDEOATTRIBS_PCLKEN;
+		ep93xxfb_outl(attribs | VIDEOATTRIBS_DATAEN
+		                      | VIDEOATTRIBS_SYNCEN
+				      | VIDEOATTRIBS_EN,
+			                VIDEOATTRIBS);
+		if (modedb[mode].on)
+			(modedb[mode].on)(info);
+	}
+
+	return 0;
+}
+
+
+/*
+ * ep93xxfb_set_par():
+ *
+ */
+static int
+ep93xxfb_set_par(struct fb_info *info)
+{
+	
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+		break;
+
+	case 16:
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	info->fix.line_length = (info->var.xres * info->var.bits_per_pixel) / 8;
+
+	return 0;
+}
+
+static struct fb_ops ep93xxfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_setcolreg	= ep93xxfb_setcolreg,
+	.fb_set_par     = ep93xxfb_set_par,
+	.fb_blank	= ep93xxfb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_cursor	= ep93xxfb_cursor,
+        .fb_ioctl       = ep93xxfb_ioctl,
+};
+
+
+
+#if defined(CONFIG_FB_EP93XX_KENWOOD_LCD)
+#define PLL2_FREQUENCY 192000000		// PLL2 : 192MHz
+#else
+
+static unsigned long
+ep93xx_get_pll_frequency(unsigned long pll)
+{
+	unsigned long fb1, fb2, ipd, ps, freq;
+
+	if (pll == 1)
+		pll = inl(SYSCON_CLKSET1);
+	else if (pll == 2)
+		pll = inl(SYSCON_CLKSET2);
+	else
+		return 0;
+
+	ps = (pll & SYSCON_CLKSET1_PLL1_PS_MASK) >>
+		SYSCON_CLKSET1_PLL1_PS_SHIFT;
+	fb1 = ((pll & SYSCON_CLKSET1_PLL1_X1FBD1_MASK) >>
+	       SYSCON_CLKSET1_PLL1_X1FBD1_SHIFT) + 1;
+	fb2 = ((pll & SYSCON_CLKSET1_PLL1_X2FBD2_MASK) >>
+	       SYSCON_CLKSET1_PLL1_X2FBD2_SHIFT) + 1;
+	ipd = ((pll & SYSCON_CLKSET1_PLL1_X2IPD_MASK) >>
+	       SYSCON_CLKSET1_PLL1_X2IPD_SHIFT) + 1;
+
+	freq = 225 * fb1 * fb2;
+
+	freq = ((freq / ipd) * 65536) + (((freq % ipd) * 65536) / ipd);
+
+	return freq;
+}
+#endif
+
+static int
+ep93xx_set_video_div(unsigned long freq)
+{
+#if defined(CONFIG_FB_EP93XX_KENWOOD_LCD)
+
+	unsigned long pdiv =  1;
+	unsigned long div  = 10;
+	unsigned long psel =  1;
+	unsigned long esel =  1;
+
+	outl(0xaa, SYSCON_SWLOCK);
+
+	outl(SYSCON_VIDDIV_VENA | (esel ? SYSCON_VIDDIV_ESEL : 0) |
+	     (psel ? SYSCON_VIDDIV_PSEL : 0) |
+	     (pdiv << SYSCON_VIDDIV_PDIV_SHIFT) |
+	     (div << SYSCON_VIDDIV_VDIV_SHIFT), SYSCON_VIDDIV);
+
+	return (PLL2_FREQUENCY / (((pdiv + 3) / 2) * div));
+
+#else
+
+	unsigned long pdiv = 0, div = 0, psel = 0, esel = 0, err, f, i, j, k;
+
+	err = -1;
+
+	for (i = 0; i < 3; i++) {
+		if (i == 0)
+			f = 14745600;
+		else if (i == 1)
+			f = ep93xx_get_pll_frequency(1);
+		else
+			f = ep93xx_get_pll_frequency(2);
+
+		for (j = 4; j <= 6; j++) {
+			k = f / (freq * j);
+			if (k < 2)
+				continue;
+			if (((f / (j * k)) - freq) < err) {
+				pdiv = j - 3;
+				div = k;
+				psel = (i == 2) ? 1 : 0;
+				esel = (i == 0) ? 0 : 1;
+				err = (f / (j * k)) - freq;
+			}
+		}
+	}
+
+	if (err == -1)
+		return -1;
+
+	outl(0xaa, SYSCON_SWLOCK);
+	outl(SYSCON_VIDDIV_VENA | (esel ? SYSCON_VIDDIV_ESEL : 0) |
+	     (psel ? SYSCON_VIDDIV_PSEL : 0) |
+	     (pdiv << SYSCON_VIDDIV_PDIV_SHIFT) |
+	     (div << SYSCON_VIDDIV_VDIV_SHIFT), SYSCON_VIDDIV);
+
+	return freq + err;
+
+#endif
+}
+
+static int
+ep93xxfb_configure(struct fb_info *info)
+{
+	unsigned long htotal, hres, hfp, hsync, hbp;
+	unsigned long vtotal, vres, vfp, vsync, vbp;
+	unsigned long fb_size, clk, attribs;
+	void *fb_log;
+
+	fb_size = modedb[mode].hres * modedb[mode].vres * (bpp / 8);
+	fb_log = dma_alloc_writecombine(NULL, fb_size, &fb_phys, GFP_KERNEL);
+	if (!fb_log)
+		return -ENOMEM;
+
+	vres = modedb[mode].vres;
+	vfp = modedb[mode].vfp;
+	vsync = modedb[mode].vsync;
+	vbp = modedb[mode].vbp;
+	vtotal = vres + vfp + vsync + vbp;
+
+	hres = modedb[mode].hres;
+	hfp = modedb[mode].hfp;
+	hsync = modedb[mode].hsync;
+	hbp = modedb[mode].hbp;
+	htotal = hres + hfp + hsync + hbp;
+
+	if (modedb[mode].clk_src == CLK_INTERNAL) {
+		outl(0xaa, SYSCON_SWLOCK);
+		outl(inl(SYSCON_DEVCFG) & ~SYSCON_DEVCFG_EXVC, SYSCON_DEVCFG);
+		clk = ep93xx_set_video_div(htotal * vtotal *
+					   modedb[mode].refresh);
+		if (clk == -1) {
+			dma_free_coherent(NULL, fb_size, fb_log, fb_phys);
+			return -ENODEV;
+		}
+
+		info->var.pixclock = 1000000000 / (clk / 1000);
+	} else {
+		outl(0xaa, SYSCON_SWLOCK);
+		outl(0, SYSCON_VIDDIV);
+		outl(0xaa, SYSCON_SWLOCK);
+		outl(inl(SYSCON_DEVCFG) | SYSCON_DEVCFG_EXVC, SYSCON_DEVCFG);
+		info->var.pixclock = modedb[mode].refresh;
+	}
+
+	info->var.xres = hres;
+	info->var.yres = vres;
+	info->var.xres_virtual = hres;
+	info->var.yres_virtual = vres;
+	info->var.bits_per_pixel = bpp;
+	if (bpp == 8) {
+		info->var.red.length = 8;
+		info->var.green.length = 8;
+		info->var.blue.length = 8;
+	} else if ( bpp == 16) {
+	    
+	     	    
+           	info->var.red.offset = 11;
+		info->var.red.length = 5;
+		info->var.green.offset = 5;
+		info->var.green.length = 6;
+		info->var.blue.offset = 0;
+		info->var.blue.length = 5;
+	    
+	}
+	info->var.activate = FB_ACTIVATE_NOW;
+	info->var.height = modedb[mode].height;
+	info->var.width = modedb[mode].width;
+	info->var.left_margin = hbp;
+	info->var.right_margin = hfp;
+	info->var.upper_margin = vbp;
+	info->var.lower_margin = vfp;
+	info->var.hsync_len = hsync;
+	info->var.vsync_len = vsync;
+	if (modedb[mode].pol_hsync == POL_HIGH)
+		info->var.sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (modedb[mode].pol_vsync == POL_HIGH)
+		info->var.sync |= FB_SYNC_VERT_HIGH_ACT;
+	info->var.vmode = FB_VMODE_NONINTERLACED;
+
+	info->fix.smem_start = fb_phys;
+	info->fix.smem_len = fb_size;
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	if (bpp == 8)
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else if (bpp == 16)
+	       	info->fix.visual = FB_VISUAL_TRUECOLOR;
+	       
+	       
+
+	info->fix.line_length = hres * (bpp / 8);
+	info->screen_base = fb_log;
+
+	ep93xxfb_outl(0, VIDEOATTRIBS);
+
+	ep93xxfb_outl(vtotal - 1, VLINESTOTAL);
+	ep93xxfb_outl((vtotal - vfp - 1) + ((vtotal - vfp - vsync - 1) << 16),
+		      VSYNCSTRTSTOP);
+	ep93xxfb_outl((vres - 1) + ((vtotal - 1) << 16), VACTIVESTRTSTOP);
+	ep93xxfb_outl((vres - 1) + ((vtotal - 1) << 16), VBLANKSTRTSTOP);
+	ep93xxfb_outl((vtotal - 1) + ((vtotal - 1) << 16), VCLKSTRTSTOP);
+
+	ep93xxfb_outl(htotal - 1, HCLKSTOTAL);
+	ep93xxfb_outl((htotal - 1) + ((htotal - hsync - 1) << 16),
+		      HSYNCSTRTSTOP);
+	ep93xxfb_outl((htotal - hsync - hbp - 1) + ((hfp - 1) << 16),
+		      HBLANKSTRTSTOP);
+	ep93xxfb_outl((htotal - hsync - hbp - 1) + ((hfp - 1) << 16),
+		      HACTIVESTRTSTOP);
+	ep93xxfb_outl((htotal - 1) + ((htotal - 1) << 16), HCLKSTRTSTOP);
+
+	ep93xxfb_outl(0, LINECARRY);
+
+	outl(fb_phys, VIDSCRNPAGE);
+	outl(vres, SCRNLINES);
+	outl(((hres * bpp) / 32) - 1, LINELENGTH);
+	outl((hres * bpp) / 32, VLINESTEP);
+
+	if (bpp == 8)
+		outl(PIXELMODE_S_1PPCMAPPED | PIXELMODE_P_8BPP |
+		     PIXELMODE_C_LUT, PIXELMODE);
+	else if (bpp == 16)
+	    	outl(PIXELMODE_S_1PPCMAPPED | PIXELMODE_P_16BPP |
+         	     PIXELMODE_C_565, PIXELMODE);
+	    
+		 
+
+	SysconSetLocked(SYSCON_DEVCFG,
+			inl(SYSCON_DEVCFG) | SYSCON_DEVCFG_RasOnP3);
+
+	attribs = 0;
+#ifdef CONFIG_EP93XX_SDCS0
+	attribs |= 0 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+#ifdef CONFIG_EP93XX_SDCS1
+	attribs |= 1 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+#ifdef CONFIG_EP93XX_SDCS2
+	attribs |= 2 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+#ifdef CONFIG_EP93XX_SDCS3
+	attribs |= 3 << VIDEOATTRIBS_SDSEL_SHIFT;
+#endif
+	if (modedb[mode].clk_edge == EDGE_RISING)
+		attribs |= VIDEOATTRIBS_INVCLK;
+	if (modedb[mode].pol_blank == POL_HIGH)
+		attribs |= VIDEOATTRIBS_BLKPOL;
+	if (modedb[mode].pol_hsync == POL_HIGH)
+		attribs |= VIDEOATTRIBS_HSPOL;
+	if (modedb[mode].pol_vsync == POL_HIGH)
+		attribs |= VIDEOATTRIBS_VCPOL;
+	ep93xxfb_outl(attribs, VIDEOATTRIBS);
+
+	if (modedb[mode].configure)
+		(modedb[mode].configure)(info);
+
+	ep93xxfb_blank(0, info);
+
+	return 0;
+}
+
+static int
+ep93xxfb_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+	struct fb_info *info=NULL;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				devicename))
+		return -EBUSY;
+
+        if (bpp == 8)
+            info = framebuffer_alloc(sizeof(u32) * 256, &pdev->dev);
+        else if (bpp == 16)
+	  
+            info = framebuffer_alloc(sizeof(u32) * 16, &pdev->dev);
+	  
+	     	   
+	info->flags = FBINFO_DEFAULT;
+	strncpy(info->fix.id, devicename, sizeof(info->fix.id));
+	info->fix.mmio_start = res->start;
+	info->fix.mmio_len = res->end - res->start + 1;
+	info->fbops = &ep93xxfb_ops;
+	info->pseudo_palette = info->par;
+	info->state = FBINFO_STATE_RUNNING;
+
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
+		ret = -ENOMEM;
+		goto framebuffer;
+	} 
+
+	if ((ret = ep93xxfb_configure(info)) < 0)
+		goto colormap;
+
+	if (register_framebuffer(info) < 0) {
+		printk(KERN_ERR "Unable to register EP93xx frame buffer\n");
+		ret = -EINVAL;
+		goto colormap;
+	}
+
+	dev_set_drvdata(dev, info);
+
+	printk(KERN_INFO "fb%d: EP93xx frame buffer at %dx%dx%d\n", info->node,
+	       info->var.xres, info->var.yres, info->var.bits_per_pixel);
+
+	return 0;
+
+colormap:
+	fb_dealloc_cmap(&info->cmap);
+framebuffer:
+	framebuffer_release(info);
+
+	return ret;
+}
+
+static int
+ep93xxfb_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct resource *res;
+
+	dev_set_drvdata(dev, NULL);
+
+	unregister_framebuffer(info);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	fb_dealloc_cmap(&info->cmap);
+	framebuffer_release(info);
+
+	return 0;
+}
+
+
+
+static  int
+ep93xxfb_ioctl(struct inode *inode, struct file *file,
+               unsigned int cmd, unsigned long arg, struct fb_info *info)
+{
+        
+        struct ep93xx_cursor cursor;
+        struct ep93xx_blit blit;
+        struct ep93xx_fill fill;
+        struct ep93xx_line line;
+        unsigned long caps;
+                                                                                                                             
+        switch (cmd) {
+        case FBIO_EP93XX_GET_CAPS:
+                caps = EP93XX_CAP_CURSOR;
+#ifdef CONFIG_EP93XX_GRAPHICS
+                caps |= EP93XX_CAP_LINE | EP93XX_CAP_FILL | EP93XX_CAP_BLIT;
+#endif
+                copy_to_user((void *)arg, &caps, sizeof(unsigned long));
+                return 0;
+                                                                                                                             
+        case FBIO_EP93XX_CURSOR:
+                copy_from_user(&cursor, (void *)arg,
+                              sizeof(struct ep93xx_cursor));
+		     		   
+		                    
+          
+	       return ep93xxfb_cursor(info,&cursor); 
+	  
+
+
+#ifdef CONFIG_EP93XX_GRAPHICS
+        case FBIO_EP93XX_LINE:
+                copy_from_user(&line, (void *)arg, sizeof(struct ep93xx_line));
+                return ep93xxfb_line(info,&line);
+                                                                                                                             
+        case FBIO_EP93XX_FILL:
+                copy_from_user(&fill, (void *)arg, sizeof(struct ep93xx_fill));
+                return ep93xxfb_fill(info,&fill);
+                                                                                                                             
+        case FBIO_EP93XX_BLIT:
+                copy_from_user(&blit, (void *)arg, sizeof(struct ep93xx_blit));
+                return ep93xxfb_blit(info,&blit);
+#endif
+                                                                                                                             
+        default:
+                return -EFAULT;
+        }
+	
+	
+}
+
+
+static struct device_driver ep93xxfb_driver = {
+	.name		= devicename,
+	.bus		= &platform_bus_type,
+	.probe		= ep93xxfb_drv_probe,
+	.remove		= ep93xxfb_drv_remove,
+};
+
+int __init
+ep93xxfb_init(void)
+{
+#ifdef MODULE
+	int i;
+
+	if (modestr) {
+		for (i = 0; i < (sizeof(modedb) / sizeof(modedb[0])); i++)
+			if (strcmp(modestr, modedb[i].name) == 0)
+				break;
+		if (i != (sizeof(modedb) / sizeof(modedb[0])))
+			mode = i;
+		else
+			printk(KERN_ERR devicename ": unknown mode: %s\n",
+			       modestr);
+	}
+#endif
+
+        outl(0x00000000, BLOCKCTRL);
+        request_irq(IRQ_GRAPHICS, ep93xxfb_irq_handler, SA_INTERRUPT,
+                    "graphics",NULL);
+
+
+	return driver_register(&ep93xxfb_driver);
+}
+
+static void __exit
+ep93xxfb_cleanup(void)
+{
+	return driver_unregister(&ep93xxfb_driver);
+}
+
+
+
+
+
+
+int __init
+ep93xxfb_setup(char *options)
+{
+	char *opt;
+	int i;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		for (i = 0; i < (sizeof(modedb) / sizeof(modedb[0])); i++)
+			if (strcmp(opt, modedb[i].name) == 0)
+				break;
+		if (i != (sizeof(modedb) / sizeof(modedb[0]))) {
+			mode = i;
+			continue;
+		}
+		if (strcmp(opt, "8bpp") == 0) {
+			bpp = 8;
+			continue;
+		} else if (strcmp(opt, "16bpp") == 0) {
+			bpp = 16;
+			continue;
+		}
+
+		printk (KERN_ERR devicename ": unknown parameter: %s\n", opt);
+	}
+
+	return 0;
+}
+
+
+ #ifdef MODULE
+   module_init(ep93xxfb_init);
+ #endif
+
+module_exit(ep93xxfb_cleanup);
+
+MODULE_PARM(modestr, "s");
+MODULE_PARM(bpp, "i");
+
+MODULE_AUTHOR("Cirrus Logic");
+MODULE_DESCRIPTION("EP93xx frame buffer driver");
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/drivers/video/fbmem.c linux-2.6.8.1/drivers/video/fbmem.c
--- linux-2.6.8.1-orig/drivers/video/fbmem.c	2004-08-14 19:54:46.000000000 +0900
+++ linux-2.6.8.1/drivers/video/fbmem.c	2007-01-24 13:03:31.000000000 +0900
@@ -173,6 +173,8 @@
 extern int mc68x328fb_init(void);
 extern int mc68x328fb_setup(char *);
 extern int asiliantfb_init(void);
+extern int ep93xxfb_init(void);
+extern int ep93xxfb_setup(char*);
 
 static struct {
 	const char *name;
@@ -389,6 +391,9 @@
 #ifdef CONFIG_FB_ASILIANT
 	{ "asiliantfb", asiliantfb_init, NULL },
 #endif
+#ifdef CONFIG_FB_EP93XX
+	{ "ep93xxfb", ep93xxfb_init, ep93xxfb_setup},
+#endif
 
 	/*
 	 * Generic drivers that don't use resource management (yet)
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/bits.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/bits.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/bits.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/bits.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,61 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Bit field defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __bits_h
+#define __bits_h                        1
+
+#define BIT0                            0x00000001
+#define BIT1                            0x00000002
+#define BIT2                            0x00000004
+#define BIT3                            0x00000008
+#define BIT4                            0x00000010
+#define BIT5                            0x00000020
+#define BIT6                            0x00000040
+#define BIT7                            0x00000080
+#define BIT8                            0x00000100
+#define BIT9                            0x00000200
+#define BIT10                           0x00000400
+#define BIT11                           0x00000800
+#define BIT12                           0x00001000
+#define BIT13                           0x00002000
+#define BIT14                           0x00004000
+#define BIT15                           0x00008000
+#define BIT16                           0x00010000
+#define BIT17                           0x00020000
+#define BIT18                           0x00040000
+#define BIT19                           0x00080000
+#define BIT20                           0x00100000
+#define BIT21                           0x00200000
+#define BIT22                           0x00400000
+#define BIT23                           0x00800000
+#define BIT24                           0x01000000
+#define BIT25                           0x02000000
+#define BIT26                           0x04000000
+#define BIT27                           0x08000000
+#define BIT28                           0x10000000
+#define BIT29                           0x20000000
+#define BIT30                           0x40000000
+#define BIT31                           0x80000000
+
+#endif
+
+/*         END */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/crunch.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/crunch.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/crunch.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/crunch.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,69 @@
+#ifndef	__asm_crunch_h__
+#define	__asm_crunch_h__
+
+#include "asm/arch/regmap.h"
+
+#define	CRUNCH_INIT	0x00900000
+#define	CRUNCH_IRQ	58
+
+#ifndef	__ASSEMBLY__
+
+/* enable the MaverickCrunch clock */
+static inline void crunch_enable(void)
+{
+	int tmp, aa = 0xAA;
+	int *lock = (int *)SYSCON_SWLOCK;
+	int *syscfg = (int *)SYSCON_DEVCFG;
+
+	asm volatile (
+	"str    %3, [%1]\n\t"
+	"ldr    %0, [%2]\n\t"
+	"orr    %0, %0, #(1 << 23)\n\t"
+	"str    %0, [%2]"
+	:"=r" (tmp)
+	:"r" (lock), "r" (syscfg), "r" (aa)
+	:"memory" );
+}
+
+
+/* disable the MaverickCrunch clock */
+static inline void crunch_disable(void)
+{
+	int tmp, aa = 0xAA;
+	int *lock = (int *)SYSCON_SWLOCK;
+	int *syscfg = (int *)SYSCON_DEVCFG;
+
+	asm volatile (
+	"str    %3, [%1]\n\t"
+	"ldr    %0, [%2]\n\t"
+	"bic    %0, %0, #(1 << 23)\n\t"
+	"str    %0, [%2]"
+	:"=r" (tmp)
+	:"r" (lock), "r" (syscfg), "r" (aa)
+	:"memory" );
+}
+
+/* forward declaration of task_struct */
+struct task_struct;
+
+unsigned int read_dspsc_low(void);
+unsigned int read_dspsc_high(void);
+void write_dspsc(unsigned int);
+void save_crunch(struct task_struct *);
+void restore_crunch(struct task_struct *);
+int setup_crunch(void);
+void crunch_init(void);
+
+#ifdef CONFIG_EP93XX_FPU
+#define	switch_crunch(prev, next)			\
+		do {					\
+				save_crunch(prev);	\
+				restore_crunch(next);	\
+		} while (0)
+#else
+#define	switch_crunch(prev, next)	do { } while (0)
+#endif
+
+#endif
+
+#endif	/* __asm_crunch_h__ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/cx25871.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/cx25871.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/cx25871.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/cx25871.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,80 @@
+/*
+ * Filename: cx25871.h
+ *                                                                     
+ * Description: Regisister Definitions and function prototypes for
+ *             CX25871 NTSC/PAL encoder.
+ *
+ * Copyright(c) Cirrus Logic Corporation 2003, All Rights Reserved                       
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _H_CX25871
+#define _H_CX25871
+
+//
+// CS25871 Device Address.
+//
+#define CX25871_DEV_ADDRESS                     0x88
+
+//
+// Register 0x32
+//
+#define CX25871_REGx32_AUTO_CHK                 0x80
+#define CX25871_REGx32_DRVS_MASK                0x60
+#define CX25871_REGx32_DRVS_SHIFT               5
+#define CX25871_REGx32_SETUP_HOLD               0x10
+#define CX25871_REGx32_INMODE_                  0x08
+#define CX25871_REGx32_DATDLY_RE                0x04
+#define CX25871_REGx32_OFFSET_RGB               0x02
+#define CX25871_REGx32_CSC_SEL                  0x01
+
+//
+// Register 0xBA
+//
+#define CX25871_REGxBA_SRESET                   0x80
+#define CX25871_REGxBA_CHECK_STAT               0x40
+#define CX25871_REGxBA_SLAVER                   0x20
+#define CX25871_REGxBA_DACOFF                   0x10
+#define CX25871_REGxBA_DACDISD                  0x08
+#define CX25871_REGxBA_DACDISC                  0x04
+#define CX25871_REGxBA_DACDISB                  0x02
+#define CX25871_REGxBA_DACDISA                  0x01
+
+//
+// Register 0xC4
+//
+#define CX25871_REGxC4_ESTATUS_MASK             0xC0
+#define CX25871_REGxC4_ESTATUS_SHIFT            6
+#define CX25871_REGxC4_ECCF2                    0x20
+#define CX25871_REGxC4_ECCF1                    0x10
+#define CX25871_REGxC4_ECCGATE                  0x08
+#define CX25871_REGxC4_ECBAR                    0x04
+#define CX25871_REGxC4_DCHROMA                  0x02
+#define CX25871_REGxC4_EN_OUT                   0x01
+                                                
+
+//
+// Register 0xC6
+//
+#define CX25871_REGxC6_EN_BLANKO                0x80
+#define CX25871_REGxC6_EN_DOT                   0x40
+#define CX25871_REGxC6_FIELDI                   0x20
+#define CX25871_REGxC6_VSYNCI                   0x10
+#define CX25871_REGxC6_HSYNCI                   0x08
+#define CX25871_REGxC6_INMODE_MASK              0x07
+#define CX25871_REGxC6_INMODE_SHIFT             0
+
+#endif // _H_CX25871
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/dma.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/dma.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/dma.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,246 @@
+/*****************************************************************************
+ *  linux/include/asm-arm/arch-ep93xx/dma.h
+ *
+ *  Copyright (C) 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS     0xffffffff
+
+/*
+ *  Not using the regular generic DMA interface for ep93xx.
+ */
+#define MAX_DMA_CHANNELS   0
+
+/*
+ * The ep93xx dma controller has 5 memory to peripheral (TX) channels, 5
+ * peripheral to memory (RX) channels and 2 memory to memory channels.
+ */
+#define MAX_EP93XX_DMA_M2P_CHANNELS 10
+#define MAX_EP93XX_DMA_M2M_CHANNELS 2
+
+/*
+ * The generic arm linux api does not support the ep93xx dma model, therefore
+ * we use a set of dma support functions written specifically for this dma
+ * controller.
+ */
+#define MAX_EP93XX_DMA_CHANNELS (MAX_EP93XX_DMA_M2P_CHANNELS + MAX_EP93XX_DMA_M2M_CHANNELS)
+
+/*****************************************************************************
+ *
+ * Max DMA buffer size
+ *
+ ****************************************************************************/
+#define DMA_MAX_BUFFER_BYTES    0xFFFF
+
+/*****************************************************************************
+ *
+ * typedefs
+ *
+ ****************************************************************************/
+
+/*****************************************************************************
+ *
+ * All devices which can use a DMA channel
+ *
+ * NOTE: There exist two types of DMA channels, those that transfer
+ *       between an internal peripheral and memory (M2P/P2M), and
+ *       those that transfer between an external peripheral and memory (M2M).
+ *       This becomes a bit confusing when you take into account the fact
+ *       that the M2M channels can also transfer between two specific
+ *       internal peripherals and memory.
+ *       The first 20 enumerated devices use the first type of channel (M2P/
+ *       P2M).  The last six enumerations are specific to the M2M channels.
+ *
+ ****************************************************************************/
+typedef enum
+{
+    /*
+     *  Hardware device options for the 10 M2P/P2M DMA channels.
+     */
+    DMATx_I2S1 = 0x00000000,    /* TX peripheral ports can be allocated an  */
+    DMATx_I2S2 = 0x00000001,    /* even numbered DMA channel.               */
+    DMATx_AAC1 = 0x00000002,
+    DMATx_AAC2 = 0x00000003,
+    DMATx_AAC3 = 0x00000004,
+    DMATx_I2S3 = 0x00000005,
+    DMATx_UART1 = 0x00000006,
+    DMATx_UART2 = 0x00000007,
+    DMATx_UART3 = 0x00000008,
+    DMATx_IRDA = 0x00000009,
+    DMARx_I2S1 = 0x0000000A,    /* RX perhipheral ports can be allocated an */
+    DMARx_I2S2 = 0x0000000B,    /* odd numbered DMA channel.                */
+    DMARx_AAC1 = 0x0000000C,
+    DMARx_AAC2 = 0x0000000D,
+    DMARx_AAC3 = 0x0000000E,
+    DMARx_I2S3 = 0x0000000F,
+    DMARx_UART1 = 0x00000010,
+    DMARx_UART2 = 0x00000011,
+    DMARx_UART3 = 0x00000012,
+    DMARx_IRDA = 0x00000013,
+
+    /*
+     *  Device options for the 2 M2M DMA channels
+     */
+    DMA_MEMORY = 0x00000014,
+    DMA_IDE = 0x00000015,
+    DMARx_SSP = 0x00000016,
+    DMATx_SSP = 0x00000017,
+    DMATx_EXT_DREQ = 0x00000018,
+    DMARx_EXT_DREQ = 0x00000019,
+    UNDEF = 0x0000001A
+} ep93xx_dma_dev_t;
+
+/*****************************************************************************
+ *
+ * Enumerated type used as a parameter for a callback function.
+ * Indicates the type of interrupt.
+ *
+ ****************************************************************************/
+typedef enum
+{
+    /*
+     *  Common interrupts
+     */
+    STALL,
+    NFB,
+
+    /*
+     *  Specific to M2P channels
+     */
+    CHERROR,
+
+    /*
+     *  Specific to M2M channels
+     */
+    DONE,
+    UNDEF_INT
+} ep93xx_dma_int_t;
+
+/*****************************************************************************
+ *
+ * Init flag bit defintions for M2P/P2M flags.
+ *
+ ****************************************************************************/
+
+/*
+ *  Channel error interrupt enable.
+ */
+#define CHANNEL_ERROR_INT_ENABLE    0x00000001
+
+/*
+ *  Determines how the channel state machine behaves in the NEXT state and
+ *  in receipt of a peripheral error.
+ *  0 -> NEXT -> ON (ignore the peripheral error.)
+ *  1 -> NEXT -> STALL (effectively disable the channel.)
+ */
+#define CHANNEL_ABORT               0x00000002
+
+/*
+ *  Ignore channel error interrupt.
+ */
+#define IGNORE_CHANNEL_ERROR        0x00000004
+
+/*****************************************************************************
+ *
+ * Init flag bit defintions for M2M flags.
+ *
+ ****************************************************************************/
+
+/*
+ *  Destination address hold.  This should be set for IDE write transfers
+ */
+#define DESTINATION_HOLD            0x0000001
+
+/*
+ *  Source Address hold. This should be set for IDE read transfers
+ */
+#define SOURCE_HOLD                 0x0000002
+
+/*
+ *  Transfer mode.
+ *  00 - s/w initiated M2M transfer
+ *  01 - h/w initiated external peripheral transfer - memory to external
+ *       peripheral/IDE/SSP.
+ *  10 - h/w initiated external peripheral transfer - external
+ *        peripheral/IDE/SSP to memory.
+ *  11 - not used.
+ */
+#define TRANSFER_MODE_MASK          0x000000C
+#define TRANSFER_MODE_SHIFT         2
+#define TRANSFER_MODE_SW            0x0000000
+#define TRANSFER_MODE_HW_M2P        0x0000004
+#define TRANSFER_MODE_HW_P2M        0x0000008
+
+/*
+ *  Peripheral wait states count. Latency in HCLK cycles needed by the
+ *  peripheral to de-assert its request line once the transfer is
+ *  finished.
+ *
+ *  IDE Operation           Wait States
+ *  --------------          ------------
+ *  IDE MDMA read               0
+ *  IDE MDMA write              3
+ *  IDE UDMA read               1
+ *  IDE UDMA write              2
+ */
+#define WAIT_STATES_MASK            0x00007F0
+#define WAIT_STATES_SHIFT           4
+#define WS_IDE_MDMA_READ            0
+#define WS_IDE_MDMA_WRITE           3
+#define WS_IDE_UDMA_READ            1
+#define WS_IDE_UDMA_WRITE           2
+
+/*****************************************************************************
+ *
+ * Type definition for the callback function
+ *
+ ****************************************************************************/
+typedef void (* dma_callback)(ep93xx_dma_int_t dma_int,
+                              ep93xx_dma_dev_t device,
+                              unsigned int user_data);
+
+/*****************************************************************************
+ *
+ * API function prototypes
+ *
+ ****************************************************************************/
+extern int ep93xx_dma_request(int * handle, const char *device_id,
+                              ep93xx_dma_dev_t device);
+extern int ep93xx_dma_free(int handle);
+extern int ep93xx_dma_config(int handle, unsigned int flags_m2p,
+                             unsigned int flags_m2m,
+                             dma_callback callback, unsigned int user_data);
+extern int ep93xx_dma_add_buffer(int handle, unsigned int source,
+                                 unsigned int dest, unsigned int size,
+                                 unsigned int last, unsigned int buf_id);
+extern int ep93xx_dma_remove_buffer(int handle, unsigned int * buf_id);
+extern int ep93xx_dma_start(int handle, unsigned int channels,
+                            unsigned int * handles);
+extern int ep93xx_dma_pause(int handle, unsigned int channels,
+                            unsigned int * handles);
+extern int ep93xx_dma_flush(int handle);
+extern int ep93xx_dma_queue_full(int handle);
+extern int ep93xx_dma_get_position(int handle, unsigned int * buf_id,
+                    unsigned int * total, unsigned int * current_frac);
+extern int ep93xx_dma_get_total(int handle);
+extern int ep93xx_dma_is_done(int handle);
+
+#endif /* _ASM_ARCH_DMA_H */
+
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/ee.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/ee.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/ee.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/ee.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,27 @@
+
+
+
+
+
+
+/*
+ *  header file for linux/arch/arm/mach-ep93xx/ee.c
+ *
+ *  Copyright (C) 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+/* This file intentionally left blank */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/hardware.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/hardware.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/hardware.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/hardware.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,59 @@
+/*
+ *  File:   linux/include/asm-arm/arch-ep93xx/hardware.h
+ *
+ *  Copyright (C) 2003 Cirrus Logic, Inc
+ *  
+ *  Copyright (C) 1999 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/arch/memory.h>
+#include <asm/arch/regmap.h>
+
+/*
+ * When adding your regs-*.h file here, please be careful to not have any
+ * macros being doubly defined.  You may need to comment out a section of
+ * regmap.h to prevent that.
+ */
+#include <asm/arch/regs_ac97.h>
+#include <asm/arch/regs_dma.h>
+#include <asm/arch/regs_gpio.h>
+#include <asm/arch/regs_ide.h>
+#include <asm/arch/regs_i2s.h>
+#include <asm/arch/regs_irda.h>
+#include <asm/arch/regs_raster.h>
+#include <asm/arch/regs_smc.h>
+#include <asm/arch/regs_spi.h>
+#include <asm/arch/regs_syscon.h>
+#include <asm/arch/regs_touch.h>
+#include <asm/arch/regs_uart.h>
+
+
+#include <asm/arch/cx25871.h>
+
+/*
+ * Here's a safe way for calculating jiffies that won't break if the
+ * value of HZ changes.
+ */
+#ifndef	MSECS_TO_JIFFIES
+#define MSECS_TO_JIFFIES(ms) (((ms)*HZ+999)/1000)
+#endif
+
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/ide.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/ide.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/ide.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/ide.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,173 @@
+/*****************************************************************************
+ *  linux/include/asm-arm/arch-ep93xx/ide.h
+ *
+ *  IDE definitions for the EP93XX architecture
+ *
+ *
+ *  Copyright (c) 2003 Cirrus Logic, Inc., All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *   
+ ****************************************************************************/
+#ifndef ASM_ARCH_IDE_H
+#define ASM_ARCH_IDE_H
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/scatterlist.h>
+
+/*
+ *  Maximum number of IDE interfaces for this architecture is 1.
+ */
+#undef  MAX_HWIFS
+#define MAX_HWIFS	1 
+
+/*
+ *  Default PIO mode used for setting up DMA commands
+ */
+#define DEFAULT_PIO_MODE	    4
+
+/*
+ *  ATA Command Register addresses.
+ */
+
+#define DATAREGISTER            0x00
+#define ERRORREGISTER           0x01
+#define FEATURESREGISTER        0x01
+#define SECTORCOUNTREGISTER     0x02
+#define SECTORNUMBERREGISTER    0x03
+#define CYLINDERLOWREGISTER     0x04
+#define CYLINDERHIGHREGISTER    0x05
+#define DEVICEHEADREGISTER      0x06
+#define COMMANDREGISTER         0x07
+#define STATUSREGISTER          0x07
+
+/*
+ *  ATA Control Register addresses.
+ */
+#define DEVICECONTROLREGISTER   0x06
+#define ALTERNATESTATUSREGISTER 0x06
+
+/*
+ *  ATA Register Bit Masks
+ */
+#define ATASRST  		        0x04
+#define ATAnIEN  		        0x02
+#define ATADEV   		        0x10
+#define ATAABRT  		        0x04
+#define ATABSY   		        0x80
+#define ATADRDY  		        0x40
+#define ATADRQ   		        0x08
+#define ATAERR   		        0x01
+#define ATADEVFAULT		        0x20
+#define	ATAWRITEFAULT	        0x20
+#define ATASERVICE 		        0x10
+#define ATACORRECTED	        0x04
+#define ATAINDEX		        0x02
+
+/*****************************************************************************
+ *
+ * Set up a hw structure for a specified data port, control port and IRQ.
+ * This should follow whatever the default interface uses.
+ *
+ ****************************************************************************/
+static __inline__ void
+old_ide_init_hwif_ports(hw_regs_t *hw, int data_port, int ctrl_port, int *irq)
+{
+       unsigned long reg; 
+	int i;
+    
+	outl(0, IDEMDMAOP);
+	outl(0, IDEUDMAOP);
+	outl(IDECfg_IDEEN | IDECfg_PIO | (4 << IDECfg_MODE_SHIFT) |
+	     (1 << IDECfg_WST_SHIFT), IDECFG);
+    
+	memset(hw, 0, sizeof(*hw));
+                                                                                                                             
+        reg = (unsigned long)data_port;
+        for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+                hw->io_ports[i] = reg;
+                reg += 1;
+        }
+                                                                                                                             
+        hw->io_ports[IDE_CONTROL_OFFSET] = (unsigned long)ctrl_port;
+                                                                                                                             
+        if(irq){
+                *irq = 0;
+	}
+  
+}
+
+extern void ep93xx_ide_init(struct hwif_s * hwif);
+
+/*****************************************************************************
+ *
+ * This registers the standard ports for this architecture with the IDE
+ * driver.
+ *
+ ****************************************************************************/
+static __inline__ void
+old_ide_init_default_hwifs(void)
+{
+    hw_regs_t hw;
+
+    struct hwif_s *hwif;
+    unsigned long value;
+
+    /*
+     *  Make sure the GPIO on IDE bits in the DEVCFG register are not set.
+     */
+    value = inl(SYSCON_DEVCFG) & ~(SYSCON_DEVCFG_EonIDE |
+                                  SYSCON_DEVCFG_GonIDE |
+                                SYSCON_DEVCFG_HonIDE);
+	
+    SysconSetLocked( SYSCON_DEVCFG, value );
+    
+    /*
+     *  Initialize the IDE interface
+     */
+    old_ide_init_hwif_ports(&hw, 0x800, 0x406, NULL);
+        
+   	
+    /*
+     *  Get the interrupt.
+     */
+    hw.irq = IRQ_EIDE;
+    
+    /*
+     * This is the dma channel number assigned to this IDE interface. Until
+     * dma is enabled for this interface, we set it to NO_DMA.
+     */
+  hw.dma = NO_DMA;    
+    
+    /*
+     *  Register the IDE interface, an ide_hwif_t pointer is passed in,
+     *  which will get filled in with the hwif pointer for this interface.
+     */
+  ide_register_hw(&hw, &hwif);
+    
+    /*
+     *  Set up a pointer to the ep93xx ideproc function.
+     */
+    ep93xx_ide_init(hwif);
+        
+    printk("Cirrus Logic EP93XX IDE initialization.\n");
+    
+    
+}
+
+
+
+#endif /* ASM_ARCH_IDE_H */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/io.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/io.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/io.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,41 @@
+/*
+ *  File:	linux/include/asm-arm/arch-ep93xx/io.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)			((unsigned long)(a))
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		((unsigned long)(a))
+
+/*
+ * These routines are used to hack the default ide i/o routines in
+ * drivers/ide/ide-iops.h so they work with PCMCIA IDE.  Sad, but
+ * necessary.	They are fleshed out in arch/arm/mach-ep93xx/pcmcia_io.c.
+ */
+inline u8 ep93xx_pcmcia_ide_inb (unsigned long port);
+inline u16 ep93xx_pcmcia_ide_inw (unsigned long port);
+inline void ep93xx_pcmcia_ide_insw (unsigned long port, void *addr, u32 count);
+inline void ep93xx_pcmcia_ide_outb (u8 addr, unsigned long port);
+inline void ep93xx_pcmcia_ide_outw (u16 addr, unsigned long port);
+inline void ep93xx_pcmcia_ide_outsw (unsigned long port, void *addr, u32 count);
+
+#endif
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/irqs.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/irqs.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/irqs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/irqs.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,105 @@
+/*
+ *  File:	linux/include/asm-arm/arch-ep93xx/irqs.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* 
+ *  Linux IRQ interrupts definitions here.
+ *	TBD not worth the effort to put duplicate bit defines in platform.h
+ *
+ *	Current IRQ implementation
+ *
+ *	1.  Current implementation does not support vectored 
+ *          interrupts.  support for this feature may be 
+ *          added later.
+ *	2.  FIQs are ignored.  None are assigned.
+ *	3.  All interrupts are assigned to IRQs.
+ *	5.  IRQ numbers are same as interrupt bit numbers.
+ *
+ */
+
+#define IRQ_RFU0	0
+#define IRQ_RFU1	1
+#define IRQ_COMMRX	2
+#define IRQ_COMMTX	3
+#define IRQ_TIMER1	4
+#define IRQ_TIMER2	5
+#define IRQ_AAC         6
+#define IRQ_DMAM2P0	7
+#define IRQ_DMAM2P1	8
+#define IRQ_DMAM2P2     9
+#define IRQ_DMAM2P3	10
+#define IRQ_DMAM2P4	11
+#define IRQ_DMAM2P5	12
+#define IRQ_DMAM2P6	13
+#define IRQ_DMAM2P7	14
+#define IRQ_DMAM2P8	15
+#define IRQ_DMAM2P9     16
+#define IRQ_DMAM2M0	17
+#define IRQ_DMAM2M1	18
+#define IRQ_GPIO0	19
+#define IRQ_GPIO1	20
+#define IRQ_GPIO2	21
+#define IRQ_GPIO3	22
+#define IRQ_UARTRX1	23
+#define IRQ_UARTTX1	24
+#define IRQ_UARTRX2	25
+#define IRQ_UARTTX2	26
+#define IRQ_UARTRX3	27
+#define IRQ_UARTTX3	28
+#define IRQ_KEY	        29
+#define IRQ_TOUCH	30
+#define IRQ_GRAPHICS	31
+
+#define INT1_IRQS       0xfffffffc
+
+#define IRQ_EXT0	32
+#define IRQ_EXT1	33
+#define IRQ_EXT2	34
+#define IRQ_64HZ	35
+#define IRQ_WEINT	36
+#define IRQ_RTC 	37
+#define IRQ_IRDA	38
+#define IRQ_MAC 	39
+#define IRQ_EXT3	40
+#define IRQ_EIDE	IRQ_EXT3
+#define IRQ_PROG	41
+#define IRQ_1HZ 	42
+#define IRQ_VSYNC	43
+#define IRQ_VIDEOFIFO	44
+#define IRQ_SSPRX	45
+#define IRQ_SSPTX	46
+#define IRQ_GPIO4	47
+#define IRQ_GPIO5	48
+#define IRQ_GPIO6	49
+#define IRQ_GPIO7	50
+#define IRQ_TIMER3	51
+#define IRQ_UART1	52
+#define IRQ_SSP 	53
+#define IRQ_UART2	54
+#define IRQ_UART3	55
+#define IRQ_USH 	56
+#define IRQ_PME 	57
+#define IRQ_DSP 	58
+#define IRQ_GPIO	59
+#define IRQ_SAI		60
+#define IRQ_RFU61	61
+#define IRQ_RFU62	62
+#define IRQ_RFU63	63
+
+#define INT2_IRQS       0x1fffffff
+
+#define NR_IRQS         61
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/memory.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/memory.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/memory.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/memory.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,91 @@
+/*
+ *  linux/include/asm-arm/arch-ep93xx/memory.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2002-2003 Cirrus Logic Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <linux/config.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	(CONFIG_EP93XX_PHYS_ADDR)
+
+
+/* for all EP93XX boards which use SDRAMCS3 and ROMCS6 */
+#if ( CONFIG_EP93XX_SDCS3 && (CONFIG_ARCH_EP9307 || CONFIG_ARCH_EP9315 || CONFIG_ARCH_EP9312) )
+
+/*
+ * Virtual DRAM offset
+ */
+#define PAGE_OFFSET	0xc0000000
+
+#ifndef __ASSEMBLY__
+
+/* on the EP9307/12/15 boards physical memory is (with SROMLL=1 ): 32MB (32MB hole) 32MB */
+
+static inline dma_addr_t __ep9312_virt_to_phys( dma_addr_t vaddr)
+{    
+    if(vaddr < 0xc2000000)
+	return (dma_addr_t)(( vaddr - PAGE_OFFSET) + CONFIG_EP93XX_PHYS_ADDR);
+    else
+	return (dma_addr_t)(( vaddr - PAGE_OFFSET) + CONFIG_EP93XX_PHYS_ADDR + 0x02000000);
+}
+
+static inline dma_addr_t __ep9312_phys_to_virt( dma_addr_t paddr)
+{
+    if( ( paddr - CONFIG_EP93XX_PHYS_ADDR) < 0x02000000 )
+	return (dma_addr_t)( paddr + PAGE_OFFSET);
+    else
+	return (dma_addr_t)( paddr - CONFIG_EP93XX_PHYS_ADDR - 0x02000000 + PAGE_OFFSET);
+}
+
+#endif
+
+#define __virt_to_phys(x)	__ep9312_virt_to_phys((x))
+#define __phys_to_virt(x)	__ep9312_phys_to_virt((x))
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys((dma_addr_t)(x))
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+#else // !( CONFIG_ARCH_EP9307 || CONFIG_ARCH_EP9312 || CONFIG_ARCH_EP9315 )
+
+// EP9315A, EP9301, EP9302
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+#endif
+
+#endif
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/param.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/param.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/param.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/param.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/platform.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/platform.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/platform.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/platform.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,25 @@
+/*
+ *  linux/include/asm-arm/arch-ep93xx/platform.h
+ *
+ *  Copyright (C) 2002-2003 Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef PLATFORM_H
+#define PLATFORM_H
+
+
+ 
+#endif
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regmap.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regmap.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regmap.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regmap.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1309 @@
+/*
+ *  File:   linux/include/asm-arm/arch-ep93xx/regmap.h
+ *
+ *  Copyright (C) 2003 Cirrus Logic, Inc
+ *  
+ *  Copyright (C) 1999 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/sizes.h> 
+
+#ifndef __ASM_ARCH_REGMAP_H
+#define __ASM_ARCH_REGMAP_H
+
+/*
+ * Where in virtual memory the IO devices (timers, system controllers
+ * and so on).  This gets used in arch/arm/mach-ep93xx/mm.c.
+ */
+#define IO_BASE_VIRT        0xFF000000     // Virtual address of IO 
+#define IO_BASE_PHYS        0x80000000     // Physical address of IO
+#define IO_SIZE             0x00A00000     // How much?
+
+/*
+ * These macro convert between virtual IO addresses an physical IO addresses.
+ */
+#define HwRegToPhys(x)      ((x) - IO_BASE_VIRT + IO_BASE_PHYS)
+#define HwRegToVirt(x)      ((x) - IO_BASE_PHYS + IO_BASE_VIRT)
+
+/*
+ * We don't map the PCMCIA initially.  The PCMCIA driver will use ioremap
+ * to be able to see it.  But besides that PCMCIA will not exist in the
+ * memory map.
+ */
+#define PCMCIA_BASE_VIRT    0xD0000000     // Virtual address of PCMCIA
+#define PCMCIA_BASE_PHYS    0x40000000     // Physical address of PCMCIA
+#define PCMCIA_SIZE         0x10000000     // How much?
+
+/*
+ * The memory maps and register lists below show physical addresses, while the
+ * corresponding #defines use virtual addresses.
+ */
+
+/******************************************************************/
+/*         EP93xx Memory Map and Register list                    */
+/******************************************************************/
+/*                                                                */
+/* 0000_0000 - 0000_03ff: Internal ROM Memory  (Remap Low)        */
+/* 0000_0400 - 1fff_ffff: External DRAM Memory (Remap Low)        */
+/* 0000_0000 - 1fff_ffff: External DRAM Memory (Remap High)       */
+/* 2000_0000 - 7fff_ffff: External SRAM Memory                    */
+/* 8800_0000 - 8fff_ffff: Expansion Device Memory and Registers   */
+/* 9000_0000 - 9fff_ffff: Expansion memory                        */
+/* A000_0000 - Afff_ffff: PCMCIA Memory, I/O, and Attribute space */
+/* B000_0000 - ffff_ffff: External SRAM memory                    */
+
+/******************************************************************/
+/*           EP93xx AHB Blocks Base Address                       */
+/******************************************************************/
+/*                                                                */
+/* The AHB device address map is:                                 */
+/* Start     End        Size Usage                                */
+/* 8000_0000 8000_FFFF: 64 K DMA control registers                */
+/* 8001_0000 8001_FFFF: 64 K Ethernet MAC control registers       */
+/* 8002_0000 8002_FFFF: 64 K USB Host control registers           */
+/* 8003_0000 8003_FFFF: 64 K Raster control registers             */
+/* 8004_0000 8004_FFFF: 64 K Graphics control registers           */
+/* 8005_0000 8005_FFFF: 64 K Reserved                             */
+/* 8006_0000 8006_FFFF: 64 K SDRAM control registes               */
+/* 8007_0000 8007_FFFF: 64 K ARM920T slave                        */
+/* 8008_0000 8008_FFFF: 64 K SMC_PCMCIA control registers         */
+/* 8009_0000 8009_FFFF: 64 K Boot ROM physical address            */
+/* 800A_0000 800A_FFFF: 64 K IDE control registers                */
+/* 800B_0000 800B_FFFF: 64 K VIC1 control registers               */
+/* 800C_0000 800C_FFFF: 64 K VIC2 control registers               */
+/* TAG: literal */
+#define EP93XX_AHB_BASE (IO_BASE_VIRT)
+
+/* ARM920T Address Description                             */
+/*                                                         */
+/* 0x8000.0000 -> 0x8000.003C M2P Channel 0 Registers (Tx) */
+/* 0x8000.0040 -> 0x8000.007C M2P Channel 1 Registers (Rx) */
+/* 0x8000.0080 -> 0x8000.00BC M2P Channel 2 Registers (Tx) */ 
+/* 0x8000.00C0 -> 0x8000.00FC M2P Channel 3 Registers (Rx) */
+/* 0x8000.0100 -> 0x8000.013C M2M Channel 0 Registers      */
+/* 0x8000.0140 -> 0x8000.017C M2M Channel 1 Registers      */
+/* 0x8000.0180 -> 0x8000.01BC Not Used                     */
+/* 0x8000.01C0 -> 0x8000.01FC Not Used                     */
+/* 0x8000.0200 -> 0x8000.023C M2P Channel 5 Registers (Rx) */
+/* 0x8000.0240 -> 0x8000.027C M2P Channel 4 Registers (Tx) */
+/* 0x8000.0280 -> 0x8000.02BC M2P Channel 7 Registers (Rx) */
+/* 0x8000.02C0 -> 0x8000.02FC M2P Channel 6 Registers (Tx) */
+/* 0x8000.0300 -> 0x8000.033C M2P Channel 9 Registers (Rx) */
+/* 0x8000.0340 -> 0x8000.037C M2P Channel 8 Registers (Tx) */
+/* 0x8000.0380 DMA Channel Arbitration register            */
+/* 0x8000.03C0 DMA Global Interrupt register               */
+/* 0x8000.03C4 -> 0x8000.03FC Not Used                     */
+
+
+/* Internal M2P/P2M Channel Register Map                   */
+
+/* Offset Name      Access  Bits Reset Value               */
+/* 0x00   CONTROL   R/W     6    0                         */
+/* 0x04   INTERRUPT R/W TC* 3    0                         */
+/* 0x08   PPALLOC   R/W     4    channel dependant         */
+/*                               (see reg description)     */
+/* 0x0C   STATUS    RO      8    0                         */
+/* 0x10   reserved                                         */
+/* 0x14   REMAIN    RO      16   0                         */
+/* 0X18   Reserved                                         */
+/* 0X1C   Reserved                                         */
+/* 0x20   MAXCNT0   R/W     16   0                         */
+/* 0x24   BASE0     R/W     32   0                         */
+/* 0x28   CURRENT0  RO      32   0                         */
+/* 0x2C   Reserved                                         */
+/* 0x30   MAXCNT1   R/W     16   0                         */
+/* 0x34   BASE1     R/W     32   0                         */
+/* 0X38   CURRENT1  RO      32   0                         */
+/* 0X3C   Reserved                                         */
+/*                                                         */
+/* M2M Channel Register Map                                */
+/* Offset Name         Access   Bits Reset Value           */
+/*                                                         */
+/* 0x00   CONTROL      R/W      22   0                     */
+/* 0x04   INTERRUPT    R/W TC*  3    0                     */
+/* 0x08   Reserved                                         */
+/* 0x0C   STATUS       R/W TC*  14   0                     */
+/* 0x10   BCR0         R/W      16   0                     */
+/* 0x14   BCR1         R/W      16   0                     */
+/* 0x18   SAR_BASE0    R/W      32   0                     */
+/* 0x1C   SAR_BASE1    R/W      32   0                     */
+/* 0x20   Reserved                                         */
+/* 0x24   SAR_CURRENT0 RO       32   0                     */
+/* 0x28   SAR_CURRENT1 RO       32   0                     */
+/* 0x2C   DAR_BASE0    R/W      32   0                     */
+/* 0x30   DAR_BASE1    R/W      32   0                     */
+/* 0x34   DAR_CURRENT0 RO       32   0                     */
+/* 0X38   Reserved                                         */
+/* 0X3C   DAR_CURRENT1 RO       32   0                     */     
+/* * Write this location once to clear the bit (see        */
+/* Interrupt/Status register description for which bits    */
+/* this rule applies to).                                  */
+
+/* 8000_0000 - 8000_ffff: DMA  */
+#define DMA_OFFSET              0x000000
+#define DMA_BASE                (EP93XX_AHB_BASE|DMA_OFFSET)
+#define DMAMP_TX_0_CONTROL      (DMA_BASE+0x0000)
+#define DMAMP_TX_0_INTERRUPT    (DMA_BASE+0x0004)
+#define DMAMP_TX_0_PPALLOC      (DMA_BASE+0x0008)
+#define DMAMP_TX_0_STATUS       (DMA_BASE+0x000C)       
+#define DMAMP_TX_0_REMAIN       (DMA_BASE+0x0014)
+#define DMAMP_TX_0_MAXCNT0      (DMA_BASE+0x0020)
+#define DMAMP_TX_0_BASE0        (DMA_BASE+0x0024)
+#define DMAMP_TX_0_CURRENT0     (DMA_BASE+0x0028)
+#define DMAMP_TX_0_MAXCNT1      (DMA_BASE+0x0030)
+#define DMAMP_TX_0_BASE1        (DMA_BASE+0x0034)
+#define DMAMP_TX_0_CURRENT1     (DMA_BASE+0x0038)
+
+#define DMAMP_RX_1_CONTROL      (DMA_BASE+0x0040)
+#define DMAMP_RX_1_INTERRUPT    (DMA_BASE+0x0044)
+#define DMAMP_RX_1_PPALLOC      (DMA_BASE+0x0048)
+#define DMAMP_RX_1_STATUS       (DMA_BASE+0x004C)       
+#define DMAMP_RX_1_REMAIN       (DMA_BASE+0x0054)
+#define DMAMP_RX_1_MAXCNT0      (DMA_BASE+0x0060)
+#define DMAMP_RX_1_BASE0        (DMA_BASE+0x0064)
+#define DMAMP_RX_1_CURRENT0     (DMA_BASE+0x0068)
+#define DMAMP_RX_1_MAXCNT1      (DMA_BASE+0x0070)
+#define DMAMP_RX_1_BASE1        (DMA_BASE+0x0074)
+#define DMAMP_RX_1_CURRENT1     (DMA_BASE+0x0078)
+
+#define DMAMP_TX_2_CONTROL      (DMA_BASE+0x0080)
+#define DMAMP_TX_2_INTERRUPT    (DMA_BASE+0x0084)
+#define DMAMP_TX_2_PPALLOC      (DMA_BASE+0x0088)
+#define DMAMP_TX_2_STATUS       (DMA_BASE+0x008C)       
+#define DMAMP_TX_2_REMAIN       (DMA_BASE+0x0094)
+#define DMAMP_TX_2_MAXCNT0      (DMA_BASE+0x00A0)
+#define DMAMP_TX_2_BASE0        (DMA_BASE+0x00A4)
+#define DMAMP_TX_2_CURRENT0     (DMA_BASE+0x00A8)
+#define DMAMP_TX_2_MAXCNT1      (DMA_BASE+0x00B0)
+#define DMAMP_TX_2_BASE1        (DMA_BASE+0x00B4)
+#define DMAMP_TX_2_CURRENT1     (DMA_BASE+0x00B8)
+
+#define DMAMP_RX_3_CONTROL      (DMA_BASE+0x00C0)
+#define DMAMP_RX_3_INTERRUPT    (DMA_BASE+0x00C4)
+#define DMAMP_RX_3_PPALLOC      (DMA_BASE+0x00C8)
+#define DMAMP_RX_3_STATUS       (DMA_BASE+0x00CC)       
+#define DMAMP_RX_3_REMAIN       (DMA_BASE+0x00D4)
+#define DMAMP_RX_3_MAXCNT0      (DMA_BASE+0x00E0)
+#define DMAMP_RX_3_BASE0        (DMA_BASE+0x00E4)
+#define DMAMP_RX_3_CURRENT0     (DMA_BASE+0x00E8)
+#define DMAMP_RX_3_MAXCNT1      (DMA_BASE+0x00F0)
+#define DMAMP_RX_3_BASE1        (DMA_BASE+0x00F4)
+#define DMAMP_RX_3_CURRENT1     (DMA_BASE+0x00F8)
+
+#define DMAMM_0_CONTROL         (DMA_BASE+0x0100)
+#define DMAMM_0_INTERRUPT       (DMA_BASE+0x0104)
+#define DMAMM_0_STATUS          (DMA_BASE+0x010C)
+#define DMAMM_0_BCR0            (DMA_BASE+0x0110)
+#define DMAMM_0_BCR1            (DMA_BASE+0x0114)
+#define DMAMM_0_SAR_BASE0       (DMA_BASE+0x0118)
+#define DMAMM_0_SAR_BASE1       (DMA_BASE+0x011C)
+#define DMAMM_0_SAR_CURRENT0    (DMA_BASE+0x0124)
+#define DMAMM_0_SAR_CURRENT1    (DMA_BASE+0x0128)
+#define DMAMM_0_DAR_BASE0       (DMA_BASE+0x012C)
+#define DMAMM_0_DAR_BASE1       (DMA_BASE+0x0130)
+#define DMAMM_0_DAR_CURRENT0    (DMA_BASE+0x0134)
+#define DMAMM_0_DAR_CURRENT1    (DMA_BASE+0x013C)
+
+#define DMAMM_1_CONTROL         (DMA_BASE+0x0140)
+#define DMAMM_1_INTERRUPT       (DMA_BASE+0x0144)
+#define DMAMM_1_STATUS          (DMA_BASE+0x014C)
+#define DMAMM_1_BCR0            (DMA_BASE+0x0150)       
+#define DMAMM_1_BCR1            (DMA_BASE+0x0154)
+#define DMAMM_1_SAR_BASE0       (DMA_BASE+0x0158)
+#define DMAMM_1_SAR_BASE1       (DMA_BASE+0x015C)
+#define DMAMM_1_SAR_CURRENT0    (DMA_BASE+0x0164)
+#define DMAMM_1_SAR_CURRENT1    (DMA_BASE+0x0168)
+#define DMAMM_1_DAR_BASE0       (DMA_BASE+0x016C)
+#define DMAMM_1_DAR_BASE1       (DMA_BASE+0x0170)
+#define DMAMM_1_DAR_CURRENT0    (DMA_BASE+0x0174)
+#define DMAMM_1_DAR_CURRENT1    (DMA_BASE+0x017C)
+
+#define DMAMP_RX_5_CONTROL      (DMA_BASE+0x0200)
+#define DMAMP_RX_5_INTERRUPT    (DMA_BASE+0x0204)
+#define DMAMP_RX_5_PPALLOC      (DMA_BASE+0x0208)
+#define DMAMP_RX_5_STATUS       (DMA_BASE+0x020C)       
+#define DMAMP_RX_5_REMAIN       (DMA_BASE+0x0214)
+#define DMAMP_RX_5_MAXCNT0      (DMA_BASE+0x0220)
+#define DMAMP_RX_5_BASE0        (DMA_BASE+0x0224)
+#define DMAMP_RX_5_CURRENT0     (DMA_BASE+0x0228)
+#define DMAMP_RX_5_MAXCNT1      (DMA_BASE+0x0230)
+#define DMAMP_RX_5_BASE1        (DMA_BASE+0x0234)
+#define DMAMP_RX_5_CURRENT1     (DMA_BASE+0x0238)
+
+#define DMAMP_TX_4_CONTROL      (DMA_BASE+0x0240)
+#define DMAMP_TX_4_INTERRUPT    (DMA_BASE+0x0244)
+#define DMAMP_TX_4_PPALLOC      (DMA_BASE+0x0248)
+#define DMAMP_TX_4_STATUS       (DMA_BASE+0x024C)       
+#define DMAMP_TX_4_REMAIN       (DMA_BASE+0x0254)
+#define DMAMP_TX_4_MAXCNT0      (DMA_BASE+0x0260)
+#define DMAMP_TX_4_BASE0        (DMA_BASE+0x0264)
+#define DMAMP_TX_4_CURRENT0     (DMA_BASE+0x0268)
+#define DMAMP_TX_4_MAXCNT1      (DMA_BASE+0x0270)
+#define DMAMP_TX_4_BASE1        (DMA_BASE+0x0274)
+#define DMAMP_TX_4_CURRENT1     (DMA_BASE+0x0278)
+
+#define DMAMP_RX_7_CONTROL      (DMA_BASE+0x0280)
+#define DMAMP_RX_7_INTERRUPT    (DMA_BASE+0x0284)
+#define DMAMP_RX_7_PPALLOC      (DMA_BASE+0x0288)
+#define DMAMP_RX_7_STATUS       (DMA_BASE+0x028C)       
+#define DMAMP_RX_7_REMAIN       (DMA_BASE+0x0294)
+#define DMAMP_RX_7_MAXCNT0      (DMA_BASE+0x02A0)
+#define DMAMP_RX_7_BASE0        (DMA_BASE+0x02A4)
+#define DMAMP_RX_7_CURRENT0     (DMA_BASE+0x02A8)
+#define DMAMP_RX_7_MAXCNT1      (DMA_BASE+0x02B0)
+#define DMAMP_RX_7_BASE1        (DMA_BASE+0x02B4)
+#define DMAMP_RX_7_CURRENT1     (DMA_BASE+0x02B8)
+
+#define DMAMP_TX_6_CONTROL      (DMA_BASE+0x02C0)
+#define DMAMP_TX_6_INTERRUPT    (DMA_BASE+0x02C4)
+#define DMAMP_TX_6_PPALLOC      (DMA_BASE+0x02C8)
+#define DMAMP_TX_6_STATUS       (DMA_BASE+0x02CC)       
+#define DMAMP_TX_6_REMAIN       (DMA_BASE+0x02D4)
+#define DMAMP_TX_6_MAXCNT0      (DMA_BASE+0x02E0)
+#define DMAMP_TX_6_BASE0        (DMA_BASE+0x02E4)
+#define DMAMP_TX_6_CURRENT0     (DMA_BASE+0x02E8)
+#define DMAMP_TX_6_MAXCNT1      (DMA_BASE+0x02F0)
+#define DMAMP_TX_6_BASE1        (DMA_BASE+0x02F4)
+#define DMAMP_TX_6_CURRENT1     (DMA_BASE+0x02F8)
+
+#define DMAMP_RX_9_CONTROL      (DMA_BASE+0x0300)
+#define DMAMP_RX_9_INTERRUPT    (DMA_BASE+0x0304)
+#define DMAMP_RX_9_PPALLOC      (DMA_BASE+0x0308)
+#define DMAMP_RX_9_STATUS       (DMA_BASE+0x030C)
+#define DMAMP_RX_9_REMAIN       (DMA_BASE+0x0314)
+#define DMAMP_RX_9_MAXCNT0      (DMA_BASE+0x0320)
+#define DMAMP_RX_9_BASE0        (DMA_BASE+0x0324)
+#define DMAMP_RX_9_CURRENT0     (DMA_BASE+0x0328)
+#define DMAMP_RX_9_MAXCNT1      (DMA_BASE+0x0330)
+#define DMAMP_RX_9_BASE1        (DMA_BASE+0x0334)
+#define DMAMP_RX_9_CURRENT1     (DMA_BASE+0x0338)
+
+#define DMAMP_TX_8_CONTROL      (DMA_BASE+0x0340)
+#define DMAMP_TX_8_INTERRUPT    (DMA_BASE+0x0344)
+#define DMAMP_TX_8_PPALLOC      (DMA_BASE+0x0348)
+#define DMAMP_TX_8_STATUS       (DMA_BASE+0x034C)
+#define DMAMP_TX_8_REMAIN       (DMA_BASE+0x0354)
+#define DMAMP_TX_8_MAXCNT0      (DMA_BASE+0x0360)
+#define DMAMP_TX_8_BASE0        (DMA_BASE+0x0364)
+#define DMAMP_TX_8_CURRENT0     (DMA_BASE+0x0368)
+#define DMAMP_TX_8_MAXCNT1      (DMA_BASE+0x0370)
+#define DMAMP_TX_8_BASE1        (DMA_BASE+0x0374)
+#define DMAMP_TX_8_CURRENT1     (DMA_BASE+0x0378)
+
+#define DMA_ARBITRATION         (DMA_BASE+0x0380)
+#define DMA_INTERRUPT           (DMA_BASE+0x03C0)
+
+
+/*
+ * DMA Register Base addresses and Offsets
+ */
+#define DMA_M2P_TX_0_BASE       DMAMP_TX_0_CONTROL
+#define DMA_M2P_RX_1_BASE       DMAMP_RX_1_CONTROL
+#define DMA_M2P_TX_2_BASE       DMAMP_TX_2_CONTROL
+#define DMA_M2P_RX_3_BASE       DMAMP_RX_3_CONTROL
+#define DMA_M2M_0_BASE          DMAMM_0_CONTROL   
+#define DMA_M2M_1_BASE          DMAMM_1_CONTROL   
+#define DMA_M2P_RX_5_BASE       DMAMP_RX_5_CONTROL
+#define DMA_M2P_TX_4_BASE       DMAMP_TX_4_CONTROL
+#define DMA_M2P_RX_7_BASE       DMAMP_RX_7_CONTROL
+#define DMA_M2P_TX_6_BASE       DMAMP_TX_6_CONTROL
+#define DMA_M2P_RX_9_BASE       DMAMP_RX_9_CONTROL
+#define DMA_M2P_TX_8_BASE       DMAMP_TX_8_CONTROL
+
+#define M2P_OFFSET_CONTROL          0x0000
+#define M2P_OFFSET_INTERRUPT        0x0004
+#define M2P_OFFSET_PPALLOC          0x0008
+#define M2P_OFFSET_STATUS           0x000C       
+#define M2P_OFFSET_REMAIN           0x0014
+#define M2P_OFFSET_MAXCNT0          0x0020
+#define M2P_OFFSET_BASE0            0x0024
+#define M2P_OFFSET_CURRENT0         0x0028
+#define M2P_OFFSET_MAXCNT1          0x0030
+#define M2P_OFFSET_BASE1            0x0034
+#define M2P_OFFSET_CURRENT1         0x0038
+
+#define M2M_OFFSET_CONTROL          0x0000
+#define M2M_OFFSET_INTERRUPT        0x0004
+#define M2M_OFFSET_STATUS           0x000C
+#define M2M_OFFSET_BCR0             0x0010
+#define M2M_OFFSET_BCR1             0x0014
+#define M2M_OFFSET_SAR_BASE0        0x0018
+#define M2M_OFFSET_SAR_BASE1        0x001C
+#define M2M_OFFSET_SAR_CURRENT0     0x0024
+#define M2M_OFFSET_SAR_CURRENT1     0x0028
+#define M2M_OFFSET_DAR_BASE0        0x002C
+#define M2M_OFFSET_DAR_BASE1        0x0030
+#define M2M_OFFSET_DAR_CURRENT0     0x0034
+#define M2M_OFFSET_DAR_CURRENT1     0x003C
+
+
+
+/* 8001_0000 - 8001_ffff: Ether MAC */
+#define MAC_OFFSET              0x010000
+#define MAC_BASE                (EP93XX_AHB_BASE|MAC_OFFSET)
+#define MAC_RXCTL               (MAC_BASE+0x00)  /* 2-RW Rx  Control */
+#define MAC_TXCTL               (MAC_BASE+0x04)  /* 1-RW Tx Control */
+#define MAC_TESTCTL             (MAC_BASE+0x08)  /* 1-RW Test Control */
+#define MAC_MIICMD              (MAC_BASE+0x10)  /* 2-RW MII(Media Independent Intf) Command */
+#define MAC_MIIDATA             (MAC_BASE+0x14)  /* 2-RW MII Data */
+#define MAC_MIISTS              (MAC_BASE+0x18)  /* 1-RO MII Status */
+
+#define MAC_SELFCTL             (MAC_BASE+0x20)  /* 1-RW Self Control for LED interface */
+#define MAC_INTEN               (MAC_BASE+0x24)  /* 4-RW Intrrpt Enable */
+#define MAC_INTSTSP             (MAC_BASE+0x28)  /* 4-RW Intrrpt Status Preserve */
+#define MAC_INTSTSC             (MAC_BASE+0x2C)  /* 4-RO Intrrpt Status Clear */
+
+#define MAC_DIAGAD              (MAC_BASE+0x38)  /* 4-RW Diag Addr (debug only) */
+#define MAC_DIAGDATA            (MAC_BASE+0x3C)  /* 4-RW Diag Data (debug only) */
+
+#define MAC_GT                  (MAC_BASE+0x40)  /* 4-RW General Timer */
+#define MAC_FCT                 (MAC_BASE+0x44)  /* 4-RO Flow Control Timer */
+#define MAC_FCF                 (MAC_BASE+0x48)  /* 4-RW Flow Control Format */
+#define MAC_AFP                 (MAC_BASE+0x4C)  /* 1-RW Addr Filter Pointer */
+#define MAC_HASHTB              (MAC_BASE+0x50)  /* 8-RW Logical Addr Filter (Hash Table) */
+#define MAC_INDAD               (MAC_BASE+0x50)  /* 6-RW Individual Addr, IA */
+#define MAC_INDAD_UPPER         (MAC_BASE+0x54)  /* 6-RW Individual Addr, IA */
+
+#define MAC_FER                 (MAC_BASE+0x60)  /* 4-RW Cardbus Functn Event Reg */
+#define MAC_FERMASK             (MAC_BASE+0x64)  /* 4-RW Cardbus Functn Event Mask Reg */
+#define MAC_FPSR                (MAC_BASE+0x68)  /* 4-RO Cardbus Functn Present Status Reg */
+#define MAC_FFER                (MAC_BASE+0x6C)  /* 4-RW Cardbus Functn Force Event Reg */
+#define MAC_TXCOLLCNT           (MAC_BASE+0x70)  /* 2-RW Tx Collision Count */
+#define MAC_RXMISSCNT           (MAC_BASE+0x74)  /* 2-RW Rx Miss Count */
+#define MAC_RXRUNTCNT           (MAC_BASE+0x78)  /* 2-RW Rx Runt Count */
+
+#define MAC_BMCTL               (MAC_BASE+0x80)  /* 1-RW Bus Master Control */
+#define MAC_BMSTS               (MAC_BASE+0x84)  /* 1-RO Bus Master Status */
+#define MAC_RXBCA               (MAC_BASE+0x88)  /* 4-RO Rx buffer current address */
+#define MAC_TXBCA               (MAC_BASE+0x8C)  /* 4-RO Tx buffer current address */
+#define MAC_RXDBA               (MAC_BASE+0x90)  /* 4-RW Rx Descrptr Queue Base Addr */
+#define MAC_RXDBL               (UINT16*)(MAC_BASE+0x94)  /* 2-RW Rx Descrptr Queue Base Length */
+#define MAC_RXDCA               (MAC_BASE+0x98)  /* 4-RW Rx Descrptr Current Addr */
+#define MAC_RXDEQ               (MAC_BASE+0x9C)  /* 2-RW Rx Descrptr Enqueue */ 
+#define MAC_RXSBA               (MAC_BASE+0xA0)  /* 4-RW Rx Status Queue Base Addr */
+#define MAC_RXSBL               (UINT16*)(MAC_BASE+0xA4)  /* 2-RW Rx Status Queue Base Length */
+
+#define MAC_RXSCA               (MAC_BASE+0xA8)  /* 4-RW Rx Status Current Addr */
+#define MAC_RXSEQ               (MAC_BASE+0xAC)  /* 2-RW Rx Status Enqueue */
+#define MAC_TXDBA               (MAC_BASE+0xB0)  /* 4-RW Tx Descrptr Queue Base Addr */
+#define MAC_TXDBL               (MAC_BASE+0xB4)  /* 2-RW Tx Descrptr Queue Base Length */
+#define MAC_TXDCL               (MAC_BASE+0xB6)  /* 2-RW Tx Descrptr Queue Current Length */
+#define MAC_TXDCA               (MAC_BASE+0xB8)  /* 4-RW Tx Descrptr Current Addr */
+#define MAC_TXDEQ               (MAC_BASE+0xBC)  /* 2-RW Tx Descrptr Enqueue */
+
+#define MAC_TXSBA               (MAC_BASE+0xC0)  /* 4-RW Tx status Queue Base Addr */
+#define MAC_TXSBL               (MAC_BASE+0xC4)  /* 2-RW Tx Status Queue Base Length */
+#define MAC_TXSCL               (MAC_BASE+0xC6)  /* 2-RW Tx Status Queue Current Length */
+#define MAC_TXSCA               (MAC_BASE+0xC8)  /* 4-RW Tx Status Current Addr */
+#define MAC_TXSEQ               (MAC_BASE+0xCC)  /* 4-RW Tx Status Current Addr */
+#define MAC_RXBTH               (MAC_BASE+0xD0)  /* 4-RW Rx Buffer Thrshold */
+#define MAC_TXBTH               (MAC_BASE+0xD4)  /* 4-RW Tx Buffer Thrshold */
+#define MAC_RXSTH               (MAC_BASE+0xD8)  /* 4-RW Rx Status Thrshold */
+#define MAC_TXSTH               (MAC_BASE+0xDC)  /* 4-RW Tx Status Thrshold */
+
+#define MAC_RXDTH               (MAC_BASE+0xE0)  /* 4-RW Rx Descrptr Thrshold */
+#define MAC_TXDTH               (MAC_BASE+0xE4)  /* 4-RW Tx Descrptr Thrshold */
+#define MAC_MAXFL               (MAC_BASE+0xE8)  /* 4-RW Maximum Frame Length */
+#define MAC_RXHLEN              (MAC_BASE+0xEC)  /* 2-RW Rx Header Length */
+#define MAC_CFG_REG0            (MAC_BASE+0x100) /* config registers 0-2 */
+#define MAC_CFG_REG1            (MAC_BASE+0x104) /*   */
+#define MAC_CFG_REG2            (MAC_BASE+0x108) /*   */
+
+
+/* 8002_0000 - 8002_ffff: USB */
+#define USB_OFFSET              0x020000
+#define USB_BASE                (EP93XX_AHB_BASE|USB_OFFSET)
+#define HCREVISION              (USB_BASE+0x00)
+#define HCCONTROL               (USB_BASE+0x04)
+#define HCCOMMANDSTATUS         (USB_BASE+0x08)
+#define HCINTERRUPTSTATUS       (USB_BASE+0x0C)
+#define HCINTERRUPTENABLE       (USB_BASE+0x10)
+#define HCINTERRUPTDISABLE      (USB_BASE+0x14)
+#define HCHCCA                  (USB_BASE+0x18)
+#define HCPERIODCURRENTED       (USB_BASE+0x1C)
+#define HCCONTROLHEADED         (USB_BASE+0x20)
+#define HCCONTROLCURRENTED      (USB_BASE+0x24)
+#define HCBULKHEADED            (USB_BASE+0x28)
+#define HCBULKCURRENTED         (USB_BASE+0x2C)
+#define HCDONEHEAD              (USB_BASE+0x30)
+#define HCFMINTERVAL            (USB_BASE+0x34)
+#define HCFMREMAINING           (USB_BASE+0x38)
+#define HCFMNUMBER              (USB_BASE+0x3C)
+#define HCPERIODICSTART         (USB_BASE+0x40)
+#define HCLSTHRESHOLD           (USB_BASE+0x44)
+#define HCRHDESCRIPTORA         (USB_BASE+0x48)
+#define HCRHDESCRIPTORB         (USB_BASE+0x4C)
+#define HCRHSTATUS              (USB_BASE+0x50)
+#define HCRHPORTSTATUS0         (USB_BASE+0x54)
+#define HCRHPORTSTATUS1         (USB_BASE+0x58)
+#define HCRHPORTSTATUS2         (USB_BASE+0x5C)
+/* some tests used these registers names which are typos of original ones */
+#define HCRHPROTSTATUS0         (USB_BASE+0x54)
+#define HCRHPROTSTATUS1         (USB_BASE+0x58)
+#define HCRHPROTSTATUS2         (USB_BASE+0x5C)
+/* additional registers for controlling the AHB-HCI interface */
+#define USBCTRL                 (USB_BASE+0x80)
+#define USBHCI                  (USB_BASE+0x84)
+#define USBTXTEST               (USB_BASE+0x88)
+#define USBRXTEST               (USB_BASE+0x8C)
+
+
+/* 8003_0000 - 8003_ffff: Raster */
+#define RASTER_OFFSET           0x030000
+#define RASTER_BASE             (EP93XX_AHB_BASE|RASTER_OFFSET)
+#define VLINESTOTAL             (RASTER_BASE+0x00)
+#define VSYNCSTRTSTOP           (RASTER_BASE+0x04)
+#define VACTIVESTRTSTOP         (RASTER_BASE+0x08)
+#define VCLKSTRTSTOP            (RASTER_BASE+0x0C)
+#define HCLKSTOTAL              (RASTER_BASE+0x10)
+#define HSYNCSTRTSTOP           (RASTER_BASE+0x14)
+#define HACTIVESTRTSTOP         (RASTER_BASE+0x18)
+#define HCLKSTRTSTOP            (RASTER_BASE+0x1C)
+#define BRIGHTNESS              (RASTER_BASE+0x20)
+#define VIDEOATTRIBS            (RASTER_BASE+0x24)
+#define VIDSCRNPAGE             (RASTER_BASE+0x28)
+#define VIDSCRNHPG              (RASTER_BASE+0x2C)
+#define SCRNLINES               (RASTER_BASE+0x30)
+#define LINELENGTH              (RASTER_BASE+0x34)
+#define VLINESTEP               (RASTER_BASE+0x38)
+#define LINECARRY               (RASTER_BASE+0x3C)
+#define BLINKRATE               (RASTER_BASE+0x40)
+#define BLINKMASK               (RASTER_BASE+0x44)
+#define BLINKPATTRN             (RASTER_BASE+0x48)
+#define PATTRNMASK              (RASTER_BASE+0x4C)
+#define BG_OFFSET               (RASTER_BASE+0x50)
+#define PIXELMODE               (RASTER_BASE+0x54)
+#define PARLLIFOUT              (RASTER_BASE+0x58)
+#define PARLLIFIN               (RASTER_BASE+0x5C)
+#define CURSOR_ADR_START        (RASTER_BASE+0x60)
+#define CURSOR_ADR_RESET        (RASTER_BASE+0x64)
+#define CURSORSIZE              (RASTER_BASE+0x68)
+#define CURSORCOLOR1            (RASTER_BASE+0x6C)
+#define CURSORCOLOR2            (RASTER_BASE+0x70)
+#define CURSORXYLOC             (RASTER_BASE+0x74)
+#define CURSOR_DHSCAN_LH_YLOC   (RASTER_BASE+0x78)
+#define RASTER_SWLOCK           (RASTER_BASE+0x7C)
+#define GS_LUT                  (RASTER_BASE+0x80)
+#define RASTER_TCR              (RASTER_BASE+0x100)
+#define RASTER_TISRA            (RASTER_BASE+0x104)
+#define RASTER_TISRB            (RASTER_BASE+0x108)
+#define CURSOR_TISR             (RASTER_BASE+0x10C)
+#define RASTER_TOCRA            (RASTER_BASE+0x110)
+#define RASTER_TOCRB            (RASTER_BASE+0x114)
+#define FIFO_TOCRA              (RASTER_BASE+0x118)
+#define FIFO_TOCRB              (RASTER_BASE+0x11C)
+#define BLINK_TISR              (RASTER_BASE+0x120)
+#define DAC_TISRA               (RASTER_BASE+0x124)
+#define DAC_TISRB               (RASTER_BASE+0x128)
+#define SHIFT_TISR              (RASTER_BASE+0x12C)
+#define DACMUX_TOCRA            (RASTER_BASE+0x130)
+#define DACMUX_TOCRB            (RASTER_BASE+0x134)
+#define PELMUX_TOCR             (RASTER_BASE+0x138)
+#define VIDEO_TOCRA             (RASTER_BASE+0x13C)
+#define VIDEO_TOCRB             (RASTER_BASE+0x140)
+#define YCRCB_TOCR              (RASTER_BASE+0x144)
+#define CURSOR_TOCR             (RASTER_BASE+0x148)
+#define VIDEO_TOCRC             (RASTER_BASE+0x14C)
+#define SHIFT_TOCR              (RASTER_BASE+0x150)
+#define BLINK_TOCR              (RASTER_BASE+0x154)
+#define RASTER_TCER             (RASTER_BASE+0x180)
+#define SIGVAL                  (RASTER_BASE+0x200)
+#define SIGCTL                  (RASTER_BASE+0x204)
+#define VSIGSTRTSTOP            (RASTER_BASE+0x208)
+#define HSIGSTRTSTOP            (RASTER_BASE+0x20C)
+#define SIGCLR                  (RASTER_BASE+0x210)
+#define ACRATE                  (RASTER_BASE+0x214)
+#define LUTCONT                 (RASTER_BASE+0x218)
+#define VBLANKSTRTSTOP          (RASTER_BASE+0x228)
+#define HBLANKSTRTSTOP          (RASTER_BASE+0x22C)
+#define LUT                     (RASTER_BASE+0x400)
+#define CURSORBLINK1            (RASTER_BASE+0x21C)
+#define CURSORBLINK2            (RASTER_BASE+0x220)
+#define CURSORBLINK             (RASTER_BASE+0x224)
+#define EOLOFFSET               (RASTER_BASE+0x230)
+#define FIFOLEVEL               (RASTER_BASE+0x234)
+#define GS_LUT2                 (RASTER_BASE+0x280)
+#define GS_LUT3                 (RASTER_BASE+0x300)
+#define COLOR_LUT               (RASTER_BASE+0x400)
+ 
+/* 8004_0000 - 8004_ffff: Graphics */
+#define GRAPHICS_OFFSET         0x040000
+#define GRAPHICS_BASE           (EP93XX_AHB_BASE|GRAPHICS_OFFSET)
+#define SRCPIXELSTRT            (GRAPHICS_BASE+0x00)
+#define DESTPIXELSTRT           (GRAPHICS_BASE+0x04)
+#define BLKSRCSTRT              (GRAPHICS_BASE+0x08)
+#define BLKDSTSTRT              (GRAPHICS_BASE+0x0C)
+#define BLKSRCWIDTH             (GRAPHICS_BASE+0x10)
+#define SRCLINELENGTH           (GRAPHICS_BASE+0x14)
+#define BLKDESTWIDTH            (GRAPHICS_BASE+0x18)
+#define BLKDESTHEIGHT           (GRAPHICS_BASE+0x1C)
+#define DESTLINELENGTH          (GRAPHICS_BASE+0x20)
+#define BLOCKCTRL               (GRAPHICS_BASE+0x24)
+#define TRANSPATTRN             (GRAPHICS_BASE+0x28)
+#define BLOCKMASK               (GRAPHICS_BASE+0x2C)
+#define BACKGROUND              (GRAPHICS_BASE+0x30)
+#define LINEINC                 (GRAPHICS_BASE+0x34)
+#define LINEINIT                (GRAPHICS_BASE+0x38)
+#define LINEPATTRN              (GRAPHICS_BASE+0x3C)
+
+
+
+/* 8005_0000 - 8005_ffff: Reserved  */
+
+
+
+/*8006_0000 - 8006_ffff: SDRAM  */
+#define SDRAM_OFFSET            0x060000
+#define SDRAM_BASE              (EP93XX_AHB_BASE|SDRAM_OFFSET)
+//#define SDRAMRESERVED         (SDRAM_BASE+0x00) /* Reserved */
+#define SDRAMGLOBALCFG          (SDRAM_BASE+0x04)
+#define SDRAMREFRESHTIME        (SDRAM_BASE+0x08) /* Refresh Timer */
+#define SDRAMBOOTSTATUS         (SDRAM_BASE+0x0C)
+#define SDRAMCFG0               (SDRAM_BASE+0x10) /* Configuration Register 0 (nSDCS0) */
+#define SDRAMCFG1               (SDRAM_BASE+0x14) /* Configuration Register 1 (nSDCS1) */
+#define SDRAMCFG2               (SDRAM_BASE+0x18) /* Configuration Register 2 (nSDCS2) */
+#define SDRAMCFG3               (SDRAM_BASE+0x1C) /* Configuration Register 3 (nSDCS3) */
+
+
+/* 8007_0000 - 8007_ffff: ARM920T Slave  */
+
+
+/* 8008_0000 - 8008_ffff: SRAM CS */
+
+
+/* SMC register map                                                            */
+/* Address     Read Location                   Write Location                  */
+/* 0x8000.2000 SMCBCR0(Bank config register 0) SMCBCR0(Bank config register 0) */
+/* 0x8000.2004 SMCBCR1(Bank config register 1) SMCBCR1(Bank config register 1) */
+/* 0x8000.2008 SMCBCR2(Bank config register 2) SMCBCR2(Bank config register 2) */
+/* 0x8000.200C SMCBCR3(Bank config register 3) SMCBCR3(Bank config register 3) */
+/* 0x8000.2010 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2014 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2018 SMCBCR6(Bank config register 6) SMCBCR6(Bank config register 6) */
+/* 0x8000.201C SMCBCR7(Bank config register 7) SMCBCR7(Bank config register 7) */
+/* 0x8000.2020 PCAttribute Register            PCAttribute Register            */
+/* 0x8000.2024 PCCommon Register               PCCommon Register               */
+/* 0x8000.2028 PCIO Register                   PCIO Register                   */
+/* 0x8000.202C Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2030 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2034 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2038 Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.203C Reserved, RAZ                   Reserved, RAZ                   */
+/* 0x8000.2040 PCMCIACtrl Register             PCMCIACtrl Register             */
+
+#define SRAM_OFFSET             0x080000
+#define SRAM_BASE               (EP93XX_AHB_BASE|SRAM_OFFSET)
+#define SMCBCR0                 (SRAM_BASE+0x00) /* 0x8000.2000  Bank config register 0 */
+#define SMCBCR1                 (SRAM_BASE+0x04) /* 0x8000.2004  Bank config register 1 */
+#define SMCBCR2                 (SRAM_BASE+0x08) /* 0x8000.2008  Bank config register 2 */
+#define SMCBCR3                 (SRAM_BASE+0x0C) /* 0x8000.200C  Bank config register 3 */
+                                                 /* 0x8000.2010  Reserved, RAZ          */
+                                                 /* 0x8000.2014  Reserved, RAZ          */
+#define SMCBCR6                 (SRAM_BASE+0x18) /* 0x8000.2018  Bank config register 6 */
+#define SMCBCR7                 (SRAM_BASE+0x1C) /* 0x8000.201C  Bank config register 7 */
+
+#define SMC_PCAttribute         (SRAM_BASE+0x20) /* 0x8000.2020  PCMCIA Attribute Register */
+#define SMC_PCCommon            (SRAM_BASE+0x24) /* 0x8000.2024  PCMCIA Common Register    */
+#define SMC_PCIO                (SRAM_BASE+0x28) /* 0x8000.2028  PCMCIA IO Register        */
+                                                 /* 0x8000.202C  Reserved, RAZ           */
+											   	 /* 0x8000.2030  Reserved, RAZ           */
+												 /* 0x8000.2034  Reserved, RAZ           */
+												 /* 0x8000.2038  Reserved, RAZ           */
+                                                 /* 0x8000.203C  Reserved, RAZ           */
+#define SMC_PCMCIACtrl          (SRAM_BASE+0x40) /* 0x8000.2040  PCMCIA control register */
+
+
+/* 8009_0000 - 8009_ffff: Boot ROM (Remap low or high) */
+/*   0000 - 8009_0FFF - Boot ROM code                  */
+/*   0FFF - 8009_FFFF - Reserved                       */
+#define BOOT_OFFSET             0x090000
+#define BOOT_BASE               (EP93XX_AHB_BASE|BOOT_OFFSET)
+#define BOOT                    (BOOT_BASE+0x00)
+
+
+/* 800A_0000 - 800A_ffff: IDE Interface  */
+#define IDE_OFFSET              0x0a0000
+#define IDE_BASE                (EP93XX_AHB_BASE|IDE_OFFSET)
+#define IDECR                   (IDE_BASE+0x00)
+#define IDECFG                  (IDE_BASE+0x04)
+#define IDEMDMAOP               (IDE_BASE+0x08)
+#define IDEUDMAOP               (IDE_BASE+0x0C)
+#define IDEDATAOUT              (IDE_BASE+0x10)
+#define IDEDATAIN               (IDE_BASE+0x14)
+#define IDEMDMADATAOUT          (IDE_BASE+0x18)
+#define IDEMDMADATAIN           (IDE_BASE+0x1C)
+#define IDEUDMADATAOUT          (IDE_BASE+0x20)
+#define IDEUDMADATAIN           (IDE_BASE+0x24)
+#define IDEUDMASTATUS           (IDE_BASE+0x28)
+#define IDEUDMADEBUG            (IDE_BASE+0x2C)
+#define IDEUDMAWFST             (IDE_BASE+0x30)
+#define IDEUDMARFST             (IDE_BASE+0x34)
+
+
+
+/* 800B_0000 - 800B_FFFF: VIC 0 */
+#define VIC0_OFFSET              0x0B0000
+#define VIC0_BASE                (EP93XX_AHB_BASE|VIC0_OFFSET)
+#define VIC0                     (VIC0_BASE+0x000) 
+#define VIC0IRQSTATUS            (VIC0_BASE+0x000) /* R   IRQ status register               */
+#define VIC0FIQSTATUS            (VIC0_BASE+0x004) /* R   FIQ status register               */
+#define VIC0RAWINTR              (VIC0_BASE+0x008) /* R   Raw interrupt status register     */
+#define VIC0INTSELECT            (VIC0_BASE+0x00C) /* R/W Interrupt select register         */
+#define VIC0INTENABLE            (VIC0_BASE+0x010) /* R/W Interrupt enable register         */
+#define VIC0INTENCLEAR           (VIC0_BASE+0x014) /* W   Interrupt enable clear register   */
+#define VIC0SOFTINT              (VIC0_BASE+0x018) /* R/W Software interrupt register       */
+#define VIC0SOFTINTCLEAR         (VIC0_BASE+0x01C) /* R/W Software interrupt clear register */
+#define VIC0PROTECTION           (VIC0_BASE+0x020) /* R/W Protection enable register        */
+#define VIC0VECTADDR             (VIC0_BASE+0x030) /* R/W Vector address register           */
+#define VIC0DEFVECTADDR          (VIC0_BASE+0x034) /* R/W Default vector address register   */
+#define VIC0VECTADDR00           (VIC0_BASE+0x100) /* R/W Vector address 00 register        */
+#define VIC0VECTADDR01           (VIC0_BASE+0x104) /* R/W Vector address 01 register        */
+#define VIC0VECTADDR02           (VIC0_BASE+0x108) /* R/W Vector address 02 register        */
+#define VIC0VECTADDR03           (VIC0_BASE+0x10C) /* R/W Vector address 03 register        */
+#define VIC0VECTADDR04           (VIC0_BASE+0x110) /* R/W Vector address 04 register        */
+#define VIC0VECTADDR05           (VIC0_BASE+0x114) /* R/W Vector address 05 register        */
+#define VIC0VECTADDR06           (VIC0_BASE+0x118) /* R/W Vector address 06 register        */
+#define VIC0VECTADDR07           (VIC0_BASE+0x11C) /* R/W Vector address 07 register        */
+#define VIC0VECTADDR08           (VIC0_BASE+0x120) /* R/W Vector address 08 register        */
+#define VIC0VECTADDR09           (VIC0_BASE+0x124) /* R/W Vector address 09 register        */
+#define VIC0VECTADDR10           (VIC0_BASE+0x128) /* R/W Vector address 10 register        */
+#define VIC0VECTADDR11           (VIC0_BASE+0x12C) /* R/W Vector address 11 register        */
+#define VIC0VECTADDR12           (VIC0_BASE+0x130) /* R/W Vector address 12 register        */
+#define VIC0VECTADDR13           (VIC0_BASE+0x134) /* R/W Vector address 13 register        */
+#define VIC0VECTADDR14           (VIC0_BASE+0x138) /* R/W Vector address 14 register        */
+#define VIC0VECTADDR15           (VIC0_BASE+0x13C) /* R/W Vector address 15 register        */
+#define VIC0VECTCNTL00           (VIC0_BASE+0x200) /* R/W Vector control 00 register        */
+#define VIC0VECTCNTL01           (VIC0_BASE+0x204) /* R/W Vector control 01 register        */
+#define VIC0VECTCNTL02           (VIC0_BASE+0x208) /* R/W Vector control 02 register        */
+#define VIC0VECTCNTL03           (VIC0_BASE+0x20C) /* R/W Vector control 03 register        */
+#define VIC0VECTCNTL04           (VIC0_BASE+0x210) /* R/W Vector control 04 register        */
+#define VIC0VECTCNTL05           (VIC0_BASE+0x214) /* R/W Vector control 05 register        */
+#define VIC0VECTCNTL06           (VIC0_BASE+0x218) /* R/W Vector control 06 register        */
+#define VIC0VECTCNTL07           (VIC0_BASE+0x21C) /* R/W Vector control 07 register        */
+#define VIC0VECTCNTL08           (VIC0_BASE+0x220) /* R/W Vector control 08 register        */
+#define VIC0VECTCNTL09           (VIC0_BASE+0x224) /* R/W Vector control 09 register        */
+#define VIC0VECTCNTL10           (VIC0_BASE+0x228) /* R/W Vector control 10 register        */
+#define VIC0VECTCNTL11           (VIC0_BASE+0x22C) /* R/W Vector control 11 register        */
+#define VIC0VECTCNTL12           (VIC0_BASE+0x230) /* R/W Vector control 12 register        */
+#define VIC0VECTCNTL13           (VIC0_BASE+0x234) /* R/W Vector control 13 register        */
+#define VIC0VECTCNTL14           (VIC0_BASE+0x238) /* R/W Vector control 14 register        */
+#define VIC0VECTCNTL15           (VIC0_BASE+0x23C) /* R/W Vector control 15 register        */
+#define VIC0ITCR                 (VIC0_BASE+0x300) /* R/W Test control register             */
+#define VIC0ITIP1                (VIC0_BASE+0x304) /* R   Test input register (nVICIRQIN/nVICFIQIN)*/
+#define VIC0ITIP2                (VIC0_BASE+0x308) /* R   Test input register (VICVECTADDRIN)      */
+#define VIC0ITOP1                (VIC0_BASE+0x30C) /* R   Test output register (nVICIRQ/nVICFIQ)   */
+#define VIC0ITOP2                (VIC0_BASE+0x310) /* R   Test output register (VICVECTADDROUT)    */
+#define VIC0PERIPHID0            (VIC0_BASE+0xFE0) /* R   Peripheral ID register bits 7:0   */
+#define VIC0PERIPHID1            (VIC0_BASE+0xFE4) /* R   Peripheral ID register bits 15:8  */
+#define VIC0PERIPHID2            (VIC0_BASE+0xFE8) /* R   Peripheral ID register bits 23:16 */
+#define VIC0PERIPHID3            (VIC0_BASE+0xFEC) /* R   Peripheral ID register bits 31:24 */
+
+
+/* 800C_0000 - 800C_FFFF: VIC 0 */
+#define VIC1_OFFSET              0x0C0000
+#define VIC1_BASE                (EP93XX_AHB_BASE|VIC1_OFFSET)
+#define VIC1                     (VIC1_BASE+0x000) 
+#define VIC1IRQSTATUS            (VIC1_BASE+0x000) /* R   IRQ status register               */
+#define VIC1FIQSTATUS            (VIC1_BASE+0x004) /* R   FIQ status register               */
+#define VIC1RAWINTR              (VIC1_BASE+0x008) /* R   Raw interrupt status register     */
+#define VIC1INTSELECT            (VIC1_BASE+0x00C) /* R/W Interrupt select register         */
+#define VIC1INTENABLE            (VIC1_BASE+0x010) /* R/W Interrupt enable register         */
+#define VIC1INTENCLEAR           (VIC1_BASE+0x014) /* W   Interrupt enable clear register   */
+#define VIC1SOFTINT              (VIC1_BASE+0x018) /* R/W Software interrupt register       */
+#define VIC1SOFTINTCLEAR         (VIC1_BASE+0x01C) /* R/W Software interrupt clear register */
+#define VIC1PROTECTION           (VIC1_BASE+0x020) /* R/W Protection enable register        */
+#define VIC1VECTADDR             (VIC1_BASE+0x030) /* R/W Vector address register           */
+#define VIC1DEFVECTADDR          (VIC1_BASE+0x034) /* R/W Default vector address register   */
+#define VIC1VECTADDR00           (VIC1_BASE+0x100) /* R/W Vector address 00 register        */
+#define VIC1VECTADDR01           (VIC1_BASE+0x104) /* R/W Vector address 01 register        */
+#define VIC1VECTADDR02           (VIC1_BASE+0x108) /* R/W Vector address 02 register        */
+#define VIC1VECTADDR03           (VIC1_BASE+0x10C) /* R/W Vector address 03 register        */
+#define VIC1VECTADDR04           (VIC1_BASE+0x110) /* R/W Vector address 04 register        */
+#define VIC1VECTADDR05           (VIC1_BASE+0x114) /* R/W Vector address 05 register        */
+#define VIC1VECTADDR06           (VIC1_BASE+0x118) /* R/W Vector address 06 register        */
+#define VIC1VECTADDR07           (VIC1_BASE+0x11C) /* R/W Vector address 07 register        */
+#define VIC1VECTADDR08           (VIC1_BASE+0x120) /* R/W Vector address 08 register        */
+#define VIC1VECTADDR09           (VIC1_BASE+0x124) /* R/W Vector address 09 register        */
+#define VIC1VECTADDR10           (VIC1_BASE+0x128) /* R/W Vector address 10 register        */
+#define VIC1VECTADDR11           (VIC1_BASE+0x12C) /* R/W Vector address 11 register        */
+#define VIC1VECTADDR12           (VIC1_BASE+0x130) /* R/W Vector address 12 register        */
+#define VIC1VECTADDR13           (VIC1_BASE+0x134) /* R/W Vector address 13 register        */
+#define VIC1VECTADDR14           (VIC1_BASE+0x138) /* R/W Vector address 14 register        */
+#define VIC1VECTADDR15           (VIC1_BASE+0x13C) /* R/W Vector address 15 register        */
+#define VIC1VECTCNTL00           (VIC1_BASE+0x200) /* R/W Vector control 00 register        */
+#define VIC1VECTCNTL01           (VIC1_BASE+0x204) /* R/W Vector control 01 register        */
+#define VIC1VECTCNTL02           (VIC1_BASE+0x208) /* R/W Vector control 02 register        */
+#define VIC1VECTCNTL03           (VIC1_BASE+0x20C) /* R/W Vector control 03 register        */
+#define VIC1VECTCNTL04           (VIC1_BASE+0x210) /* R/W Vector control 04 register        */
+#define VIC1VECTCNTL05           (VIC1_BASE+0x214) /* R/W Vector control 05 register        */
+#define VIC1VECTCNTL06           (VIC1_BASE+0x218) /* R/W Vector control 06 register        */
+#define VIC1VECTCNTL07           (VIC1_BASE+0x21C) /* R/W Vector control 07 register        */
+#define VIC1VECTCNTL08           (VIC1_BASE+0x220) /* R/W Vector control 08 register        */
+#define VIC1VECTCNTL09           (VIC1_BASE+0x224) /* R/W Vector control 09 register        */
+#define VIC1VECTCNTL10           (VIC1_BASE+0x228) /* R/W Vector control 10 register        */
+#define VIC1VECTCNTL11           (VIC1_BASE+0x22C) /* R/W Vector control 11 register        */
+#define VIC1VECTCNTL12           (VIC1_BASE+0x230) /* R/W Vector control 12 register        */
+#define VIC1VECTCNTL13           (VIC1_BASE+0x234) /* R/W Vector control 13 register        */
+#define VIC1VECTCNTL14           (VIC1_BASE+0x238) /* R/W Vector control 14 register        */
+#define VIC1VECTCNTL15           (VIC1_BASE+0x23C) /* R/W Vector control 15 register        */
+#define VIC1ITCR                 (VIC1_BASE+0x300) /* R/W Test control register             */
+#define VIC1ITIP1                (VIC1_BASE+0x304) /* R   Test input register (nVICIRQIN/nVICFIQIN)*/
+#define VIC1ITIP2                (VIC1_BASE+0x308) /* R   Test input register (VICVECTADDRIN)      */
+#define VIC1ITOP1                (VIC1_BASE+0x30C) /* R   Test output register (nVICIRQ/nVICFIQ)   */
+#define VIC1ITOP2                (VIC1_BASE+0x310) /* R   Test output register (VICVECTADDROUT)    */
+#define VIC1PERIPHID0            (VIC1_BASE+0xFE0) /* R   Peripheral ID register bits 7:0   */
+#define VIC1PERIPHID1            (VIC1_BASE+0xFE4) /* R   Peripheral ID register bits 15:8  */
+#define VIC1PERIPHID2            (VIC1_BASE+0xFE8) /* R   Peripheral ID register bits 23:16 */
+#define VIC1PERIPHID3            (VIC1_BASE+0xFEC) /* R   Peripheral ID register bits 31:24 */
+
+
+/*800D_0000 - 807F_FFFF: Reserved AHB space  */
+  
+/******************************************************************/
+/******************************************************************/
+/* EP93xx APB Blocks Base Addrs                                   */
+/* The APB address map is:                                        */
+/* Start     End        Size Usage                                */
+/* 8080_0000 8080_FFFF: 64 K Reserved                             */
+/* 8081_0000 8081_FFFF: 64 K Timer control registers              */
+/* 8082_0000 8082_FFFF: 64 K I2S control registers                */
+/* 8083_0000 8083_FFFF: 64 K Reserved                             */
+/* 8084_0000 8084_FFFF: 64 K GPIO control registers               */
+/* 8085_0000 8085_FFFF: 64 K Reserved                             */
+/* 8086_0000 8086_FFFF: 64 K Reserved                             */
+/* 8087_0000 8087_FFFF: 64 K Reserved                             */
+/* 8088_0000 8088_FFFF: 64 K AC97 control registers                */
+/* 8089_0000 8089_FFFF: 64 K Reserved                             */
+/* 808A_0000 808A_FFFF: 64 K SPI1 control registers               */
+/* 808B_0000 808B_FFFF: 64 K IrDA control registers               */
+/* 808C_0000 808C_FFFF: 64 K UART1 control registers              */
+/* 808D_0000 808D_FFFF: 64 K UART2 control registers              */
+/* 808E_0000 808E_FFFF: 64 K UART3 control registers              */
+/* 808F_0000 808F_FFFF: 64 K Key Matrix control registers         */
+/* 8090_0000 8090_FFFF: 64 K Touch Screen control registers       */
+/* 8091_0000 8091_FFFF: 64 K PWM control registers                */
+/* 8092_0000 8092_FFFF: 64 K Real Time Clock control registers    */
+/* 8093_0000 8093_1FFF: 64 K Syscon control registers             */
+/* 8093_2000 8093_FFFF: 64 K Security control registers           */
+/* 8094_0000 8094_FFFF: 64 K Watchdog control registers           */
+/* 8095_0000 8FFF_FFFF: 128M Reserved                             */
+
+
+#define EP93XX_APB_BASE (IO_BASE_VIRT | 0x00800000)
+
+
+/* 8080_0000 - 8080_ffff: Reserved  */
+
+ 
+
+/* 8081_0000 - 8081_ffff: Timers */
+#define TIMERS_OFFSET           0x010000
+#define TIMERS_BASE             (EP93XX_APB_BASE|TIMERS_OFFSET)
+
+#define TIMER1LOAD              (TIMERS_BASE+0x00)
+#define TIMER1VALUE             (TIMERS_BASE+0x04)
+#define TIMER1CONTROL           (TIMERS_BASE+0x08)
+#define TIMER1CLEAR             (TIMERS_BASE+0x0C)
+#define TIMER1TEST              (TIMERS_BASE+0x10)
+
+#define TIMER2LOAD              (TIMERS_BASE+0x20)
+#define TIMER2VALUE             (TIMERS_BASE+0x24)
+#define TIMER2CONTROL           (TIMERS_BASE+0x28)
+#define TIMER2CLEAR             (TIMERS_BASE+0x2C)
+#define TIMER2TEST              (TIMERS_BASE+0x30)
+
+#define TIMER3LOAD              (TIMERS_BASE+0x80)
+#define TIMER3VALUE             (TIMERS_BASE+0x84)
+#define TIMER3CONTROL           (TIMERS_BASE+0x88)
+#define TIMER3CLEAR             (TIMERS_BASE+0x8C)
+#define TIMER3TEST              (TIMERS_BASE+0x90)
+
+#define TTIMERBZCONT            (TIMERS_BASE+0x40)
+
+#define TIMER4VALUELOW          (TIMERS_BASE+0x60)
+#define TIMER4VALUEHIGH         (TIMERS_BASE+0x64)
+
+
+
+/* 8082_0000 - 8082_ffff: I2S */
+#define I2S_OFFSET            0x020000
+#define I2S_BASE              (EP93XX_APB_BASE|I2S_OFFSET)
+
+#define I2STxClkCfg           (I2S_BASE+0x00) /* 8082.0000 R/W Transmitter clock config register  */
+#define I2SRxClkCfg           (I2S_BASE+0x04) /* 8082.0004 R/W Receiver clock config register     */
+#define I2SGlSts              (I2S_BASE+0x08) /* 8082.0008 R/W SAI Global Status register.        */
+#define I2SGlCtrl             (I2S_BASE+0x0C) /* 8082.000C R/W SAI Global Control register        */
+
+#define I2STX0Lft             (I2S_BASE+0x10) /* 8082.0010 R/W Left  TX data reg for channel 0    */
+#define I2STX0Rt              (I2S_BASE+0x14) /* 8082.0014 R/W Right TX data reg for channel 0    */
+#define I2STX1Lft             (I2S_BASE+0x18) /* 8082.0018 R/W Left  TX data reg for channel 1    */
+#define I2STX1Rt              (I2S_BASE+0x1C) /* 8082.001C R/W Right TX data reg for channel 1    */
+#define I2STX2Lft             (I2S_BASE+0x20) /* 8082.0020 R/W Left  TX data reg for channel 2    */
+#define I2STX2Rt              (I2S_BASE+0x24) /* 8082.0024 R/W Right TX data reg for channel 2    */
+
+#define I2STXLinCtrlData      (I2S_BASE+0x28) /* 8082.0028 R/W TX Line Control data register      */
+#define I2STXCtrl             (I2S_BASE+0x2C) /* 8082.002C R/W TX Control register                */
+#define I2STXWrdLen           (I2S_BASE+0x30) /* 8082.0030 R/W TX Word Length                     */
+#define I2STX0En              (I2S_BASE+0x34) /* 8082.0034 R/W TX0 Channel Enable                 */
+#define I2STX1En              (I2S_BASE+0x38) /* 8082.0038 R/W TX1 Channel Enable                 */
+#define I2STX2En              (I2S_BASE+0x3C) /* 8082.003C R/W TX2 Channel Enable                 */
+
+#define I2SRX0Lft             (I2S_BASE+0x40) /* 8082.0040 R   Left  RX data reg for channel 0    */
+#define I2SRX0Rt              (I2S_BASE+0x44) /* 8082.0044 R   Right RX data reg for channel 0    */
+#define I2SRX1Lft             (I2S_BASE+0x48) /* 8082.0048 R   Left  RX data reg for channel 1    */
+#define I2SRX1Rt              (I2S_BASE+0x4C) /* 8082.004c R   Right RX data reg for channel 1    */
+#define I2SRX2Lft             (I2S_BASE+0x50) /* 8082.0050 R   Left  RX data reg for channel 2    */
+#define I2SRX2Rt              (I2S_BASE+0x54) /* 8082.0054 R   Right RX data reg for channel 2    */
+
+#define I2SRXLinCtrlData      (I2S_BASE+0x58) /* 8082.0058 R/W RX Line Control data register      */
+#define I2SRXCtrl             (I2S_BASE+0x5C) /* 8082.005C R/W RX Control register                */
+#define I2SRXWrdLen           (I2S_BASE+0x60) /* 8082.0060 R/W RX Word Length                     */
+#define I2SRX0En              (I2S_BASE+0x64) /* 8082.0064 R/W RX0 Channel Enable                 */
+#define I2SRX1En              (I2S_BASE+0x68) /* 8082.0068 R/W RX1 Channel Enable                 */
+#define I2SRX2En              (I2S_BASE+0x6C) /* 8082.006C R/W RX2 Channel Enable                 */
+
+
+/* 8083_0000 - 8083_ffff: Security Block */
+#define SECURITY_OFFSET         0x030000
+#define SECURITY_BASE           (EP93XX_APB_BASE|SECURITY_OFFSET)
+#define SECFLG                  (SECURITY_BASE+0x2400)
+#define SECEN                   (SECURITY_BASE+0x2410)
+#define UNIQID                  (SECURITY_BASE+0x2440)
+#define UNIQCHK                 (SECURITY_BASE+0x2450)
+#define UNIQVAL                 (SECURITY_BASE+0x2460)
+#define CLINBOOT                (SECURITY_BASE+0x2480)
+#define CLINVADDR               (SECURITY_BASE+0x2484)
+#define CLSETSKRNL              (SECURITY_BASE+0x2488)
+#define CLSKRNL                 (SECURITY_BASE+0x248C)
+#define ITTMP                   (SECURITY_BASE+0x2490)
+#define ETBL1                   (SECURITY_BASE+0x24A0)
+#define ETCL1                   (SECURITY_BASE+0x24A4)
+#define ETAPL1                  (SECURITY_BASE+0x24A8)
+#define ETSPTREG1               (SECURITY_BASE+0x24B0)
+#define ETSPTREG2               (SECURITY_BASE+0x24B4)
+#define ETSPTREG3               (SECURITY_BASE+0x24B8)
+
+#define SECID1                  (SECURITY_BASE+0x2500)
+#define SECID2                  (SECURITY_BASE+0x2504)
+#define SECCHK1                 (SECURITY_BASE+0x2520)
+#define SECCHK2                 (SECURITY_BASE+0x2524)
+#define SECVAL1                 (SECURITY_BASE+0x2540)
+#define SECVAL2                 (SECURITY_BASE+0x2544)
+
+#define UNIQID2                 (SECURITY_BASE+0x2700)
+#define UNIQID3                 (SECURITY_BASE+0x2704)
+#define UNIQID4                 (SECURITY_BASE+0x2708)
+#define UNIQID5                 (SECURITY_BASE+0x270C)
+#define UNIQCHK2                (SECURITY_BASE+0x2710)
+#define USRFLG                  (SECURITY_BASE+0x2714)
+#define UNIQVAL2                (SECURITY_BASE+0x2720)
+#define UNIQVAL3                (SECURITY_BASE+0x2724)
+#define UNIQVAL4                (SECURITY_BASE+0x2728)
+#define TESTVAL                 (SECURITY_BASE+0x2744)
+#define TESTCHK                 (SECURITY_BASE+0x2754)
+#define ACHK1                   (SECURITY_BASE+0x27A0)
+#define ACHK2                   (SECURITY_BASE+0x27A4)
+#define PROCRESET               (SECURITY_BASE+0x27A8)
+#define TESTIDR                 (SECURITY_BASE+0x27AC)
+#define AVAL1                   (SECURITY_BASE+0x27B0)
+#define AVAL2                   (SECURITY_BASE+0x27B4)
+#define AID1                    (SECURITY_BASE+0x27C4)
+#define AID2                    (SECURITY_BASE+0x27C8)
+#define ADYNREMAP               (SECURITY_BASE+0x27D0)
+#define ALTTMP                  (SECURITY_BASE+0x27D4)
+#define PROCSIGN                (SECURITY_BASE+0x27F0)
+
+#define ECLIDX                  (SECURITY_BASE+0x2800)
+#define ECLINE0                 (SECURITY_BASE+0x2810)
+#define ECLINE1                 (SECURITY_BASE+0x2814)
+#define ECLINE2                 (SECURITY_BASE+0x2818)
+#define ECLINE3                 (SECURITY_BASE+0x281C)
+#define ECLINE4                 (SECURITY_BASE+0x2820)
+#define ECLINE5                 (SECURITY_BASE+0x2824)
+#define ECLINE6                 (SECURITY_BASE+0x2828)
+#define ECLINE7                 (SECURITY_BASE+0x282C)
+#define ETWIDX1                 (SECURITY_BASE+0x2840)
+#define ETWL1                   (SECURITY_BASE+0x2844)
+#define ETWIDX2                 (SECURITY_BASE+0x2848)
+#define ETWL2                   (SECURITY_BASE+0x284C)
+
+#define ETSPT10                 (SECURITY_BASE+0x4000)
+#define ETSPT11                 (SECURITY_BASE+0x4004)
+#define ETSPT12                 (SECURITY_BASE+0x4008)
+#define ETSPT13                 (SECURITY_BASE+0x400C)
+
+#define ETSPT2000               (SECURITY_BASE+0x6000)
+#define ETSPT2020               (SECURITY_BASE+0x6020)
+#define ETSPT2024               (SECURITY_BASE+0x6024)
+
+
+
+/* 8084_0000 - 8084_ffff: GPIO */
+#define GPIO_OFFSET              0x040000
+#define GPIO_BASE                (EP93XX_APB_BASE|GPIO_OFFSET)
+#define GPIO_PADR                (GPIO_BASE+0x00)
+#define GPIO_PBDR                (GPIO_BASE+0x04)
+#define GPIO_PCDR                (GPIO_BASE+0x08)
+#define GPIO_PDDR                (GPIO_BASE+0x0C)
+#define GPIO_PADDR               (GPIO_BASE+0x10)
+#define GPIO_PBDDR               (GPIO_BASE+0x14)
+#define GPIO_PCDDR               (GPIO_BASE+0x18)
+#define GPIO_PDDDR               (GPIO_BASE+0x1C)
+#define GPIO_PEDR                (GPIO_BASE+0x20)
+#define GPIO_PEDDR               (GPIO_BASE+0x24)
+// #define 0x8084.0028 Reserved
+// #define 0x8084.002C Reserved
+#define GPIO_PFDR                (GPIO_BASE+0x30) 
+#define GPIO_PFDDR               (GPIO_BASE+0x34)
+#define GPIO_PGDR                (GPIO_BASE+0x38)
+#define GPIO_PGDDR               (GPIO_BASE+0x3C)
+#define GPIO_PHDR                (GPIO_BASE+0x40)
+#define GPIO_PHDDR               (GPIO_BASE+0x44)
+// #define 0x8084.0048 RAZ RAZ                            
+#define GPIO_FINTTYPE1           (GPIO_BASE+0x4C)
+#define GPIO_FINTTYPE2           (GPIO_BASE+0x50)
+#define GPIO_FEOI                (GPIO_BASE+0x54) /* WRITE ONLY - READ UNDEFINED */
+#define GPIO_FINTEN              (GPIO_BASE+0x58)
+#define GPIO_INTSTATUSF          (GPIO_BASE+0x5C)
+#define GPIO_RAWINTSTASUSF       (GPIO_BASE+0x60) 
+#define GPIO_FDB                 (GPIO_BASE+0x64)
+#define GPIO_PAPINDR             (GPIO_BASE+0x68)
+#define GPIO_PBPINDR             (GPIO_BASE+0x6C)
+#define GPIO_PCPINDR             (GPIO_BASE+0x70)
+#define GPIO_PDPINDR             (GPIO_BASE+0x74)
+#define GPIO_PEPINDR             (GPIO_BASE+0x78)
+#define GPIO_PFPINDR             (GPIO_BASE+0x7C)
+#define GPIO_PGPINDR             (GPIO_BASE+0x80)
+#define GPIO_PHPINDR             (GPIO_BASE+0x84)
+#define GPIO_AINTTYPE1           (GPIO_BASE+0x90)
+#define GPIO_AINTTYPE2           (GPIO_BASE+0x94)
+#define GPIO_AEOI                (GPIO_BASE+0x98) /* WRITE ONLY - READ UNDEFINED */
+#define GPIO_AINTEN              (GPIO_BASE+0x9C)
+#define GPIO_INTSTATUSA          (GPIO_BASE+0xA0)
+#define GPIO_RAWINTSTSTISA       (GPIO_BASE+0xA4)
+#define GPIO_ADB                 (GPIO_BASE+0xA8)
+#define GPIO_BINTTYPE1           (GPIO_BASE+0xAC)
+#define GPIO_BINTTYPE2           (GPIO_BASE+0xB0)
+#define GPIO_BEOI                (GPIO_BASE+0xB4) /* WRITE ONLY - READ UNDEFINED */
+#define GPIO_BINTEN              (GPIO_BASE+0xB8)
+#define GPIO_INTSTATUSB          (GPIO_BASE+0xBC)
+#define GPIO_RAWINTSTSTISB       (GPIO_BASE+0xC0)
+#define GPIO_BDB                 (GPIO_BASE+0xC4)
+#define GPIO_EEDRIVE             (GPIO_BASE+0xC8)
+//#define Reserved               (GPIO_BASE+0xCC)
+#define GPIO_TCR                 (GPIO_BASE+0xD0) /* Test Registers */
+#define GPIO_TISRA               (GPIO_BASE+0xD4) /* Test Registers */
+#define GPIO_TISRB               (GPIO_BASE+0xD8) /* Test Registers */
+#define GPIO_TISRC               (GPIO_BASE+0xDC) /* Test Registers */
+#define GPIO_TISRD               (GPIO_BASE+0xE0) /* Test Registers */
+#define GPIO_TISRE               (GPIO_BASE+0xE4) /* Test Registers */
+#define GPIO_TISRF               (GPIO_BASE+0xE8) /* Test Registers */
+#define GPIO_TISRG               (GPIO_BASE+0xEC) /* Test Registers */
+#define GPIO_TISRH               (GPIO_BASE+0xF0) /* Test Registers */
+#define GPIO_TCER                (GPIO_BASE+0xF4) /* Test Registers */
+
+
+
+/* 8085_0000 - 8085_ffff: Reserved  */
+
+
+
+/* 8086_0000 - 8086_ffff: Reserved  */
+
+
+
+/* 8087_0000 - 8087_ffff: Reserved  */
+
+
+/* 8088_0000 - 8088_ffff: Ac97 Controller (AAC) */
+#define AC97_OFFSET             0x080000
+#define AC97_BASE               (EP93XX_APB_BASE|AC97_OFFSET)
+#define AC97DR1                 (AC97_BASE+0x00) /* 8088.0000 R/W Data read or written from/to FIFO1  */
+#define AC97RXCR1               (AC97_BASE+0x04) /* 8088.0004 R/W Control register for receive        */
+#define AC97TXCR1               (AC97_BASE+0x08) /* 8088.0008 R/W Control register for transmit       */
+#define AC97SR1                 (AC97_BASE+0x0C) /* 8088.000C R   Status register                     */
+#define AC97RISR1               (AC97_BASE+0x10) /* 8088.0010 R   Raw interrupt status register       */
+#define AC97ISR1                (AC97_BASE+0x14) /* 8088.0014 R   Interrupt Status                    */
+#define AC97IE1                 (AC97_BASE+0x18) /* 8088.0018 R/W Interrupt Enable                    */
+                                                               /* 8088.001C Reserved - RAZ                          */
+#define AC97DR2                 (AC97_BASE+0x20) /* 8088.0020 R/W Data read or written from/to FIFO2  */
+#define AC97RXCR2               (AC97_BASE+0x24) /* 8088.0024 R/W Control register for receive        */
+#define AC97TXCR2               (AC97_BASE+0x28) /* 8088.0028 R/W Control register for transmit       */
+#define AC97SR2                 (AC97_BASE+0x2C) /* 8088.002C R   Status register                     */
+#define AC97RISR2               (AC97_BASE+0x30) /* 8088.0030 R   Raw interrupt status register       */
+#define AC97ISR2                (AC97_BASE+0x34) /* 8088.0034 R   Interrupt Status                    */
+#define AC97IE2                 (AC97_BASE+0x38) /* 8088.0038 R/W Interrupt Enable                    */
+                                                               /* 8088.003C Reserved - RAZ                          */
+#define AC97DR3                 (AC97_BASE+0x40) /* 8088.0040 R/W Data read or written from/to FIFO3. */
+#define AC97RXCR3               (AC97_BASE+0x44) /* 8088.0044 R/W Control register for receive        */
+#define AC97TXCR3               (AC97_BASE+0x48) /* 8088.0048 R/W Control register for transmit       */
+#define AC97SR3                 (AC97_BASE+0x4C) /* 8088.004C R   Status register                     */
+#define AC97RISR3               (AC97_BASE+0x50) /* 8088.0050 R   Raw interrupt status register       */
+#define AC97ISR3                (AC97_BASE+0x54) /* 8088.0054 R   Interrupt Status                    */
+#define AC97IE3                 (AC97_BASE+0x58) /* 8088.0058 R/W Interrupt Enable                    */
+                                                               /* 8088.005C Reserved - RAZ                          */
+#define AC97DR4                 (AC97_BASE+0x60) /* 8088.0060 R/W Data read or written from/to FIFO4. */
+#define AC97RXCR4               (AC97_BASE+0x64) /* 8088.0064 R/W Control register for receive        */
+#define AC97TXCR4               (AC97_BASE+0x68) /* 8088.0068 R/W Control register for transmit       */
+#define AC97SR4                 (AC97_BASE+0x6C) /* 8088.006C R   Status register                     */
+#define AC97RISR4               (AC97_BASE+0x70) /* 8088.0070 R   Raw interrupt status register       */
+#define AC97ISR4                (AC97_BASE+0x74) /* 8088.0074 R   Interrupt Status                    */
+#define AC97IE4                 (AC97_BASE+0x78) /* 8088.0078 R/W Interrupt Enable                    */
+                                                               /* 8088.007C Reserved - RAZ                          */
+#define AC97S1DATA              (AC97_BASE+0x80) /* 8088.0080 R/W Data received/transmitted on SLOT1  */
+#define AC97S2DATA              (AC97_BASE+0x84) /* 8088.0084 R/W Data received/transmitted on SLOT2  */
+#define AC97S12DATA             (AC97_BASE+0x88) /* 8088.0088 R/W Data received/transmitted on SLOT12 */
+#define AC97RGIS                (AC97_BASE+0x8C) /* 8088.008C R/W Raw Global interrupt status register*/
+#define AC97GIS                 (AC97_BASE+0x90) /* 8088.0090 R   Global interrupt status register    */
+#define AC97IM                  (AC97_BASE+0x94) /* 8088.0094 R/W Interrupt mask register             */
+#define AC97EOI                 (AC97_BASE+0x98) /* 8088.0098 W   Interrupt clear register            */
+#define AC97GCR                 (AC97_BASE+0x9C) /* 8088.009C R/W Main Control register               */
+#define AC97RESET               (AC97_BASE+0xA0) /* 8088.00A0 R/W RESET control register.             */
+#define AC97SYNC                (AC97_BASE+0xA4) /* 8088.00A4 R/W SYNC control register.              */
+#define AC97GCIS                (AC97_BASE+0xA8) /* 8088.00A8 R  Global chan FIFO int status register */
+
+
+/* 8089_0000 - 8089_ffff: Reserved */
+
+/* 808A_0000 - 808A_ffff: SSP - (SPI) */
+#define SSP_OFFSET             0x0A0000
+#define SSP_BASE               (EP93XX_APB_BASE|SSP_OFFSET)
+#define SSPCR0                 (SSP_BASE+0x00)
+#define SSPCR1                 (SSP_BASE+0x04)
+#define SSPDR                  (SSP_BASE+0x08)
+#define SSPSR                  (SSP_BASE+0x0c)
+#define SSPCPSR                (SSP_BASE+0x10)
+#define SSPIIR                 (SSP_BASE+0x14)
+
+/*808B_0000 - 808B_ffff: IrDA */
+#define IRDA_OFFSET             0x0B0000
+#define IRDA_BASE               (EP93XX_APB_BASE|IRDA_OFFSET)
+#define IrEnable                (IRDA_BASE+0x00)
+#define IrCtrl                  (IRDA_BASE+0x04)
+#define IrAdrMatchVal           (IRDA_BASE+0x08)
+#define IrFlag                  (IRDA_BASE+0x0C)
+#define IrData                  (IRDA_BASE+0x10)
+#define IrDataTail1             (IRDA_BASE+0x14)
+#define IrDataTail2             (IRDA_BASE+0x18)
+#define IrDataTail3             (IRDA_BASE+0x1c)
+#define IrRIB                   (IRDA_BASE+0x20)
+#define IrTR0                   (IRDA_BASE+0x24)
+#define IrDMACR                 (IRDA_BASE+0x28)
+#define SIRTR0                  (IRDA_BASE+0x30)
+#define MISR                    (IRDA_BASE+0x80)
+#define MIMR                    (IRDA_BASE+0x84)
+#define MIIR                    (IRDA_BASE+0x88)
+#define FISR                    (IRDA_BASE+0x180)
+#define FIMR                    (IRDA_BASE+0x184)
+#define FIIR                    (IRDA_BASE+0x188)
+
+
+/* 808C_0000 - 808C_ffff: UART1 */
+#define UART1_OFFSET            0x0C0000
+#define UART1_BASE              (EP93XX_APB_BASE|UART1_OFFSET)
+#define UART1DR                 (UART1_BASE+0x000)
+#define UART1RSR                (UART1_BASE+0x004)
+#define UART1ECR                (UART1_BASE+0x004)
+#define UART1CR_H               (UART1_BASE+0x008)
+#define UART1CR_M               (UART1_BASE+0x00C)
+#define UART1CR_L               (UART1_BASE+0x010)
+#define UART1CR                 (UART1_BASE+0x014)
+#define UART1FR                 (UART1_BASE+0x018)
+#define UART1IIR                (UART1_BASE+0x01C)
+#define UART1ICR                (UART1_BASE+0x01C)
+#define UART1ILPR               (UART1_BASE+0x020)
+#define UART1DMACR              (UART1_BASE+0x028)
+#define UART1TMR                (UART1_BASE+0x084)
+#define UART1MCR                (UART1_BASE+0x100)
+#define UART1MSR                (UART1_BASE+0x104)
+#define UART1TCR                (UART1_BASE+0x108)
+#define UART1TISR               (UART1_BASE+0x10C)
+#define UART1TOCR               (UART1_BASE+0x110)
+#define HDLC1CR                 (UART1_BASE+0x20c)
+#define HDLC1AMV                (UART1_BASE+0x210)
+#define HDLC1AMSK               (UART1_BASE+0x214)
+#define HDLC1RIB                (UART1_BASE+0x218)
+#define HDLC1SR                 (UART1_BASE+0x21c)
+
+/* Offsets to the various UART registers */
+#define UARTDR                  0x0000
+#define UARTRSR                 0x0004
+#define UARTECR                 0x0004
+#define UARTCR_H                0x0008
+#define UARTCR_M                0x000C
+#define UARTCR_L                0x0010
+#define UARTCR                  0x0014
+#define UARTFR                  0x0018
+#define UARTIIR                 0x001C
+#define UARTICR                 0x001C
+#define UARTMCR                 0x0100
+#define UARTMSR                 0x0104
+
+/* 808d_0000 - 808d_ffff: UART2 */
+#define UART2_OFFSET            0x0D0000
+#define UART2_BASE              (EP93XX_APB_BASE|UART2_OFFSET)
+#define UART2DR                 (UART2_BASE+0x00)
+#define UART2RSR                (UART2_BASE+0x04) /* Read */
+#define UART2ECR                (UART2_BASE+0x04) /* Write */
+#define UART2CR_H               (UART2_BASE+0x08)
+#define UART2CR_M               (UART2_BASE+0x0C)
+#define UART2CR_L               (UART2_BASE+0x10)
+#define UART2CR                 (UART2_BASE+0x14)
+#define UART2FR                 (UART2_BASE+0x18)
+#define UART2IIR                (UART2_BASE+0x1C) /* Read */
+#define UART2ICR                (UART2_BASE+0x1C) /* Write */
+#define UART2ILPR               (UART2_BASE+0x20)
+#define UART2DMACR              (UART2_BASE+0x28)
+#define UART2TMR                (UART2_BASE+0x84)
+
+
+/* 808e_0000 - 808e_ffff: UART3 */
+#define UART3_OFFSET            0x0E0000
+#define UART3_BASE              (EP93XX_APB_BASE|UART3_OFFSET)
+#define UART3DR                 (UART3_BASE+0x00)
+#define UART3RSR                (UART3_BASE+0x04) /* Read */
+#define UART3ECR                (UART3_BASE+0x04) /* Write */
+#define UART3CR_H               (UART3_BASE+0x08)
+#define UART3CR_M               (UART3_BASE+0x0C)
+#define UART3CR_L               (UART3_BASE+0x10)
+#define UART3CR                 (UART3_BASE+0x14)
+#define UART3FR                 (UART3_BASE+0x18)
+#define UART3IIR                (UART3_BASE+0x1C) /* Read */
+#define UART3ICR                (UART3_BASE+0x1C) /* Write */
+#define UART3ILPR               (UART3_BASE+0x20)
+#define UART3DMACR              (UART3_BASE+0x28)
+#define UART3TCR                (UART3_BASE+0x80)
+#define UART3TISR               (UART3_BASE+0x88)
+#define UART3TOCR               (UART3_BASE+0x8C)
+#define UART3TMR                (UART3_BASE+0x84)
+#define UART3MCR                (UART3_BASE+0x100) /* Modem Control Reg */
+#define UART3MSR                (UART3_BASE+0x104) /* Modem Status Reg */
+
+#define UART3HDLCCR             (UART3_BASE+0x20C) /* HDLC Registers */
+#define UART3HDLCAMV            (UART3_BASE+0x210) /* HDLC Registers */
+#define UART3HDLCAMSK           (UART3_BASE+0x214) /* HDLC Registers */
+#define UART3HDLCCRIB           (UART3_BASE+0x218) /* HDLC Registers */
+#define UART3HDLCSR             (UART3_BASE+0x21C) /* HDLC Registers */
+           
+
+/* 808f_0000 - 808f_ffff: KEY Matrix */
+#define KEY_OFFSET              0x0F0000
+#define KEY_BASE                (EP93XX_APB_BASE|KEY_OFFSET)
+#define SCANINIT                (KEY_BASE+0x00)
+#define KEY_DIAG                (KEY_BASE+0x04)
+#define KEY_REG                 (KEY_BASE+0x08)
+#define KEY_TCR                 (KEY_BASE+0x10)
+#define KEY_TISR                (KEY_BASE+0x14)
+#define KEY_TOCR                (KEY_BASE+0x18)
+
+/* 8090_0000 - 8090_ffff: Analog Resistive Touchscreen  */
+#define TOUCH_OFFSET            0x100000
+#define TOUCH_BASE              (EP93XX_APB_BASE|TOUCH_OFFSET)
+#define TSSetup                 (TOUCH_BASE+0x00) /* R/W touchscreen controller setup control register.     */
+#define TSXYMaxMin              (TOUCH_BASE+0x04) /* R/W touchscreen controller max/min register.           */
+#define TSXYResult              (TOUCH_BASE+0x08) /* R   touchscreen controller result register.            */
+#define TSDischarge             (TOUCH_BASE+0x0C) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSXSample               (TOUCH_BASE+0x10) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSYSample               (TOUCH_BASE+0x14) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSDirect                (TOUCH_BASE+0x18) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSDetect                (TOUCH_BASE+0x1C) /* LOCKED R/W touchscreen Switch Matrix control register. */
+#define TSSWLock                (TOUCH_BASE+0x20) /*  NA    R/W touchscreen software lock register.         */
+#define TSSetup2                (TOUCH_BASE+0x24) /* R/W touchscreen setup control register #2.             */
+
+
+/* 8091_0000 - 8091_ffff: PWM */
+#define PWM_OFFSET              0x110000
+#define PWM_BASE                (EP93XX_APB_BASE|PWM_OFFSET)
+#define PWM0_TC                 (PWM_BASE+0x00) /* 80910000 R/W PWM_0 Terminal Count */
+#define PWM0_DC                 (PWM_BASE+0x04) /* 80910004 R/W PWM_0 Duty Cycle     */
+#define PWM0_EN                 (PWM_BASE+0x08) /* 80910008 R/W PWM_0 Enable         */
+#define PWM0_INV                (PWM_BASE+0x0C) /* 8091000C R/W PWM_0 Invert         */
+#define PWM0_SYNC               (PWM_BASE+0x10) /* 80910010 R/W PWM_0 Synchronous    */
+#define PWM1_TC                 (PWM_BASE+0x20) /* 80910020 R/W PWM_1 Terminal Count */
+#define PWM1_DC                 (PWM_BASE+0x24) /* 80910024 R/W PWM_1 Duty Cycle     */
+#define PWM1_EN                 (PWM_BASE+0x28) /* 80910028 R/W PWM_1 Enable         */
+#define PWM1_INV                (PWM_BASE+0x2C) /* 8091002C R/W PWM_1 Invert         */
+#define PWM1_SYNC               (PWM_BASE+0x30) /* 80910030 R/W PWM_1 Synchronous    */
+
+
+/* 8092_0000 - 8092_ffff: RTC */
+#define RTC_OFFSET              0x120000
+#define RTC_BASE                (EP93XX_APB_BASE|RTC_OFFSET)
+#define RTCDR                   (RTC_BASE+0x00)
+#define RTCMR                   (RTC_BASE+0x04)
+#define RTCSTAT                 (RTC_BASE+0x08) /* Read */
+#define RTCEOI                  (RTC_BASE+0x08) /* Write */
+#define RTCLR                   (RTC_BASE+0x0C)
+#define RTCCR                   (RTC_BASE+0x10)
+#define RTCSCOMP                (RTC_BASE+0x108)
+
+
+/* 8093_0000 - 8093_ffff: CSC/Syscon  PLL, clock control, & misc. stuff */
+#define SYSCON_OFFSET           0x130000
+#define SYSCON_BASE             (EP93XX_APB_BASE|SYSCON_OFFSET)
+#define SYSCON_PWRSR            (SYSCON_BASE+0x0000)
+#define SYSCON_PWRCNT           (SYSCON_BASE+0x0004)
+#define SYSCON_HALT             (SYSCON_BASE+0x0008)
+#define SYSCON_STBY             (SYSCON_BASE+0x000c)
+#define SYSCON_BLEOI            (SYSCON_BASE+0x0010)
+#define SYSCON_MCEOI            (SYSCON_BASE+0x0014)
+#define SYSCON_TEOI             (SYSCON_BASE+0x0018)
+#define SYSCON_STFCLR           (SYSCON_BASE+0x001c)
+#define SYSCON_CLKSET1          (SYSCON_BASE+0x0020)
+#define SYSCON_CLKSET2          (SYSCON_BASE+0x0024)
+#define SYSCON_RESV00           (SYSCON_BASE+0x0028)
+#define SYSCON_RESV01           (SYSCON_BASE+0x002c)
+#define SYSCON_RESV02           (SYSCON_BASE+0x0030)
+#define SYSCON_RESV03           (SYSCON_BASE+0x0034)
+#define SYSCON_RESV04           (SYSCON_BASE+0x0038)
+#define SYSCON_RESV05           (SYSCON_BASE+0x003c)
+#define SYSCON_SCRREG0          (SYSCON_BASE+0x0040)
+#define SYSCON_SCRREG1          (SYSCON_BASE+0x0044)
+#define SYSCON_CLKTEST          (SYSCON_BASE+0x0048)
+#define SYSCON_USBRESET         (SYSCON_BASE+0x004c)
+#define SYSCON_APBWAIT          (SYSCON_BASE+0x0050)
+#define SYSCON_BMAR             (SYSCON_BASE+0x0054)
+#define SYSCON_BOOTCLR          (SYSCON_BASE+0x0058)
+#define SYSCON_DEVCFG           (SYSCON_BASE+0x0080)
+#define SYSCON_VIDDIV           (SYSCON_BASE+0x0084)
+#define SYSCON_MIRDIV           (SYSCON_BASE+0x0088)
+#define SYSCON_I2SDIV           (SYSCON_BASE+0x008C)
+#define SYSCON_KTDIV            (SYSCON_BASE+0x0090)
+#define SYSCON_CHIPID           (SYSCON_BASE+0x0094)
+#define SYSCON_TSTCR            (SYSCON_BASE+0x0098)
+#define SYSCON_SYSCFG           (SYSCON_BASE+0x009C)
+#define SYSCON_SWLOCK           (SYSCON_BASE+0x00C0)
+
+#define SYSCON_DEVCFG_KEYS      0x00000002
+#define SYSCON_DEVCFG_RasOnP3   0x00000010
+#define SYSCON_DEVCFG_GONK      0x08000000
+
+#define SYSCON_KTDIV_KEN        0x00008000
+
+
+/* 8094_0000 - 8094_ffff: Watchdog */
+#define WATCHDOG_OFFSET         0x140000
+#define WATCHDOG_BASE           (EP93XX_APB_BASE|WATCHDOG_OFFSET)
+#define WATCHDOG                (WATCHDOG_BASE+0x00)
+#define WDSTATUS                (WATCHDOG_BASE+0x04)
+#define WD_TCR                  (WATCHDOG_BASE+0x08)
+#define WD_TISR                 (WATCHDOG_BASE+0x0C)
+#define WDTOCR                  (WATCHDOG_BASE+0x10)
+
+
+/* 8095_0000 - 87ff_ffff: Reserved APB space */
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_ac97.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_ac97.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_ac97.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_ac97.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,180 @@
+/*=============================================================================
+ *  FILE:           regs_ac97.h
+ *
+ *  DESCRIPTION:    Ac'97 Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *=============================================================================
+ */
+#ifndef _REGS_AC97_H_
+#define _REGS_AC97_H_
+
+//-----------------------------------------------------------------------------
+// Bit definitionses
+//-----------------------------------------------------------------------------
+#define AC97ISR_RIS                     8
+#define AC97ISR_TIS                     4
+#define AC97ISR_RTIS                    2
+#define AC97ISR_TCIS                    1
+
+#define AC97RGIS_SLOT1TXCOMPLETE     0x01
+#define AC97RGIS_SLOT2RXVALID        0x02
+#define AC97RGIS_GPIOTXCOMPLETE      0x04
+#define AC97RGIS_GPIOINTRX           0x08
+#define AC97RGIS_RWIS                0x10
+#define AC97RGIS_CODECREADY          0x20
+#define AC97RGIS_SLOT2TXCOMPLETE     0x40
+
+#define AC97SR_RXFE                 0x0001
+#define AC97SR_TXFE                 0x0002      
+#define AC97SR_RXFF                 0x0004
+#define AC97SR_TXFF                 0x0008
+#define AC97SR_TXBUSY               0x0010
+#define AC97SR_RXOE                 0x0020
+#define AC97SR_TXUE                 0x0040
+
+#define AC97GSR_IFE                     0x1
+#define AC97GSR_LOOP                    0x2
+#define AC97GSR_OVERRIDECODECREADY      0x4
+
+#define AC97RESET_TIMEDRESET            0x1
+#define AC97RESET_FORCEDRESET           0x2
+#define AC97RESET_EFORCER               0x4
+
+#define AC97RXCR_REN                    0x1
+
+#define AC97TXCR_TEN                    0x1
+
+
+//****************************************************************************
+//
+// The Ac97 Codec registers, accessable through the Ac-link.
+// These are not controller registers and are not memory mapped.
+// Includes registers specific to CS4202 (Beavis).
+//
+//****************************************************************************
+#define AC97_REG_OFFSET_MASK                0x0000007E
+
+#define AC97_00_RESET                          0x00000000
+#define AC97_02_MASTER_VOL                     0x00000002
+#define AC97_04_HEADPHONE_VOL                  0x00000004
+#define AC97_06_MONO_VOL                       0x00000006
+#define AC97_08_TONE                           0x00000008
+#define AC97_0A_PC_BEEP_VOL                    0x0000000A
+#define AC97_0C_PHONE_VOL                      0x0000000C
+#define AC97_0E_MIC_VOL                        0x0000000E
+#define AC97_10_LINE_IN_VOL                    0x00000010
+#define AC97_12_CD_VOL                         0x00000012
+#define AC97_14_VIDEO_VOL                      0x00000014
+#define AC97_16_AUX_VOL                        0x00000016
+#define AC97_18_PCM_OUT_VOL                    0x00000018
+#define AC97_1A_RECORD_SELECT                  0x0000001A
+#define AC97_1C_RECORD_GAIN                    0x0000001C
+#define AC97_1E_RESERVED_1E                    0x0000001E
+#define AC97_20_GENERAL_PURPOSE                0x00000020
+#define AC97_22_3D_CONTROL                     0x00000022
+#define AC97_24_MODEM_RATE                     0x00000024
+#define AC97_26_POWERDOWN                      0x00000026
+#define AC97_28_EXT_AUDIO_ID                   0x00000028
+#define AC97_2A_EXT_AUDIO_POWER                0x0000002A
+#define AC97_2C_PCM_FRONT_DAC_RATE             0x0000002C
+#define AC97_2E_PCM_SURR_DAC_RATE              0x0000002E
+#define AC97_30_PCM_LFE_DAC_RATE               0x00000030
+#define AC97_32_PCM_LR_ADC_RATE                0x00000032
+#define AC97_34_MIC_ADC_RATE                   0x00000034
+#define AC97_36_6CH_VOL_C_LFE                  0x00000036
+#define AC97_38_6CH_VOL_SURROUND               0x00000038
+#define AC97_3A_SPDIF_CONTROL                  0x0000003A
+#define AC97_3C_EXT_MODEM_ID                   0x0000003C
+#define AC97_3E_EXT_MODEM_POWER                0x0000003E
+#define AC97_40_LINE1_CODEC_RATE               0x00000040
+#define AC97_42_LINE2_CODEC_RATE               0x00000042
+#define AC97_44_HANDSET_CODEC_RATE             0x00000044
+#define AC97_46_LINE1_CODEC_LEVEL              0x00000046
+#define AC97_48_LINE2_CODEC_LEVEL              0x00000048
+#define AC97_4A_HANDSET_CODEC_LEVEL            0x0000004A
+#define AC97_4C_GPIO_PIN_CONFIG                0x0000004C
+#define AC97_4E_GPIO_PIN_TYPE                  0x0000004E
+#define AC97_50_GPIO_PIN_STICKY                0x00000050
+#define AC97_52_GPIO_PIN_WAKEUP                0x00000052
+#define AC97_54_GPIO_PIN_STATUS                0x00000054
+#define AC97_56_RESERVED                       0x00000056
+#define AC97_58_RESERVED                       0x00000058
+#define AC97_5A_CRYSTAL_REV_N_FAB_ID           0x0000005A
+#define AC97_5C_TEST_AND_MISC_CTRL             0x0000005C
+#define AC97_5E_AC_MODE                        0x0000005E
+#define AC97_60_MISC_CRYSTAL_CONTROL           0x00000060
+#define AC97_62_VENDOR_RESERVED                0x00000062
+#define AC97_64_DAC_SRC_PHASE_INCR             0x00000064
+#define AC97_66_ADC_SRC_PHASE_INCR             0x00000066
+#define AC97_68_RESERVED_68                    0x00000068
+#define AC97_6A_SERIAL_PORT_CONTROL            0x0000006A
+#define AC97_6C_VENDOR_RESERVED                0x0000006C
+#define AC97_6E_VENDOR_RESERVED                0x0000006E
+#define AC97_70_BDI_CONFIG                     0x00000070
+#define AC97_72_BDI_WAKEUP                     0x00000072
+#define AC97_74_VENDOR_RESERVED                0x00000074
+#define AC97_76_CAL_ADDRESS                    0x00000076
+#define AC97_78_CAL_DATA                       0x00000078
+#define AC97_7A_VENDOR_RESERVED                0x0000007A
+#define AC97_7C_VENDOR_ID1                     0x0000007C
+#define AC97_7E_VENDOR_ID2                     0x0000007E
+
+
+#ifndef __ASSEMBLY__
+
+//
+// enum type for use with reg AC97_RECORD_SELECT
+//
+typedef enum{
+    RECORD_MIC          = 0x0000,
+    RECORD_CD           = 0x0101,
+    RECORD_VIDEO_IN     = 0x0202,
+    RECORD_AUX_IN       = 0x0303,
+    RECORD_LINE_IN      = 0x0404,
+    RECORD_STEREO_MIX   = 0x0505,
+    RECORD_MONO_MIX     = 0x0606,
+    RECORD_PHONE_IN     = 0x0707
+} Ac97RecordSources;
+
+#endif /* __ASSEMBLY__ */
+
+//
+// Sample rates supported directly in AC97_PCM_FRONT_DAC_RATE and 
+// AC97_PCM_LR_ADC_RATE.
+//
+#define Ac97_Fs_8000        0x1f40
+#define Ac97_Fs_11025       0x2b11
+#define Ac97_Fs_16000       0x3e80
+#define Ac97_Fs_22050       0x5622
+#define Ac97_Fs_32000       0x7d00
+#define Ac97_Fs_44100       0xac44
+#define Ac97_Fs_48000       0xbb80
+
+//
+// RSIZE and TSIZE in AC97RXCR and AC97TXCR
+//
+#define Ac97_SIZE_20            2
+#define Ac97_SIZE_18            1
+#define Ac97_SIZE_16            0
+#define Ac97_SIZE_12            3
+
+//=============================================================================
+//=============================================================================
+
+
+#endif /* _REGS_AC97_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_dma.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_dma.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_dma.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,276 @@
+/*****************************************************************************
+ *  
+ * linux/include/asm-arm/arch-ep93xx/regs_dma.h
+ *
+ *  Register definitions for the ep93xx dma channel registers.
+ *
+ *  Copyright (C) 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+#ifndef _REGS_DMA_H_
+#define _REGS_DMA_H_
+
+/*****************************************************************************
+ * 0x8000.0000 -> 0x8000.003C M2P Channel 0 Registers (Tx) 
+ * 0x8000.0040 -> 0x8000.007C M2P Channel 1 Registers (Rx) 
+ * 0x8000.0080 -> 0x8000.00BC M2P Channel 2 Registers (Tx)  
+ * 0x8000.00C0 -> 0x8000.00FC M2P Channel 3 Registers (Rx) 
+ * 0x8000.0100 -> 0x8000.013C M2M Channel 0 Registers      
+ * 0x8000.0140 -> 0x8000.017C M2M Channel 1 Registers      
+ * 0x8000.0180 -> 0x8000.01BC Not Used                     
+ * 0x8000.01C0 -> 0x8000.01FC Not Used                     
+ * 0x8000.0200 -> 0x8000.023C M2P Channel 5 Registers (Rx) 
+ * 0x8000.0240 -> 0x8000.027C M2P Channel 4 Registers (Tx) 
+ * 0x8000.0280 -> 0x8000.02BC M2P Channel 7 Registers (Rx) 
+ * 0x8000.02C0 -> 0x8000.02FC M2P Channel 6 Registers (Tx) 
+ * 0x8000.0300 -> 0x8000.033C M2P Channel 9 Registers (Rx) 
+ * 0x8000.0340 -> 0x8000.037C M2P Channel 8 Registers (Tx) 
+ * 0x8000.0380 DMA Channel Arbitration register            
+ * 0x8000.03C0 DMA Global Interrupt register               
+ * 0x8000.03C4 -> 0x8000.03FC Not Used                     
+ *
+ *
+ * Internal M2P/P2M Channel Register Map                   
+ *
+ * Offset Name      Access  Bits Reset Value               
+ * 0x00   CONTROL   R/W     6    0                         
+ * 0x04   INTERRUPT R/W TC* 3    0                         
+ * 0x08   PPALLOC   R/W     4    channel dependant         
+ *                               (see reg description)     
+ * 0x0C   STATUS    RO      8    0                         
+ * 0x10   reserved                                         
+ * 0x14   REMAIN    RO      16   0                         
+ * 0X18   Reserved                                         
+ * 0X1C   Reserved                                         
+ * 0x20   MAXCNT0   R/W     16   0                         
+ * 0x24   BASE0     R/W     32   0                         
+ * 0x28   CURRENT0  RO      32   0                         
+ * 0x2C   Reserved                                         
+ * 0x30   MAXCNT1   R/W     16   0                         
+ * 0x34   BASE1     R/W     32   0                         
+ * 0X38   CURRENT1  RO      32   0                         
+ * 0X3C   Reserved                                         
+ *                                                         
+ * M2M Channel Register Map                                
+ * Offset Name         Access   Bits Reset Value           
+ *                                                         
+ * 0x00   CONTROL      R/W      22   0                     
+ * 0x04   INTERRUPT    R/W TC*  3    0                     
+ * 0x08   Reserved                                         
+ * 0x0C   STATUS       R/W TC*  14   0                     
+ * 0x10   BCR0         R/W      16   0                     
+ * 0x14   BCR1         R/W      16   0                     
+ * 0x18   SAR_BASE0    R/W      32   0                     
+ * 0x1C   SAR_BASE1    R/W      32   0                     
+ * 0x20   Reserved                                         
+ * 0x24   SAR_CURRENT0 RO       32   0                     
+ * 0x28   SAR_CURRENT1 RO       32   0                     
+ * 0x2C   DAR_BASE0    R/W      32   0                     
+ * 0x30   DAR_BASE1    R/W      32   0                     
+ * 0x34   DAR_CURRENT0 RO       32   0                     
+ * 0X38   Reserved                                         
+ * 0X3C   DAR_CURRENT1 RO       32   0                          
+ * * Write this location once to clear the bit (see        
+ * Interrupt/Status register description for which bits    
+ * this rule applies to).
+ *                                  
+ ****************************************************************************/
+
+#ifndef __ASSEMBLY__ 
+/*
+ * DMA Register Base addresses
+ */
+static unsigned int const DMAM2PChannelBase[10] =
+{
+    DMA_M2P_TX_0_BASE,
+    DMA_M2P_RX_1_BASE,
+    DMA_M2P_TX_2_BASE,
+    DMA_M2P_RX_3_BASE,
+    DMA_M2P_TX_4_BASE,
+    DMA_M2P_RX_5_BASE,
+    DMA_M2P_TX_6_BASE,
+    DMA_M2P_RX_7_BASE,
+    DMA_M2P_TX_8_BASE,
+    DMA_M2P_RX_9_BASE
+};
+
+static unsigned int const DMAM2MChannelBase[2] = 
+{
+    DMA_M2M_0_BASE,
+    DMA_M2M_1_BASE
+};
+
+#endif /* __ASSEMBLY__ */
+
+/*----------------------------------------------------------------------------------*/
+/* M2P Registers                                                                    */
+/*----------------------------------------------------------------------------------*/
+/*
+ * M2P CONTROL register bit defines 
+ */
+#define CONTROL_M2P_STALLINTEN      0x00000001	    /* Enables the STALL interrupt  */
+#define CONTROL_M2P_NFBINTEN        0x00000002	    /* Enables the NFB interrupt    */
+#define CONTROL_M2P_CHERRORINTEN    0x00000008      /* Enables the ChError interrupt*/
+#define CONTROL_M2P_ENABLE		    0x00000010      /* Enables the channel          */
+#define CONTROL_M2P_ABRT		    0x00000020      /* Determines how DMA behaves in*/ 
+			                                        /* NEXT state with peripheral   */
+                                                    /* error                        */
+			                                        /* 0: NEXT -> ON, ignore error  */
+			                                        /* 1: NEXT -> STALL, disable ch.*/ 
+#define CONTROL_M2P_ICE			    0x00000040      /* Ignore Channel Error         */
+
+/*
+ * M2P INTERRUPT register bit defines
+ */
+#define INTERRUPT_M2P_STALLINT      0x00000001	    /* Indicates channel stalled.   */
+#define INTERRUPT_M2P_NFBINT        0x00000002		/* Indicates channel is hungry. */
+#define INTERRUPT_M2P_CHERRORINT    0x00000008	    /* Peripheral detects error     */
+
+
+/*
+ * STATUS register bit defines
+ */
+#define STATUS_M2P_STALL            0x00000001		/* A '1' indicates channel is       */
+                                                    /* stalled                          */
+#define STATUS_M2P_NFB			    0x00000002      /* A '1' indicates channel has moved*/
+			                                        /* from NEXT state to ON state, but */
+			                                        /* waiting for next buffer to be    */
+                                                    /* programmed.                      */
+#define STATUS_M2P_CHERROR		    0x00000008      /* Enables the ChError interrupt    */
+#define STATUS_M2P_CURRENT_MASK     0x00000030      /* Current state of the FSM         */
+#define STATUS_M2P_CURRENT_SHIFT    4
+#define STATUS_M2P_NEXTBUFFER	    0x00000040      /* Informs the int handler after an */
+			                                        /* NFB int which pair of maxcnt and */
+                                                    /* base regs to update.             */
+#define STATUS_M2P_BYTES_MASK       0x0000f800 		/* number of valid DMA data         */
+#define STATUS_M2P_BYTES_SHIFT      7               /* currently in                     */
+								        		    /* packer/unpacker                  */
+
+#define STATUS_M2P_DMA_NO_BUF		0x00000000
+#define STATUS_M2P_DMA_BUF_ON		0x00000010
+#define STATUS_M2P_DMA_BUF_NEXT		0x00000020
+
+/*
+ * Register masks to mask off reserved bits after reading register.
+ */
+#define M2P_MASK_PPALLOC            0x0000000f
+#define M2P_MASK_REMAIN             0x0000ffff
+#define M2P_MASK_MAXCNT0            0x0000ffff
+#define M2P_MASK_BASE0              0xffffffff
+#define M2P_MASK_CURRENT0           0xffffffff
+#define M2P_MASK_MAXCNT1            0x0000ffff
+#define M2P_MASK_BASE1              0xffffffff
+#define M2P_MASK_CURRENT1           0xffffffff
+
+
+/*----------------------------------------------------------------------------------*/
+/* M2M Registers                                                                    */
+/*----------------------------------------------------------------------------------*/
+
+#define CONTROL_M2M_STALLINTEN	0x00000001  /* Enables the STALL interrupt                     */
+#define CONTROL_M2M_SCT			0x00000002  /* Source Copy Transfer. Setup a                   */
+										    /* block transfer from 1 memory source             */
+										    /* location.                                       */
+#define CONTROL_M2M_DONEINTEN	0x00000004  /* Enables the DONE interrupt which                */
+										    /* indicates if the xfer completed                 */
+										    /* successfully                                    */
+#define CONTROL_M2M_ENABLE		0x00000008  /* Enables the channel                             */
+#define CONTROL_M2M_START		0x00000010  /* Initiates the xfer. 'software trigger'          */
+#define CONTROL_M2M_BWC_MASK	0x000001e0  /* Bandwidth control. Indicate number of           */
+#define CONTROL_M2M_BWC_SHIFT   5			/* bytes in a transfer.                            */
+#define CONTROL_M2M_PW_MASK		0x00000600  /* Peripheral width. Used for xfers                */
+#define CONTROL_M2M_PW_SHIFT    9			/* between memory and external peripheral.         */
+										    /* 00: byte, 01: halfword, 10: word.               */
+#define CONTROL_M2M_DAH			0x00000800  /* Destination Address Hold                        */
+#define CONTROL_M2M_SAH			0x00001000  /* Source Address Hold                             */
+#define CONTROL_M2M_TM_MASK     0x00006000  /* Transfer Mode. 00: sw triggered,                */
+#define CONTROL_M2M_TM_SHIFT    13			/* 01: hw initiated M2P, 01: hw initiated P2M      */
+#define CONTROL_M2M_ETDP_MASK	0x00018000  /* End-of-Transfer/Terminal Count pin              */
+#define CONTROL_M2M_ETDP_SHIFT  15		    /* direction and polarity.                         */
+#define CONTROL_M2M_DACKP		0x00020000  /* DMA acknowledge pin polarity                    */
+
+#define CONTROL_M2M_DREQP_MASK  0x00180000	/* DMA request pin polarity. must be set           */
+#define CONTROL_M2M_DREQP_SHIFT 19			/* before enable bit.                              */
+#define CONTROL_M2M_NFBINTEN	0x00200000  /* Enables generation of the NFB interrupt.        */
+#define CONTROL_M2M_RSS_MASK    0x00c00000	/* Request source selection:                       */
+#define CONTROL_M2M_RSS_SHIFT	22			/*		000 - External DReq[0]                     */
+										    /*		001 - External DReq[1]                     */
+										    /*		01X - Internal SSPRx                       */
+										    /*		10X - Internal SSPTx                       */
+										    /*		11X - Internal IDE                         */
+#define CONTROL_M2M_NO_HDSK		0x01000000  /* No handshake.  When set the peripheral doesn't  */
+										    /* require the regular handshake protocal. Must    */
+									    	/* be set for SSP and IDE operations, optional     */
+										    /* for external peripherals.                       */
+#define CONTROL_M2M_PWSC_MASK   0xfe000000	/* Peripheral wait states count. Gives the latency */
+#define CONTROL_M2M_PWSC_SHIFT	25			/* (in PCLK cycles) needed by the peripheral to    */
+								    		/* deassert its' request once the M2M xfer w/ DMA  */
+									    	/* is complete.                                    */
+
+/*
+ * M2M INTERRUPT register bit defines
+ */
+#define INTERRUPT_M2M_STALLINT	0x00000001	/* Stall interrupt indicates channel stalled. */
+#define INTERRUPT_M2M_DONEINT	0x00000002	/* Transaction done.                          */
+#define INTERRUPT_M2M_NFBINT	0x00000004	/* Next frame buffer interrupt indicates      */
+											/* channel requires a new buffer              */
+
+
+
+/*
+ * M2M STATUS register bit defines
+ */
+#define STATUS_M2M_STALL		0x00000001  /* A '1' indicates channel is stalled           */
+#define STATUS_M2M_CURRENTSTATE_MASK  0x0000003e  /* Indicates state of M2M Channel control       */
+#define STATUS_M2M_CURRENTSTATE_SHIFT 1		/* FSM (0-2):                                   */
+										    /*	000 - IDLE, 001 - STALL, 010 - MEM_RD,      */
+										    /*  011 - MEM_WR, 100 - BWC_WAIT                */
+										    /* and M2M buffer FSM (3-2):                    */
+										    /* 	00 - NO_BUF, 01 - BUF_ON, 10 - BUF_NEXT     */
+#define STATUS_M2M_DONE		    0x00000040  /* Transfer completed successfully if 1.        */
+#define STATUS_M2M_TCS_MASK		0x00000180  /* Terminal Count status. Indicates whether or  */
+#define STATUS_M2M_TCS_SHIFT    7			/* or not the actual byte count reached         */
+								    		/* programmed limit for buffer descriptor       */
+#define STATUS_M2M_EOTS_MASK    0x00000600  /* End-of-Transfer status for buffer            */
+#define STATUS_M2M_EOTS_SHIFT   9
+#define STATUS_M2M_NFB			0x00000800  /* A '1' indicates channel has moved            */
+										    /* from NEXT state to ON state, but	the next    */
+										    /* byte count reg for next buffer has not been  */
+										    /* programmed yet.                              */
+#define STATUS_M2M_NB			0x00001000  /* NextBuffer status. Informs NFB service       */
+										    /* routine, after NFB int, which pair of buffer */
+										    /* descriptor registers is free to update.      */
+#define STATUS_M2M_DREQS		0x00002000  /* DREQ status.  Reflects the status of the     */
+										    /* synchronized external peripherals DMA        */
+										    /* request signal.                              */
+
+/*
+ * Register masks to mask off reserved bits after reading register.
+ */
+#define M2M_MASK_BCR0             0x0000ffff
+#define M2M_MASK_BCR1             0x0000ffff
+#define M2M_MASK_SAR_BASE0        0xffffffff
+#define M2M_MASK_SAR_BASE1        0xffffffff
+#define M2M_MASK_SAR_CURRENT0     0xffffffff
+#define M2M_MASK_SAR_CURRENT1     0xffffffff
+#define M2M_MASK_DAR_BASE0        0xffffffff
+#define M2M_MASK_DAR_BASE1        0xffffffff
+#define M2M_MASK_DAR_CURRENT0     0xffffffff
+#define M2M_MASK_DAR_CURRENT1     0xffffffff
+
+
+#endif /* _REGS_DMA_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_gpio.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_gpio.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_gpio.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_gpio.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,31 @@
+/*=======================================================================
+ *
+ *  FILE:       regs_gpio.h
+ *
+ *  DESCRIPTION:    GPIO Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *=======================================================================
+ */
+#ifndef _REGS_GPIO_H_
+#define _REGS_GPIO_H_
+
+/*
+ * This file intentionally blank.
+ */
+ 
+#endif /* _REGS_GPIO_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_i2s.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_i2s.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_i2s.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_i2s.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,97 @@
+/*=============================================================================
+ *
+ *  FILE:       	reg_i2s.h
+ *
+ *  DESCRIPTION:    ep93xx I2S Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *=============================================================================
+ */
+#ifndef _REG_I2S_H_
+#define _REG_I2S_H_
+
+//
+// I2STXClkCfg bits
+//
+#define i2s_txcc_trls           0x00000001
+#define i2s_txcc_tckp           0x00000002
+#define i2s_txcc_trel           0x00000004
+#define i2s_txcc_mstr           0x00000008
+#define i2s_txcc_nbcg           0x00000010
+
+#define i2s_txcc_bcr_32x        0x00000020
+#define i2s_txcc_bcr_64x        0x00000040
+#define i2s_txcc_bcr_128x       0x00000060
+
+//
+// I2SRxClkCfg bits
+//
+#define i2s_rxcc_rrls           0x00000001
+#define i2s_rxcc_rckp           0x00000002
+#define i2s_rxcc_rrel           0x00000004
+#define i2s_rxcc_mstr           0x00000008
+#define i2s_rxcc_nbcg           0x00000010
+
+#define i2s_rxcc_bcr_32x        0x00000020
+#define i2s_rxcc_bcr_64x        0x00000040
+#define i2s_rxcc_bcr_128x       0x00000060
+
+//
+// I2SGlSts bits
+//
+#define TX0_UNDERFLOW           0x00000001
+#define TX1_UNDERFLOW           0x00000002
+#define TX2_UNDERFLOW           0x00000004
+
+#define RX0_OVERFLOW            0x00000008
+#define RX1_OVERFLOW            0x00000010
+#define RX2_OVERFLOW            0x00000020
+
+#define TX0_OVERFLOW            0x00000040
+#define TX1_OVERFLOW            0x00000080
+#define TX2_OVERFLOW            0x00000100
+
+#define RX0_UNDERFLOW           0x00000200
+#define RX1_UNDERFLOW           0x00000400
+#define RX2_UNDERFLOW           0x00000800
+
+#define TX0_FIFO_FULL           0x00001000
+#define TX0_FIFO_EMPTY          0x00002000
+#define TX0_FIFO_HALF_EMPTY     0x00004000
+
+#define RX0_FIFO_FULL           0x00008000
+#define RX0_FIFO_EMPTY          0x00010000
+#define RX0_FIFO_HALF_FULL      0x00020000
+
+#define TX1_FIFO_FULL           0x00040000
+#define TX1_FIFO_EMPTY          0x00080000
+#define TX1_FIFO_HALF_EMPTY     0x00100000
+
+#define RX1_FIFO_FULL           0x00200000
+#define RX1_FIFO_EMPTY          0x00400000
+#define RX1_FIFO_HALF_FULL      0x00800000
+
+#define TX2_FIFO_FULL           0x01000000
+#define TX2_FIFO_EMPTY          0x02000000
+#define TX2_FIFO_HALF_EMPTY     0x04000000
+
+#define RX2_FIFO_FULL           0x08000000
+#define RX2_FIFO_EMPTY          0x10000000
+#define RX2_FIFO_HALF_FULL      0x20000000
+
+#endif // _REG_I2S_H_
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_ide.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_ide.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_ide.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_ide.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,105 @@
+/*****************************************************************************
+ *
+ *  linux/include/asm-arm/arch-ep93xx/regs_ide.h
+ *
+ *  Register definitions for the ep93xx ide registers.
+ *
+ *  Copyright (C) 2003 Cirrus Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ 
+ *
+ ****************************************************************************/
+#ifndef _REGS_IDE_H_
+#define _REGS_IDE_H_
+
+/*****************************************************************************
+ *
+ *  Bit definitions for use with assembly code for the ide control register.
+ *
+ ****************************************************************************/
+#define IDECtrl_CS0n			0x00000001
+#define IDECtrl_CS1n			0x00000002
+#define IDECtrl_DA_MASK			0x0000001c
+#define IDECtrl_DA_SHIFT		2
+#define IDECtrl_DIORn			0x00000020
+#define IDECtrl_DIOWn			0x00000040
+#define IDECtrl_DASPn			0x00000080
+#define IDECtrl_DMARQ			0x00000100
+#define IDECtrl_INTRQ			0x00000200
+#define IDECtrl_IORDY			0x00000400
+
+#define IDECfg_IDEEN			0x00000001
+#define IDECfg_PIO			0x00000002
+#define IDECfg_MDMA			0x00000004
+#define IDECfg_UDMA			0x00000008
+#define IDECfg_MODE_MASK		0x000000f0
+#define IDECfg_MODE_SHIFT		4
+#define IDECfg_WST_MASK			0x00000300
+#define IDECfg_WST_SHIFT		8
+
+#define IDEMDMAOp_MEN			0x00000001
+#define IDEMDMAOp_RWOP			0x00000002
+
+#define IDEUDMAOp_UEN			0x00000001
+#define IDEUDMAOp_RWOP			0x00000002
+
+#define IDEUDMASts_CS0n			0x00000001
+#define IDEUDMASts_CS1n			0x00000002
+#define IDEUDMASts_DA_MASK		0x0000001c
+#define IDEUDMASts_DA_SHIFT		2
+#define IDEUDMASts_HSHD			0x00000020
+#define IDEUDMASts_STOP			0x00000040
+#define IDEUDMASts_DM			0x00000080
+#define IDEUDMASts_DDOE			0x00000100
+#define IDEUDMASts_DMARQ		0x00000200
+#define IDEUDMASts_DSDD			0x00000400
+#define IDEUDMASts_DMAide		0x00010000
+#define IDEUDMASts_INTide		0x00020000
+#define IDEUDMASts_SBUSY		0x00040000
+#define IDEUDMASts_NDO			0x01000000
+#define IDEUDMASts_NDI			0x02000000
+#define IDEUDMASts_N4X			0x04000000
+
+#define IDEUDMADebug_RWOE		0x00000001
+#define IDEUDMADebug_RWPTR		0x00000002
+#define IDEUDMADebug_RWDR		0x00000004
+#define IDEUDMADebug_RROE		0x00000008
+#define IDEUDMADebug_RRPTR		0x00000010
+#define IDEUDMADebug_RRDR		0x00000020
+
+#define IDEUDMAWrBufSts_HPTR_MASK	0x0000000f
+#define IDEUDMAWrBufSts_HPTR_SHIFT	0
+#define IDEUDMAWrBufSts_TPTR_MASK	0x000000f0
+#define IDEUDMAWrBufSts_TPTR_SHIFT	4
+#define IDEUDMAWrBufSts_EMPTY		0x00000100
+#define IDEUDMAWrBufSts_HOM		0x00000200
+#define IDEUDMAWrBufSts_NFULL		0x00000400
+#define IDEUDMAWrBufSts_FULL		0x00000800
+#define IDEUDMAWrBufSts_CRC_MASK	0xffff0000
+#define IDEUDMAWrBufSts_CRC_SHIFT	16
+
+#define IDEUDMARdBufSts_HPTR_MASK	0x0000000f
+#define IDEUDMARdBufSts_HPTR_SHIFT	0
+#define IDEUDMARdBufSts_TPTR_MASK	0x000000f0
+#define IDEUDMARdBufSts_TPTR_SHIFT	4
+#define IDEUDMARdBufSts_EMPTY		0x00000100
+#define IDEUDMARdBufSts_HOM		0x00000200
+#define IDEUDMARdBufSts_NFULL		0x00000400
+#define IDEUDMARdBufSts_FULL		0x00000800
+#define IDEUDMARdBufSts_CRC_MASK	0xffff0000
+#define IDEUDMARdBufSts_CRC_SHIFT	16
+
+#endif /* _REGS_IDE_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_irda.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_irda.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_irda.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_irda.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,24 @@
+/*=======================================================================
+ *
+ *  FILE:       regs_irda.h
+ *
+ *  DESCRIPTION:    IrDA Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ *=======================================================================
+ */
+#ifndef _REGS_IRDA_H_
+#define _REGS_IRDA_H_
+
+/* Bit definitions */
+
+#define IrEnable_EN_NONE	0x00
+#define IrEnable_EN_SIR		0x01
+#define IrEnable_EN_MIR		0x02
+#define IrEnable_EN_FIR		0x03
+#define IrEnable_LBM		0x04
+#define IrEnable_MD			0x08
+#define IrEnable_FD			0x10
+
+#endif /* _REGS_IRDA_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_raster.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_raster.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_raster.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_raster.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,347 @@
+/*=============================================================================
+ *
+ *  FILE:       	regs_raster.h
+ *
+ *  DESCRIPTION:    ep93xx Raster Engine Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *=============================================================================
+ */
+#ifndef _REGS_RASTER_H_
+#define _REGS_RASTER_H_
+
+//-----------------------------------------------------------------------------
+// VLINESTOTAL Register Definitions
+//-----------------------------------------------------------------------------
+#define VLINESTOTAL_MASK            0x000007ff
+
+//-----------------------------------------------------------------------------
+// VSYNCSTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define VSYNCSTRTSTOP_STRT_MASK     0x07ff0000 
+#define VSYNCSTRTSTOP_STRT_SHIFT    0 
+#define VSYNCSTRTSTOP_STOP_MASK     0x000007ff
+#define VSYNCSTRTSTOP_STOP_SHIFT    16 
+
+//-----------------------------------------------------------------------------
+// VACTIVESTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define VACTIVESTRTSTOP_STRT_MASK   0x07ff0000
+#define VACTIVESTRTSTOP_STRT_SHIFT  0 
+#define VACTIVESTRTSTOP_STOP_MASK   0x000007ff
+#define VACTIVESTRTSTOP_STOP_SHIFT  16 
+
+//-----------------------------------------------------------------------------
+// VCLKSTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define VCLKSTRTSTOP_STRT_MASK      0x07ff0000
+#define VCLKSTRTSTOP_STRT_SHIFT     0 
+#define VCLKSTRTSTOP_STOP_MASK      0x000007ff
+#define VCLKSTRTSTOP_STOP_SHIFT     16 
+
+//-----------------------------------------------------------------------------
+// VBLANKSTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define VBLANKSTRTSTOP_STRT_MASK  0x07ff0000
+#define VBLANKSTRTSTOP_STRT_SHIFT 0 
+#define VBLANKSTRTSTOP_STOP_MASK  0x000007ff
+#define VBLANKSTRTSTOP_STOP_SHIFT 16 
+
+//-----------------------------------------------------------------------------
+// HSYNCSTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define HSYNCSTRTSTOP_STRT_MASK      0x07ff0000
+#define HSYNCSTRTSTOP_STRT_SHIFT     0 
+#define HSYNCSTRTSTOP_STOP_MASK      0x000007ff
+#define HSYNCSTRTSTOP_STOP_SHIFT     16 
+
+//-----------------------------------------------------------------------------
+// HACTIVESTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define HACTIVESTRTSTOP_STRT_MASK    0x07ff0000
+#define HACTIVESTRTSTOP_STRT_SHIFT   0 
+#define HACTIVESTRTSTOP_STOP_MASK    0x000007ff
+#define HACTIVESTRTSTOP_STOP_SHIFT   16 
+
+//-----------------------------------------------------------------------------
+// HCLKSTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define HCLKSTRTSTOP_STRT_MASK      0x07ff0000
+#define HCLKSTRTSTOP_STRT_SHIFT     0 
+#define HCLKSTRTSTOP_STOP_MASK      0x000007ff
+#define HCLKSTRTSTOP_STOP_SHIFT     16 
+
+//-----------------------------------------------------------------------------
+// BRIGHTNESS Register Definitions
+//-----------------------------------------------------------------------------
+#define BRIGHTNESS_MASK             0x0000ffff
+#define BRIGHTNESS_CNT_MASK         0x000000ff
+#define BRIGHTNESS_CNT_SHIFT        0
+#define BRIGHTNESS_CMP_MASK         0x0000ff00
+#define BRIGHTNESS_CMP_SHIFT        8
+
+//-----------------------------------------------------------------------------
+// VIDEOATTRIBS Register Definitions
+//-----------------------------------------------------------------------------
+#define VIDEOATTRIBS_MASK           0x001fffff
+#define VIDEOATTRIBS_EN             0x00000001
+#define VIDEOATTRIBS_PCLKEN         0x00000002
+#define VIDEOATTRIBS_SYNCEN         0x00000004
+#define VIDEOATTRIBS_DATAEN         0x00000008
+#define VIDEOATTRIBS_CSYNC          0x00000010
+#define VIDEOATTRIBS_VCPOL          0x00000020
+#define VIDEOATTRIBS_HSPOL          0x00000040
+#define VIDEOATTRIBS_BLKPOL         0x00000080
+#define VIDEOATTRIBS_INVCLK         0x00000100
+#define VIDEOATTRIBS_ACEN           0x00000200
+#define VIDEOATTRIBS_LCDEN          0x00000400
+#define VIDEOATTRIBS_CCIREN         0x00001000
+#define VIDEOATTRIBS_PIFEN          0x00002000
+#define VIDEOATTRIBS_INTEN          0x00004000
+#define VIDEOATTRIBS_INT            0x00008000
+#define VIDEOATTRIBS_INTRLC         0x00010000
+#define VIDEOATTRIBS_EQUSER         0x00020000
+#define VIDEOATTRIBS_DHORZ          0x00040000
+#define VIDEOATTRIBS_DVERT          0x00080000
+#define VIDEOATTRIBS_BKPXD          0x00100000
+
+#define VIDEOATTRIBS_SDSEL_MASK     0x00600000
+#define VIDEOATTRIBS_SDSEL_SHIFT    21
+
+//-----------------------------------------------------------------------------
+// HBLANKSTRTSTOP Register Definitions
+//-----------------------------------------------------------------------------
+#define HBLANKSTRTSTOP_STRT_MASK    0x07ff0000
+#define HBLANKSTRTSTOP_STRT_SHIFT   0 
+#define HBLANKSTRTSTOP_STOP_MASK    0x000007ff
+#define HBLANKSTRTSTOP_STOP_SHIFT   16 
+
+//-----------------------------------------------------------------------------
+// LINECARRY Register Definitions
+//-----------------------------------------------------------------------------
+#define LINECARRY_LCARY_MASK        0x000007ff
+#define LINECARRY_LCARY_SHIFT       0
+
+//-----------------------------------------------------------------------------
+// BLINKRATE Register Definitons
+//-----------------------------------------------------------------------------
+#define BLINKRATE_MASK              0x000000ff
+
+//-----------------------------------------------------------------------------
+// BLINKMASK Register Definitons
+//-----------------------------------------------------------------------------
+#define BLINKMASK_MASK              0x00ffffff
+
+//-----------------------------------------------------------------------------
+// VIDSCRNPAGE Register Definitons
+//-----------------------------------------------------------------------------
+#define VIDSCRNPAGE_PAGE_MASK       0x0ffffffc
+
+//-----------------------------------------------------------------------------
+// VIDSCRNHPG Register Definitons
+//-----------------------------------------------------------------------------
+#define VIDSCRNHPG_MASK             0x0ffffffc
+
+//-----------------------------------------------------------------------------
+// SCRNLINES Register Definitons
+//-----------------------------------------------------------------------------
+#define SCRNLINES_MASK              0x000007ff
+
+//-----------------------------------------------------------------------------
+// LINELENGTH Register Definitons
+//-----------------------------------------------------------------------------
+#define LINELENGTH_MASK             0x000007ff
+
+//-----------------------------------------------------------------------------
+// VLINESTEP Register Definitons
+//-----------------------------------------------------------------------------
+#define VLINESTEP_MASK              0x00000fff
+
+//-----------------------------------------------------------------------------
+// RASTER_SWLOCK Register Definitons
+//-----------------------------------------------------------------------------
+#define RASTER_SWLOCK_MASK_WR      0xff
+#define RASTER_SWLOCK_MASK_R       0x1
+#define RASTER_SWLOCK_VALUE        0xaa
+
+//-----------------------------------------------------------------------------
+// LUTCONT Register Definitions
+//-----------------------------------------------------------------------------
+#define LUTCONT_MASK                0x00000003
+#define LUTCONT_SWTCH               0x00000001
+#define LUTCONT_STAT                0x00000002
+#define LUTCONT_RAM0                0
+#define LUTCONT_RAM1                1
+
+//-----------------------------------------------------------------------------
+// CURSORBLINK1 Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSORBLINK1_MASK           0x00ffffff
+//-----------------------------------------------------------------------------
+// CURSORBLINK2 Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSORBLINK2_MASK           0x00ffffff
+
+//-----------------------------------------------------------------------------
+// CURSORBLINK Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSORBLINK_MASK            0x000001ff
+#define CURSORBLINK_RATE_MASK       0x000000ff
+#define CURSORBLINK_RATE_SHIFT      0
+#define CURSORBLINK_EN              0x00000100    
+
+//-----------------------------------------------------------------------------
+// BLINKPATRN Register Definitions
+//-----------------------------------------------------------------------------
+#define BLINKPATRN_MASK             0x00ffffff
+
+//-----------------------------------------------------------------------------
+// PATRNMASK Register Definitions
+//-----------------------------------------------------------------------------
+#define PATRNMASK_MASK              0x00ffffff
+
+//-----------------------------------------------------------------------------
+// BG_OFFSET Register Definitions
+//-----------------------------------------------------------------------------
+#define BG_OFFSET_MASK              0x00ffffff
+
+//-----------------------------------------------------------------------------
+// PIXELMODE Register Definitions
+//-----------------------------------------------------------------------------
+#define PIXELMODE_P_MASK            0x00000007
+#define PIXELMODE_P_MUX_DISABLE     0x00000000            
+#define PIXELMODE_P_4BPP            0x00000001            
+#define PIXELMODE_P_8BPP            0x00000002            
+#define PIXELMODE_P_16BPP           0x00000004            
+#define PIXELMODE_P_24BPP           0x00000006            
+#define PIXELMODE_P_32BPP           0x00000007            
+
+#define PIXELMODE_S_MASK            0x00000038
+#define PIXELMODE_S_1PPC            0x00000000
+#define PIXELMODE_S_1PPCMAPPED      0x00000008
+#define PIXELMODE_S_2PPC            0x00000010
+#define PIXELMODE_S_4PPC            0x00000018
+#define PIXELMODE_S_8PPC            0x00000020
+#define PIXELMODE_S_223PPC          0x00000028
+#define PIXELMODE_S_DS223PPC        0x00000030
+#define PIXELMODE_S_UNDEF           0x00000038
+
+#define PIXELMODE_M_MASK            0x000003c0
+#define PIXELMODE_M_NOBLINK         0x00000000
+#define PIXELMODE_M_ANDBLINK        0x00000040
+#define PIXELMODE_M_ORBLINK         0x00000080
+#define PIXELMODE_M_XORBLINK        0x000000c0
+#define PIXELMODE_M_BGBLINK         0x00000100
+#define PIXELMODE_M_OFFSINGBLINK    0x00000140
+#define PIXELMODE_M_OFF888BLINK     0x00000180
+#define PIXELMODE_M_DIMBLINK        0x00000300
+#define PIXELMODE_M_BRTBLINK        0x00000340
+#define PIXELMODE_M_DIM888BLINK     0x00000380
+#define PIXELMODE_M_BRT888BLINK     0x000003c0
+
+#define PIXELMODE_C_MASK            0x00003c00
+#define PIXELMODE_C_LUT             0x00000000
+#define PIXELMODE_C_888             0x00001000
+#define PIXELMODE_C_565             0x00001400
+#define PIXELMODE_C_555             0x00001800
+#define PIXELMODE_C_GSLUT           0x00002000
+
+#define PIXELMODE_DSCAN             0x00004000
+#define PIXELMODE_TRBSW             0x00008000
+
+//-----------------------------------------------------------------------------
+//PARLLIFOUT Register Defintions
+//-----------------------------------------------------------------------------
+#define PARLLIFOUT_DAT_MASK         0x0000000f
+#define PARLLIFOUT_DAT_SHIFT        0
+#define PARLLIFOUT_RD               0x00000010
+
+//-----------------------------------------------------------------------------
+//PARLLIFIN Register Defintions
+//-----------------------------------------------------------------------------
+#define PARLLIFIN_DAT_MASK          0x0000000f
+#define PARLLIFIN_DAT_SHIFT         0
+#define PARLLIFIN_CNT_MASK          0x000f0000
+#define PARLLIFIN_CNT_SHIFT         16
+#define PARLLIFIN_ESTRT_MASK        0x00f00000
+#define PARLLIFIN_ESTRT_SHIFT       20
+
+//-----------------------------------------------------------------------------
+// CURSORADRSTART Register Defintions
+//-----------------------------------------------------------------------------
+#define CURSOR_ADR_START_MASK         0xfffffffc
+
+//-----------------------------------------------------------------------------
+// CURSORADRSTART Register Defintions
+//-----------------------------------------------------------------------------
+#define CURSOR_ADR_RESET_MASK         0xfffffffc
+
+//-----------------------------------------------------------------------------
+// CURSORCOLOR1 Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSORCOLOR1_MASK               0x00ffffff
+//-----------------------------------------------------------------------------
+// CURSORCOLOR2 Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSORCOLOR2_MASK               0x00ffffff
+
+//-----------------------------------------------------------------------------
+// CURSORXYLOC Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSORXYLOC_MASK                0x07ff87ff
+#define CURSORXYLOC_XLOC_MASK           0x000007ff
+#define CURSORXYLOC_XLOC_SHIFT          0
+#define CURSORXYLOC_CEN                 0x00008000
+#define CURSORXYLOC_YLOC_MASK           0x07ff0000
+#define CURSORXYLOC_YLOC_SHIFT          16
+
+//-----------------------------------------------------------------------------
+// CURSOR_DSCAN_LH_YLOC Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSOR_DSCAN_LH_YLOC_MASK       0x000087ff
+
+#define CURSOR_DSCAN_LH_YLOC_YLOC_MASK  0x000007ff
+#define CURSOR_DSCAN_LH_YLOC_YLOC_SHIFT 0
+#define CURSOR_DSCAN_LH_YLOC_CLHEN      0x00008000
+
+//-----------------------------------------------------------------------------
+// CURSORSIZE Register Definitions
+//-----------------------------------------------------------------------------
+#define CURSORSIZE_MASK                 0x0000ffff
+
+#define CURSORSIZE_CWID_MASK            0x00000003
+#define CURSORSIZE_CWID_SHIFT           0
+#define CURSORSIZE_CWID_1_WORD          0
+#define CURSORSIZE_CWID_2_WORD          1
+#define CURSORSIZE_CWID_3_WORD          2
+#define CURSORSIZE_CWID_4_WORD          3
+
+#define CURSORSIZE_CLINS_MASK           0x000000fc
+#define CURSORSIZE_CLINS_SHIFT          2
+
+#define CURSORSIZE_CSTEP_MASK           0x00000300
+#define CURSORSIZE_CSTEP_SHIFT          8
+#define CURSORSIZE_CSTEP_1_WORD         0
+#define CURSORSIZE_CSTEP_2_WORD         1
+#define CURSORSIZE_CSTEP_3_WORD         2
+#define CURSORSIZE_CSTEP_4_WORD         3
+
+#define CURSORSIZE_DLNS_MASK            0x0000fc00
+#define CURSORSIZE_DLNS_SHIFT           10
+
+#endif /* _REGS_RASTER_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_smc.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_smc.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_smc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_smc.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,57 @@
+/*=======================================================================
+ *
+ *  FILE:       regs_smc.h
+ *
+ *  DESCRIPTION:    Static Memory Controller/PCMCIA Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2004
+ *
+ *=======================================================================
+ */
+#ifndef _REGS_SMC_H_
+#define _REGS_SMC_H_
+
+/* Bit definitions */
+
+//
+// Bit fields for SMCBCR?
+//
+#define SMCBCR_IDCY_MASK		0x0000000f
+#define SMCBCR_WST1_MASK		0x000003e0
+#define SMCBCR_RBLE			0x00000400
+#define SMCBCR_WST2_MASK		0x0000f800
+#define SMCBCR_WPERR			0x02000000
+#define SMCBCR_WP			0x04000000
+#define SMCBCR_PME			0x08000000
+#define SMCBCR_MW_MASK			0x30000000
+#define SMCBCR_MW_8			0x00000000
+#define SMCBCR_MW_16			0x10000000
+#define SMCBCR_MW_32			0x20000000
+#define SMCBCR_EBIBRKDIS		0x40000000
+#define SMCBCR_IDCY_SHIFT		0
+#define SMCBCR_WST1_SHIFT		5
+#define SMCBCR_WST2_SHIFT		11
+#define SMCBCR_MW_SHIFT			28
+
+//
+// Bit field for SMC_PCAttribute, SMC_PCCommon, and SMC_PCIO
+//      
+#define PCCONFIG_ADDRESSTIME_MASK   0x000000FF
+#define PCCONFIG_HOLDTIME_MASK      0x00000F00
+#define PCCONFIG_ACCESSTIME_MASK    0x00FF0000
+#define PCCONFIG_MW_8BIT            0x00000000
+#define PCCONFIG_MW_16BIT           0x80000000
+#define PCCONFIG_ADDRESSTIME_SHIFT  0
+#define PCCONFIG_HOLDTIME_SHIFT     8
+#define PCCONFIG_ACCESSTIME_SHIFT   16
+
+//
+// Bit field for SMC_PCMCIACtrl
+//
+#define PCCONT_PC1EN                0x00000001
+#define PCCONT_PC2EN                0x00000002
+#define PCCONT_PC1RST               0x00000004
+#define PCCONT_WEN                  0x00000010
+
+
+#endif /* _REGS_SMC_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_spi.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_spi.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_spi.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_spi.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,87 @@
+/*=======================================================================
+ *
+ *  FILE:       regs_spi.h
+ *
+ *  DESCRIPTION:    SSP Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *=======================================================================
+ */
+ 
+#ifndef _REGS_SSP_H_
+#define _REGS_SSP_H_
+
+//-----------------------------------------------------------------------------
+// Bits in SSPCR0
+//-----------------------------------------------------------------------------
+#define SSPCR0_DSS_MASK             0x0000000f
+#define SSPCR0_DSS_4BIT             0x00000003
+#define SSPCR0_DSS_5BIT             0x00000004
+#define SSPCR0_DSS_6BIT             0x00000005
+#define SSPCR0_DSS_7BIT             0x00000006
+#define SSPCR0_DSS_8BIT             0x00000007
+#define SSPCR0_DSS_9BIT             0x00000008
+#define SSPCR0_DSS_10BIT            0x00000009
+#define SSPCR0_DSS_11BIT            0x0000000a
+#define SSPCR0_DSS_12BIT            0x0000000b
+#define SSPCR0_DSS_13BIT            0x0000000c
+#define SSPCR0_DSS_14BIT            0x0000000d
+#define SSPCR0_DSS_15BIT            0x0000000e
+#define SSPCR0_DSS_16BIT            0x0000000f
+
+//-----------------------------------------------------------------------------
+// Bits in SSPCR1
+//-----------------------------------------------------------------------------
+#define SSPC1_RIE                   0x00000001
+#define SSPC1_TIE                   0x00000002
+#define SSPC1_RORIE		            0x00000004
+#define SSPC1_LBM                   0x00000008
+#define SSPC1_SSE                   0x00000010
+#define SSPC1_MS                    0x00000020
+#define SSPC1_SOD                   0x00000040
+
+#define SSPCR0_DSS_SHIFT            0
+#define SSPCR0_FRF_MASK             0x00000030
+#define SSPCR0_FRF_SHIFT            4
+#define SSPCR0_FRF_MOTOROLA         (0 << SSPCR0_FRF_SHIFT)
+#define SSPCR0_FRF_TI               (1 << SSPCR0_FRF_SHIFT)
+#define SSPCR0_FRF_NI               (2 << SSPCR0_FRF_SHIFT)
+#define SSPCR0_SPO                  0x00000040
+#define SSPCR0_SPH                  0x00000080
+#define SSPCR0_SCR_MASK             0x0000ff00
+#define SSPCR0_SCR_SHIFT            8
+
+//-----------------------------------------------------------------------------
+// Bits in SSPSR
+//-----------------------------------------------------------------------------
+#define SSPSR_TFE		    0x00000001      // TX FIFO is empty
+#define SSPSR_TNF    		0x00000002      // TX FIFO is not full
+#define SSPSR_RNE        	0x00000004      // RX FIFO is not empty
+#define SSPSR_RFF   		0x00000008      // RX FIFO is full
+#define SSPSR_BSY			0x00000010      // SSP is busy
+
+//-----------------------------------------------------------------------------
+// Bits in SSPIIR
+//-----------------------------------------------------------------------------
+#define SSPIIR_RIS			0x00000001      // RX FIFO IRQ status
+#define SSPIIR_TIS			0x00000002      // TX FIFO is not full
+#define SSPIIR_RORIS		0x00000004      // RX FIFO is full
+
+//=============================================================================
+//=============================================================================
+
+#endif /* _REGS_SSP_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_syscon.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_syscon.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_syscon.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_syscon.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,284 @@
+/*=============================================================================
+ *
+ *  FILE:       	reg_syscon.h
+ *
+ *  DESCRIPTION:    ep93xx Syscon Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *=============================================================================
+ */
+#ifndef _REGS_SYSCON_H_
+#define _REGS_SYSCON_H_
+
+//=============================================================================
+#ifndef __ASSEMBLY__
+
+#define SysconSetLocked(registername,value)     \
+    {                                           \
+        outl( 0xAA, SYSCON_SWLOCK);             \
+        outl( value, registername);             \
+    }
+
+#endif /* Not __ASSEMBLY__ */
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+// SYSCON_CLKSET1
+//-----------------------------------------------------------------------------
+#define SYSCON_CLKSET1_PLL1_X2IPD_SHIFT     0
+#define SYSCON_CLKSET1_PLL1_X2IPD_MASK      0x0000001f
+#define SYSCON_CLKSET1_PLL1_X2FBD2_SHIFT    5
+#define SYSCON_CLKSET1_PLL1_X2FBD2_MASK     0x000007e0
+#define SYSCON_CLKSET1_PLL1_X1FBD1_SHIFT    11
+#define SYSCON_CLKSET1_PLL1_X1FBD1_MASK     0x0000f800
+#define SYSCON_CLKSET1_PLL1_PS_SHIFT        16
+#define SYSCON_CLKSET1_PLL1_PS_MASK         0x00030000
+#define SYSCON_CLKSET1_PCLKDIV_SHIFT        18
+#define SYSCON_CLKSET1_PCLKDIV_MASK         0x000c0000
+#define SYSCON_CLKSET1_HCLKDIV_SHIFT        20
+#define SYSCON_CLKSET1_HCLKDIV_MASK         0x00700000
+#define SYSCON_CLKSET1_nBYP1                0x00800000
+#define SYSCON_CLKSET1_SMCROM               0x01000000
+#define SYSCON_CLKSET1_FCLKDIV_SHIFT        25
+#define SYSCON_CLKSET1_FCLKDIV_MASK         0x0e000000
+
+#define SYSCON_CLKSET1_HSEL                 0x00000001
+#define SYSCON_CLKSET1_PLL1_EXCLKSEL        0x00000002
+
+#define SYSCON_CLKSET1_PLL1_P_MASK          0x0000007C
+#define SYSCON_CLKSET1_PLL1_P_SHIFT         2
+
+#define SYSCON_CLKSET1_PLL1_M1_MASK         0x00000780
+#define SYSCON_CLKSET1_PLL1_M1_SHIFT        7
+#define SYSCON_CLKSET1_PLL1_M2_MASK         0x0000F800
+#define SYSCON_CLKSET1_PLL1_M2_SHIFT        11
+#define SYSCON_CLKSET1_PLL1_PS_MASK         0x00030000
+#define SYSCON_CLKSET1_PLL1_PS_SHIFT        16
+#define SYSCON_CLKSET1_PCLK_DIV_MASK        0x000C0000
+#define SYSCON_CLKSET1_PCLK_DIV_SHIFT       18
+#define SYSCON_CLKSET1_HCLK_DIV_MASK        0x00700000
+#define SYSCON_CLKSET1_HCLK_DIV_SHIFT       20
+#define SYSCON_CLKSET1_SMCROM               0x01000000
+#define SYSCON_CLKSET1_FCLK_DIV_MASK        0x0E000000
+#define SYSCON_CLKSET1_FCLK_DIV_SHIFT       25
+
+#define SYSCON_CLKSET2_PLL2_EN              0x00000001
+#define SYSCON_CLKSET2_PLL2EXCLKSEL         0x00000002
+#define SYSCON_CLKSET2_PLL2_P_MASK          0x0000007C
+#define SYSCON_CLKSET2_PLL2_P_SHIFT         2
+#define SYSCON_CLKSET2_PLL2_M2_MASK         0x00000F80
+#define SYSCON_CLKSET2_PLL2_M2_SHIFT        7
+#define SYSCON_CLKSET2_PLL2_M1_MASK         0x0001F000
+#define SYSCON_CLKSET2_PLL2_M1              12
+#define SYSCON_CLKSET2_PLL2_PS_MASK         0x000C0000
+#define SYSCON_CLKSET2_PLL2_PS_SHIFT        18
+#define SYSCON_CLKSET2_USBDIV_MASK          0xF0000000
+#define SYSCON_CLKSET2_USBDIV_SHIFT         28
+
+//-----------------------------------------------------------------------------
+// DEV_CFG Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_DEVCFG_SHena            0x00000001
+#define SYSCON_DEVCFG_KEYS             0x00000002
+#define SYSCON_DEVCFG_ADCPD            0x00000004
+#define SYSCON_DEVCFG_RAS              0x00000008
+#define SYSCON_DEVCFG_RASonP3          0x00000010
+#define SYSCON_DEVCFG_TTIC             0x00000020
+#define SYSCON_DEVCFG_I2SonAC97        0x00000040
+#define SYSCON_DEVCFG_I2SonSSP         0x00000080
+#define SYSCON_DEVCFG_EonIDE           0x00000100
+#define SYSCON_DEVCFG_PonG             0x00000200
+#define SYSCON_DEVCFG_GonIDE           0x00000400
+#define SYSCON_DEVCFG_HonIDE           0x00000800
+#define SYSCON_DEVCFG_HC1CEN           0x00001000
+#define SYSCON_DEVCFG_HC1IN            0x00002000
+#define SYSCON_DEVCFG_HC3CEN           0x00004000
+#define SYSCON_DEVCFG_HC3IN            0x00008000
+#define SYSCON_DEVCFG_TIN              0x00020000
+#define SYSCON_DEVCFG_U1EN             0x00040000
+#define SYSCON_DEVCFG_EXVC             0x00080000
+#define SYSCON_DEVCFG_U2EN             0x00100000
+#define SYSCON_DEVCFG_A1onG            0x00200000
+#define SYSCON_DEVCFG_A2onG            0x00400000
+#define SYSCON_DEVCFG_CPENA            0x00800000
+#define SYSCON_DEVCFG_U3EN             0x01000000
+#define SYSCON_DEVCFG_MonG             0x02000000
+#define SYSCON_DEVCFG_TonG             0x04000000
+#define SYSCON_DEVCFG_GonK             0x08000000
+#define SYSCON_DEVCFG_IonU2            0x10000000
+#define SYSCON_DEVCFG_D0onG            0x20000000
+#define SYSCON_DEVCFG_D1onG            0x40000000
+#define SYSCON_DEVCFG_SWRST            0x80000000
+
+//-----------------------------------------------------------------------------
+// VIDDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_VIDDIV_VDIV_MASK         0x0000007f              
+#define SYSCON_VIDDIV_VDIV_SHIFT        0
+#define SYSCON_VIDDIV_PDIV_MASK         0x00000300
+#define SYSCON_VIDDIV_PDIV_SHIFT        8
+#define SYSCON_VIDDIV_PSEL              0x00002000
+#define SYSCON_VIDDIV_ESEL              0x00004000
+#define SYSCON_VIDDIV_VENA              0x00008000
+
+//-----------------------------------------------------------------------------
+// MIRDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_MIRDIV_MDIV_MASK         0x0000003f
+#define SYSCON_MIRDIV_MDIV_SHIFT        0
+#define SYSCON_MIRDIV_PDIV_MASK         0x00000300
+#define SYSCON_MIRDIV_PDIV_SHIFT        8
+#define SYSCON_MIRDIV_PSEL              0x00002000              
+#define SYSCON_MIRDIV_ESEL              0x00004000
+#define SYSCON_MIRDIV_MENA              0x00008000
+
+//-----------------------------------------------------------------------------
+// I2SDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_I2SDIV_MDIV_MASK         0x0000007f
+#define SYSCON_I2SDIV_MDIV_SHIFT        0
+#define SYSCON_I2SDIV_PDIV_MASK         0x00000300
+#define SYSCON_I2SDIV_PDIV_SHIFT        8
+#define SYSCON_I2SDIV_PSEL              0x00002000
+#define SYSCON_I2SDIV_ESEL              0x00004000
+#define SYSCON_I2SDIV_MENA              0x00008000
+#define SYSCON_I2SDIV_SDIV              0x00010000
+#define SYSCON_I2SDIV_LRDIV_MASK        0x00060000
+#define SYSCON_I2SDIV_LRDIV_SHIFT       17
+#define SYSCON_I2SDIV_SPOL              0x00080000
+#define SYSCON_I2SDIV_DROP              0x00100000
+#define SYSCON_I2SDIV_ORIDE             0x20000000
+#define SYSCON_I2SDIV_SLAVE             0x40000000
+#define SYSCON_I2SDIV_SENA              0x80000000
+
+#define SYSCON_I2SDIV_PDIV_OFF          0x00000000
+#define SYSCON_I2SDIV_PDIV_2            0x00000100
+#define SYSCON_I2SDIV_PDIV_25           0x00000200
+#define SYSCON_I2SDIV_PDIV_3            0x00000300
+
+#define SYSCON_I2SDIV_LRDIV_32          0x00000000
+#define SYSCON_I2SDIV_LRDIV_64          0x00020000
+#define SYSCON_I2SDIV_LRDIV_128         0x00040000
+
+//-----------------------------------------------------------------------------
+// KTDIV Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_KTDIV_KDIV               0x00000001
+#define SYSCON_KTDIV_KEN                0x00008000
+#define SYSCON_KTDIV_ADIV               0x00010000
+#define SYSCON_KTDIV_TSEN               0x80000000
+
+//-----------------------------------------------------------------------------
+// CHIPID Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_CHIPID_ID_MASK           0x0000ffff
+#define SYSCON_CHIPID_ID_SHIFT          0
+#define SYSCON_CHIPID_PKID              0x00010000
+#define SYSCON_CHIPID_BND               0x00040000
+#define SYSCON_CHIPID_FAB_MASK          0x0e000000
+#define SYSCON_CHIPID_FAB_SHIFT         25
+#define SYSCON_CHIPID_REV_MASK          0xf0000000
+#define SYSCON_CHIPID_REV_SHIFT         28
+
+//-----------------------------------------------------------------------------
+// TESTCR Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_TESTCR_TMODE_MASK        0x000000ff
+#define SYSCON_TESTCR_TMODE_SHIFT       0
+#define SYSCON_TESTCR_BONDO             0x00000100
+#define SYSCON_TESTCR_PACKO             0x00000800
+#define SYSCON_TESTCR_ETOM              0x00002000
+#define SYSCON_TESTCR_TOM               0x00004000
+#define SYSCON_TESTCR_OVR               0x00008000
+#define SYSCON_TESTCR_TonIDE            0x00010000
+#define SYSCON_TESTCR_RonG              0x00020000
+
+//-----------------------------------------------------------------------------
+// SYSCFG Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_SYSCFG_LCSn1             0x00000001
+#define SYSCON_SYSCFG_LCSn2             0x00000002
+#define SYSCON_SYSCFG_LCSn3             0x00000004
+#define SYSCON_SYSCFG_LEECK             0x00000008
+#define SYSCON_SYSCFG_LEEDA             0x00000010
+#define SYSCON_SYSCFG_LASDO             0x00000020
+#define SYSCON_SYSCFG_LCSn6             0x00000040
+#define SYSCON_SYSCFG_LCSn7             0x00000080
+#define SYSCON_SYSCFG_SBOOT             0x00000100
+#define SYSCON_SYSCFG_FAB_MASK          0x0e000000
+#define SYSCON_SYSCFG_FAB_SHIFT         25
+#define SYSCON_SYSCFG_REV_MASK          0xf0000000
+#define SYSCON_SYSCFG_REV_SHIFT         28
+
+
+//-----------------------------------------------------------------------------
+// PWRSR Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_PWRSR_CHIPMAN_MASK       0xFF000000
+#define SYSCON_PWRSR_CHIPMAN_SHIFT      24
+#define SYSCON_PWRSR_CHIPID_MASK        0x00FF0000
+#define SYSCON_PWRSR_CHIPID_SHIFT       16
+#define SYSCON_PWRSR_WDTFLG             0x00008000
+#define SYSCON_PWRSR_CLDFLG             0x00002000
+#define SYSCON_PWRSR_TEST_RESET         0x00001000
+#define SYSCON_PWRSR_RSTFLG             0x00000800
+#define SYSCON_PWRSR_SWRESET            0x00000400
+#define SYSCON_PWRSR_PLL2_LOCKREG       0x00000200
+#define SYSCON_PWRSR_PLL2_LOCK          0x00000100
+#define SYSCON_PWRSR_PLL1_LOCKREG       0x00000080    
+#define SYSCON_PWRSR_PLL1_LOCK          0x00000040    
+#define SYSCON_PWRSR_RTCDIV             0x0000003F
+
+//-----------------------------------------------------------------------------
+// PWRCNT Register Defines
+//-----------------------------------------------------------------------------
+#define SYSCON_PWRCNT_FIREN             0x80000000
+#define SYSCON_PWRCNT_UARTBAUD          0x20000000
+#define SYSCON_PWRCNT_USHEN             0x10000000
+#define SYSCON_PWRCNT_DMA_M2MCH1        0x08000000
+#define SYSCON_PWRCNT_DMA_M2MCH0        0x04000000
+#define SYSCON_PWRCNT_DMA_M2PCH8        0x02000000
+#define SYSCON_PWRCNT_DMA_M2PCH9        0x01000000
+#define SYSCON_PWRCNT_DMA_M2PCH6        0x00800000
+#define SYSCON_PWRCNT_DMA_M2PCH7        0x00400000
+#define SYSCON_PWRCNT_DMA_M2PCH4        0x00200000
+#define SYSCON_PWRCNT_DMA_M2PCH5        0x00100000
+#define SYSCON_PWRCNT_DMA_M2PCH2        0x00080000
+#define SYSCON_PWRCNT_DMA_M2PCH3        0x00040000
+#define SYSCON_PWRCNT_DMA_M2PCH0        0x00020000
+#define SYSCON_PWRCNT_DMA_M2PCH1        0x00010000
+
+//-----------------------------------------------------------------------------
+// BMAR Register Defines
+//-----------------------------------------------------------------------------
+#define BMAR_PRIORD_00              0x00000000
+#define BMAR_PRIORD_01              0x00000001
+#define BMAR_PRIORD_02              0x00000002
+#define BMAR_PRIORD_03              0x00000003
+#define BMAR_PRI_CORE               0x00000008
+#define BMAR_DMA_ENIRQ              0x00000010
+#define BMAR_DMA_ENFIQ              0x00000020
+#define BMAR_USB_ENIRQ              0x00000040
+#define BMAR_USB_ENFIQ              0x00000080
+#define BMAR_MAC_ENIRQ              0x00000100
+#define BMAR_MAC_ENFIQ              0x00000200
+#define BMAR_GRAPHICS_ENIRQ         0x00000400
+#define BMAR_GRAPHICS_ENFIQ         0x00000800
+
+
+#endif // _REGS_SYSCON_H_
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_touch.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_touch.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_touch.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_touch.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,95 @@
+/*=============================================================================
+ *
+ *  FILE:       regs_touch.h
+ *
+ *  DESCRIPTION:    Analog Touchscreen Register Definition
+ *
+ *  Copyright Cirrus Logic, 2001-2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *=============================================================================
+ */
+#ifndef _REGS_TOUCH_H_
+#define _REGS_TOUCH_H_
+
+/*
+ *-----------------------------------------------------------------------------
+ * Individual bit #defines
+ *-----------------------------------------------------------------------------
+ */
+#define TSSETUP_SDLY_MASK           0x000003FF 
+#define TSSETUP_SDLY_SHIFT          0
+#define TSSETUP_NSMP_4              0x00000000
+#define TSSETUP_NSMP_8              0x00000400
+#define TSSETUP_NSMP_16             0x00000800
+#define TSSETUP_NSMP_32             0x00000C00
+#define TSSETUP_NSMP_MASK           0x00000C00
+#define TSSETUP_DEV_4               0x00000000
+#define TSSETUP_DEV_8               0x00001000
+#define TSSETUP_DEV_12              0x00002000
+#define TSSETUP_DEV_16              0x00003000
+#define TSSETUP_DEV_24              0x00004000
+#define TSSETUP_DEV_32              0x00005000
+#define TSSETUP_DEV_64              0x00006000
+#define TSSETUP_DEV_128             0x00007000
+#define TSSETUP_ENABLE              0x00008000
+#define TSSETUP_DLY_MASK            0x03FF0000
+#define TSSETUP_DLY_SHIFT           16
+#define TSSETUP_TDTCT               0x80000000
+
+#define TSMAXMIN_XMIN_MASK          0x000000FF
+#define TSMAXMIN_XMIN_SHIFT         0
+#define TSMAXMIN_YMIN_MASK          0x0000FF00
+#define TSMAXMIN_YMIN_SHIFT         8
+#define TSMAXMIN_XMAX_MASK          0x00FF0000
+#define TSMAXMIN_XMAX_SHIFT         16
+#define TSMAXMIN_YMAX_MASK          0xFF000000
+#define TSMAXMIN_YMAX_SHIFT         24
+
+#define TSXYRESULT_X_MASK           0x00000FFF
+#define TSXYRESULT_X_SHIFT          0
+#define TSXYRESULT_AD_MASK          0x0000FFFF
+#define TSXYRESULT_AD_SHIFT         0
+#define TSXYRESULT_Y_MASK           0x0FFF0000
+#define TSXYRESULT_Y_SHIFT          16
+#define TSXYRESULT_SDR              0x80000000
+
+#define TSX_SAMPLE_MASK             0x00003FFF
+#define TSX_SAMPLE_SHIFT            0x00
+#define TSY_SAMPLE_MASK             0x3FFF0000
+#define TSY_SAMPLE_SHIFT            0x10
+
+#define TSSETUP2_TINT               0x00000001
+#define TSSETUP2_NICOR              0x00000002
+#define TSSETUP2_PINT               0x00000004
+#define TSSETUP2_PENSTS             0x00000008
+#define TSSETUP2_PINTEN             0x00000010
+#define TSSETUP2_DEVINT             0x00000020
+#define TSSETUP2_DINTEN             0x00000040
+#define TSSETUP2_DTMEN              0x00000080
+#define TSSETUP2_DISDEV             0x00000100
+#define TSSETUP2_NSIGND             0x00000200
+#define TSSETUP2_S28EN              0x00000400
+#define TSSETUP2_RINTEN             0x00000800
+
+#define TSXYRESULT_SDR     			0x80000000
+
+/*
+ *-----------------------------------------------------------------------------
+ *-----------------------------------------------------------------------------
+ */
+
+
+#endif /* _REGS_TOUCH_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_uart.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_uart.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/regs_uart.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/regs_uart.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,91 @@
+/*
+ *  File:   linux/include/asm-arm/arch-ep93xx/regs_uart.h
+ *
+ *  Copyright (C) 2003 Cirrus Logic, Inc
+ *  
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _REGS_UART_H_
+#define _REGS_UART_H_
+
+//-----------------------------------------------------------------------------
+// Bits in UARTRSR
+//-----------------------------------------------------------------------------
+#define UARTRSR_FE              0x00000001      // Framing error
+#define UARTRSR_PE              0x00000002      // Parity error
+#define UARTRSR_BE              0x00000004      // Break error
+#define UARTRSR_OE              0x00000008      // Overrun error
+#define UARTRSR_ANY             0x0000000f      // Any error
+
+//-----------------------------------------------------------------------------
+// Bits in UARTCR - UART1CR, UART2CR, or UART3CR
+//-----------------------------------------------------------------------------
+#define UARTLCR_H_BRK           0x00000001
+#define UARTLCR_H_PEN           0x00000002
+#define UARTLCR_H_EPS           0x00000004
+#define UARTLCR_H_STP2          0x00000008
+#define UARTLCR_H_FEN           0x00000010
+#define UARTLCR_H_WLEN          0x00000060
+#define UARTLCR_H_WLEN_8        0x00000060
+#define UARTLCR_H_WLEN_7        0x00000040
+#define UARTLCR_H_WLEN_6        0x00000020
+#define UARTLCR_H_WLEN_5        0x00000000
+
+//-----------------------------------------------------------------------------
+// Bits in UARTFR - UART1FR, UART2FR, or UART3FR
+//-----------------------------------------------------------------------------
+#define UARTFR_RSR_ERRORS       0x0000000F
+#define UARTFR_CTS              0x00000001
+#define UARTFR_DSR              0x00000002
+#define UARTFR_DCD              0x00000004
+#define UARTFR_BUSY             0x00000008
+#define UARTFR_RXFE             0x00000010
+#define UARTFR_TXFF             0x00000020
+#define UARTFR_RXFF             0x00000040
+#define UARTFR_TXFE             0x00000080
+#define UARTFR_TMSK             (UARTFR_TXFF | UARTFR_BUSY)
+#define UARTFR_MODEM_ANY        (UARTFR_CTS | UARTFR_DSR | UARTFR_DCD)
+
+//-----------------------------------------------------------------------------
+// Bits in UARTIIR
+//-----------------------------------------------------------------------------
+#define UARTIIR_MIS             0x00000001
+#define UARTIIR_RIS             0x00000002
+#define UARTIIR_TIS             0x00000004
+#define UARTIIR_RTIS            0x00000008
+
+//-----------------------------------------------------------------------------
+// Bits in UARTCR
+//-----------------------------------------------------------------------------
+#define UARTCR_UARTEN           0x00000001
+#define UARTCR_MSIE             0x00000008
+#define UARTCR_RIE              0x00000010
+#define UARTCR_TIE              0x00000020
+#define UARTCR_RTIE             0x00000040
+#define UARTCR_LBE              0x00000080
+
+//-----------------------------------------------------------------------------
+// Bits in UARTMCR
+//-----------------------------------------------------------------------------
+#define UARTMCR_DTR             0x00000001
+#define UARTMCR_RTS             0x00000002
+#define UARTMCR_OUT1            0x00000004
+#define UARTMCR_OUT2            0x00000008
+#define UARTMCR_LOOP            0x00000010
+
+//=============================================================================
+//=============================================================================
+#endif /* _REGS_UART_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/serial.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/serial.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/serial.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/serial.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/serial.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/arch/platform.h>
+#include <asm/irq.h>
+
+/*
+ * This assumes you have a 1.8432 MHz clock for your UART.
+ *
+ * It'd be nice if someone built a serial card with a 24.576 MHz
+ * clock, since the 16550A is capable of handling a top speed of 1.5
+ * megabits/second; but this requires the faster clock.
+ */
+#define BASE_BAUD (1843200 / 16)
+
+#define _SER_IRQ0	IRQ_UARTINT0
+#define _SER_IRQ1	IRQ_UARTINT1
+
+#define RS_TABLE_SIZE	2
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+
+     /* UART CLK        PORT  IRQ     FLAGS        */
+#define STD_SERIAL_PORT_DEFNS \
+	{ 0, BASE_BAUD, 0x3F8, _SER_IRQ0, STD_COM_FLAGS },	/* ttyS0 */	\
+	{ 0, BASE_BAUD, 0x2F8, _SER_IRQ1, STD_COM_FLAGS },	/* ttyS1 */
+
+#define EXTRA_SERIAL_PORT_DEFNS
+
+#endif
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/ssp.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/ssp.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/ssp.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/ssp.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ * 
+ *  FILE:           ssp.h
+ *
+ *  DESCRIPTION:    SSP Interface Driver Module implementation
+ *
+ *  Copyright Cirrus Logic Corporation, 2001-2003.  All rights reserved
+ *
+ */
+#ifndef _SSP_DRV_H_
+#define _SSP_DRV_H_
+
+typedef enum 
+{
+	PS2_KEYBOARD = 0,
+	I2S_CODEC    = 1,
+	SERIAL_FLASH = 2
+} SSPDeviceType;
+
+typedef void (*SSPDataCallback)(unsigned int Data);
+
+typedef struct _SSP_DRIVER_API
+{
+    int (*Open)(SSPDeviceType Device, SSPDataCallback Callback);
+    int (*Read)(int Handle, unsigned int Addr, unsigned int *pValue);
+    int (*Write)(int Handle, unsigned int Addr, unsigned int Value);
+    int (*Close)(int Handle);
+} SSP_DRIVER_API;
+
+extern SSP_DRIVER_API *SSPDriver;
+
+#endif /* _SSP_DRV_H_ */
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/system.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/system.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/system.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,131 @@
+/*
+ *  linux/include/asm-arm/arch-ep93xx/system.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/platform.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+static void arch_idle(void)
+{
+	unsigned long ulTemp;
+
+	ulTemp = inl(SYSCON_HALT);
+}
+
+extern __inline__ void arch_reset(char mode)
+{
+	//
+	// Disable the peripherals.
+	//
+	outl(0xffffffff, VIC0INTENCLEAR);
+	outl(0xffffffff, VIC1INTENCLEAR);
+	outl(0, DMAMP_TX_0_CONTROL);
+	outl(0, DMAMP_RX_1_CONTROL);
+	outl(0, DMAMP_TX_2_CONTROL);
+	outl(0, DMAMP_RX_3_CONTROL);
+	outl(0, DMAMM_0_CONTROL);
+	outl(0, DMAMM_1_CONTROL);
+	outl(0, DMAMP_TX_4_CONTROL);
+	outl(0, DMAMP_RX_5_CONTROL);
+	outl(0, DMAMP_TX_6_CONTROL);
+	outl(0, DMAMP_RX_7_CONTROL);
+	outl(0, DMAMP_TX_8_CONTROL);
+	outl(0, DMAMP_RX_9_CONTROL);
+	outl(1, MAC_SELFCTL);
+	while(inl(MAC_SELFCTL) & 1)
+		barrier();
+	outl(1, HCCOMMANDSTATUS);
+	while(inl(HCCOMMANDSTATUS) & 1)
+		barrier();
+	outl(0, IrEnable);
+	outl(0, UART1CR);
+	outl(0, UART2CR);
+	outl(0, I2STX0En);
+	outl(0, I2SRX0En);
+	outl(0, AC97GCR);
+	outl(0, SSPCR1);
+#ifdef CONFIG_ARCH_EP9315
+	outl(0, SMC_PCMCIACtrl);
+	outl(0, BLOCKCTRL);
+#endif
+#if defined(CONFIG_ARCH_EP9312) || defined(CONFIG_ARCH_EP9315)
+	outl(0, VIDEOATTRIBS);
+	outl(0, UART3CR);
+	outl(0, I2STX1En);
+	outl(0, I2SRX1En);
+	outl(0, I2STX2En);
+	outl(0, I2SRX2En);
+	outl(0, TSSetup);
+	outl(0, IDECFG);
+	outl(0xaa, SYSCON_SWLOCK);
+	outl(0, SYSCON_VIDDIV);
+	outl(0xaa, SYSCON_SWLOCK);
+	outl(0, SYSCON_KTDIV);
+#endif
+	outl(0xaa, SYSCON_SWLOCK);
+	outl(0, SYSCON_MIRDIV);
+	outl(0xaa, SYSCON_SWLOCK);
+	outl(0, SYSCON_I2SDIV);
+	outl(0, SYSCON_PWRCNT);
+	outl(0xaa, SYSCON_SWLOCK);
+	outl(0, SYSCON_DEVCFG);
+	outl(0x000398e7, SYSCON_CLKSET1);
+	inl(SYSCON_CLKSET1);
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	outl(0x0003c317, SYSCON_CLKSET2);
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+	outl(0, GPIO_PADDR);
+	outl(0, GPIO_PBDDR);
+	outl(0, GPIO_PCDDR);
+#if defined(CONFIG_ARCH_EP9312) || defined(CONFIG_ARCH_EP9315)
+	outl(0, GPIO_PDDDR);
+#endif
+	outl(0x3, GPIO_PEDR);
+	outl(0x3, GPIO_PEDDR);
+	outl(0, GPIO_PFDDR);
+	outl(0, GPIO_PGDR);
+	outl(0xc, GPIO_PGDDR);
+	outl(0, GPIO_PHDDR);
+	outl(0, GPIO_PDDDR);
+	outl(0, GPIO_PDDDR);
+	outl(0, GPIO_AINTEN);
+	outl(0, GPIO_BINTEN);
+	outl(0, GPIO_FINTEN);
+	outl(0, GPIO_EEDRIVE);
+
+	//
+	// Reset the CPU, branching to the appropriate location based on the
+	// boot mode.
+	//
+	cpu_reset((inl(SYSCON_SYSCFG) & SYSCON_SYSCFG_LEECK) ?
+		  0x80090000 : 0x0);
+}
+#endif
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/timex.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/timex.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/timex.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/timex.h
+ *
+ *  Integrator architecture timex specifications
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE 508000
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/uncompress.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/uncompress.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/uncompress.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/uncompress.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,52 @@
+/*
+ *  linux/include/asm-arm/arch-ep93xx/uncompress.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#undef EP93XX_APB_BASE
+#define EP93XX_APB_BASE (IO_BASE_PHYS | 0x00800000)
+
+#define BAUDRATE ((14745600 / (16 * 57600)) - 1)
+
+static void puts(const char *s)
+{
+	while (*s)
+	{
+		while (inl(UART1FR) & UARTFR_TXFF)
+			barrier();
+
+		outl(*s, UART1DR);
+        
+		if (*s == '\n') {
+			while (inl(UART1FR) & UARTFR_TXFF)
+				barrier();
+	    
+			outl('\r', UART1DR);
+		}
+		s++;
+	}
+	while(inl(UART1FR) & UARTFR_BUSY)
+		barrier();
+}
+
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
diff -burN linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/vmalloc.h linux-2.6.8.1/include/asm-arm/arch-ep93xx/vmalloc.h
--- linux-2.6.8.1-orig/include/asm-arm/arch-ep93xx/vmalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/arch-ep93xx/vmalloc.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,31 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
diff -burN linux-2.6.8.1-orig/include/asm-arm/fpstate.h linux-2.6.8.1/include/asm-arm/fpstate.h
--- linux-2.6.8.1-orig/include/asm-arm/fpstate.h	2004-08-14 19:56:23.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/fpstate.h	2007-01-24 13:03:31.000000000 +0900
@@ -36,6 +36,19 @@
 	__u32 fpinst2;
 };
 
+
+struct fp_crunch_struct {
+	long long regs[16];
+#ifdef CONFIG_EP93XX_FPU_ACC
+	int acc0[3];
+	int acc1[3];
+	int acc2[3];
+	int acc3[3];
+#endif
+	unsigned long dspsc;
+};
+
+
 union vfp_state {
 	struct vfp_hard_struct	hard;
 };
@@ -54,8 +67,14 @@
 union fp_state {
 	struct fp_hard_struct	hard;
 	struct fp_soft_struct	soft;
+#ifdef CONFIG_EP93XX_FPU
+	struct fp_crunch_struct	crunch;
+#endif
 };
 
+
+
+
 #endif
 
 #endif
diff -burN linux-2.6.8.1-orig/include/asm-arm/hardware/serial_amba.h linux-2.6.8.1/include/asm-arm/hardware/serial_amba.h
--- linux-2.6.8.1-orig/include/asm-arm/hardware/serial_amba.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/hardware/serial_amba.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,94 @@
+/*
+ *  linux/include/asm-arm/hardware/serial_amba.h
+ *
+ *  Internal header file for AMBA serial ports
+ *
+ *  Copyright (C) ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef ASM_ARM_HARDWARE_SERIAL_AMBA_H
+#define ASM_ARM_HARDWARE_SERIAL_AMBA_H
+
+/* -------------------------------------------------------------------------------
+ *  From AMBA UART (PL010) Block Specification (ARM-0001-CUST-DSPC-A03)
+ * -------------------------------------------------------------------------------
+ *  UART Register Offsets.
+ */
+#define AMBA_UARTDR                     0x00	 /*  Data read or written from the interface. */
+#define AMBA_UARTRSR                    0x04	 /*  Receive status register (Read). */
+#define AMBA_UARTECR                    0x04	 /*  Error clear register (Write). */
+#define AMBA_UARTLCR_H                  0x08	 /*  Line control register, high byte. */
+#define AMBA_UARTLCR_M                  0x0C	 /*  Line control register, middle byte. */
+#define AMBA_UARTLCR_L                  0x10	 /*  Line control register, low byte. */
+#define AMBA_UARTCR                     0x14	 /*  Control register. */
+#define AMBA_UARTFR                     0x18	 /*  Flag register (Read only). */
+#define AMBA_UARTIIR                    0x1C	 /*  Interrupt indentification register (Read). */
+#define AMBA_UARTICR                    0x1C	 /*  Interrupt clear register (Write). */
+#define AMBA_UARTILPR                   0x20	 /*  IrDA low power counter register. */
+
+#define AMBA_UARTRSR_OE                 0x08
+#define AMBA_UARTRSR_BE                 0x04
+#define AMBA_UARTRSR_PE                 0x02
+#define AMBA_UARTRSR_FE                 0x01
+
+#define AMBA_UARTFR_TXFF                0x20
+#define AMBA_UARTFR_RXFE                0x10
+#define AMBA_UARTFR_BUSY                0x08
+#define AMBA_UARTFR_DCD			0x04
+#define AMBA_UARTFR_DSR			0x02
+#define AMBA_UARTFR_CTS			0x01
+#define AMBA_UARTFR_TMSK                (AMBA_UARTFR_TXFF + AMBA_UARTFR_BUSY)
+ 
+#define AMBA_UARTCR_RTIE                0x40
+#define AMBA_UARTCR_TIE                 0x20
+#define AMBA_UARTCR_RIE                 0x10
+#define AMBA_UARTCR_MSIE                0x08
+#define AMBA_UARTCR_IIRLP               0x04
+#define AMBA_UARTCR_SIREN               0x02
+#define AMBA_UARTCR_UARTEN              0x01
+ 
+#define AMBA_UARTLCR_H_WLEN_8           0x60
+#define AMBA_UARTLCR_H_WLEN_7           0x40
+#define AMBA_UARTLCR_H_WLEN_6           0x20
+#define AMBA_UARTLCR_H_WLEN_5           0x00
+#define AMBA_UARTLCR_H_FEN              0x10
+#define AMBA_UARTLCR_H_STP2             0x08
+#define AMBA_UARTLCR_H_EPS              0x04
+#define AMBA_UARTLCR_H_PEN              0x02
+#define AMBA_UARTLCR_H_BRK              0x01
+
+#define AMBA_UARTIIR_RTIS               0x08
+#define AMBA_UARTIIR_TIS                0x04
+#define AMBA_UARTIIR_RIS                0x02
+#define AMBA_UARTIIR_MIS                0x01
+
+#define ARM_BAUD_460800                 1
+#define ARM_BAUD_230400                 3
+#define ARM_BAUD_115200                 7
+#define ARM_BAUD_57600                  15
+#define ARM_BAUD_38400                  23
+#define ARM_BAUD_19200                  47
+#define ARM_BAUD_14400                  63
+#define ARM_BAUD_9600                   95
+#define ARM_BAUD_4800                   191
+#define ARM_BAUD_2400                   383
+#define ARM_BAUD_1200                   767
+
+#define AMBA_UARTRSR_ANY	(AMBA_UARTRSR_OE|AMBA_UARTRSR_BE|AMBA_UARTRSR_PE|AMBA_UARTRSR_FE)
+#define AMBA_UARTFR_MODEM_ANY	(AMBA_UARTFR_DCD|AMBA_UARTFR_DSR|AMBA_UARTFR_CTS)
+
+#endif
diff -burN linux-2.6.8.1-orig/include/asm-arm/system.h linux-2.6.8.1/include/asm-arm/system.h
--- linux-2.6.8.1-orig/include/asm-arm/system.h	2004-08-14 19:54:50.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/system.h	2007-01-24 13:03:31.000000000 +0900
@@ -4,6 +4,7 @@
 #ifdef __KERNEL__
 
 #include <linux/config.h>
+#include <asm/arch/crunch.h>
 
 #define CPU_ARCH_UNKNOWN	0
 #define CPU_ARCH_ARMv3		1
@@ -174,9 +175,12 @@
 struct thread_info;
 struct task_struct;
 extern struct task_struct *__switch_to(struct task_struct *, struct thread_info *, struct thread_info *);
+extern int crunch_is_enabled;
 
 #define switch_to(prev,next,last)					\
 do {									\
+	if(crunch_is_enabled)						\
+	    switch_crunch(prev, next);					\
 	last = __switch_to(prev,prev->thread_info,next->thread_info);	\
 } while (0)
 
diff -burN linux-2.6.8.1-orig/include/asm-arm/unistd.h linux-2.6.8.1/include/asm-arm/unistd.h
--- linux-2.6.8.1-orig/include/asm-arm/unistd.h	2004-08-14 19:56:22.000000000 +0900
+++ linux-2.6.8.1/include/asm-arm/unistd.h	2007-01-24 13:03:31.000000000 +0900
@@ -301,6 +301,17 @@
 #define __NR_pciconfig_write		(__NR_SYSCALL_BASE+273)
 
 /*
+ * For POSIX message queues.
+ */
+
+#define __NR_mq_open                    (__NR_SYSCALL_BASE+274)
+#define __NR_mq_unlink                  (__NR_SYSCALL_BASE+275)
+#define __NR_mq_timedsend               (__NR_SYSCALL_BASE+276)
+#define __NR_mq_timedreceive            (__NR_SYSCALL_BASE+277)
+#define __NR_mq_notify                  (__NR_SYSCALL_BASE+278)
+#define __NR_mq_getsetattr              (__NR_SYSCALL_BASE+279)
+
+/*
  * The following SWIs are ARM private.
  */
 #define __ARM_NR_BASE			(__NR_SYSCALL_BASE+0x0f0000)
diff -burN linux-2.6.8.1-orig/include/linux/console_struct.h linux-2.6.8.1/include/linux/console_struct.h
--- linux-2.6.8.1-orig/include/linux/console_struct.h	2004-08-14 19:54:46.000000000 +0900
+++ linux-2.6.8.1/include/linux/console_struct.h	2007-01-24 13:19:57.000000000 +0900
@@ -87,6 +87,9 @@
 	struct vc_data **vc_display_fg;		/* [!] Ptr to var holding fg console for this display */
 	unsigned long	vc_uni_pagedir;
 	unsigned long	*vc_uni_pagedir_loc;  /* [!] Location of uni_pagedir variable for this console */
+#ifdef CONFIG_BOOTSPLASH
+	struct splash_data *vc_splash_data;
+#endif
 	/* additional information is in vt_kern.h */
 };
 
diff -burN linux-2.6.8.1-orig/include/linux/fb.h linux-2.6.8.1/include/linux/fb.h
--- linux-2.6.8.1-orig/include/linux/fb.h	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/include/linux/fb.h	2007-01-24 13:19:57.000000000 +0900
@@ -591,6 +591,15 @@
 
 	/* From here on everything is device dependent */
 	void *par;	
+#ifdef CONFIG_BOOTSPLASH
+	struct splash_data *splash_data;
+	unsigned char *splash_pic;
+	int splash_pic_size;
+	int splash_bytes;
+	char *silent_screen_base;       /* real screen base */
+	char fb_cursordata[64];
+#endif
+
 };
 
 #ifdef MODULE
diff -burN linux-2.6.8.1-orig/include/linux/ide.h linux-2.6.8.1/include/linux/ide.h
--- linux-2.6.8.1-orig/include/linux/ide.h	2004-08-14 19:55:10.000000000 +0900
+++ linux-2.6.8.1/include/linux/ide.h	2007-01-24 13:03:31.000000000 +0900
@@ -227,7 +227,7 @@
 #endif /* CONFIG_APM || CONFIG_APM_MODULE */
 #define WAIT_PIDENTIFY	(10*HZ)	/* 10sec  - should be less than 3ms (?), if all ATAPI CD is closed at boot */
 #define WAIT_WORSTCASE	(30*HZ)	/* 30sec  - worst case when spinning up */
-#define WAIT_CMD	(10*HZ)	/* 10sec  - maximum wait for an IRQ to happen */
+#define WAIT_CMD	(1*HZ)	/* 1sec  - maximum wait for an IRQ to happen */
 #define WAIT_MIN_SLEEP	(2*HZ/100)	/* 20msec - minimum sleep time */
 
 #define HOST(hwif,chipset)					\
@@ -796,6 +796,7 @@
 	struct device	gendev;
 	struct semaphore gendev_rel_sem;	/* to deal with device release() */
 	struct gendisk *disk;
+	u32    ep93xx_if_test;
 } ide_drive_t;
 
 typedef struct ide_pio_ops_s {
diff -burN linux-2.6.8.1-orig/include/linux/irda.h linux-2.6.8.1/include/linux/irda.h
--- linux-2.6.8.1-orig/include/linux/irda.h	2004-08-14 19:54:48.000000000 +0900
+++ linux-2.6.8.1/include/linux/irda.h	2007-01-24 13:03:31.000000000 +0900
@@ -16,7 +16,7 @@
  *     published by the Free Software Foundation; either version 2 of 
  *     the License, or (at your option) any later version.
  *  
- *     Neither Dag Brattli nor University of Troms admit liability nor
+ *     Neither Dag Brattli nor University of Troms?admit liability nor
  *     provide warranty for any of this software. This material is 
  *     provided "AS-IS" and at no charge.
  *
@@ -76,6 +76,7 @@
 	IRDA_MCP2120_DONGLE      = 9,
 	IRDA_ACT200L_DONGLE      = 10,
 	IRDA_MA600_DONGLE        = 11,
+	IRDA_EP93XX_SIR          = 12,
 } IRDA_DONGLE;
 
 /* Protocol types to be used for SOCK_DGRAM */
diff -burN linux-2.6.8.1-orig/include/linux/rtc_isl1208.h linux-2.6.8.1/include/linux/rtc_isl1208.h
--- linux-2.6.8.1-orig/include/linux/rtc_isl1208.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/linux/rtc_isl1208.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,108 @@
+/*
+ *  linux/drivers/i2c/chips/rtc8564.h
+ *
+ *  Copyright (C) 2002-2004 Stefan Eletzhofer
+ *
+ *	based on linux/drivers/acron/char/pcf8583.h
+ *  Copyright (C) 2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+struct rtc_tm {
+	unsigned char	secs;
+	unsigned char	mins;
+	unsigned char	hours;
+	unsigned char	mday;
+	unsigned char	mon;
+	unsigned short	year; /* xxxx 4 digits :) */
+	unsigned char	wday;
+	unsigned char	vl;
+};
+
+struct mem {
+	unsigned int	loc;
+	unsigned int	nr;
+	unsigned char	*data;
+};
+
+
+
+/* Register map */
+/* rtc section */
+#define ISL1208_REG_SC  0x00
+#define ISL1208_REG_MN  0x01
+#define ISL1208_REG_HR  0x02
+#define ISL1208_REG_HR_MIL     (1<<7) /* 24h/12h mode */
+#define ISL1208_REG_HR_PM      (1<<5) /* PM/AM bit in 12h mode */
+#define ISL1208_REG_DT  0x03
+#define ISL1208_REG_MO  0x04
+#define ISL1208_REG_YR  0x05
+#define ISL1208_REG_DW  0x06
+#define ISL1208_RTC_SECTION_LEN 7
+
+/* control/status section */
+#define ISL1208_REG_SR  0x07
+#define ISL1208_REG_SR_ARST    (1<<7) /* auto reset */
+#define ISL1208_REG_SR_XTOSCB  (1<<6) /* crystal oscillator */
+#define ISL1208_REG_SR_WRTC    (1<<4) /* write rtc */
+#define ISL1208_REG_SR_ALM     (1<<2) /* alarm */
+#define ISL1208_REG_SR_BAT     (1<<1) /* battery */
+#define ISL1208_REG_SR_RTCF    (1<<0) /* rtc fail */
+#define ISL1208_REG_INT 0x08
+#define ISL1208_REG_09  0x09 /* reserved */
+#define ISL1208_REG_ATR 0x0a
+#define ISL1208_REG_DTR 0x0b
+
+/* alarm section */
+#define ISL1208_REG_SCA 0x0c
+#define ISL1208_REG_MNA 0x0d
+#define ISL1208_REG_HRA 0x0e
+#define ISL1208_REG_DTA 0x0f
+#define ISL1208_REG_MOA 0x10
+#define ISL1208_REG_DWA 0x11
+#define ISL1208_ALARM_SECTION_LEN 6
+
+/* user section */
+#define ISL1208_REG_USR1 0x12
+#define ISL1208_REG_USR2 0x13
+#define ISL1208_USR_SECTION_LEN 2
+
+/* i2c configuration */
+#define ISL1208_I2C_ADDR 0xde
+#define ISL1208_I2C_ADDR_WR 0xde
+#define ISL1208_I2C_ADDR_RE 0xdf
+
+/* CLKOUT frequencies */
+#define ISL1208_FD_0HZ			(0x0)
+#define ISL1208_FD_32768HZ		(0x1)
+#define ISL1208_FD_4096HZ		(0x2)
+#define ISL1208_FD_1024HZ		(0x3)
+#define ISL1208_FD_64HZ			(0x4)
+#define ISL1208_FD_32HZ			(0x5)
+#define ISL1208_FD_16HZ			(0x6)
+#define ISL1208_FD_8HZ			(0x7)
+#define ISL1208_FD_4HZ			(0x8)
+#define ISL1208_FD_2HZ			(0x9)
+#define ISL1208_FD_1HZ			(0xA)
+#define ISL1208_FD_1_2HZ		(0xB)
+#define ISL1208_FD_1_4HZ		(0xC)
+#define ISL1208_FD_1_8HZ		(0xD)
+#define ISL1208_FD_1_16HZ		(0xE)
+#define ISL1208_FD_1_32HZ		(0xF)
+
+/* RTC device commmand */
+#define RTC_GETDATETIME	0
+#define RTC_SETTIME	1
+#define RTC_SETDATETIME	2
+#define RTC_GETALARM	3
+#define RTC_SETALARM	4
+#define RTC_GETCTRL	5
+#define RTC_SETCTRL	6
+#define MEM_READ	7
+#define MEM_WRITE	8
+
+
+#define I2C_DRIVERID_ISL1208 0xf001
+extern int isl1208_do_command(unsigned int cmd, void *arg);
\ 
diff -burN linux-2.6.8.1-orig/include/video/ep93xxfb.h linux-2.6.8.1/include/video/ep93xxfb.h
--- linux-2.6.8.1-orig/include/video/ep93xxfb.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/include/video/ep93xxfb.h	2007-01-15 12:17:43.000000000 +0900
@@ -0,0 +1,254 @@
+/*
+ * drivers/video/ep93xxfb.h -- IOCTLs for the EP93xx graphics accelerator
+ *
+ * Copyright (c) 2004 Cirrus Logic, Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file COPYING in the main directory of this
+ * archive for more details.
+ *
+ */
+#ifndef __EP93XXFB_H__
+#define __EP93XXFB_H__
+
+/*
+ * The following are the IOCTLs that can be sent to the EP93xx frame buffer
+ * device.
+ */
+
+/*
+ * We need to set the IOCTLs to 0xc for EDB9315A because of SDCSn0
+ *
+*/ 
+        #define FBIO_EP93XX_GET_CAPS	0x000046c0
+	#define FBIO_EP93XX_CURSOR	0x000046c1
+	#define FBIO_EP93XX_LINE	0x000046c2
+	#define FBIO_EP93XX_FILL	0x000046c3
+	#define FBIO_EP93XX_BLIT	0x000046c4
+	
+
+
+/*
+ * ioctl(fd, FBIO_EP93XX_GET_CAPS, unsigned long *)
+ *
+ * The unsigned long is filled in with these capabilities flags to indicate
+ * what the frame buffer driver is capable of performing.
+ */
+
+/*
+ * We need to set the IOCTLs to 0xc for EDB9315A because of SDCSn0
+ *
+*/ 
+	#define EP93XX_CAP_CURSOR	0x00000001
+	#define EP93XX_CAP_LINE		0x00000002
+	#define EP93XX_CAP_FILL		0x00000004
+	#define EP93XX_CAP_BLIT		0x00000008
+	
+
+
+/*
+ * The bits in the flags field of ep93xx_cursor.
+ */
+
+/*
+ * We need to set the IOCTLs to 0xc for EDB9315A because of SDCSn0
+ *
+*/ 
+	#define CURSOR_BLINK		0x00000001
+	#define CURSOR_MOVE		0x00000002
+	#define CURSOR_SETSHAPE		0x00000004
+	#define CURSOR_SETCOLOR		0x00000008
+	#define CURSOR_ON		0x00000010
+	#define CURSOR_OFF		0x00000020
+
+
+/*
+ * ioctl(fd, FBIO_EP93XX_CURSOR, ep93xx_cursor *)
+ *
+ * "data" points to an array of pixels that define the cursor; each row should
+ * be a multiple of 32-bit values (i.e. 16 pixels).  Each pixel is two bits,
+ * where the values are:
+ *
+ *     00 => transparent    01 => invert    10 => color1    11 => color2
+ *
+ * The data is arranged as follows (per word):
+ *
+ *    bits: |31-30|29-28|27-26|25-24|23-22|21-20|19-18|17-16|
+ *   pixel: | 12  | 13  | 14  | 15  |  8  |  9  | 10  | 11  |
+ *    bits: |15-14|13-12|11-10| 9-8 | 7-6 | 5-4 | 3-2 | 1-0 |
+ *   pixel: |  4  |  5  |  6  |  7  |  0  |  1  |  2  |  3  |
+ *
+ * Regardless of the frame buffer color depth, "color1", "color2",
+ * "blinkcolor1", and "blinkcolor2" are 24-bit colors since the cursor is
+ * injected into the data stream right before the video DAC.
+ *
+ * When "blinkrate" is not zero, pixel value 10 will alternate between "color1"
+ * and "blinkcolor1" (similar for pixel value 11 and "color2"/"blinkcolor2").
+ *
+ * "blinkrate" ranges between 0 and 255.  When 0, blinking is disabled.  255 is
+ * the fastest blink rate and 1 is the slowest.
+ *
+ * Both "width" and "height" must be between 1 and 64; it is preferable to have
+ * "width" a multiple of 16.
+ */
+struct ep93xx_cursor {
+    __u32 flags;
+    __u32 dx;		// Only used if CURSOR_MOVE is set
+    __u32 dy;		// Only used if CURSOR_MOVE is set
+    __u32 width;	// Only used if CURSOR_SETSHAPE is set
+    __u32 height;	// Only used if CURSOR_SETSHAPE is set
+    const char *data;	// Only used if CURSOR_SETSHAPE is set
+    __u32 blinkrate;	// Only used if CURSOR_BLINK is set
+    __u32 color1;	// Only used if CURSOR_SETCOLOR is set
+    __u32 color2;	// Only used if CURSOR_SETCOLOR is set
+    __u32 blinkcolor1;	// Only used if CURSOR_SETCOLOR is set
+    __u32 blinkcolor2;	// Only used if CURSOR_SETCOLOR is set
+};
+
+/*
+ * The bits in the flags field of ep93xx_line.
+ */
+ 
+/*
+ * We need to set the IOCTLs to 0xc for EDB9315A because of SDCSn0
+ *
+ */ 
+
+	#define LINE_PATTERN		0x00000001
+	#define LINE_PRECISE		0x00000002
+	#define LINE_BACKGROUND		0x00000004
+
+
+
+
+/*
+ * ioctl(fd, FBIO_EP93XX_LINE, ep93xx_line *)
+ *
+ * The line starts at ("x1","y1") and ends at ("x2","y2").  This means that
+ * when using a pattern, the two coordinates are not transitive (i.e. swapping
+ * ("x1","y1") with ("x2","y2") will not necessarily draw the exact same line,
+ * pattern-wise).
+ *
+ * "pattern" is a 2 to 16 bit pattern (since a 1 bit pattern isn't much of a
+ * pattern).  The lower 16 bits define the pattern (1 being foreground, 0 being
+ * background or transparent), and bits 19-16 define the length of the pattern
+ * (as pattern length - 1).  So, for example, "0xf00ff" defines a 16 bit
+ * with the first 8 pixels in the foreground color and the next 8 pixels in the
+ * background color or transparent.
+ *
+ * LINE_PRECISE is used to apply angularly corrected patterns to line.  It
+ * should only be used when LINE_PATTERN is also set.  The pattern will be
+ * applied along the length of the line, instead of along the length of the
+ * major axis.  This may result in the loss of fine details in the pattern, and
+ * will take more time to draw the line in most cases.
+ */
+struct ep93xx_line {
+    __u32 flags;
+    __s32 x1;
+    __s32 y1;
+    __s32 x2;
+    __s32 y2;
+    __u32 fgcolor;
+    __u32 bgcolor;	// Only used if LINE_BACKGROUND is set
+    __u32 pattern;	// Only used if LINE_PATTERN is set
+};
+
+/*
+ * ioctl(fd, FBIO_EP93XX_FILL, ep93xx_fill *)
+ *
+ * Fills from dx to (dx + width - 1), and from dy to (dy + height - 1).
+ */
+struct ep93xx_fill {
+    __u32 dx;
+    __u32 dy;
+    __u32 width;
+    __u32 height;
+    __u32 color;
+};
+
+/*
+ * The bits in the flags field of ep93xx_blit.
+ */
+ 
+/*
+ * We need to set the IOCTLs to 0xc for EDB9315A because of SDCSn0
+ *
+ */ 
+
+	#define BLIT_SOURCE_MASK	0x00000001
+	#define BLIT_SOURCE_MEMORY	0x00000000
+	#define BLIT_SOURCE_SCREEN	0x00000001
+	#define BLIT_TRANSPARENT	0x00000004
+	#define BLIT_MASK_MASK		0x00000600
+	#define BLIT_MASK_DISABLE	0x00000000
+	#define BLIT_MASK_AND		0x00000200
+	#define BLIT_MASK_OR		0x00000400
+	#define BLIT_MASK_XOR		0x00000600
+	#define BLIT_DEST_MASK		0x00001800
+	#define BLIT_DEST_DISABLE	0x00000000
+	#define BLIT_DEST_AND		0x00000800
+	#define BLIT_DEST_OR		0x00001000
+	#define BLIT_DEST_XOR		0x00001800
+	#define BLIT_1BPP_SOURCE	0x00006000
+	
+
+
+/*
+ * ioctl(fd, FBIO_EP93XX_BLIT, ep93xx_blit *)
+ *
+ * When BLIT_SOURCE_MEMORY is set, "data" points to an array of pixels that are
+ * to be blitted to the screen; each row should be a multiple of 32-bit values.
+ * When BLIT_1BPP_SOURCE is set, each pixel is one bit and is arranged as
+ * follows (per word):
+ *
+ *     bit: |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|
+ *   pixel: |24|25|26|27|28|29|30|31|16|17|18|19|20|21|22|23|
+ *     bit: |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ *   pixel: | 8| 9|10|11|12|13|14|15| 0| 1| 2| 3| 4| 5| 6| 7|
+ *
+ * When the frame buffer is in 8bpp mode, each pixel is one byte and is
+ * arranged as follows (per word):
+ *
+ *    bits: |31-24|23-16|15-8 | 7-0 |
+ *   pixel: |  3  |  2  |  1  |  0  |
+ *
+ * When the frame buffer is in 16bpp mode, each pixel is two bytes and is
+ * arranged as follows (per word):
+ *
+ *    bits: |31-16|15-0 |
+ *   pixel: |  1  |  0  |
+ *
+ * When BLIT_SOURCE_SCREEN is set, BLIT_1BPP_SOURCE is not valid (not for any
+ * hardware imposed reason, but because it simply doesn't make any sense).
+ * When BLIT_SOURCE_MEMORY and BLIT_1BPP_SOURCE are set, BLIT_MASK_DISABLE must
+ * be set.
+ *
+ * BLIT_MASK_MASK applies a masking operation on the source data as it is read.
+ * When not disabled, each pixel is modified by the given operation with the
+ * "fgcolor" value.
+ *
+ * BLIT_DEST_MASK determines how the data is written to the destination
+ * location.  When not disabled, each destination pixel is modified by the
+ * given operation with the current value.  This operation takes place after
+ * the BLIT_MASK_MASK operation.
+ *
+ * BLIT_TRANSPARENT allows a transparency color to be defined for the blit.  If
+ * set, after BLIT_DEST_MASK has been applied, if the resulting pixel matches
+ * "transcolor", the destination pixel is not modified.
+ */
+struct ep93xx_blit {
+    __u32 flags;
+    __u32 dx;
+    __u32 dy;
+    __u32 width;
+    __u32 height;
+    const char *data;	// Only used if BLIT_SOURCE_MEMORY is set
+    __u32 swidth;	// Only used if BLIT_SOURCE_MEMORY is set
+    __u32 sx;		// Only used if BLIT_SOURCE_SCREEN is set
+    __u32 sy;		// Only used if BLIT_SOURCE_SCREEN is set
+    __u32 fgcolor;	// Only used if BLIT_1BPP_SOURCE or BLIT_MASK_?? is set
+    __u32 bgcolor;	// Only used if BLIT_1BPP_SOURCE is set
+    __u32 transcolor;	// Only used if BLIT_TRANSPARENT is set
+};
+
+#endif /* __EP93XXFB_H__ */
diff -burN linux-2.6.8.1-orig/init/initramfs.c linux-2.6.8.1/init/initramfs.c
--- linux-2.6.8.1-orig/init/initramfs.c	2004-08-14 19:54:48.000000000 +0900
+++ linux-2.6.8.1/init/initramfs.c	2007-01-24 13:03:31.000000000 +0900
@@ -175,9 +175,13 @@
 	return 0;
 }
 
+static unsigned insize;  /* valid bytes in inbuf */
+
 static int __init do_header(void)
 {
 	if (memcmp(collected, "070701", 6)) {
+		if (dry_run)
+			insize = 0;
 		error("no cpio magic");
 		return 1;
 	}
@@ -356,7 +360,7 @@
 static uch *inbuf;
 static uch *window;
 
-static unsigned insize;  /* valid bytes in inbuf */
+//static unsigned insize;  /* valid bytes in inbuf */
 static unsigned inptr;   /* index of next byte to be processed in inbuf */
 static unsigned outcnt;  /* bytes in output buffer */
 static long bytes_out;
@@ -446,7 +450,7 @@
 		crc = (ulg)0xffffffffL; /* shift register contents */
 		makecrc();
 		if (gunzip())
-			message = "ungzip failed";
+			error("ungzip failed");
 		if (state != Reset)
 			error("junk in gzipped archive");
 		this_header = saved_offset + inptr;
diff -burN linux-2.6.8.1-orig/kernel/panic.c linux-2.6.8.1/kernel/panic.c
--- linux-2.6.8.1-orig/kernel/panic.c	2004-08-14 19:56:22.000000000 +0900
+++ linux-2.6.8.1/kernel/panic.c	2007-01-24 13:19:57.000000000 +0900
@@ -82,6 +82,12 @@
 		 * We can't use the "normal" timers since we just panicked..
 	 	 */
 		printk(KERN_EMERG "Rebooting in %d seconds..",panic_timeout);
+#ifdef CONFIG_BOOTSPLASH
+		{
+			extern int splash_verbose(void);
+			(void)splash_verbose();
+		}
+#endif
 		for (i = 0; i < panic_timeout; i++) {
 			touch_nmi_watchdog();
 			mdelay(1000);
@@ -105,6 +111,12 @@
         disabled_wait(caller);
 #endif
 	local_irq_enable();
+#ifdef CONFIG_BOOTSPLASH
+	{
+		extern int splash_verbose(void);
+		(void)splash_verbose();
+	}
+#endif
 	for (;;)
 		;
 }
diff -burN linux-2.6.8.1-orig/net/irda/Makefile linux-2.6.8.1/net/irda/Makefile
--- linux-2.6.8.1-orig/net/irda/Makefile	2004-08-14 19:56:09.000000000 +0900
+++ linux-2.6.8.1/net/irda/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -6,7 +6,7 @@
 obj-$(CONFIG_IRLAN) += irlan/
 obj-$(CONFIG_IRNET) += irnet/
 obj-$(CONFIG_IRCOMM) += ircomm/
-
+#obj-$(CONFIG_EP93XX_SIR)        += ep93xx_sir.o
 irda-y := iriap.o iriap_event.o irlmp.o irlmp_event.o irlmp_frame.o \
           irlap.o irlap_event.o irlap_frame.o timer.o qos.o irqueue.o \
           irttp.o irda_device.o irias_object.o wrapper.o af_irda.o \
diff -burN linux-2.6.8.1-orig/scripts/kconfig/mconf.c linux-2.6.8.1/scripts/kconfig/mconf.c
--- linux-2.6.8.1-orig/scripts/kconfig/mconf.c	2004-08-14 19:54:51.000000000 +0900
+++ linux-2.6.8.1/scripts/kconfig/mconf.c	2007-01-24 13:03:31.000000000 +0900
@@ -88,7 +88,7 @@
 static int indent;
 static struct termios ios_org;
 static int rows = 0, cols = 0;
-static struct menu *current_menu;
+struct menu *current_menu;
 static int child_count;
 static int do_resize;
 static int single_menu_mode;
diff -burN linux-2.6.8.1-orig/sound/arm/Kconfig linux-2.6.8.1/sound/arm/Kconfig
--- linux-2.6.8.1-orig/sound/arm/Kconfig	2004-08-14 19:56:14.000000000 +0900
+++ linux-2.6.8.1/sound/arm/Kconfig	2007-01-15 12:17:44.000000000 +0900
@@ -11,5 +11,51 @@
 	  Say Y or M if you have a Compaq iPaq H3x00 handheld computer and want
 	  to use its Philips UDA 1341 audio chip.
 
+config SND_EP93XX_IIS
+	tristate "EP93xx ALSA iis audio driver"
+	depends on ARCH_EP93XX && SND
+	select SND_PCM
+	help
+	  Say Y or M if you have a EP93xx board and want to use iis audio and 
+	  to use CS4228A and CS4271.
+
+config CODEC_CS4228A
+	tristate "Cirrus cs4228a 6-channels sound"
+	depends on ARCH_EP9307 || ARCH_EP9312 || ARCH_EP9315
+	help
+	  This module drives the Cirrus Logic device CS4281A when wired
+	  as native sound drivers with I2S codecs. It olny work on
+	  EDB9307/12/15 with disable CS4202 driver.
+                                                                                                                             
+config CODEC_CS4271
+	tristate "Cirrus cs4271 2-channels sound"
+	depends on ARCH_EP9301 || ARCH_EP9302 || ARCH_EP9315A || ARCH_EP9307A || ARCH_EP9302A
+	help
+	  This module drives the Cirrus Logic device CS4271 when wired
+	  as native sound drivers with I2S codecs. It olny work on
+	  EDB9301/02/15A with disable CS4202 driver.
+
+
+config CODEC_KENWOOD
+	tristate "KENWOOD 2-channels sound"
+	depends on (ARCH_EP9307 || ARCH_EP9312 || ARCH_EP9315) && SND_EP93XX_IIS && !CODEC_CS4271 && !CODEC_CS4228A 
+	help
+		It only work on EDB9307/12/15 with disable CS4228A and CS4271
+
+config SND_EP93XX_AC97
+        tristate "AC97 driver for the Cirrus EP93xx chip"
+        depends on ARCH_EP93XX && SND
+        select SND_EP93XX_PCM
+        select SND_AC97_CODEC
+        help
+          Say Y or M if you want to support any AC97 codec attached to
+          the EP93xx AC97 interface.
+                                                                                                                             
+config SND_EP93XX_PCM
+        tristate
+        select SND_PCM
+        help
+          Generic PCM module for EP93xx
+
 endmenu
 
diff -burN linux-2.6.8.1-orig/sound/arm/Makefile linux-2.6.8.1/sound/arm/Makefile
--- linux-2.6.8.1-orig/sound/arm/Makefile	2004-08-14 19:56:15.000000000 +0900
+++ linux-2.6.8.1/sound/arm/Makefile	2007-01-24 13:03:31.000000000 +0900
@@ -3,6 +3,13 @@
 #
 
 snd-sa11xx-uda1341-objs := sa11xx-uda1341.o
+snd-ep93xx-i2s-objs := ep93xx-i2s.o
+snd-ep93xx-pcm-objs := ep93xx-alsa-pcm.o
+snd-ep93xx-ac97-objs := ep9xxx-alsa-ac97.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_SA11XX_UDA1341) += snd-sa11xx-uda1341.o 
+obj-$(CONFIG_SND_EP93XX_IIS) += snd-ep93xx-i2s.o
+obj-$(CONFIG_SND_EP93XX_PCM) += ep93xx-alsa-pcm.o
+obj-$(CONFIG_SND_EP93XX_AC97) += ep93xx-alsa-ac97.o
+
diff -burN linux-2.6.8.1-orig/sound/arm/ep93xx-alsa-ac97.c linux-2.6.8.1/sound/arm/ep93xx-alsa-ac97.c
--- linux-2.6.8.1-orig/sound/arm/ep93xx-alsa-ac97.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/sound/arm/ep93xx-alsa-ac97.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,1523 @@
+/*
+ * linux/sound/arm/ep93xx-alsa-ac97.c -- ALSA PCM interface for the edb93xx ac97 audio
+ *
+ * Author:      Shrek Wu
+ * Created:     July 19, 2005
+ * Copyright:   Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include <linux/sched.h>
+#include <linux/soundcard.h>
+#include <linux/version.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+
+#include <asm/irq.h>
+#include <asm/semaphore.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+//#include <asm/arch/dma-ep93xx.h>
+#include <asm/arch/dma.h>
+#include "ep93xx-alsa-pcm.h"
+
+
+/*------------------------------------------------------------------------------------*/
+#ifdef alsa_ac97_debug
+#define DEBUG( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DEBUG( fmt, arg... )
+#endif
+
+/*-------------------------------------------------------------------------------------*/
+#define	DRIVER_VERSION	"14-6-2005"
+#define	DRIVER_DESC	"EP93xx AC97 Audio driver"
+
+#define AUDIO_NAME      "ep93xx_ac97"
+#define AUDIO_SAMPLE_RATE_DEFAULT   44100
+static int ac_link_enabled = 0;
+static int codec_supported_mixers;
+
+
+static DECLARE_MUTEX(car_mutex);
+static DECLARE_WAIT_QUEUE_HEAD(gsr_wq);
+/*static volatile long gsr_bits;*/
+
+static snd_pcm_t *ep93xx_ac97_pcm;
+static ac97_t *ep93xx_ac97_ac97;
+
+/*-----------------------------------------------------------------------------------------*/
+
+static int		peek(unsigned int uiAddress);
+static int              poke(unsigned int uiAddress, unsigned int uiValue);
+static void     	ep93xx_setup_src(void);
+static void     	ep93xx_set_samplerate(long lFrequency, int bCapture);
+static void     	ep93xx_init_ac97_codec( void );
+static void     	ep93xx_set_hw_format( long format,long channel );
+static void             ep93xx_init_ac97_controller( void );
+
+static void             ep93xx_audio_enable( int input_or_output_stream );
+static void             ep93xx_audio_disable( int input_or_output_stream );
+
+static int 		ep93xx_ac97_pcm_startup(snd_pcm_substream_t *substream);
+static void 		ep93xx_ac97_pcm_shutdown(snd_pcm_substream_t *substream);
+static int 		ep93xx_ac97_pcm_prepare(snd_pcm_substream_t *substream);
+
+static int 		ep93xx_ac97_do_suspend(snd_card_t *card, unsigned int state);
+static int 		ep93xx_ac97_do_resume(snd_card_t *card, unsigned int state);
+
+/*----------------------------------------------------------------------------------------*/
+static audio_stream_t output_stream =
+{
+	.audio_num_channels 	=	EP93XX_DEFAULT_NUM_CHANNELS,
+	.audio_format 		=	EP93XX_DEFAULT_FORMAT,
+	.audio_stream_bitwidth 	=	EP93XX_DEFAULT_BIT_WIDTH,
+};
+
+static audio_stream_t input_stream =
+{
+	.audio_num_channels 	= EP93XX_DEFAULT_NUM_CHANNELS,
+	.audio_format 		= EP93XX_DEFAULT_FORMAT,
+	.audio_stream_bitwidth 	= EP93XX_DEFAULT_BIT_WIDTH,
+};
+
+static audio_state_t audio_state =
+{
+	.output_stream      	=&output_stream,
+	.output_dma        	=DMATx_AAC1,
+	.output_id          	="Ac97 out",
+	
+	.input_stream       	=&input_stream,
+	.input_dma          	=DMARx_AAC1,
+	.input_id           	="Ac97 in",
+	
+	.hw_enable          	=ep93xx_audio_enable,
+	.hw_disable         	=ep93xx_audio_disable,
+	//.client_ioctl       =ep93xx_audio_ioctl,
+	
+	.set_hw_serial_format	=ep93xx_set_hw_format,
+	
+	.startup		 = ep93xx_ac97_pcm_startup,
+	.shutdown	 = ep93xx_ac97_pcm_shutdown,
+	.prepare		 = ep93xx_ac97_pcm_prepare,
+	.sem                	 =__MUTEX_INITIALIZER(audio_state.sem),
+	
+	.DAC_bit_width		 =16,
+	.bCompactMode		 =0,
+	
+};
+
+
+
+/*----------------------------------------------------------------------------------------*/
+/*
+ * peek
+ *
+ * Reads an AC97 codec register.  Returns -1 if there was an error.
+ */
+static int peek(unsigned int uiAddress)
+{
+	unsigned int uiAC97RGIS;
+	
+	if( !ac_link_enabled )
+	{
+		printk("ep93xx ac97 peek: attempt to peek before enabling ac-link.\n");
+		return -1;
+	}
+	
+	/*
+	 * Check to make sure that the address is aligned on a word boundary 
+	 * and is 7E or less.
+	 */
+	if( ((uiAddress & 0x1)!=0) || (uiAddress > 0x007e))
+	{
+		return -1;
+	}
+
+	/*
+	 * How it is supposed to work is:
+	 *  - The ac97 controller sends out a read addr in slot 1.
+	 *  - In the next frame, the codec will echo that address back in slot 1
+	 *    and send the data in slot 2.  SLOT2RXVALID will be set to 1.
+	 *
+	 * Read until SLOT2RXVALID goes to 1.  Reading the data in AC97S2DATA
+	 * clears SLOT2RXVALID.
+	 */
+
+	/*
+	 * First, delay one frame in case of back to back peeks/pokes.
+	 */
+	mdelay( 1 );
+
+	/*
+	 * Write the address to AC97S1DATA, delay 1 frame, read the flags.
+	 */
+	outl( uiAddress, AC97S1DATA);
+	udelay( 21 * 4 );
+	uiAC97RGIS = inl( AC97RGIS );
+
+	/*
+	 * Return error if we timed out.
+	 */
+	if( ((uiAC97RGIS & AC97RGIS_SLOT1TXCOMPLETE) == 0 ) &&
+		((uiAC97RGIS & AC97RGIS_SLOT2RXVALID) == 0 ) )
+	{
+		printk( "ep93xx-ac97 - peek failed reading reg 0x%02x.\n", uiAddress ); 
+		return -1;
+	}
+	
+	return ( inl(AC97S2DATA) & 0x000fffff);
+}
+
+/*
+ * poke
+ *
+ * Writes an AC97 codec Register.  Return -1 if error.
+ */
+static int poke(unsigned int uiAddress, unsigned int uiValue)
+{
+	unsigned int uiAC97RGIS;
+
+	if( !ac_link_enabled )
+	{
+		printk("ep93xx ac97 poke: attempt to poke before enabling ac-link.\n");
+		return -1;
+	}
+	
+	/*
+	 * Check to make sure that the address is align on a word boundary and
+	 * is 7E or less.  And that the value is a 16 bit value.
+	 */
+	if( ((uiAddress & 0x1)!=0) || (uiAddress > 0x007e))
+	{
+		printk("ep93xx ac97 poke: address error.\n");
+		return -1;
+	}
+ 	
+	/*stop the audio loop from the input to the output directly*/
+
+	if((uiAddress==AC97_0E_MIC_VOL)||(uiAddress==AC97_10_LINE_IN_VOL))
+	{
+		uiValue = (uiValue | 0x8000);
+	
+	}
+	
+	/*
+	 * First, delay one frame in case of back to back peeks/pokes.
+	 */
+	mdelay( 1 );
+
+	/*
+	 * Write the data to AC97S2DATA, then the address to AC97S1DATA.
+	 */
+	outl( uiValue, AC97S2DATA );
+	outl( uiAddress, AC97S1DATA );
+	
+	/*
+	 * Wait for the tx to complete, get status.
+	 */
+	udelay( 30 );/*21*/
+	uiAC97RGIS = inl(AC97RGIS);
+
+	/*
+	 * Return error if we timed out.
+	 */
+	if( !(inl(AC97RGIS) & AC97RGIS_SLOT1TXCOMPLETE) )
+	{
+		printk( "ep93xx-ac97: poke failed writing reg 0x%02x  value 0x%02x.\n", uiAddress, uiValue ); 
+		return -1;
+	}
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+/*
+ * When we get to the multichannel case the pre-fill and enable code
+ * will go to the dma driver's start routine.
+ */
+static void ep93xx_audio_enable( int input_or_output_stream )
+{
+	unsigned int uiTemp;
+
+	DEBUG("ep93xx_audio_enable :%x\n",input_or_output_stream);
+
+	/*
+	 * Enable the rx or tx channel depending on the value of 
+	 * input_or_output_stream
+	 */
+	if( input_or_output_stream )
+	{
+		uiTemp = inl(AC97TXCR1);
+		outl( (uiTemp | AC97TXCR_TEN), AC97TXCR1 );
+	}
+	else
+	{
+		uiTemp = inl(AC97RXCR1);
+		outl( (uiTemp | AC97RXCR_REN), AC97RXCR1 );
+	}
+	
+	
+	//DDEBUG("ep93xx_audio_enable - EXIT\n");
+}
+
+static void ep93xx_audio_disable( int input_or_output_stream )
+{
+	unsigned int uiTemp;
+
+	DEBUG("ep93xx_audio_disable\n");
+
+	/*
+	 * Disable the rx or tx channel depending on the value of 
+	 * input_or_output_stream
+	 */
+	if( input_or_output_stream )
+	{
+		uiTemp = inl(AC97TXCR1);
+		outl( (uiTemp & ~AC97TXCR_TEN), AC97TXCR1 );
+	}
+	else
+	{
+		uiTemp = inl(AC97RXCR1);
+		outl( (uiTemp & ~AC97RXCR_REN), AC97RXCR1 );
+	}
+
+	//DDEBUG("ep93xx_audio_disable - EXIT\n");
+}
+
+
+/*
+ *cirrus EPD use the cs4202 to be ac97 extern codec
+ *The AC97 input use slot 3\4\6\7\8\  to PCM,11    to SPDIF
+ *The AC97 input use slot 3\4\6\7\8\9 to PCM,11\10 to SPDIF
+ */
+/*
+static void
+ep93xx_set_ac97_slots(unsigned long slots,unsigned short dir)
+{
+	if(dir==SNDRV_PCM_STREAM_PLAYBACK)	
+		outl( slots, AC97TXCR1 );
+	else if(dir==SNDRV_PCM_STREAM_CAPTURE)
+		outl( slots, AC97RXCR1 );
+	else
+		printk("%s substream->stream %x error,slots=%x \n",__FUNCTION__,dir,slots);
+}
+
+static void
+ep93xx_set_ac97_channel(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if(runtime->channels==2)
+		ep93xx_set_ac97_slots(AC97_SLOT_4|AC97_SLOT_3,substream->stream);
+	else if(runtime->channels==4)
+		ep93xx_set_ac97_slots(AC97_SLOT_7|AC97_SLOT_6|AC97_SLOT_4|AC97_SLOT_3,substream->stream);
+	else if(runtime->channels==5)
+		ep93xx_set_ac97_slots(AC97_SLOT_8|AC97_SLOT_7|AC97_SLOT_6|AC97_SLOT_4|AC97_SLOT_3,substream->stream);
+	else if(runtime->channels==6)
+		ep93xx_set_ac97_slots(AC97_SLOT_9|AC97_SLOT_8|AC97_SLOT_7|AC97_SLOT_6|AC97_SLOT_4|AC97_SLOT_3,substream->stream);
+	else
+		printk("%s:ac97 the number of the channel is %x\n",__FUNCTION__,runtime->channels);
+}
+
+static void
+ep93xx_set_ac97_spdif_channel(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	if(substream->stream==SNDRV_PCM_STREAM_PLAYBACK)
+		ep93xx_set_ac97_slots(AC97_SLOT_11|AC97_SLOT_10,substream->stream);
+	else if(substream->stream==SNDRV_PCM_STREAM_PLAYBACK)
+		ep93xx_set_ac97_slots(AC97_SLOT_11,substream->stream);
+}
+
+*/
+
+/*
+ * ep93xx_setup_src
+ *
+ * Once the ac-link is up and all is good, we want to set the codec to a 
+ * usable mode.
+ */
+static void ep93xx_setup_src(void)
+{
+	int iTemp;
+
+	/*
+	 * Set the VRA bit to enable the SRC.
+	 */
+	iTemp = peek( AC97_2A_EXT_AUDIO_POWER );
+	poke( AC97_2A_EXT_AUDIO_POWER,  (iTemp | 0x1) );
+	
+	/*
+	 * Set the DSRC/ASRC bits to enable the variable rate SRC.
+	 */
+	iTemp = peek( AC97_60_MISC_CRYSTAL_CONTROL  );
+	poke( AC97_60_MISC_CRYSTAL_CONTROL, (iTemp  | 0x0300) );
+}
+
+/*
+ * ep93xx_set_samplerate
+ *
+ *   lFrequency       - Sample Rate in Hz
+ *   bCapture       - 0 to set Tx sample rate; 1 to set Rx sample rate
+ */
+static void ep93xx_set_samplerate( long lSampleRate, int bCapture )
+{
+	unsigned short usDivider, usPhase;
+
+	DEBUG( "ep93xx_set_samplerate - Fs = %d\n", (int)lSampleRate );
+
+	if( (lSampleRate <  7200) || (lSampleRate > 48000)  )
+	{
+		printk( "ep93xx_set_samplerate - invalid Fs = %d\n", 
+				 (int)lSampleRate );
+		return;
+	}
+
+	/*
+	 * Calculate divider and phase increment.
+	 *
+	 * divider = round( 0x1770000 / lSampleRate )
+	 *  Note that usually rounding is done by adding 0.5 to a floating 
+	 *  value and then truncating.  To do this without using floating
+	 *  point, I multiply the fraction by two, do the division, then add one, 
+	 *  then divide the whole by 2 and then truncate.
+	 *  Same effect, no floating point math.
+	 *
+	 * Ph incr = trunc( (0x1000000 / usDivider) + 1 )
+	 */
+
+	usDivider = (unsigned short)( ((2 * 0x1770000 / lSampleRate) +  1) / 2 );
+
+	usPhase = (0x1000000 / usDivider) + 1;
+
+	/*
+	 * Write them in the registers.  Spec says divider must be
+	 * written after phase incr.
+	 */
+	if(!bCapture)
+	{
+		poke( AC97_2C_PCM_FRONT_DAC_RATE, usDivider);
+		poke( AC97_64_DAC_SRC_PHASE_INCR, usPhase);
+	}
+	else
+	{
+		
+		poke( AC97_32_PCM_LR_ADC_RATE,  usDivider);
+		poke( AC97_66_ADC_SRC_PHASE_INCR, usPhase);
+	}
+	
+	DEBUG( "ep93xx_set_samplerate - phase = %d,  divider = %d\n",
+				(unsigned int)usPhase, (unsigned int)usDivider );
+
+	/*
+	 * We sorta should report the actual samplerate back to the calling
+	 * application.  But some applications freak out if they don't get
+	 * exactly what they asked for.  So we fudge and tell them what
+	 * they want to hear.
+	 */
+	//audio_samplerate = lSampleRate;
+
+	DEBUG( "ep93xx_set_samplerate - EXIT\n" );
+}
+
+/*
+ * ep93xx_stop_loop
+ *
+ * Once the ac-link is up and all is good, we want to set the codec to a
+ * usable mode.
+ */
+static void ep93xx_stop_loop(void)
+{
+        int iTemp;
+                                                                                                                             
+        /*
+         * Set the AC97_0E_MIC_VOL MUTE bit to enable the LOOP.
+         */
+        iTemp = peek( AC97_0E_MIC_VOL );
+        poke( AC97_0E_MIC_VOL,  (iTemp | 0x8000) );
+                                                                                                                             
+        /*
+         * Set the AC97_10_LINE_IN_VOL MUTE bit to enable the LOOP.
+         */
+        iTemp = peek( AC97_10_LINE_IN_VOL  );
+        poke( AC97_10_LINE_IN_VOL, (iTemp  | 0x8000) );
+}
+
+/*
+ * ep93xx_set_hw_format
+ *
+ * Sets up whether the controller is expecting 20 bit data in 32 bit words
+ * or 16 bit data compacted to have a stereo sample in each 32 bit word.
+ */
+static void ep93xx_set_hw_format( long format,long channel )
+{
+	int bCompactMode;
+	
+	switch( format )
+	{
+		/*
+		 * Here's all the <=16 bit formats.  We can squeeze both L and R
+		 * into one 32 bit sample so use compact mode.
+		 */
+		case /*AFMT_U8*/ 	SNDRV_PCM_FORMAT_U8:		   
+		case /*AFMT_S8*/ 	SNDRV_PCM_FORMAT_S8:		   
+		case /*AFMT_S16_LE*/ 	SNDRV_PCM_FORMAT_S16_LE:
+		case /*AFMT_U16_LE*/ 	SNDRV_PCM_FORMAT_U16_LE:
+			bCompactMode = 1;
+			break;
+
+		/*
+		 * Add any other >16 bit formats here...
+		 */
+		case /*AFMT_S32_BLOCKED*/ SNDRV_PCM_FORMAT_S32_LE:
+		default:
+			bCompactMode = 0;
+			break;
+	}
+	
+	if( bCompactMode )
+	{
+		DEBUG("ep93xx_set_hw_format - Setting serial mode to 16 bit compact.\n");
+	
+		/*
+		 * Turn on Compact Mode so we can fit each stereo sample into
+		 * a 32 bit word.  Twice as efficent for DMA and FIFOs.
+		 */
+		if(channel==2){
+			outl( 0x00008018, AC97RXCR1 );
+			outl( 0x00008018, AC97TXCR1 );
+		}
+		else {
+		        outl( 0x00008018, AC97RXCR1 );
+                        outl( 0x00008018, AC97TXCR1 );
+                }
+
+
+		audio_state.DAC_bit_width = 16;
+		audio_state.bCompactMode = 1;
+	}
+	else
+	{
+		DEBUG("ep93xx_set_hw_format - Setting serial mode to 20 bit non-CM.\n");
+	
+		/*
+		 * Turn off Compact Mode so we can do > 16 bits per channel 
+		 */
+		if(channel==2){
+			outl( 0x00004018, AC97RXCR1 );
+			outl( 0x00004018, AC97TXCR1 );
+		}
+		else{
+                        outl( 0x00004018, AC97RXCR1 );
+                        outl( 0x00004018, AC97TXCR1 );
+		}
+
+		audio_state.DAC_bit_width = 20;
+		audio_state.bCompactMode = 0;
+	}
+
+}
+
+
+static int
+ep93xx_set_ac97_rate(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int ret=0,reg;
+	
+	//if((runtime->channels==2)||(runtime->channels==1)){
+		reg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		  	 AC97_PCM_FRONT_DAC_RATE : AC97_PCM_LR_ADC_RATE;
+	//	ret =snd_ac97_set_rate(ep93xx_ac97_ac97, reg, runtime->rate);
+	ep93xx_set_samplerate(runtime->rate,0);
+	ep93xx_set_samplerate(runtime->rate,1);
+	//}
+	//else{
+		DEBUG("%s:ac97 the number of the channel is %x\n",__FUNCTION__,runtime->channels);
+	//	ret=0;
+	//}
+
+	return ret;
+}
+
+
+
+/*
+ * ep93xx_init_ac97_controller
+ *
+ * This routine sets up the Ac'97 Controller.
+ */
+static void ep93xx_init_ac97_controller(void)
+{
+	unsigned int uiDEVCFG, uiTemp;
+
+	DEBUG("ep93xx_init_ac97_controller - enter\n");
+
+	/*
+	 * Configure the multiplexed Ac'97 pins to be Ac97 not I2s.
+	 * Configure the EGPIO4 and EGPIO6 to be GPIOS, not to be  
+	 * SDOUT's for the second and third I2S controller channels.
+	 */
+	uiDEVCFG = inl(SYSCON_DEVCFG);
+	
+	uiDEVCFG &= ~(SYSCON_DEVCFG_I2SonAC97 | 
+				  SYSCON_DEVCFG_A1onG |
+				  SYSCON_DEVCFG_A2onG);
+		
+	SysconSetLocked(SYSCON_DEVCFG, uiDEVCFG);
+
+	/*
+	 * Disable the AC97 controller internal loopback.  
+	 * Disable Override codec ready.
+	 */
+	outl( 0, AC97GCR );
+
+	/*
+	 * Enable the AC97 Link.
+	 */
+	uiTemp = inl(AC97GCR);
+	outl( (uiTemp | AC97GSR_IFE), AC97GCR );
+
+	/*
+	 * Set the TIMEDRESET bit.  Will cause a > 1uSec reset of the ac-link.
+	 * This bit is self resetting.
+	 */
+	outl( AC97RESET_TIMEDRESET, AC97RESET );
+	
+	/*
+	 *  Delay briefly, but let's not hog the processor.
+	 */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout( 5 ); /* 50 mSec */
+
+	/*
+	 * Read the AC97 status register to see if we've seen a CODECREADY
+	 * signal from the AC97 codec.
+	 */
+	if( !(inl(AC97RGIS) & AC97RGIS_CODECREADY))
+	{
+		printk( "ep93xx-ac97 - FAIL: CODECREADY still low!\n");
+		return;
+	}
+
+	/*
+	 *  Delay for a second, not hogging the processor
+	 */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout( HZ ); /* 1 Sec */
+	
+	/*
+	 * Now the Ac-link is up.  We can read and write codec registers.
+	 */
+	ac_link_enabled = 1;
+
+	/*
+	 * Set up the rx and tx channels
+	 * Set the CM bit, data size=16 bits, enable tx slots 3 & 4.
+	 */
+	ep93xx_set_hw_format( EP93XX_DEFAULT_FORMAT,EP93XX_DEFAULT_NUM_CHANNELS );
+
+	DEBUG( "ep93xx-ac97 -- AC97RXCR1:  %08x\n", inl(AC97RXCR1) ); 
+	DEBUG( "ep93xx-ac97 -- AC97TXCR1:  %08x\n", inl(AC97TXCR1) ); 
+
+	DEBUG("ep93xx_init_ac97_controller - EXIT - success\n");
+
+}
+
+
+
+
+#define supported_mixer(FOO) \
+        ( (FOO >= 0) && \
+        (FOO < SOUND_MIXER_NRDEVICES) && \
+        codec_supported_mixers & (1<<FOO) )
+                                                                                                                             
+/*
+ * Available record sources.
+ * LINE1 refers to AUX in.
+ * IGAIN refers to input gain which means stereo mix.
+ */
+#define AC97_RECORD_MASK \
+        (SOUND_MASK_MIC | SOUND_MASK_CD | SOUND_MASK_IGAIN | SOUND_MASK_VIDEO |\
+        SOUND_MASK_LINE1 | SOUND_MASK_LINE | SOUND_MASK_PHONEIN)
+                                                                                                                             
+#define AC97_STEREO_MASK \
+        (SOUND_MASK_VOLUME | SOUND_MASK_PCM | SOUND_MASK_LINE | SOUND_MASK_CD | \
+        SOUND_MASK_ALTPCM | SOUND_MASK_IGAIN | SOUND_MASK_LINE1 | SOUND_MASK_VIDEO)
+                                                                                                                             
+#define AC97_SUPPORTED_MASK \
+        (AC97_STEREO_MASK | SOUND_MASK_BASS | SOUND_MASK_TREBLE | \
+        SOUND_MASK_SPEAKER | SOUND_MASK_MIC | \
+        SOUND_MASK_PHONEIN | SOUND_MASK_PHONEOUT)
+
+
+
+
+/* this table has default mixer values for all OSS mixers. */
+typedef struct  {
+	int mixer;
+	unsigned int value;
+} mixer_defaults_t;
+
+/*
+ * Default mixer settings that are set up during boot.
+ *
+ * These values are 16 bit numbers in which the upper byte is right volume
+ * and the lower byte is left volume or mono volume for mono controls.
+ *
+ * OSS Range for each of left and right volumes is 0 to 100 (0x00 to 0x64).
+ * 
+ */
+static mixer_defaults_t mixer_defaults[SOUND_MIXER_NRDEVICES] = 
+{
+	/* Outputs */
+	{SOUND_MIXER_VOLUME,	0x6464},   /* 0 dB */  /* -46.5dB to  0 dB */
+	{SOUND_MIXER_ALTPCM,	0x6464},   /* 0 dB */  /* -46.5dB to  0 dB */
+	{SOUND_MIXER_PHONEOUT,	0x6464},   /* 0 dB */  /* -46.5dB to  0 dB */
+
+	/* PCM playback gain */
+	{SOUND_MIXER_PCM,		0x4b4b},   /* 0 dB */  /* -34.5dB to +12dB */
+
+	/* Record gain */
+	{SOUND_MIXER_IGAIN,		0x0000},   /* 0 dB */  /* -34.5dB to +12dB */
+
+	/* Inputs */
+	{SOUND_MIXER_MIC,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_LINE,		0x4b4b},   /* 0 dB */  /* -34.5dB to +12dB */
+
+	/* Inputs that are not connected. */
+	{SOUND_MIXER_SPEAKER,	0x0000},   /* mute */  /* -45dB   to   0dB */
+	{SOUND_MIXER_PHONEIN,	0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_CD,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_VIDEO,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+	{SOUND_MIXER_LINE1,		0x0000},   /* mute */  /* -34.5dB to +12dB */
+
+	{-1,0} /* last entry */
+};
+
+/* table to scale scale from OSS mixer value to AC97 mixer register value */	
+typedef struct {
+	unsigned int offset;
+	int scale;
+} ac97_mixer_hw_t; 
+
+static ac97_mixer_hw_t ac97_hw[SOUND_MIXER_NRDEVICES] = 
+{
+	[SOUND_MIXER_VOLUME]		=  	{AC97_02_MASTER_VOL,	64},
+	[SOUND_MIXER_BASS]			=	{0, 0},
+	[SOUND_MIXER_TREBLE]		=	{0, 0},
+	[SOUND_MIXER_SYNTH]			=  	{0,	0},
+	[SOUND_MIXER_PCM]			=  	{AC97_18_PCM_OUT_VOL,	32},
+	[SOUND_MIXER_SPEAKER]		=  	{AC97_0A_PC_BEEP_VOL,	32},
+	[SOUND_MIXER_LINE]			=  	{AC97_10_LINE_IN_VOL,	32},
+	[SOUND_MIXER_MIC]			=  	{AC97_0E_MIC_VOL,		32},
+	[SOUND_MIXER_CD]			=  	{AC97_12_CD_VOL,		32},
+	[SOUND_MIXER_IMIX]			=  	{0,	0},
+	[SOUND_MIXER_ALTPCM]		=  	{AC97_04_HEADPHONE_VOL,	64},
+	[SOUND_MIXER_RECLEV]		=  	{0,	0},
+	[SOUND_MIXER_IGAIN]			=  	{AC97_1C_RECORD_GAIN,	16},
+	[SOUND_MIXER_OGAIN]			=  	{0,	0},
+	[SOUND_MIXER_LINE1]			=  	{AC97_16_AUX_VOL,		32},
+	[SOUND_MIXER_LINE2]			=  	{0,	0},
+	[SOUND_MIXER_LINE3]			=  	{0,	0},
+	[SOUND_MIXER_DIGITAL1]		=  	{0,	0},
+	[SOUND_MIXER_DIGITAL2]		=  	{0,	0},
+	[SOUND_MIXER_DIGITAL3]		=  	{0,	0},
+	[SOUND_MIXER_PHONEIN]		=  	{AC97_0C_PHONE_VOL,		32},
+	[SOUND_MIXER_PHONEOUT]		=  	{AC97_06_MONO_VOL,		64},
+	[SOUND_MIXER_VIDEO]			=  	{AC97_14_VIDEO_VOL,		32},
+	[SOUND_MIXER_RADIO]			=  	{0,	0},
+	[SOUND_MIXER_MONITOR]		=  	{0,	0},
+};
+
+
+/* the following tables allow us to go from OSS <-> ac97 quickly. */
+enum ac97_recsettings 
+{
+	AC97_REC_MIC=0,
+	AC97_REC_CD,
+	AC97_REC_VIDEO,
+	AC97_REC_AUX,
+	AC97_REC_LINE,
+	AC97_REC_STEREO, /* combination of all enabled outputs..  */
+	AC97_REC_MONO,	      /*.. or the mono equivalent */
+	AC97_REC_PHONE
+};
+
+static const unsigned int ac97_rm2oss[] = 
+{
+	[AC97_REC_MIC] 	 = SOUND_MIXER_MIC,
+	[AC97_REC_CD] 	 = SOUND_MIXER_CD,
+	[AC97_REC_VIDEO] = SOUND_MIXER_VIDEO,
+	[AC97_REC_AUX] 	 = SOUND_MIXER_LINE1,
+	[AC97_REC_LINE]  = SOUND_MIXER_LINE,
+	[AC97_REC_STEREO]= SOUND_MIXER_IGAIN,
+	[AC97_REC_PHONE] = SOUND_MIXER_PHONEIN
+};
+
+/* indexed by bit position */
+static const unsigned int ac97_oss_rm[] = 
+{
+	[SOUND_MIXER_MIC] 	= AC97_REC_MIC,
+	[SOUND_MIXER_CD] 	= AC97_REC_CD,
+	[SOUND_MIXER_VIDEO] = AC97_REC_VIDEO,
+	[SOUND_MIXER_LINE1] = AC97_REC_AUX,
+	[SOUND_MIXER_LINE] 	= AC97_REC_LINE,
+	[SOUND_MIXER_IGAIN]	= AC97_REC_STEREO,
+	[SOUND_MIXER_PHONEIN] 	= AC97_REC_PHONE
+};
+
+
+/* reads the given OSS mixer from the ac97 the caller must have insured that the ac97 knows
+   about that given mixer, and should be holding a spinlock for the card */
+/*
+static int ep93xx_read_mixer( int oss_channel ) 
+{
+	u16 val;
+	int ret = 0;
+	ac97_mixer_hw_t * mh = &ac97_hw[oss_channel];
+
+	if( !mh->scale )
+	{
+		printk( "ep93xx-ac97.c: ep93xx_read_mixer - not a valid OSS channel\n");
+		return 0;
+	}
+
+	val = peek( mh->offset );
+	
+	if( val & 0x8000 ) 
+	{
+		ret = 0;
+	}
+	else if (AC97_STEREO_MASK & (1 << oss_channel)) 
+	{
+		int left,right;
+
+		left = (val >> 8)  & 0x7f;
+		right = val  & 0x7f;
+
+		right = 100 - ((right * 100) / mh->scale);
+		left = 100 - ((left * 100) / mh->scale);
+
+		ret = ((right << 8) | left);
+	}
+	else if (oss_channel == SOUND_MIXER_SPEAKER) 
+	{
+		ret = 100 - ((((val & 0x1e)>>1) * 100) / mh->scale);
+	}
+	else if( (oss_channel == SOUND_MIXER_PHONEIN) ||
+		(oss_channel == SOUND_MIXER_PHONEOUT) ||
+		(oss_channel == SOUND_MIXER_MIC) )
+	{
+		ret = 100 - (((val & 0x1f) * 100) / mh->scale);
+	} 
+	//  
+	// For bass and treble, the low bit is optional.  Masking it
+	// lets us avoid the 0xf 'bypass'.. 
+	//
+	else if (oss_channel == SOUND_MIXER_BASS) 
+	{
+		ret = 100 - ((((val >> 8) & 0xe) * 100) / mh->scale);
+	} 
+	else if (oss_channel == SOUND_MIXER_TREBLE) 
+	{
+		ret = 100 - (((val & 0xe) * 100) / mh->scale);
+	}
+	
+	DEBUG("ac97_codec: read OSS mixer %2d (ac97 register 0x%02x), "
+	       "0x%04x -> 0x%04x\n",
+	       oss_channel, mh->offset, val, ret);
+
+	return ret;
+}
+*/
+
+/*
+ * ep93xx_write_mixer
+ *
+ */
+static void ep93xx_write_mixer
+( 
+	int oss_channel,
+	unsigned int left, 
+	unsigned int right
+)
+{
+	u16 val = 0;
+	ac97_mixer_hw_t * mh = &ac97_hw[oss_channel];
+
+	DEBUG("ac97_codec: wrote OSS %2d (ac97 0x%02x), "
+	       "l:%2d, r:%2d:",
+	       oss_channel, mh->offset, left, right);
+
+	if( !mh->scale )
+	{
+		printk( "ep93xx-ac97.c: ep93xx_write_mixer - not a valid OSS channel\n");
+		return;
+	}
+
+	if( AC97_STEREO_MASK & (1 << oss_channel) ) 
+	{
+		/* stereo mixers */
+		if (left == 0 && right == 0) 
+		{
+			val = 0x8000;
+		} 
+		else 
+		{
+			if (oss_channel == SOUND_MIXER_IGAIN) 
+			{
+				right = (right * mh->scale) / 100;
+				left = (left * mh->scale) / 100;
+				if (right >= mh->scale)
+					right = mh->scale-1;
+				if (left >= mh->scale)
+					left = mh->scale-1;
+			} 
+			else 
+			{
+				right = ((100 - right) * mh->scale) / 100;
+				left = ((100 - left) * mh->scale) / 100;
+				if (right >= mh->scale)
+					right = mh->scale-1;
+				if (left >= mh->scale)
+					left = mh->scale-1;
+			}
+			val = (left << 8) | right;
+		}
+	} 
+	else if(left == 0) 
+	{
+		val = 0x8000;
+	} 
+	else if( (oss_channel == SOUND_MIXER_SPEAKER) ||
+			(oss_channel == SOUND_MIXER_PHONEIN) ||
+			(oss_channel == SOUND_MIXER_PHONEOUT) )
+	{
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val = left;
+	} 
+	else if (oss_channel == SOUND_MIXER_MIC) 
+	{
+		val = peek( mh->offset) & ~0x801f;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= left;
+	} 
+	/*  
+	 * For bass and treble, the low bit is optional.  Masking it
+	 * lets us avoid the 0xf 'bypass'.
+	 * Do a read, modify, write as we have two contols in one reg. 
+	 */
+	else if (oss_channel == SOUND_MIXER_BASS) 
+	{
+		val = peek( mh->offset) & ~0x0f00;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= (left << 8) & 0x0e00;
+	} 
+	else if (oss_channel == SOUND_MIXER_TREBLE) 
+	{
+		val = peek( mh->offset) & ~0x000f;
+		left = ((100 - left) * mh->scale) / 100;
+		if (left >= mh->scale)
+			left = mh->scale-1;
+		val |= left & 0x000e;
+	}
+	
+	DEBUG(" 0x%04x", val);
+
+	poke( mh->offset, val );
+
+#ifdef alsa_ac97_debug
+	val = peek( mh->offset );
+	DEBUG(" -> 0x%04x\n", val);
+#endif
+
+}
+
+/* a thin wrapper for write_mixer */
+static void ep93xx_set_mixer
+(
+	unsigned int oss_mixer, 
+	unsigned int val 
+) 
+{
+	unsigned int left,right;
+
+	/* cleanse input a little */
+	right = ((val >> 8)  & 0xff) ;
+	left = (val  & 0xff) ;
+
+	if (right > 100) right = 100;
+	if (left > 100) left = 100;
+
+	/*mixer_state[oss_mixer] = (right << 8) | left;*/
+	ep93xx_write_mixer( oss_mixer, left, right);
+}
+
+static void ep93xx_init_mixer(void)
+{
+	u16 cap;
+	int i;
+
+	/* mixer masks */
+	codec_supported_mixers 	= AC97_SUPPORTED_MASK;
+	
+	cap = peek( AC97_00_RESET );
+	if( !(cap & 0x04) )
+	{
+		codec_supported_mixers &= ~(SOUND_MASK_BASS|SOUND_MASK_TREBLE);
+	}
+	if( !(cap & 0x10) )
+	{
+		codec_supported_mixers &= ~SOUND_MASK_ALTPCM;
+	}
+
+	/* 
+	 * Detect bit resolution of output volume controls by writing to the
+	 * 6th bit (not unmuting yet)
+	 */
+	poke( AC97_02_MASTER_VOL, 0xa020 );
+	if( peek( AC97_02_MASTER_VOL) != 0xa020 )
+	{
+		ac97_hw[SOUND_MIXER_VOLUME].scale = 32;
+	}
+
+	poke( AC97_04_HEADPHONE_VOL, 0xa020 );
+	if( peek( AC97_04_HEADPHONE_VOL) != 0xa020 )
+	{
+		ac97_hw[AC97_04_HEADPHONE_VOL].scale = 32;
+	}
+
+	poke( AC97_06_MONO_VOL, 0x8020 );
+	if( peek( AC97_06_MONO_VOL) != 0x8020 )
+	{
+		ac97_hw[AC97_06_MONO_VOL].scale = 32;
+	}
+
+	/* initialize mixer channel volumes */
+	for( i = 0; 
+		(i < SOUND_MIXER_NRDEVICES) && (mixer_defaults[i].mixer != -1) ; 
+		i++ ) 
+	{
+		if( !supported_mixer( mixer_defaults[i].mixer) )
+		{ 
+			continue;
+		}
+		
+		ep93xx_set_mixer( mixer_defaults[i].mixer, mixer_defaults[i].value);
+	}
+
+}
+
+
+/*
+ * ac97_recmask_io
+ *
+ * Read or write the record source.
+ */
+/*
+static int ep93xx_read_recsource(void) 
+{
+	unsigned int val;
+
+	// read it from the card 
+	val = peek( AC97_1A_RECORD_SELECT );
+	
+	DEBUG("ac97_codec: ac97 recmask to set to 0x%04x\n", val);
+	
+	return( 1 << ac97_rm2oss[val & 0x07] );
+}
+*/
+
+static int ep93xx_set_recsource( int mask ) 
+{
+	unsigned int val;
+
+	/* Arg contains a bit for each recording source */
+	if( mask == 0 ) 
+	{
+		return 0;
+	}
+	
+	mask &= AC97_RECORD_MASK;
+	
+	if( mask == 0 ) 
+	{
+		return -EINVAL;
+	}
+				
+	/*
+	 * May have more than one bit set.  So clear out currently selected
+	 * record source value first (AC97 supports only 1 input) 
+	 */
+	val = (1 << ac97_rm2oss[peek( AC97_1A_RECORD_SELECT ) & 0x07]);
+	if (mask != val)
+	    mask &= ~val;
+       
+	val = ffs(mask); 
+	val = ac97_oss_rm[val-1];
+	val |= val << 8;  /* set both channels */
+
+	/*
+	 *
+	 */
+        val = peek( AC97_1A_RECORD_SELECT ) & 0x0707;
+        if ((val&0x0404)!=0)
+          val=0x0404;
+        else if((val&0x0000)!=0)
+          val=0x0101;
+
+
+	DEBUG("ac97_codec: setting ac97 recmask to 0x%04x\n", val);
+
+	poke( AC97_1A_RECORD_SELECT, val);
+
+	return 0;
+}
+
+
+
+
+
+
+/*
+ * ep93xx_init_ac97_codec
+ *
+ * Program up the external Ac97 codec.
+ *
+ */
+static void ep93xx_init_ac97_codec( void )
+{
+	DEBUG("ep93xx_init_ac97_codec - enter\n");
+
+	ep93xx_setup_src();
+	ep93xx_set_samplerate( AUDIO_SAMPLE_RATE_DEFAULT, 0 );
+	ep93xx_set_samplerate( AUDIO_SAMPLE_RATE_DEFAULT, 1 );
+	ep93xx_init_mixer();
+
+	DEBUG("ep93xx_init_ac97_codec - EXIT\n");
+	
+}
+
+#if alsa_ac97_debug
+static void ep93xx_dump_ac97_regs(void)
+{
+	int i;
+	unsigned int reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
+	
+	DEBUG( "---------------------------------------------\n");
+	DEBUG( "   :   0    2    4    6    8    A    C    E\n" ); 
+	
+	for( i=0 ; i < 0x80 ; i+=0x10 )
+	{
+		reg0 = 0xffff & (unsigned int)peek( i );
+		reg1 = 0xffff & (unsigned int)peek( i + 0x2 );
+		reg2 = 0xffff & (unsigned int)peek( i + 0x4 );
+		reg3 = 0xffff & (unsigned int)peek( i + 0x6 );
+		reg4 = 0xffff & (unsigned int)peek( i + 0x8 );
+		reg5 = 0xffff & (unsigned int)peek( i + 0xa );
+		reg6 = 0xffff & (unsigned int)peek( i + 0xc );
+		reg7 = 0xffff & (unsigned int)peek( i + 0xe );
+
+		DEBUG( " %02x : %04x %04x %04x %04x %04x %04x %04x %04x\n", 
+				 i, reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7);
+	}
+}
+#endif
+
+/*
+ * Audio interface
+ */
+static void ep93xx_audio_init(void *dummy)
+{
+	DEBUG("ep93xx_audio_init - enter\n");
+	/*
+	 * Init the controller, enable the ac-link.
+	 * Initialize the codec.
+	 */	 
+	ep93xx_init_ac97_controller();
+	ep93xx_init_ac97_codec();
+	/*stop the audio loop from the input to the output directly*/
+	ep93xx_stop_loop();
+	
+#if alsa_ac97_debug
+	ep93xx_dump_ac97_regs();
+#endif
+	DEBUG("ep93xx_audio_init - EXIT\n");
+}
+
+/*----------------------------------------------------------------------------------------*/
+static unsigned short ep93xx_ac97_read(ac97_t *ac97, unsigned short reg)
+{
+	int val = -1;
+	/*volatile u32 *reg_addr;*/
+
+	DEBUG(" number of codec:%x reg=%x\n",ac97->num,reg);
+	val=peek(reg);
+	if(val==-1){
+		printk(KERN_ERR "%s: read error (ac97_reg=%d )val=%x\n",
+				__FUNCTION__, reg, val);
+		return 0;
+	}
+
+	return val;
+}
+
+static void ep93xx_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
+{
+	/*volatile u32 *reg_addr;*/
+	int ret;
+
+	DEBUG(" number of codec:%x rge=%x val=%x\n",ac97->num,reg,val);
+	ret=poke(reg, val);
+	if(ret!=0){
+		printk(KERN_ERR "%s: write error (ac97_reg=%d val=%x)\n",
+				__FUNCTION__, reg, val);
+	}
+
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+static void ep93xx_ac97_reset(ac97_t *ac97)
+{
+
+	DEBUG(" ep93xx_ac97_reset\n");
+	ep93xx_audio_init(0);
+
+}
+
+static ac97_bus_ops_t ep93xx_ac97_ops = {
+	.read	= ep93xx_ac97_read,
+	.write	= ep93xx_ac97_write,
+	.reset	= ep93xx_ac97_reset,
+};
+#endif
+
+
+static int ep93xx_ac97_pcm_startup(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int r;
+	int iTempMasterVol,iTempHeadphoneVol,iTempMonoVol,iTempRecordSelect;
+        /*save the old mixer*/
+      	iTempRecordSelect 	= peek(AC97_1A_RECORD_SELECT);
+        iTempMasterVol		= peek( AC97_02_MASTER_VOL);
+        iTempHeadphoneVol	= peek( AC97_04_HEADPHONE_VOL);
+        iTempMonoVol		= peek( AC97_06_MONO_VOL);
+
+	runtime->hw.channels_min = 1;
+	runtime->hw.channels_max = 2;
+
+ 	ep93xx_audio_init( 0 );
+	/*ep93xx_init_ac97_controller();*/
+
+        /*reset the old output mixer*/
+        poke( AC97_02_MASTER_VOL, iTempMasterVol);
+        poke( AC97_04_HEADPHONE_VOL,iTempHeadphoneVol );
+        poke( AC97_06_MONO_VOL, iTempMonoVol);
+	poke( AC97_1A_RECORD_SELECT,iTempRecordSelect);
+		
+	r = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+	    AC97_RATES_FRONT_DAC : AC97_RATES_ADC;
+	
+	DEBUG(" ep93xx_ac97_pcm_startup=%x\n",r);
+
+		return 0;
+}
+
+static void ep93xx_ac97_pcm_shutdown(snd_pcm_substream_t *substream)
+{
+	DEBUG(" ep93xx_ac97_pcm_shutdown\n");
+
+}
+
+static int ep93xx_ac97_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	int ret=-1;
+
+	ret=ep93xx_set_ac97_rate(substream);
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE){
+		ep93xx_set_recsource(SOUND_MASK_MIC|SOUND_MASK_LINE1 | SOUND_MASK_LINE);
+		poke( AC97_1C_RECORD_GAIN, 0);
+	}
+#if alsa_ac97_debug
+	ep93xx_dump_ac97_regs();
+#endif
+
+	DEBUG(" ep93xx_ac97_pcm_prepare=%x\n",ret);
+	return ret;
+}
+
+/*----------------------------------------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+
+int ep93xx_ac97_do_suspend(snd_card_t *card, unsigned int state)
+{
+	if (card->power_state != SNDRV_CTL_POWER_D3cold) {
+		snd_pcm_suspend_all(ep93xx_ac97_pcm);
+		snd_ac97_suspend(ep93xx_ac97_ac97);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D3cold);
+	}
+
+	return 0;
+}
+
+int ep93xx_ac97_do_resume(snd_card_t *card, unsigned int state)
+{
+	if (card->power_state != SNDRV_CTL_POWER_D0) {
+
+		snd_ac97_resume(ep93xx_ac97_ac97);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	}
+
+	return 0;
+}
+
+int ep93xx_ac97_suspend(struct device *_dev, u32 state, u32 level)
+{
+	snd_card_t *card = dev_get_drvdata(_dev);
+	int ret = 0;
+
+	if (card && level == SUSPEND_DISABLE)
+		ret = ep93xx_ac97_do_suspend(card, SNDRV_CTL_POWER_D3cold);
+
+	return ret;
+}
+
+int ep93xx_ac97_resume(struct device *_dev, u32 level)
+{
+	snd_card_t *card = dev_get_drvdata(_dev);
+	int ret = 0;
+
+	if (card && level == RESUME_ENABLE)
+		ret = ep93xx_ac97_do_resume(card, SNDRV_CTL_POWER_D0);
+
+	return ret;
+}
+
+#else
+
+/*
+#define ep93xx_ac97_do_suspend		NULL
+#define ep93xx_ac97_do_resume		NULL
+#define ep93xx_ac97_suspend		NULL
+#define ep93xx_ac97_resume		NULL
+*/
+
+int ep93xx_ac97_do_suspend(snd_card_t *card, unsigned int state)
+{                                                                                                                            
+        return 0;
+}
+                                                                                                                             
+int ep93xx_ac97_do_resume(snd_card_t *card, unsigned int state)
+{                                                                                                                     
+        return 0;
+}
+
+int ep93xx_ac97_resume(struct device *_dev, u32 level)
+{
+        snd_card_t *card = dev_get_drvdata(_dev);
+        int ret = 0;
+                                                                                                                             
+        if (card && level == RESUME_ENABLE)
+                ret = ep93xx_ac97_do_resume(card, SNDRV_CTL_POWER_D0);
+                                                                                                                             
+        return ret;
+}
+
+int ep93xx_ac97_suspend(struct device *_dev, u32 state, u32 level)
+{
+        snd_card_t *card = dev_get_drvdata(_dev);
+        int ret = 0;
+                                                                                                                             
+        if (card && level == SUSPEND_DISABLE)
+                ret = ep93xx_ac97_do_suspend(card, SNDRV_CTL_POWER_D3cold);
+                                                                                                                             
+        return ret;
+}
+
+
+
+#endif
+
+static int ep93xx_ac97_probe(struct device *dev)
+{
+
+	snd_card_t *card;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	
+	ac97_bus_t *ac97_bus;
+	ac97_template_t ac97_template;
+
+#else
+	ac97_bus_t ac97_bus_ops, *ac97_bus;
+	ac97_t ac97;
+#endif
+	int ret;
+
+	/*
+	 * Enable audio early on, give the DAC time to come up.
+	 */ 
+	ep93xx_audio_init( 0 );
+	
+
+	ret = -ENOMEM;
+	/*regist the new card device*/
+	card = snd_card_new(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			    THIS_MODULE, 0);
+	if (!card){
+		printk("AC97: snd_card_new error\n");
+		goto err;
+	}
+
+	card->dev = dev;
+	
+	/*regist the new pcm device*/
+	ret = ep93xx_ac97_pcm_new(card, &audio_state, &ep93xx_ac97_pcm);
+	if (ret){
+		printk("AC97: ep93xx_ac97_pcm_new error\n");
+		goto err;
+	}
+		
+
+	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	/*regist the new ac97 device*/
+	ret = snd_ac97_bus(card, 0, &ep93xx_ac97_ops, NULL, &ac97_bus);
+	if (ret){
+		printk("AC97: snd_ac97_bus error\n");
+		goto err;
+	}
+	memset(&ac97_template, 0, sizeof(ac97_template));
+	ret = snd_ac97_mixer(ac97_bus, &ac97_template, &ep93xx_ac97_ac97);
+	if (ret){
+		printk("AC97: snd_ac97_mixer error\n");
+		goto err;
+	}
+	
+	strncpy(card->driver, dev->driver->name, sizeof(card->driver));
+
+	snprintf(card->shortname, sizeof(card->shortname),
+		 "%s", snd_ac97_get_short_name(ep93xx_ac97_ac97));
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s (%s)", dev->driver->name, card->mixername);
+	
+#else
+	memset(&ac97_bus_ops, 0, sizeof(ac97_bus_ops));
+	ac97_bus_ops.write = ep93xx_ac97_write;
+	ac97_bus_ops.read = ep93xx_ac97_read;
+	
+	ret = snd_ac97_bus(card, &ac97_bus_ops, &ac97_bus);
+	if (ret){
+		printk("AC97: snd_ac97_bus error\n");
+		goto err;
+	}
+
+	DEBUG("AC97: register snd_ac97_bus ok\n");
+	
+	memset(&ac97, 0, sizeof(ac97));
+	ret = snd_ac97_mixer(ac97_bus, &ac97, &ep93xx_ac97_ac97);
+	if (ret){
+		printk("AC97: snd_ac97_mixer error\n");
+		goto err;
+	}
+	
+	DEBUG("AC97: register snd_ac97_mixer ok\n");
+
+	strcpy(card->driver,    "EP93xx  CS4202");
+	strcpy(card->shortname, "EPD93XX CS4202");
+	strcpy(card->longname,  "Cirrus EPD93XX Codec CS4202");
+	
+#endif
+
+#if alsa_ac97_debug
+	ep93xx_dump_ac97_regs();
+#endif
+
+	ep93xx_audio_init( 0 );	
+
+	/*setting the card device callback*/
+        ret = snd_card_set_pm_callback(card, ep93xx_ac97_do_suspend,ep93xx_ac97_do_resume, (void*)NULL);
+	if(ret != 0){
+		DEBUG("snd_card_set_pm_callback error\n");
+	}
+	/*regist the new CARD device*/
+	ret = snd_card_register(card);
+	if (ret == 0) {
+		dev_set_drvdata(dev, card);
+		printk("AC97: register snd_card_register ok\n");
+		return 0;
+	}
+
+ err:
+	if (card){
+		snd_card_free(card);
+
+		DEBUG("the card register fail");
+	}
+
+	return ret;
+}
+
+static int ep93xx_ac97_remove(struct device *dev)
+{
+	snd_card_t *card = dev_get_drvdata(dev);
+
+	if (card) {
+		snd_card_free(card);
+		dev_set_drvdata(dev, NULL);
+	}
+
+	return 0;
+}
+
+static struct device_driver ep93xx_ac97_driver = {
+	.name		= "ep93xx-ac97",
+	.bus		= &platform_bus_type,
+	.probe		= ep93xx_ac97_probe,
+	.remove		= ep93xx_ac97_remove,
+	.suspend	= ep93xx_ac97_suspend,
+	.resume		= ep93xx_ac97_resume,
+};
+
+static int __init ep93xx_ac97_init(void)
+{
+	DEBUG(KERN_INFO "%s: version %s\n", DRIVER_DESC, DRIVER_VERSION);
+	return driver_register(&ep93xx_ac97_driver);
+}
+
+static void __exit ep93xx_ac97_exit(void)
+{
+	driver_unregister(&ep93xx_ac97_driver);
+}
+
+module_init(ep93xx_ac97_init);
+module_exit(ep93xx_ac97_exit);
+
+MODULE_AUTHOR("Shrek");
+MODULE_DESCRIPTION("AC97 driver for the Cirrus EP93xx chip");
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/sound/arm/ep93xx-alsa-pcm.c linux-2.6.8.1/sound/arm/ep93xx-alsa-pcm.c
--- linux-2.6.8.1-orig/sound/arm/ep93xx-alsa-pcm.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/sound/arm/ep93xx-alsa-pcm.c	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,2680 @@
+/*
+ * linux/sound/arm/ep93xx-alsa-pcm.c -- ALSA PCM interface for the edb93xx ac97 audio
+ *
+ * Author:      Shrek Wu
+ * Created:     July 19, 2005
+ * Copyright:   Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/version.h>
+#include <linux/soundcard.h>
+
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+                                                                                                                             
+#include <asm/irq.h>
+#include <asm/semaphore.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+//#include <asm/arch/dma-ep93xx.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/regs_ac97.h>
+#include "ep93xx-alsa-pcm.h"
+
+/*-----------------------------------------------------------------------------------------------*/
+#define Alsa_DMA
+
+#ifdef ALSA_AC97_DEBUG
+#define DPRINTK( x... )  printk( ##x )
+#else
+#define DPRINTK( x... )
+#endif
+
+/* Mostly just prints what ioctls got called */
+/* #define DEBUG 1 */
+#ifdef ALSA_AC97_DEBUG
+#define DPRINTK_IOCTL( x... )  printk( ##x )
+#else
+#define DPRINTK_IOCTL( x... )
+#endif
+
+
+static const snd_pcm_hardware_t ep93xx_ac97_pcm_hardware = {
+	.info				= 	(SNDRV_PCM_INFO_MMAP |
+				  			SNDRV_PCM_INFO_MMAP_VALID |
+				  			SNDRV_PCM_INFO_INTERLEAVED |
+				  			SNDRV_PCM_INFO_PAUSE),
+	/*.formats			= 	SNDRV_PCM_FMTBIT_U8 SNDRV_PCM_FMTBIT_S16_LE,*/
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
+				SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE,
+	.rates				=	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |
+							SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |
+							SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+							SNDRV_PCM_RATE_48000),
+	.rate_min			= 8000,
+	.rate_max			= 48000,
+	.channels_min		= 1,
+	.channels_max		= 2,					
+	.period_bytes_min	= 16,
+	.period_bytes_max	= 16384,/*32768*/
+	.periods_min		= 8,//2,
+	.periods_max		= 16,//8,//4,
+	.buffer_bytes_max	= 16* 1024,/*128*1024*/
+	.fifo_size			= 32,
+};
+
+
+/*-------------------------------------------------------------------------------------------*/
+#define AUDIO_NAME		"ep93xx-audio"
+
+#define AUDIO_NBFRAGS_DEFAULT	8
+#define AUDIO_FRAGSIZE_DEFAULT	16384
+
+/*
+ * Translates to:
+ * 		s->buf_idx++;
+ * 		s->buf_idx %= s->nbfrags;
+ *		s->buf = s->buffers + s->buf_idx;
+ *
+ * So s->buf always points to the s->buf_idx-nth element of s->buffers.
+ */
+#define NEXT_BUF(_s_,_b_) { \
+	(_s_)->_b_##_idx++; \
+	(_s_)->_b_##_idx %= (_s_)->nbfrags; \
+	(_s_)->_b_ = (_s_)->buffers + (_s_)->_b_##_idx; }
+
+#define AUDIO_ACTIVE(state)	((state)->rd_ref || (state)->wr_ref)
+
+
+
+int stoptmp;
+unsigned int ReadEnd,WriteEnd;
+unsigned int Stack_buf_id[100];
+
+/*-----------------------------------------------------------------------------------------*/
+
+static void print_audio_format( long format )
+{
+	switch( format )
+	{
+		case SNDRV_PCM_FORMAT_U8:		   
+			DPRINTK( "AFMT_U8\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_S8:
+			DPRINTK( "AFMT_S8\n" );		   
+			break;
+
+		case /*AFMT_S32_BLOCKED*/SNDRV_PCM_FORMAT_S32_LE:
+			DPRINTK( "AFMT_S32_BLOCKED\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_S16_LE:
+			DPRINTK( "AFMT_S16_LE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_S16_BE:
+			DPRINTK( "AFMT_S16_BE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_U16_LE:
+			DPRINTK( "AFMT_U16_LE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_U16_BE:
+		default:
+			DPRINTK( "AFMT_U16_BE\n" );		   
+			break;
+	}
+}
+
+/*
+ * We convert to 24 bit samples that occupy 32 bits each.
+ * Formats we support:
+ *
+ * AFMT_U8		   
+ * AFMT_S16_LE	   	Little endian signed 16
+ * AFMT_S8		   
+ * AFMT_U16_LE	   	Little endian U16
+ * AFMT_S32_BLOCKED	32 bit little endian format, taken from the rme96xx driver.
+ *
+ */
+static void audio_set_format( audio_stream_t * s, long val )
+{
+
+	switch( val )
+	{
+		case /*AFMT_U8*/ SNDRV_PCM_FORMAT_U8:		   
+			s->audio_format = val;
+			s->audio_stream_bitwidth = 8;
+			break;
+
+		case /*AFMT_S8*/ SNDRV_PCM_FORMAT_S8:
+			s->audio_format = val;
+			s->audio_stream_bitwidth = 8;
+			break;
+
+		case /*AFMT_S32_BLOCKED*/ SNDRV_PCM_FORMAT_S32_BE:
+		case SNDRV_PCM_FMTBIT_S32_LE:
+		
+			s->audio_format = SNDRV_PCM_FORMAT_S32_LE;
+			s->audio_stream_bitwidth = 32;
+			break;
+
+		case /*AFMT_S16_LE*/ SNDRV_PCM_FORMAT_S16_LE:
+		case /*AFMT_S16_BE*/ SNDRV_PCM_FORMAT_S16_BE:
+			s->audio_format = SNDRV_PCM_FORMAT_S16_LE /*AFMT_S16_LE*/;
+			s->audio_stream_bitwidth = 16;
+			break;
+
+		case /*AFMT_U16_LE*/ SNDRV_PCM_FORMAT_U16_LE:
+		case /*AFMT_U16_BE*/ SNDRV_PCM_FORMAT_U16_BE:
+		default:
+			s->audio_format = SNDRV_PCM_FORMAT_U16_LE/*AFMT_U16_LE*/;
+			s->audio_stream_bitwidth = 16;
+			break;
+	}
+
+	DPRINTK( "audio_set_format EXIT format set to be (%d) ", 
+				(int)s->audio_format );
+	print_audio_format( (long)s->audio_format );
+}
+
+static  unsigned long copy_to_user_U16_LE_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	unsigned short * user_ptr = (unsigned short *)to; /* 16 bit user buffer */
+	short * dma_ptr = (short *)from;
+	short right, left;
+	
+	/*
+	 * Compact mode - left is the lower 16 bits.  right is the upper 16 bits.
+	 */
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			right = *dma_ptr++;
+			left  = *dma_ptr++;
+			__put_user( left ^ 0x8000, user_ptr++ );
+			__put_user( right^ 0x8000, user_ptr++ );
+			to_count -= 4;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			dma_ptr++;	/* skip right channel sample */
+			left  = *dma_ptr++;
+			__put_user( left ^ 0x8000, user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static  unsigned long copy_to_user_U16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	short * user_ptr = (short *)to;	/* 16 bit user buffer */
+	int * dma_ptr = (int *)from;	/* 32 bit dma buffer  */
+
+	int shift = state->DAC_bit_width - 16;
+	
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((short)( (*dma_ptr++) >> shift )) ^ 0x8000, user_ptr++ );
+			__put_user( ((short)( (*dma_ptr++) >> shift )) ^ 0x8000, user_ptr++ );
+			to_count -= 4;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((short)( (*dma_ptr++) >> shift )) ^ 0x8000, user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count -= 2;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static  unsigned long copy_to_user_S16_LE_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	short * user_ptr = (short *)to;	  /* 16 bit user buffer */
+	short * dma_ptr = (short *)from;
+	short left, right;
+
+	/*
+	 * Compact mode - left is the lower 16 bits.  right is the upper 16 bits.
+	 */
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			right = *dma_ptr++;
+			left  = *dma_ptr++;
+			__put_user( left,  user_ptr++ );
+			__put_user( right, user_ptr++ );
+			to_count -= 4;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			dma_ptr++; /* skip right sample */
+			left  = *dma_ptr++;
+			__put_user( left,  user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static  unsigned long copy_to_user_S16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	short * user_ptr = (short *)to;	/* 16 bit user buffer */
+	int * dma_ptr = (int *)from;	/* 32 bit dma buffer  */
+
+	int shift = state->DAC_bit_width - 16;
+	
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (short)( (*dma_ptr++) >> shift ), user_ptr++ );
+			__put_user( (short)( (*dma_ptr++) >> shift ), user_ptr++ );
+			to_count -= 4;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (short)((*dma_ptr++) >> shift), user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count -= 2;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static  unsigned long copy_to_user_S8_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	char * user_ptr = (char *)to;  	/*  8 bit user buffer */
+	unsigned short * dma_ptr = (unsigned short *)from;    /* 16 bit dma buffer  */
+	char right, left;
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			right = ((char)(*dma_ptr++ >> 8));
+			left  = ((char)(*dma_ptr++ >> 8));
+			__put_user( left,  user_ptr++ );
+			__put_user( right, user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			dma_ptr++;	/* skip right channel sample */
+			left  = ((char)(*dma_ptr++ >> 8));
+			__put_user( left,  user_ptr++ );
+			to_count--;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static  unsigned long copy_to_user_S8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	char * user_ptr = (char *)to;  /*  8 bit user buffer */
+	int * dma_ptr = (int *)from;    /* 32 bit dma buffer  */
+
+	int shift = state->DAC_bit_width- 8;
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (char)( (*dma_ptr++) >> shift ), user_ptr++ );
+			__put_user( (char)( (*dma_ptr++) >> shift ), user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (char)((*dma_ptr++) >> shift), user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count--;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static  unsigned long copy_to_user_U8_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	char * user_ptr = (char *)to;  	/*  8 bit user buffer */
+	unsigned short * dma_ptr = (unsigned short *)from;    /* 16 bit dma buffer  */
+	char right, left;
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			right = ((char)(*dma_ptr++ >> 8)) ^ 0x80;
+			left  = ((char)(*dma_ptr++ >> 8)) ^ 0x80;
+			__put_user( left,  user_ptr++ );
+			__put_user( right, user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			dma_ptr++;	/* skip right channel sample */
+			left  = ((char)(*dma_ptr++ >> 8)) ^ 0x80;
+			__put_user( left,  user_ptr++ );
+			to_count--;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static  unsigned long copy_to_user_U8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	char * user_ptr = (char *)to;  /*  8 bit user buffer */
+	int * dma_ptr = (int *)from;    /* 32 bit dma buffer  */
+
+	int shift = state->DAC_bit_width - 8;
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((char)( (*dma_ptr++) >> shift )) ^ 0x80, user_ptr++ );
+			__put_user( ((char)( (*dma_ptr++) >> shift )) ^ 0x80, user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((char)( (*dma_ptr++) >> shift )) ^ 0x80, user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count--;
+		}
+	}
+	
+	return total_to_count;
+}
+
+/*
+ * Returns negative for error
+ * Returns # of bytes transferred out of the from buffer
+ * for success.
+ */
+static  int copy_to_user_with_conversion
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount
+)
+{
+	int ret=0;
+	
+	if( toCount == 0 )
+	{
+		printk("copy_to_user_with_conversion - nothing to copy!\n");
+	}
+
+	/*
+	 * Compact Mode means that each 32 bit word has both the
+	 * left and right sample in it.
+	 */
+	DPRINTK("copy %x %x\n",state->bCompactMode,state->input_stream->audio_format);
+	if( state->bCompactMode )
+	{
+		switch( state->input_stream->audio_format )
+		{
+			case /*AFMT_U8:*/SNDRV_PCM_FORMAT_U8:
+				ret = copy_to_user_U8_CM( state, to, from, toCount );
+				break;
+
+			case /*AFMT_S16_LE:*/SNDRV_PCM_FORMAT_S16_LE:
+				ret = copy_to_user_S16_LE_CM( state, to, from, toCount );
+				break;
+		
+			case /*AFMT_S8:*/SNDRV_PCM_FORMAT_S8:
+				ret = copy_to_user_S8_CM( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_U16_LE:*/SNDRV_PCM_FORMAT_U16_LE:
+				ret = copy_to_user_U16_LE_CM( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_S32_BLOCKED:*/SNDRV_PCM_FORMAT_S32_LE:
+			default:
+				break;
+		}
+	}
+	else
+	{
+		switch( state->input_stream->audio_format )
+		{
+			case /*AFMT_U8:*/SNDRV_PCM_FORMAT_U8:
+				ret = copy_to_user_U8( state, to, from, toCount );
+				break;
+
+			case /*AFMT_S16_LE:*/SNDRV_PCM_FORMAT_S16_LE:
+				ret = copy_to_user_S16_LE( state, to, from, toCount );
+				break;
+		
+			case /*AFMT_S8:*/SNDRV_PCM_FORMAT_S8:
+				ret = copy_to_user_S8( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_U16_LE:*/SNDRV_PCM_FORMAT_U16_LE:
+				ret = copy_to_user_U16_LE( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_S32_BLOCKED:*/SNDRV_PCM_FORMAT_S32_LE:
+			default:
+				__copy_to_user( (char *)to, from, toCount);
+				ret = toCount;
+				break;
+		}
+	}
+
+	return ret;
+}
+
+
+static int copy_from_user_U16_LE_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	unsigned short data;
+	unsigned int val;
+	int toCount0 = toCount;
+	unsigned int * p = (unsigned int *)to;
+	unsigned short * userPtr = (unsigned short *)from;
+	int mono = (state->output_stream->audio_num_channels == 1);
+
+	/*
+	 * Compact mode - slot 3 (left) is the lower 16 bits.  slot 4 (right)
+	 * is the upper 16 bits.
+	 */
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = (unsigned int)data & 0x0000ffff;
+		
+		/*
+		 * If mono, use this mono sample for both channels, else we just got
+		 * the left channel sample.  So get the right sample and use it for 
+		 * the right channel.
+		 */
+		if( !mono )
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+		}
+
+		*p++ = (((unsigned int)data << 16) | val) ^ 0x80008000;
+
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in one stereo 32 bit sample going out.  So
+	 * mono   = (2 bytes in)/(4 bytes out)
+	 * stereo = (4 bytes in)/(4 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 2;
+	}
+	
+	return toCount0;
+}
+
+static int copy_from_user_U16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	unsigned short data;
+	int val;
+	int toCount0 = toCount;
+	int * p = (int *)to;
+	unsigned short * userPtr = (unsigned short *)from;
+	int mono = (state->output_stream->audio_num_channels == 1);
+	int shift = state->DAC_bit_width - 16;
+
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = (data ^ 0x8000) << shift;
+		*p++ = val;
+		toCount -= 4;
+
+		if (!mono) 
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+			val = (data ^ 0x8000) << shift;
+		}
+
+		*p++ = val;
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in a two 32 bit (left & right) samples going out.  So
+	 * mono   = (2 bytes in)/(8 bytes out)
+	 * stereo = (4 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 4;
+	}
+	
+	return toCount0 / 2;
+}
+
+static int copy_from_user_S16_LE_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	short data;
+	unsigned int val;
+	unsigned int * p = (int *)to;
+	int toCount0 = toCount;
+	unsigned short * userPtr = (unsigned short *)from;
+	int mono = (state->output_stream->audio_num_channels == 1);
+
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = (unsigned int)data & 0x0000ffff;
+
+		if( !mono )
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+		}
+
+		*p++ = ((unsigned int)data << 16) | val;
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in one stereo 32 bit sample going out.  So
+	 * mono   = (2 bytes in)/(4 bytes out)
+	 * stereo = (4 bytes in)/(4 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 2;
+	}
+	
+	return toCount0;
+}
+
+
+static int copy_from_user_S16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	short data;
+	int val;
+	int toCount0 = toCount;
+	int * p = (int *)to;
+	unsigned short * userPtr = (unsigned short *)from;
+	int mono = (state->output_stream->audio_num_channels == 1);
+	int shift = state->DAC_bit_width - 16;
+
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = data << shift;
+		*p++ = val;
+		toCount -= 4;
+
+		if (!mono) 
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+			val = data << shift;
+		}
+
+		*p++ = val;
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in a two 32 bit samples (left & right) going out.  So
+	 * mono   = (2 bytes in)/(8 bytes out)
+	 * stereo = (4 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 4;
+	}
+	
+	return toCount0 / 2;
+}
+
+static int copy_from_user_S8_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	char data;
+	int val;
+	int toCount0 = toCount;
+	int * p = (int *)to;
+	unsigned char * userPtr = (unsigned char *)from;
+	int mono = (state->output_stream->audio_num_channels == 1);
+
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = (data << 8) & 0x0000ffff;
+
+		if (!mono) 
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+		}
+
+		*p++ = (data << 24) | val;
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 8 bit sample going in results
+	 * in one stereo 32 bit sample going out.  So
+	 * mono   = (1 byte  in)/(4 bytes out)
+	 * stereo = (2 bytes in)/(4 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 4;
+	}
+	
+	return toCount0 / 2;
+}
+
+static int copy_from_user_S8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	char data;
+	int val;
+	int toCount0 = toCount;
+	int * p = (int *)to;
+	unsigned char * userPtr = (unsigned char *)from;
+	int mono = (state->output_stream->audio_num_channels == 1);
+	int shift = state->DAC_bit_width - 8;
+
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = data << shift;
+		*p++ = val;
+		toCount -= 4;
+
+		if (!mono) 
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+			val = data << shift;
+		}
+
+		*p++ = val;
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 8 bit sample going in results
+	 * in a two 32 bit samples (left & right) going out.  So
+	 * mono   = (1 byte  in)/(8 bytes out)
+	 * stereo = (2 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 8;
+	}
+	
+	return toCount0 / 4;
+}
+
+static int copy_from_user_U8_CM
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int * p = (int *)to;
+	unsigned char * userPtr = (unsigned char *)from;
+	unsigned char data;
+	int val;
+	int toCount0 = toCount;
+
+	int mono = (state->output_stream->audio_num_channels == 1);
+
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = ((data ^ 0x80) << 8) & 0x0000ffff;
+
+		if (!mono) 
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+		}
+
+		*p++ = ((data ^ 0x80) << 24) | val;
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 8 bit sample going in results
+	 * in one stereo 32 bit sample going out.  So
+	 * mono   = (1 byte  in)/(4 bytes out)
+	 * stereo = (2 bytes in)/(4 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 4;
+	}
+	
+	return toCount0 / 2;
+}
+
+static int copy_from_user_U8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int * p = (int *)to;
+	unsigned char * userPtr = (unsigned char *)from;
+
+	unsigned char data;
+	int val;
+	int toCount0 = toCount;
+	int shift = state->DAC_bit_width - 8;
+
+	int mono = (state->output_stream->audio_num_channels == 1);
+
+	while (toCount > 0) 
+	{
+		if (__get_user(data, userPtr++))
+		{
+			return -EFAULT;
+		}
+		val = (data ^ 0x80) << shift;
+		*p++ = val;
+		toCount -= 4;
+
+		if (!mono) 
+		{
+			if (__get_user(data, userPtr++))
+			{
+				return -EFAULT;
+			}
+			val = (data ^ 0x80) << shift;
+		}
+
+		*p++ = val;
+		toCount -= 4;
+	}
+
+	/*
+	 * Each mono or stereo 8 bit sample going in results
+	 * in a two 32 bit samples (left & right) going out.  So
+	 * mono   = (1 byte  in)/(8 bytes out)
+	 * stereo = (2 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+	{
+		return toCount0 / 8;
+	}
+	
+	return toCount0 / 4;
+}
+
+static int copy_from_user_U32
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	if (copy_from_user( (char *)to, from, toCount)) 
+	{
+		return -EFAULT;
+	}
+
+	return toCount;
+}
+
+/*
+ * Returns negative for error
+ * Returns # of bytes transferred out of the from buffer
+ * for success.
+ */
+static int copy_n_convert
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int ret=0;
+	
+	if( toCount == 0 )
+	{
+		printk("copy_n_convert - nothing to copy!\n");
+	}
+
+	/*
+	 * Compact Mode means that each 32 bit word has both the
+	 * left and right sample in it.
+	 */
+	if( state->bCompactMode )
+	{
+		switch( state->output_stream->audio_format )
+		{
+			case /*AFMT_U8*/ SNDRV_PCM_FORMAT_U8:
+				ret = copy_from_user_U8_CM( state, to, from, toCount );
+				break;
+
+			case /*AFMT_S16_LE*/ SNDRV_PCM_FORMAT_S16_LE:
+				ret = copy_from_user_S16_LE_CM( state, to, from, toCount );
+				break;
+		
+			case /*AFMT_S8*/ SNDRV_PCM_FORMAT_S8:
+				ret = copy_from_user_S8_CM( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_U16_LE*/ SNDRV_PCM_FORMAT_U16_LE:
+				ret = copy_from_user_U16_LE_CM( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_S32_BLOCKED*/SNDRV_PCM_FORMAT_S32_LE:
+			default:
+				break;
+		}
+	}
+	else
+	{
+		switch( state->output_stream->audio_format )
+		{
+			case /*AFMT_U8*/ SNDRV_PCM_FORMAT_U8:
+				ret = copy_from_user_U8( state, to, from, toCount );
+				break;
+
+			case /*AFMT_S16_LE*/ SNDRV_PCM_FORMAT_S16_LE:
+				ret = copy_from_user_S16_LE( state, to, from, toCount );
+				break;
+		
+			case /*AFMT_S8*/ SNDRV_PCM_FORMAT_S8:
+				ret = copy_from_user_S8( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_U16_LE*/ SNDRV_PCM_FORMAT_U16_LE:
+				ret = copy_from_user_U16_LE( state, to, from, toCount );
+				break;
+				
+			case /*AFMT_S32_BLOCKED*/SNDRV_PCM_FORMAT_S32_LE:
+			default:
+				ret = copy_from_user_U32( state, to, from, toCount );
+				break;
+		}
+	}
+	
+	if( ret == -EFAULT )
+	{
+		printk( "copy_n_convert: get_user failed!!!!\n" );
+	}
+	return ret;
+}
+
+
+/*
+ * We samples of arbitrary format to be 32 bit for our hardware.
+ *	Input format is arbitrary.
+ *	Output format is either CM (compact mode) where two 16 bit samples
+ *  together in a 32 bit word become a stereo sample or non-CM where
+ *  each channel gets a 32 bit word.
+ *
+ *  Input format       Input sample     Output sample size    ratio (out:in)
+ *  bits   channels    size (bytes)       CM   non-CM          CM   non-CM
+ *   8       mono          1               4      8            4:1   8:1
+ *   8      stereo         2			   4      8            2:1   4:1
+ *   16      mono          2			   4      8            2:1   4:1
+ *   16     stereo         4			   4      8            1:1   2:1
+ *
+ *   24      mono          3			   4      8             X    8:3
+ *   24     stereo         6			   4      8             X    8:6
+ *   32      mono          4			   4      8             X    2:1
+ *   32     stereo         8			   4      8             X    1:1
+ */
+static int scale_to_expanded_samples( audio_state_t *state, int input_bufsize,int dir)
+{
+	int output_bufsize = input_bufsize;
+
+#ifdef I2S_SCALE_BUFFERS
+	audio_stream_t *os ;//= state->output_stream;
+	int output_sample_size, input_sample_size;
+
+	if(dir==SNDRV_PCM_STREAM_PLAYBACK)
+		os = state->output_stream;
+	else
+		os = state->input_stream;
+	
+	if( state->bCompactMode )
+	{
+		output_sample_size = 4;
+	}
+	else
+	{
+		output_sample_size = 8;
+	}
+	
+	input_sample_size = os->audio_stream_bitwidth / 8;
+	
+	if( os->audio_num_channels != 1 )
+	{
+		input_sample_size <<= 1;
+	}
+
+	output_bufsize = input_bufsize * output_sample_size / input_sample_size;
+
+#endif
+	
+	return output_bufsize;
+}
+
+
+
+/*
+static int input_scale_to_expanded_samples( audio_state_t *state, int input_bufsize )
+{
+	int output_bufsize = input_bufsize;
+
+#ifdef I2S_SCALE_BUFFERS
+	audio_stream_t *os = state->output_stream;
+	int output_sample_size, input_sample_size;
+	
+	if( state->bCompactMode )
+	{
+		output_sample_size = 4;
+	}
+	else
+	{
+		output_sample_size = 8;
+	}
+	
+	input_sample_size = os->audio_stream_bitwidth / 8;
+	
+	if( os->audio_num_channels != 1 )
+	{
+		input_sample_size <<= 1;
+	}
+
+	output_bufsize = input_bufsize * input_sample_size /output_sample_size;
+
+#endif
+	
+	return output_bufsize;
+}
+*/
+
+
+/*---------------------------------------------------------------------------------------------*/
+
+/*
+ * audio_dma_start
+ *
+ * Our Ac97 has a specific start order that it likes.  Enable the 
+ * Ac97 channel AFTER enabling DMA.  Our I2S is not so picky.
+ */
+static void audio_dma_start( audio_state_t * state, audio_stream_t * stream )
+{
+	int err;
+
+	err = ep93xx_dma_start( stream->dmahandles[0],
+					  stream->NumDmaChannels, 
+					  stream->dmahandles );
+	DPRINTK("audio_dma_start s1=%x\n",err);
+	if (state->hw_enable){
+		state->hw_enable( state->output_stream == stream );
+	}
+}
+
+/*
+ * audio_dma_pause
+ */
+static void audio_dma_pause( audio_state_t * state, audio_stream_t * stream )
+{
+	DPRINTK("audio_dma_pause\n");
+	if (state->hw_disable){
+		state->hw_disable( state->output_stream == stream );
+	}
+	
+	ep93xx_dma_pause( stream->dmahandles[0],
+					  stream->NumDmaChannels, 
+					  stream->dmahandles );
+}
+
+static void audio_prime_dma( unsigned long externedtotsize,unsigned long totsize,audio_state_t * state, audio_stream_t * s )
+{
+	unsigned long i=0,j=0,bufferlen=0,bufferlen1=0;
+	int ret;
+
+	j=totsize;
+	i=externedtotsize;
+	while(i > 0){
+	audio_buf_t *buf =s->buf;
+	
+	if(i>=s->externedfragsize){
+	   	bufferlen=s->externedfragsize;
+		bufferlen1=s->fragsize;
+	}
+	else{
+		bufferlen=i;
+		bufferlen1=j;
+	}
+	
+	down(&buf->sem);
+
+	ret=ep93xx_dma_add_buffer( s->dmahandles[0], 				/* dma instance*/ 
+                               		(unsigned int)buf->dma_addr,			/*source*/
+                               		0,						/* dest*/
+                               		bufferlen,						/* size*/  
+                               		0,     						/*is the last chunk?*/   
+                               		(unsigned int) buf );				/* buf id*/
+	buf->size=bufferlen;
+	buf->reportedsize=bufferlen1;
+	memset(buf->start, 0, buf->size);
+
+	buf->sent = 1;
+    	NEXT_BUF(s, buf);
+
+	up(&buf->sem);
+    	i=i-bufferlen;
+	j=j-bufferlen1;
+
+	}
+
+
+}
+
+/*
+ * audio_deallocate_buffers
+ * 
+ * This function frees all buffers
+ */
+static void audio_deallocate_buffers( snd_pcm_substream_t *substream, audio_stream_t * s )
+{
+	int frag, i;
+	audio_state_t  *state = (audio_state_t *)substream->private_data;
+	
+	DPRINTK("EP93xx - audio_deallocate_buffers\n");
+
+	/* ensure DMA won't run anymore */
+	audio_dma_pause( state, s );
+	s->active = 0;
+	s->stopped = 0;
+
+	for( i=0 ; i<s->NumDmaChannels ; i++ )
+	{
+		ep93xx_dma_flush( s->dmahandles[0] );
+	}
+	
+	if (s->buffers) 
+	{
+		for (frag = 0; frag < s->nbfrags; frag++) 
+		{
+			if (!s->buffers[frag].master)
+			{
+				continue;
+			}
+
+			/*
+			consistent_free(s->buffers[frag].start,
+					s->buffers[frag].master,
+					s->buffers[frag].dma_addr);
+			*/
+			memset(s->buffers[frag].start, 0, s->buffers[frag].size);
+			s->buffers[frag].start		=	NULL;
+			s->buffers[frag].master		=	0;
+			s->buffers[frag].dma_addr	=	(dma_addr_t)NULL;
+			
+		}
+
+		/*
+		 * Free the space allocated to the array of buf structs.
+		 */
+		kfree(s->buffers);
+		s->buffers = NULL;
+	}
+
+	s->buf_idx = 0;
+	s->buf = NULL;
+
+	DPRINTK("EP93xx - audio_deallocate_buffers - EXIT\n");
+}
+
+
+/*
+ * audio_allocate_buffers
+ *
+ * This function allocates the buffer structure array and buffer data space
+ * according to the current number of fragments and fragment size.
+ * Note that the output_stream and input_stream structs are allocated
+ * in ep93xx-ac97.c or ep93xx-i2s.c.
+ */
+static int audio_allocate_buffers( snd_pcm_substream_t *substream, audio_stream_t * s)
+{
+	int frag;
+	int dmasize = 0;
+	char *dmabuf = NULL;
+	dma_addr_t dmaphys = 0;
+	
+	/*audio_state_t  *state = (audio_state_t *)substream->private_data;*/
+	struct snd_dma_buffer *pcmbuf = &substream->dma_buffer;
+	
+	if (s->buffers){
+		printk("%s BUSY\n",__FUNCTION__);
+		return -EBUSY;
+	}
+
+	DPRINTK("EP93xx audio_allocate_buffers ENTER\n" );
+	
+	/*
+	 * Allocate space for the array of audio_buf_t structs.
+	 */
+	s->buffers = (audio_buf_t *)
+		kmalloc(sizeof(audio_buf_t) * s->nbfrags, GFP_KERNEL);
+
+	if (!s->buffers)
+	{
+		printk(AUDIO_NAME ": unable to allocate audio memory\n ");
+		audio_deallocate_buffers(substream,s);
+		return -ENOMEM;
+	}
+
+	memset( s->buffers, 0, sizeof(audio_buf_t) * s->nbfrags );
+
+	/*
+	 * Let's allocate non-cached memory for DMA buffers.
+	 * We try to allocate all memory at once.
+	 * If this fails (a common reason is memory fragmentation),
+	 * then we allocate more smaller buffers.
+	 */
+	
+	
+	for (frag = 0; frag < s->nbfrags; frag++) 
+	{
+		audio_buf_t *buf = &s->buffers[frag];
+
+		if (!dmasize) 
+		{
+			/*
+			 * First try to allocate enough for all the frags that
+			 * don't yet have memory allocated.
+			 */
+			/*dmasize = (s->nbfrags - frag) * s->fragsize;*/
+			//dmasize	=	pcmbuf->bytes; 
+			//dmasize	=	pcmbuf->bytes;
+			dmasize	=	s->nbfrags*s->externedfragsize;
+
+			
+//			printk("pcmbuf->bytes=%x\n",pcmbuf->bytes);
+			//dmasize=	substream->runtime->dma_bytes;
+			do {
+			  	/*dmabuf = consistent_alloc(GFP_KERNEL|GFP_DMA,
+							  dmasize, &dmaphys);
+				*/
+				dmabuf	=	pcmbuf->area;
+				//dmabuf	=	substream->runtime->dma_area;
+
+				dmaphys	=	pcmbuf->addr;
+				//dmaphys =	substream->runtime->dma_addr;
+				/* 
+				 * If that fails, try to allocate a chunk of memory
+				 * that is one less fragment is size.
+				 */
+				if (!dmabuf)
+				{
+					dmasize -= s->fragsize;
+				}
+
+			  /* 
+			   * Keep trying but the minimum we'll attempt is one 
+			   * fragment.  If we can't even get that, give up.
+			   */
+			} while (!dmabuf && dmasize);
+		
+			/*
+			 * If we do fail to allocate enough for all the frags, 
+			 * deallocate whatever we did get and quit.
+			 */
+			if (!dmabuf)
+			{
+				DPRINTK(AUDIO_NAME ": unable to allocate audio memory\n ");
+				audio_deallocate_buffers(substream, s);
+				return -ENOMEM;
+			}
+
+//			printk("EP93xx allocated %d bytes:  dmabuf=0x%08x  dmaphys=0x%08x\n",
+//					dmasize, (int)dmabuf, (int)dmaphys );
+			
+			/*
+			 * Success!	 Save the size of this chunk to use when we deallocate it.
+			 */
+			buf->master = dmasize;
+			memzero(dmabuf, dmasize);
+		}
+
+		/*
+		 * Save the start address of the buf fragment.
+		 * We know the size of the fragment is fragsize.
+		 */
+		buf->start = dmabuf;
+		buf->dma_addr = dmaphys;
+//		printk("buf->start=%x,buf->dma_addr=%x\n",buf->start,buf->dma_addr);
+		buf->stream = s;
+		buf->size = 0;
+		buf->reportedsize = 0;
+		buf->sent = 0;
+
+		sema_init(&buf->sem, 1);
+
+		/*
+		 * Now if we only allocated the minimal one frag of space, the
+		 * dmasize will be ==0 after this subtraction so it will allocate more
+		 * for the next frag.  Otherwise, the next time(s) thru this for loop
+		 * will dole out frag sized pieces of this big master chunk.
+		 */
+		//dmabuf += s->fragsize;
+		//dmaphys += s->fragsize;
+		//dmasize -= s->fragsize;
+
+		dmabuf += s->externedfragsize;
+		dmaphys += s->externedfragsize;
+		dmasize -= s->externedfragsize;
+	}
+
+	/*
+	 * Initialize the stream.
+	 */
+	s->buf_idx = 0;				/* Init the current buffer index. 			*/
+	s->buf = &s->buffers[0];	/* Point buf to the current buffer struct. 	*/
+	s->bytecount = 0;
+	s->externedbytecount = 0;
+	s->getptrCount = 0;
+	s->fragcount = 0;
+
+//	DPRINTK("EP93xx audio_allocate_buffers -- exit SUCCESS\n" );
+	return 0;
+
+}
+
+
+/*
+ * audio_reset_buffers
+ *
+ * This function stops and flushes the dma, gets all buffers back
+ * from the DMA driver and resets them ready to be used again.
+ */
+/*
+static void audio_reset_buffers( audio_state_t * state, audio_stream_t * s )
+{
+	int frag, i;
+
+	audio_dma_pause( state, s );
+	s->active = 0;
+	s->stopped = 0;
+
+	for( i=0 ; i < s->NumDmaChannels ; i++ )
+	{
+		ep93xx_dma_flush( s->dmahandles[0] );
+	}
+
+	if (s->buffers) 
+	{
+		for (frag = 0; frag < s->nbfrags; frag++) 
+		{
+			audio_buf_t *buf = &s->buffers[frag];
+			buf->size = 0;
+			buf->sent = 0;
+			sema_init(&buf->sem, 1);
+		}
+	}
+
+	s->bytecount = 0;
+	s->getptrCount = 0;
+	s->fragcount = 0;
+}
+*/
+
+/*
+ * DMA callback functions
+ */
+static void audio_dma_tx_callback
+( 
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+	unsigned int buf_id;
+	int handle;
+
+
+	
+	snd_pcm_substream_t *substream	=	(snd_pcm_substream_t *)user_data;
+	audio_state_t *state = (audio_state_t *)(substream->private_data);
+	audio_stream_t *s = state->output_stream;
+
+	DPRINTK( "audio_dma_tx_callback  - enter\n"); 
+	
+	switch( device )
+	{
+    		case DMATx_I2S3:
+			handle = s->dmahandles[2];
+			break;
+
+    		case DMATx_I2S2:
+			handle = s->dmahandles[1];
+			break;
+
+		case DMATx_I2S1:
+		default:
+			handle = s->dmahandles[0];
+			break;
+	}
+	
+	s->mapped=1;
+
+
+  	/*if (s->mapped)*/
+	if(!s->stopped)
+	{
+		/*
+		 * If we are mapped, get one buffer back and recycle it.
+		 */
+		if( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0 )
+		{
+		   	audio_buf_t *buf = (audio_buf_t *)buf_id;
+
+		
+			DPRINTK("%x\n",*(unsigned int *)buf->start);
+			/* Accounting */
+			s->bytecount += buf->size;
+			s->externedbytecount += buf->reportedsize;
+			s->fragcount++;
+			//buf->size = 0;
+		
+			/* Recycle buffer */
+		 	//buf->size = s->fragsize;
+			
+			ep93xx_dma_add_buffer( s->dmahandles[0], 	/* dma instance 		*/
+								   (unsigned int)buf->dma_addr, /* source 		*/
+								   0, 					/* dest 				*/
+								   buf->reportedsize,/*s->fragsize,*/			/* size					*/
+								   0,					/* is the last chunk? 	*/
+								   (unsigned int) buf ); /* buf id			 	*/	
+	  		
+			buf->sent = 1;
+		}
+	}
+	else
+	{
+//		printk("audio_dma_tx_callback no been mapped\n");	
+		/*
+		 * Get all buffers that are free'ed back and clear their semephores.
+		 */
+		while( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0 )
+		{
+		   	audio_buf_t *buf = (audio_buf_t *)buf_id;
+			memset(buf->start, 0, buf->size);
+
+		 /*	DPRINTK( "audio_dma_tx_callback  - got buffer index=%d\n", buf_id); */
+		
+			/* Accounting */
+			s->bytecount += buf->size;
+			s->fragcount++;
+
+			buf->sent = 0;
+			
+			/*
+			 * Release the semaphore on this buf.
+			 * If write is waiting on this buf then it can go ahead and fill
+			 * it and send it to the dma.
+			 */
+			up(&buf->sem);
+		}
+
+//		printk("audio_dma_tx_callback no been mapped --over\n");
+	}
+
+	/* And any process polling on write. */
+	wake_up(&s->wq);
+
+	/*update the substream runtime date status*/
+	snd_pcm_period_elapsed(substream);
+
+	
+//	printk("audio_dma_tx_callback EXIT\n");
+
+	
+}
+
+static void audio_dma_rx_callback
+( 
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+	unsigned int buf_id;
+	int handle;
+
+
+	snd_pcm_substream_t *substream	=	(snd_pcm_substream_t *)user_data;
+	audio_state_t *state 		= (audio_state_t *)(substream->private_data);
+	audio_stream_t *s 			= state->input_stream;
+	audio_buf_t *buf;
+
+	DPRINTK("audio_dma_rx_callback\n");
+	switch( device )
+	{
+    		case DMARx_I2S3:
+			handle = s->dmahandles[2];
+			break;
+
+    		case DMARx_I2S2:
+			handle = s->dmahandles[1];
+			break;
+
+		case DMARx_I2S1:
+		default:
+			handle = s->dmahandles[0];
+			break;
+	}
+
+	s->mapped=1;
+	/*
+	 * Keep removing and recycling buffers as long as there are buffers
+	 * to remove.
+	 */
+	while( !ep93xx_dma_remove_buffer( handle, &buf_id ) ){
+	   	buf = (audio_buf_t *) buf_id;
+
+		/* Accounting */
+		s->fragcount++;
+
+		/* Recycle buffer */
+		if( s->mapped ){
+	
+	            		down(&buf->sem);
+		  	//s->bytecount += buf->size;
+			s->bytecount += buf->reportedsize;
+			s->externedbytecount += buf->size;
+
+			DPRINTK("rx1\n");	
+			snd_pcm_period_elapsed(substream);
+			DPRINTK("rx2\n");	
+
+		 	ep93xx_dma_add_buffer( s->dmahandles[0], 	/* dma instance 		*/
+						(unsigned int)buf->dma_addr, /* source 		*/
+						 0,		/* dest 				*/
+						 buf->size,	/*s->fragsize,*/	/* size 	*/
+						 0,		/* is the last chunk? 	*/
+						 (unsigned int) buf ); /* buf id			 	*/	
+
+			up(&buf->sem);
+
+
+ 		} 
+		else 
+		{
+			down(&s->buf->sem);
+	
+			s->bytecount += buf->reportedsize;
+			s->externedbytecount += buf->size;
+
+			up(&s->buf->sem);
+			DPRINTK("update 1\n");
+			snd_pcm_period_elapsed(substream);
+		}
+
+		/* And any process polling on write. */
+		wake_up(&s->wq);
+	}
+
+	/*shrek add it*/
+	
+
+	
+}
+
+
+/*
+ * audio_sync
+ *
+ * Wait until the last byte written to this device has been played.
+ */
+static int audio_sync(snd_pcm_substream_t *substream)
+{
+	audio_state_t *state = (audio_state_t *)substream->private_data;
+	audio_stream_t *s = state->output_stream;
+	audio_buf_t *buf;
+/*	int frag; */
+	int buf_wait_index;
+  /*	audio_buf_t *buftemp; */
+
+	DPRINTK( "EP93xx - audio_sync - enter\n" );
+
+	if (!(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ) || !s->buffers || s->mapped)
+	{
+		DPRINTK( "EP93xx - audio_sync - exit immediately.\n" );
+		return 0;
+	}
+	
+	/*
+	 * Send current buffer if it contains data and hasn't been sent. 
+	 */
+#if 0	 
+	for (frag = 0; frag < s->nbfrags; frag++) 
+	{
+		buftemp = &s->buffers[frag];
+		DPRINTK("audio_sync - buf# %d: size=%d  sent=%d\n",
+			frag, buftemp->size, buftemp->sent );
+	}
+#endif
+
+	buf = s->buf;
+	if( buf->size && !buf->sent ) 
+	{
+		DPRINTK("audio_sync -- SENDING BUFFER index=%d size=%d\n",
+				s->buf_idx, buf->size );
+		
+		down(&buf->sem);
+	 	ep93xx_dma_add_buffer( s->dmahandles[0], 	/* dma instance 		*/
+							   (unsigned int)buf->dma_addr, /* source 		*/
+							   0, 					/* dest 				*/
+							   buf->size,			/* size					*/
+							   0,					/* is the last chunk? 	*/
+							   (unsigned int) buf ); /* buf id			 	*/	
+	 	buf->sent = 1;
+		NEXT_BUF(s, buf);
+	}
+
+	/*
+	 * Let's wait for the last buffer we sent i.e. the one before the
+	 * current buf_idx.  When we acquire the semaphore, this means either:
+	 * - DMA on the buffer completed or
+	 * - the buffer was already free thus nothing else to sync.
+	 */
+	buf_wait_index = ((s->nbfrags + s->buf_idx - 1) % s->nbfrags);
+	buf = s->buffers + buf_wait_index;
+
+#if 0
+	while( buf->sent )
+	{
+		mdelay( 1000 );
+		for (frag = 0; frag < s->nbfrags; frag++) 
+		{
+			buftemp = &s->buffers[frag];
+			DPRINTK("audio_sync - buf# %d: size=%d  sent=%d\n",
+				frag, buftemp->size, buftemp->sent );
+		}
+		DPRINTK("\n");
+	}
+	DPRINTK("audio_sync -- current buf index is %d.  Waiting on buffer index=%d\n",
+			s->buf_idx, buf_wait_index );
+#endif
+
+	if (down_interruptible(&buf->sem))
+	{
+		return -EINTR;
+	}
+	
+	up(&buf->sem);
+	DPRINTK("EP93xx - audio_sync - EXIT\n");
+	return 0;
+}
+
+
+
+/*
+*
+*/
+static int audio_release(snd_pcm_substream_t *substream)
+{
+	int i;
+	audio_state_t *state = (audio_state_t *)substream->private_data;
+
+	DPRINTK("EP93xx - audio_release -- enter.  \n");
+			
+
+	down(&state->sem);
+
+	/*read data from codec to controller */
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE) 
+	{
+		audio_deallocate_buffers(substream, state->input_stream);
+		
+		for( i=0 ; i < state->input_stream->NumDmaChannels ; i++ )
+		{
+			ep93xx_dma_free( state->input_stream->dmahandles[i] );
+		}
+		state->rd_ref = 0;
+	}
+	
+	/*write data from controller to codec*/
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ) 
+	{
+		/*
+		 * Wait for all our buffers to play.
+		 */
+		audio_sync(substream);
+		
+		/*
+		 * audio_deallocate_buffers will pause and flush the dma
+		 * then deallocate the buffers.
+		 */
+		audio_deallocate_buffers(substream, state->output_stream);
+		for( i=0 ; i < state->output_stream->NumDmaChannels ; i++ )
+		{
+			ep93xx_dma_free( state->output_stream->dmahandles[i] );
+		}
+		state->wr_ref = 0;
+	}
+
+	up(&state->sem);
+
+	DPRINTK("EP93xx - audio_release -- EXIT\n");
+
+	return 0;
+}
+
+/*--------------------------------------------------------------------------------------------*/
+
+/*
+ *ep93xx_ac97_pcm_hw_params
+ *set the pcm dma buffer to the runtime pcm dma buffer
+ */
+static int ep93xx_ac97_pcm_hw_params(snd_pcm_substream_t *substream,
+				snd_pcm_hw_params_t *params)
+{
+/*	
+	snd_pcm_runtime_t 	*runtime 		= substream->runtime;	
+	audio_state_t  		*state 			= (audio_state_t *)substream->private_data;
+	audio_stream_t 		*sTriggerStream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+ 						state->output_stream:state->input_stream;
+*/
+
+	int err;
+	
+	DPRINTK("ep93xx_ac97_pcm_hw_params----ENTER\n");
+	DPRINTK("%s: sub=%p, hwp=%p\n", __FUNCTION__, substream, params);
+	DPRINTK("%s:PCM addr=%x, area=%x,size=%x\n", __FUNCTION__, pcmbuf->addr, pcmbuf->area,pcmbuf->bytes);
+	/*
+	 *Set the substream DMA buffer address to the runtime DMA buffer address
+	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	return 0;
+#else
+	err = snd_pcm_lib_malloc_pages(substream,params_buffer_bytes(params));
+	if(err<0){
+		printk("err=%x,size=%x\n",err,params_buffer_bytes(params));
+	}
+
+	/*
+	  *Dump the infromation
+	  */
+	DPRINTK("err=%x,size=%x\n",err,params_buffer_bytes(params));
+
+	DPRINTK("%s:Runtime : addr=%x, area=%x,size=%x\n", __FUNCTION__, 
+		runtime->dma_addr, runtime->dma_area,runtime->dma_bytes);
+
+	DPRINTK("%s:Runtime frame_bits=%x, buffer_size=%x,periods=%x,period_size=%x,period_step=%x,rate=%x,format=%x\n",
+		__FUNCTION__, 
+		runtime->frame_bits, runtime->buffer_size,runtime->periods,runtime->period_size,
+		runtime->period_step,runtime->rate,runtime->format);
+	DPRINTK("\ntotsize=%x,period=%x\n",totsize,period);
+	
+
+	DPRINTK("ep93xx_ac97_pcm_hw_params----EXIT\n");
+	return err;
+#endif
+
+	
+}
+
+/*
+ *free the runtime_data buffer 
+ */
+static int ep93xx_ac97_pcm_hw_free(snd_pcm_substream_t *substream)
+{
+
+	DPRINTK("ep93xx_ac97_pcm_hw_free----ENTER\n");
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	snd_pcm_set_runtime_buffer(substream, NULL);
+	return 0;
+#else
+	return snd_pcm_lib_free_pages(substream);
+#endif
+
+	DPRINTK("ep93xx_ac97_pcm_hw_free----EXIT\n");
+}
+
+
+/*
+ *ep93xx_ac97_pcm_prepare: need to finish these functions as lower
+ *chip_set_sample_format
+ *chip_set_sample_rate
+ *chip_set_channels
+ *chip_set_dma_setup
+ */
+static int ep93xx_ac97_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	audio_state_t *state  		= (audio_state_t *)substream->private_data;
+
+	snd_pcm_runtime_t *runtime 	= substream->runtime;
+	
+	audio_stream_t *sTriggerStream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+					state->output_stream:state->input_stream;
+	int ret	=	0;
+
+	
+	/*
+	*dump the informatiom
+	*/	
+	DPRINTK("ep93xx_ac97_pcm_prepare----ENTER\n");
+
+	DPRINTK("%s:Runtime channel=%x,frame_bits=%x, buffer_size=%x,periods=%x,period_size=%x,period_step=%x,rate=%x\n,format=%x,snd_pcm_lib_period_bytes(substream)=%x\n",
+	    __FUNCTION__,runtime->channels,
+	    runtime->frame_bits, runtime->buffer_size,runtime->periods,runtime->period_size,
+	    runtime->period_step,runtime->rate,runtime->format,snd_pcm_lib_period_bytes(substream));
+
+	DPRINTK("%s:Runtime addr=%x, area=%x,size=%x\n", __FUNCTION__, 
+		runtime->dma_addr, runtime->dma_area,runtime->dma_bytes);
+	DPRINTK("%s:PCM addr=%x, area=%x,size=%x\n", __FUNCTION__, 
+		substream->dma_buffer.addr,substream->dma_buffer.area,substream->dma_buffer.bytes);
+
+
+	/*
+	 *Re_init the pcm frame_bits,rate,format,channels for AC97 Controller and Codec
+	 */
+
+	/*
+	 *Do the set channel for audio streaming.
+	 */
+	sTriggerStream->audio_num_channels	=	runtime->channels;
+	/*
+	 * Do the set format for audio streaming.
+	 */
+	audio_set_format( sTriggerStream, (runtime->format));
+	 
+	/*
+	 * If the audio hardware needs some setup, do it.
+	 */
+	if( state->set_hw_serial_format )
+	{
+		state->set_hw_serial_format( sTriggerStream->audio_format,sTriggerStream->audio_num_channels );
+	}
+	
+	ret	=	state->prepare(substream);
+
+	return ret;
+}
+
+
+/*
+ *start/stop/pause dma translate
+ */
+static int ep93xx_ac97_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	
+	audio_state_t  *state 		= (audio_state_t *)substream->private_data;
+	audio_stream_t *sTriggerStream 	= (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+						state->output_stream:state->input_stream;
+	
+	size_t totsize			= snd_pcm_lib_buffer_bytes(substream),bufferlen=0,bufferlen1=0;
+	size_t externedtotsize		= scale_to_expanded_samples(state,snd_pcm_lib_buffer_bytes(substream),substream->stream);
+
+	/*snd_pcm_runtime_t *runtime = substream->runtime;	*/
+	int ret = 0,i=0,j=0;
+	unsigned long flags;
+	audio_buf_t * buf ;
+/*	
+	unsigned int bufdma_addr=substream->dma_buffer.addr;
+	unsigned int bufdma_addr=substream->runtime->dma_addr;
+  
+ 	DPRINTK("%s:Runtime sample_bits=%x,byte_align=%x,frame_bits=%x,\nbuffer_size=%x,periods=%x,period_size=%x,period_step=%x,rate=%x\n,format=%x,snd_pcm_lib_period_bytes(substream)=%x,totsize=%x\n",
+            __FUNCTION__,runtime->sample_bits,runtime->byte_align,
+            runtime->frame_bits, runtime->buffer_size,runtime->periods,runtime->period_size,
+            runtime->period_step,runtime->rate,runtime->format,snd_pcm_lib_period_bytes(substream),totsize);
+ */
+  
+	/*
+	 *Init the substream privat data struct audio_stream_t
+	 *runtime->period_size based on frame not byes
+	 */
+
+	sTriggerStream->fragsize		=snd_pcm_lib_period_bytes(substream);
+	sTriggerStream->externedfragsize	=scale_to_expanded_samples(state,snd_pcm_lib_period_bytes(substream),substream->stream);
+
+	if(totsize%sTriggerStream->fragsize==0)
+		sTriggerStream->nbfrags = totsize/sTriggerStream->fragsize;
+	else
+		sTriggerStream->nbfrags = (totsize/sTriggerStream->fragsize) +1;
+	
+/*
+	printk("fragsize=%x,externedfragsize=%x,totsize=%x,externedtotsize=%x\n",
+		sTriggerStream->fragsize,sTriggerStream->externedfragsize,
+		totsize,externedtotsize);
+	
+	printk("ep93xx_ac97_pcm_trigger----ENTER cmd=%x,active=%x,mapped=%x,stopped=%x\n",
+		cmd,sTriggerStream->active,sTriggerStream->mapped,sTriggerStream->stopped);
+
+	printk("addr=%x,area=%x,bytes=%x\n",
+		substream->dma_buffer.addr,substream->dma_buffer.area,
+		substream->dma_buffer.bytes);
+	printk("data=%x,%x,%x,%x,%x,%x,%x,%x\n",
+		*(substream->dma_buffer.area),*(substream->dma_buffer.area+1),
+		*(substream->dma_buffer.area+2),*(substream->dma_buffer.area+3),
+		*(substream->dma_buffer.area+4),*(substream->dma_buffer.area+5),
+		*(substream->dma_buffer.area+6),*(substream->dma_buffer.area+7));
+*/
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+
+	sTriggerStream->stopped = 0;
+	sTriggerStream->active  = 0;
+        sTriggerStream->mapped  = 0;
+		
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		if (sTriggerStream->mapped) {
+			printk("%s error %i\n", __FUNCTION__, __LINE__);
+			return -ENXIO;
+		}
+
+		/*
+		 * Allocate dma buffers if we haven't already done so.
+		 */
+		if( !sTriggerStream->buffers && audio_allocate_buffers(substream, sTriggerStream) )
+		{
+			printk("%s error %i\n", __FUNCTION__, __LINE__);
+			return -ENOMEM;
+		}
+		
+		sTriggerStream->buf_idx=0;
+		/*
+		 * If we haven't already started the DMA start it.
+		 * But don't start it if we are waiting on a trigger.
+		 */
+		if( !sTriggerStream->active && !sTriggerStream->stopped )
+		{
+		 	DPRINTK("ep93xx_dma_start \n");
+
+			sTriggerStream->active = 1;
+			audio_dma_start( state, sTriggerStream );
+		}
+
+		/*
+		 *Add the audio data to dma request
+		 */
+		local_irq_save(flags);
+		
+		//i=totsize;
+		j=totsize;
+		i=externedtotsize;
+		while(i > 0){
+			
+			DPRINTK("i=%x\n",i);
+			/*audio_buf_t * */buf =(audio_buf_t *)(sTriggerStream->buf);
+		
+	   
+			if(i>=sTriggerStream->externedfragsize){
+	    			bufferlen1=sTriggerStream->externedfragsize;
+				bufferlen=sTriggerStream->fragsize;
+			}
+	    		else{
+	        			bufferlen1=i;
+				bufferlen=j;
+	    		}
+		
+			DPRINTK("len=%x\n",bufferlen);
+	    
+			down(&buf->sem);
+
+			ret=ep93xx_dma_add_buffer( sTriggerStream->dmahandles[0], 				/* dma instance*/ 
+	                               				(unsigned int)buf->dma_addr,	/*source*/
+	                               				0,				/* dest*/
+	                               				bufferlen1,				/* size*/  
+	                               				0,				/*is the last chunk?*/   
+	                               				(unsigned int) buf );		/* buf id*/
+			buf->size=bufferlen;
+			buf->reportedsize=bufferlen1;
+			
+			DPRINTK("%x ",buf->size);
+
+			buf->sent = 1;
+	    		NEXT_BUF(sTriggerStream, buf);
+
+	    		//i=i-bufferlen;
+	   		i=i-bufferlen1;
+			j=j-bufferlen;
+
+			up(&buf->sem);	
+			DPRINTK("add dma buffer ret=%x,buffer=%x\n",ret,bufferlen);
+			DPRINTK("a1\n");  
+	    	}
+
+		local_irq_restore(flags);
+	
+	}
+	else{
+		DPRINTK("EP93xx - audio_read Enter\n");
+		
+	    	if( !sTriggerStream->active && !sTriggerStream->stopped ){
+                		sTriggerStream->active = 1;
+                		audio_dma_start( state, sTriggerStream );
+        		}
+
+		if (sTriggerStream->mapped){
+			printk("mmap error\n");
+			return -ENXIO;
+		}
+		
+		if (sTriggerStream->active) 
+		{
+			if (!sTriggerStream->buffers && audio_allocate_buffers(substream, sTriggerStream))
+			{
+				printk("memory error\n");
+				return -ENOMEM;
+			}
+			audio_prime_dma( externedtotsize,totsize,state, sTriggerStream);
+		}
+
+		DPRINTK("EP93xx - audio_read Exit\n");
+	}
+	
+	break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+
+		/*audio_dma_pause( state, sTriggerStream );*/
+
+		sTriggerStream->stopped = 1;
+		sTriggerStream->active 	= 0;
+		sTriggerStream->mapped  = 0;
+
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+/*		if (!sTriggerStream->active){
+			if (!sTriggerStream->buffers && audio_allocate_buffers(substream, sTriggerStream))
+				return -ENOMEM;
+			
+			if (sTriggerStream->mapped)
+				audio_prime_dma( totsize,state, sTriggerStream);
+		}
+					
+		if (sTriggerStream->stopped){
+			sTriggerStream->stopped = 0;
+			sTriggerStream->active 	= 1;
+			audio_dma_start( state, sTriggerStream );
+		}
+*/		break;
+
+	default:
+		ret = -EINVAL;
+		DPRINTK("SNDRV_PCM_TRIGGER didnot support this command %x",cmd);
+	}
+
+	return ret;
+}
+
+/*
+ *Get the frame location
+ */
+static snd_pcm_uframes_t ep93xx_ac97_pcm_pointer(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime 	= substream->runtime;
+
+	audio_state_t  *state 		= (audio_state_t *)substream->private_data;
+	audio_stream_t *sStream 		= (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+						state->output_stream:state->input_stream;
+	snd_pcm_uframes_t x=0;
+
+	unsigned int buf_id, total,current_frac;
+
+
+	if( (ep93xx_dma_get_position(sStream->dmahandles[0], &buf_id, &total, &current_frac) == 0) &&
+		(buf_id != -1) ){
+	 	x = bytes_to_frames(runtime,sStream->bytecount);
+		
+	}
+	else{
+	 	x = bytes_to_frames(runtime,sStream->bytecount);
+
+	}
+	
+	DPRINTK(" %x %x %x\n",sStream->bytecount,current_frac,bytes_to_frames(runtime,total)%runtime->buffer_size);
+	if (x >= runtime->buffer_size){
+ 		x = 0;
+		/*x=runtime->buffer_size;*/
+	   	sStream->bytecount=0;
+		sStream->externedbytecount=0;
+    }
+	DPRINTK("x=%x\n",x);
+
+
+
+
+	return x;
+}
+
+
+
+static int ep93xx_ac97_pcm_open(snd_pcm_substream_t *substream)
+{
+	audio_state_t *state = substream->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+	int err;
+
+	DPRINTK("ep93xx_ac97_pcm_open----ENTER\n");
+	
+	/* set the hardware description*/
+	runtime->hw = ep93xx_ac97_pcm_hardware;
+
+
+	down(&state->sem);
+	
+	/*write :output direction*/
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ) 
+	{
+		DPRINTK("ep93xx_audio_open -- FMODE_WRITE\n");
+		
+		strncpy( os->devicename, state->output_id, MAX_DEVICE_NAME );
+
+		/* 
+	 	 * Request DMA channels 
+	 	 */
+		err = ep93xx_dma_request( 	&os->dmahandles[0], 
+									os->devicename,
+                       				state->output_dma );
+		if (err)
+		{
+			up(&state->sem);
+			DPRINTK("ep93xx_audio_open -- EXIT ERROR dma request failed\n");
+			return err;
+		}
+		/* 
+	 	 * Config DMA channels 
+	 	 */
+		err = ep93xx_dma_config( 	os->dmahandles[0], 
+									IGNORE_CHANNEL_ERROR, 
+									0,
+									audio_dma_tx_callback, 
+									(unsigned int)substream );
+		if (err) 
+		{
+			ep93xx_dma_free( os->dmahandles[0] );
+			up(&state->sem);
+			DPRINTK("ep93xx_audio_attach -- EXIT ERROR dma config failed\n");
+			return err;
+		}
+
+		os->NumDmaChannels = 1;
+		state->wr_ref = 1;
+		audio_deallocate_buffers(substream,os);
+
+		os->fragsize 	= AUDIO_FRAGSIZE_DEFAULT;
+		os->nbfrags  	= AUDIO_NBFRAGS_DEFAULT;
+
+		os->reportedfrags = scale_to_expanded_samples( state, AUDIO_NBFRAGS_DEFAULT,substream->stream );
+
+		os->mapped 	= 0;
+		os->stopped = 0;
+		init_waitqueue_head(&os->wq);
+	}
+	
+	/*read :input direction*/
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE) 
+	{
+		strncpy( is->devicename, state->input_id, MAX_DEVICE_NAME );
+		/* 
+	 	 * Request DMA channels 
+	 	 */
+		err = ep93xx_dma_request( 	&is->dmahandles[0], 
+									is->devicename,
+                       				state->input_dma);
+		DPRINTK("%x %x %x\n", &is->dmahandles[0],is->devicename,state->input_dma);
+		if (err) 
+		{
+			up(&state->sem);
+			printk("ep93xx_audio_attach -- EXIT ERROR dma request failed\n");
+			return err;
+		}
+		
+		/* 
+	 	 * Config DMA channels 
+	 	 */
+		err = ep93xx_dma_config( 	is->dmahandles[0], 
+									IGNORE_CHANNEL_ERROR, 
+									0,
+									audio_dma_rx_callback, 
+									(unsigned int)substream );
+		if (err) 
+		{
+			ep93xx_dma_free( is->dmahandles[0] );
+			up(&state->sem);
+			printk("ep93xx_audio_attach -- EXIT ERROR dma config failed\n");
+			return err;
+		}
+
+		is->NumDmaChannels = 1;
+		state->rd_ref = 1;
+		audio_deallocate_buffers(substream,is);
+		is->fragsize 	= AUDIO_FRAGSIZE_DEFAULT;
+		is->nbfrags 	= AUDIO_NBFRAGS_DEFAULT;
+
+		is->reportedfrags = scale_to_expanded_samples( state, AUDIO_NBFRAGS_DEFAULT,substream->stream );
+
+		is->mapped 	= 0;
+		is->stopped = 		0;
+		init_waitqueue_head(&is->wq);
+	}
+
+	up(&state->sem);
+
+	DPRINTK("ep93xx_audio_open -- EXIT\n");
+
+	/*ac97 controller and codec startup*/
+	err = state->startup(substream);
+	if (!err)
+		goto out;
+ out:
+	return err;
+
+	
+}
+
+/*
+ *free the HW dma channel
+ *free the HW dma buffer
+ *free the Hw dma decrotion using function :kfree
+ *shut down the ac97 codec and  Ac97 controller
+ */
+static int ep93xx_ac97_pcm_close(snd_pcm_substream_t *substream)
+{
+	audio_state_t *state = substream->private_data;
+	int ret;
+
+	DPRINTK("ep93xx_ac97_pcm_close----ENTER\n");
+
+	ret = audio_release(substream);
+	if(ret!=0)
+		printk("%s error %x",__FUNCTION__,ret);
+
+	/*ac97 controller and codec shutdown*/
+	state->shutdown(substream);
+
+	DPRINTK("ep93xx_ac97_pcm_close----Over\n");
+	return 0;
+}
+
+
+/*
+ *map the driver memory space to user memory space
+ */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+static int
+ep93xx_ac97_pcm_mmap(snd_pcm_substream_t *substream, struct vm_area_struct *vma)
+{
+		
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	//snd_pcm_lib_mmap_iomem
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+
+
+}
+#endif
+
+
+static int ep93xx_ac97_pcm_copy(snd_pcm_substream_t * substream,int channel, snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+
+	audio_state_t *state 		= (audio_state_t *)substream->private_data;
+	snd_pcm_runtime_t *runtime 	= substream->runtime;
+
+	/*unsigned long bpos=frames_to_bytes(runtime,pos);*/
+	int tocount=frames_to_bytes(runtime,count);
+	int ret=0;	
+	char *hwbuf ;
+	size_t dma_csize = runtime->dma_bytes / runtime->channels;
+	
+	if(channel==-1){
+		//hwbuf	= runtime->dma_area  + scale_to_expanded_samples( state,frames_to_bytes(runtime, pos),substream->stream);
+	
+		//hwbuf	= runtime->dma_area  + scale_to_expanded_samples( state,samples_to_bytes(runtime, pos)*2,substream->stream);
+	hwbuf = runtime->dma_area  + scale_to_expanded_samples( state,frames_to_bytes(runtime, pos),substream->stream);
+	
+	DPRINTK("copy frames=%x,%x,pos=%x,bpos=%x channel=%x\n ",count,tocount,pos,samples_to_bytes(runtime, pos),channel);
+	}
+	else{
+		hwbuf	= runtime->dma_area + (channel * dma_csize) + samples_to_bytes(runtime, pos);
+		DPRINTK("copy frames=%x,,pos=%x,bpos=%x channel=%x\n ",count,pos,(channel * dma_csize) + samples_to_bytes(runtime, pos),channel);
+	}
+	
+	ret=copy_n_convert(state,hwbuf,(const char*)src,scale_to_expanded_samples(state,tocount,substream->stream));
+	if(ret<=0){
+		DPRINTK(" copy_n_convert error ,convert %x\n",ret);
+		return -EFAULT;
+	}
+	
+	ret=0;
+	return ret;
+}
+
+static int ep93xx_ac97_pcm_capture_copy(snd_pcm_substream_t * substream,int channel, snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+	audio_state_t *state 		= (audio_state_t *)(substream->private_data);
+	snd_pcm_runtime_t *runtime 	= substream->runtime;
+	/*audio_stream_t *s 			= state->input_stream;*/
+
+	char *hwbuf = runtime->dma_area + scale_to_expanded_samples(state,frames_to_bytes(runtime, pos),substream->stream);//frames_to_bytes(runtime, pos);
+	
+
+	/*audio_buf_t *buf ;*/
+
+     	DPRINTK("copy frames=%x,%x,pos=%x,bpos=%x channel=%x\n ",count,tocount,pos,samples_to_bytes(runtime, pos),channel);
+
+
+
+	if(copy_to_user_with_conversion(state,(char *)src,hwbuf, frames_to_bytes(runtime, count))==0)
+	//if (copy_to_user((char *)src, hwbuf, frames_to_bytes(runtime, count)))
+	{
+		DPRINTK("copy to user eror\n");
+		/*up(&buf->sem);*/
+		return -EFAULT;
+	}
+
+	return 0;
+	
+}
+
+static snd_pcm_ops_t ep93xx_ac97_palyback_pcm_ops = {
+	.open		= ep93xx_ac97_pcm_open,
+	.close		= ep93xx_ac97_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= ep93xx_ac97_pcm_hw_params,
+	.hw_free		= ep93xx_ac97_pcm_hw_free,
+	.prepare		= ep93xx_ac97_pcm_prepare,
+	.trigger		= ep93xx_ac97_pcm_trigger,
+	.pointer		= ep93xx_ac97_pcm_pointer,
+	.copy 		= ep93xx_ac97_pcm_copy,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	.mmap		= ep93xx_ac97_pcm_mmap,
+#endif
+
+};
+
+static snd_pcm_ops_t ep93xx_ac97_capture_pcm_ops = {
+	.open		= ep93xx_ac97_pcm_open,
+	.close		= ep93xx_ac97_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= ep93xx_ac97_pcm_hw_params,
+	.hw_free		= ep93xx_ac97_pcm_hw_free,
+	.prepare		= ep93xx_ac97_pcm_prepare,
+	.trigger		= ep93xx_ac97_pcm_trigger,
+	.pointer		= ep93xx_ac97_pcm_pointer,
+	.copy 		= ep93xx_ac97_pcm_capture_copy,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	.mmap		= ep93xx_ac97_pcm_mmap,
+#endif
+
+};
+
+/* -----------------------------------------------------------------------------------*/
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+
+static int ep93xx_ac97_pcm_preallocate_dma_buffer(snd_pcm_t *pcm, int stream)
+{
+	snd_pcm_substream_t *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = ep93xx_ac97_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+		
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area){
+		DPRINTK("%s buf->area=%x,size=%x\n,buf->addr=%x",__FUNCTION__,buf->area,size,buf->addr);
+		return -ENOMEM;
+	}
+
+	buf->bytes = size;
+	return 0;
+}
+
+static void ep93xx_ac97_pcm_free_dma_buffers(snd_pcm_t *pcm)
+{
+	snd_pcm_substream_t *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+#endif
+
+
+static u64 ep93xx_ac97_pcm_dmamask = 0xffffffff;
+
+int ep93xx_ac97_pcm_new(snd_card_t *card, audio_state_t *state, snd_pcm_t **rpcm)
+{
+	snd_pcm_t *pcm;
+	int play = state->output_stream? 1 : 0;/*SNDRV_PCM_STREAM_PLAYBACK*/
+	int capt = state->input_stream ? 1 : 0;/*SNDRV_PCM_STREAM_CAPTURE*/
+	int ret;
+
+
+	DPRINTK("ep93xx_ac97_pcm_new----ENTER\n");
+
+	/*
+	 *Register the new pcm device interface
+	 */
+	ret = snd_pcm_new(card, "EP93xx-AC97-PCM", 0, play, capt, &pcm);
+	if (ret){
+		DPRINTK("%s--%x:card=%x,play=%x,capt=%x,&pcm=%x\n",__FUNCTION__,ret,card,play,capt,pcm);
+		goto out;
+	}
+
+	/*
+	 *Allocate the pcm(DMA) memory  
+	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+#else
+/*
+	ret=snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+						snd_dma_continuous_data(GFP_KERNEL), 128*1024, 128*1024);
+*/
+	ret=snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,0, 2*2*128*1024, 2*2*128*1024);
+#endif
+
+	DPRINTK("err=%x---1add=%x,1area=%x,1bytes=%x,2add=%x,2area=%x,2bytes=%x\n",ret,
+						pcm->streams[0].substream->dma_buffer.addr,
+						pcm->streams[0].substream->dma_buffer.area,
+						pcm->streams[0].substream->dma_buffer.bytes,
+						pcm->streams[1].substream->dma_buffer.addr,
+						pcm->streams[1].substream->dma_buffer.area,
+						pcm->streams[1].substream->dma_buffer.bytes);	
+
+
+	pcm->private_data = state;
+
+	/*seem to free the pcm data struct-->self dma buffer*/
+	#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	pcm->private_free = ep93xx_ac97_pcm_free_dma_buffers;
+	#else
+	pcm->private_free = (void *)snd_pcm_lib_preallocate_free_for_all;
+	#endif
+
+	
+	/*in the ep93 arch file,have similar setting*/
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &ep93xx_ac97_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+
+	/*
+	 *alsa pcm ops setting for SNDRV_PCM_STREAM_PLAYBACK
+	 */
+	if (play) {
+		int stream = SNDRV_PCM_STREAM_PLAYBACK;
+		snd_pcm_set_ops(pcm, stream, &ep93xx_ac97_palyback_pcm_ops);
+		
+		#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+		ret = ep93xx_ac97_pcm_preallocate_dma_buffer(pcm, stream);
+		if (ret){
+			DPRINTK("%s--%x:pcm=%x,stream=%x\n",__FUNCTION__,ret,pcm,stream);
+			goto out;
+		}
+		#endif
+	}
+
+	/*
+	 *alsa pcm ops setting for SNDRV_PCM_STREAM_CAPTURE
+	 */	
+	if (capt) {
+		int stream = SNDRV_PCM_STREAM_CAPTURE;
+		snd_pcm_set_ops(pcm, stream, &ep93xx_ac97_capture_pcm_ops);
+
+		#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+		ret = ep93xx_ac97_pcm_preallocate_dma_buffer(pcm, stream);
+		if (ret){
+			DPRINTK("%s--%x:pcm=%x,stream=%x\n",__FUNCTION__,ret,pcm,stream);;
+			goto out;
+		}
+		#endif
+	}
+
+	if (rpcm)
+		*rpcm = pcm;
+	
+	ret = 0;
+	
+	DPRINTK("ep93xx_ac97_pcm_new----EXIT\n");
+	
+ out:
+	return ret;
+}
+
+EXPORT_SYMBOL(ep93xx_ac97_pcm_new);
+
+MODULE_AUTHOR("Shrek");
+MODULE_DESCRIPTION("Cirrus Ep9xxx AC97 PCM module");
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/sound/arm/ep93xx-alsa-pcm.h linux-2.6.8.1/sound/arm/ep93xx-alsa-pcm.h
--- linux-2.6.8.1-orig/sound/arm/ep93xx-alsa-pcm.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/sound/arm/ep93xx-alsa-pcm.h	2007-01-24 13:03:31.000000000 +0900
@@ -0,0 +1,150 @@
+/*
+ * linux/sound/arm/ep93xx-alsa-ac97.c -- ALSA PCM interface for the edb93xx ac97 audio
+ *
+ * Author:      Shrek Wu
+ * Created:     July 19, 2005
+ * Copyright:   Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+ 
+#define AC97_SLOT_0 	0x0001
+#define AC97_SLOT_1 	0x0002
+#define AC97_SLOT_2 	0x0004
+#define AC97_SLOT_3 	0x0008
+#define AC97_SLOT_4 	0x0010
+#define AC97_SLOT_5 	0x0020
+#define AC97_SLOT_6 	0x0040
+#define AC97_SLOT_7 	0x0080
+#define AC97_SLOT_8 	0x0100
+#define AC97_SLOT_9 	0x0200
+#define AC97_SLOT_10 	0x0400
+#define AC97_SLOT_11 	0x0800
+#define AC97_SLOT_12 	0x1000
+
+
+
+#define I2S_SCALE_BUFFERS
+
+/*
+ *  Getting this from the rme96xx driver.  Has same numerical value
+ *  as AC3.  Hmmmm.
+ */
+#ifndef AFMT_S32_BLOCKED
+#define AFMT_S32_BLOCKED 0x0000400
+#endif
+
+#define EP93XX_DEFAULT_NUM_CHANNELS      2
+#define EP93XX_DEFAULT_FORMAT            AFMT_S16_LE
+#define EP93XX_DEFAULT_BIT_WIDTH         16
+
+/*
+ * Buffer Management
+ */
+
+typedef struct {
+
+	int 				size;			/* buffer size 						*/
+	int 				reportedsize;			/* buffer size 						*/
+	int 				sent;			/* indicates that dma has the buf	*/
+	char 				*start;			/* points to actual buffer 			*/
+	dma_addr_t 			dma_addr;		/* physical buffer address 			*/
+	struct semaphore 	sem;			/* down before touching the buffer 	*/
+	int 				master;			/* owner for buffer allocation,    	*/
+										/* contains size when true 			*/
+	struct audio_stream_s 	*stream;	/* owning stream 					*/
+
+} audio_buf_t;
+
+#define MAX_DEVICE_NAME 20
+
+typedef struct audio_stream_s {
+
+	/* dma stuff */
+	int				dmahandles[3];		/* handles for dma driver instances */
+	char			devicename[MAX_DEVICE_NAME]; /* string - name of device */
+	int				NumDmaChannels;		/* 1, 2, or 3 DMA channels 			*/
+	
+	audio_buf_t 	*buffers;			/* array of audio buffer structures */
+	audio_buf_t 	*buf;				/* current buffer used by read/write */
+	u_int 			buf_idx;			/* index for the pointer above... 	*/
+	u_int 			fragsize;			/* fragment i.e. buffer size 		*/
+	u_int 			nbfrags;			/* nbr of fragments i.e. buffers 	*/
+	u_int			reportedfrags;		/* # of frags reported to app		*/
+	u_int 			externedfragsize;			/* fragment i.e. buffer size 		*/
+	int 			bytecount;			/* nbr of processed bytes 			*/
+	int 			externedbytecount;			/* nbr of processed bytes 			*/
+	int 			getptrCount;		/* value of bytecount last time 	*/
+										/* anyone asked via GETxPTR 		*/
+	int 			fragcount;			/* nbr of fragment transitions 		*/
+	ep93xx_dma_int_t dma_ch;			/* DMA channel ID 					*/
+	wait_queue_head_t 	wq;				/* for poll 						*/
+	int 			mapped;			/* mmap()'ed buffers 				*/
+	int 			active;			/* actually in progress 			*/
+	int 			stopped;			/* might be active but stopped 		*/
+
+	/*
+	 * Data about the file format that we are configured to play.
+	 */
+	long 				audio_num_channels;			/* Range: 1 to 6 */
+	long 				audio_format;
+	long 				audio_stream_bitwidth;		/* Range: 8, 16, 24, 32 */
+
+} audio_stream_t;
+
+
+/*
+ * State structure for one instance
+ */
+typedef struct {
+	audio_stream_t 		*output_stream;
+	audio_stream_t 		*input_stream;
+	
+	ep93xx_dma_dev_t 	output_dma;
+	ep93xx_dma_dev_t 	input_dma;
+	
+	char 				*output_id;
+	char 				*input_id;
+	
+	int 				rd_ref:1;			/* open reference for recording */
+	int 				wr_ref:1;			/* open reference for playback */
+	
+	/*
+	 * Pointers to init, shutdown, and ioctl functions.
+	 */
+	void 				(*hw_enable)(int input_or_output_stream);
+	void 				(*hw_disable)(int input_or_output_stream);
+	int 				(*client_ioctl)(struct inode *, struct file *, uint, ulong);
+	void				(*set_hw_serial_format)( long,long );
+
+	/*
+	 *
+	 */
+	struct 				semaphore Loopsem;		/* to protect against races in attach() */
+	int (*startup)(snd_pcm_substream_t *);
+	void (*shutdown)(snd_pcm_substream_t *);
+	int (*prepare)(snd_pcm_substream_t *);
+
+	/*
+	 *
+	 */
+
+	struct 				semaphore sem;		/* to protect against races in attach() */
+
+	/*
+	 * Data about how the audio controller and codec are set up.
+	 */
+	int					DAC_bit_width;		/* 16, 20, 24 bits */
+	int					bCompactMode;		/* set if 32bits = a stereo sample */
+
+} audio_state_t;
+
+
+
+
+
+
+extern int ep93xx_ac97_pcm_new(snd_card_t *card, audio_state_t *state, snd_pcm_t **rpcm);
+
diff -burN linux-2.6.8.1-orig/sound/arm/ep93xx-i2s.c linux-2.6.8.1/sound/arm/ep93xx-i2s.c
--- linux-2.6.8.1-orig/sound/arm/ep93xx-i2s.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/sound/arm/ep93xx-i2s.c	2007-01-15 12:17:44.000000000 +0900
@@ -0,0 +1,3139 @@
+/*
+ * linux/sound/arm/ep93xx-i2s.c -- ALSA PCM interface for the edb93xx i2s audio
+ *
+ * Author:      Fred Wei
+ * Created:     July 19, 2005
+ * Copyright:   Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/version.h>
+#include <linux/soundcard.h>
+#include <linux/sched.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+                                                                                                                             
+#include <asm/irq.h>
+#include <asm/semaphore.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <asm/arch/dma.h>
+#include <asm/arch/regs_i2s.h>
+#include <asm/arch/ssp.h>
+#include "ep93xx-i2s.h"
+
+//#define DEBUG 1
+#ifdef DEBUG
+#define DPRINTK( fmt, arg... )  printk( fmt, ##arg )
+#else
+#define DPRINTK( fmt, arg... )
+#endif
+
+static const snd_pcm_hardware_t ep93xx_i2s_pcm_hardware = {
+    .info           = (
+				   SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_PAUSE ),
+	.formats 		= (SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
+				   SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+				   SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+				   SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_S24_LE |
+				   SNDRV_PCM_FMTBIT_U24_BE | SNDRV_PCM_FMTBIT_S24_BE ),
+	.rates			=( SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |
+				   SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |
+				   SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+				   SNDRV_PCM_RATE_48000),
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 1,
+	.channels_max		= 2,					
+    .period_bytes_min   = 2*1024,
+    .period_bytes_max   = 16*1024,
+    .periods_min        = 4,
+    .periods_max        = 16,
+    .buffer_bytes_max   = 32*1024,
+};
+
+#define AUDIO_NAME		"ep93xx-audio"
+
+#define AUDIO_NBFRAGS_DEFAULT	8
+#define AUDIO_FRAGSIZE_DEFAULT	16384
+
+/*
+ * Translates to:
+ * 		s->buf_idx++;
+ * 		s->buf_idx %= s->nbfrags;
+ *		s->buf = s->buffers + s->buf_idx;
+ *
+ * So s->buf always points to the s->buf_idx-nth element of s->buffers.
+ */
+#define NEXT_BUF(_s_,_b_) { \
+	(_s_)->_b_##_idx++; \
+	(_s_)->_b_##_idx %= (_s_)->nbfrags; \
+	(_s_)->_b_ = (_s_)->buffers + (_s_)->_b_##_idx; }
+
+#define AUDIO_ACTIVE(state)	((state)->rd_ref || (state)->wr_ref)
+
+#define AUDIO_SAMPLE_RATE_DEFAULT	44100
+
+/*
+ * Set the volume attenuation to minimum
+ */ 
+#define AUDIO_DEFAULT_VOLUME		0 
+
+/*
+ * Statics
+ */
+static int volume = AUDIO_DEFAULT_VOLUME;
+static int mute = 0;
+
+static int audio_has_been_initialized = 0;
+static int audio_clocks_enabled_in_syscon = 0;
+static int SSP_Handle = -1;
+
+static int ep93xx_calc_closest_freq
+(
+    ulong   ulPLLFreq, 
+    ulong   ulRequestedMClkFreq,
+    ulong * pulActualMClkFreq,
+    ulong * pulI2SDiv
+);
+static void ep93xx_set_samplerate(long lFrequency);
+static void ep93xx_init_i2s_controller( void );
+
+static void ep93xx_init_i2s_codec( void );
+static void ep93xx_automute_i2s_codec( void );
+static int ep93xx_set_volume( int val );
+
+static void ep93xx_audio_init(void *dummy);
+
+static audio_stream_t output_stream =
+{
+	.audio_num_channels 	= EP93XX_DEFAULT_NUM_CHANNELS,
+	.audio_format 		= EP93XX_DEFAULT_FORMAT,
+	.audio_stream_bitwidth 	= EP93XX_DEFAULT_BIT_WIDTH,
+	.dma2usr_ratio 		= 2,
+};
+
+static audio_stream_t input_stream =
+{
+	.audio_num_channels 	= EP93XX_DEFAULT_NUM_CHANNELS,
+	.audio_format 		= EP93XX_DEFAULT_FORMAT,
+	.audio_stream_bitwidth 	= EP93XX_DEFAULT_BIT_WIDTH,
+	.dma2usr_ratio 		= 2,
+};
+
+static audio_state_t audio_state =
+{
+	.output_stream		= &output_stream,
+	.output_dma		= DMATx_I2S1,
+	.output_id		= "I2S out",
+	
+	.input_stream		= &input_stream,
+	.input_dma		= DMARx_I2S1,
+	.input_id		= "I2S in",
+	
+//	.client_ioctl		= ep93xx_audio_ioctl,
+	.hw_enable          	= 0,
+	.hw_disable         	= 0,
+	
+	.set_hw_serial_format 	= 0,
+
+//	.startup		 = ep93xx_i2s_pcm_startup,
+//	.shutdown		 = ep93xx_i2s_pcm_shutdown,
+//	.prepare		 = ep93xx_i2s_pcm_prepare,
+	.sem			=__MUTEX_INITIALIZER(audio_state.sem),
+	
+	.DAC_bit_width		= 24,
+	.bCompactMode		= 0,
+};
+
+static snd_pcm_t *ep93xx_i2s_pcm;
+
+typedef struct {
+    ulong   ulTotalDiv;
+    ulong   ulI2SDiv;
+} DIV_TABLE;
+
+static const DIV_TABLE I2SDivTable[] =
+{
+    {   6, SYSCON_I2SDIV_PDIV_2  | (  2 & SYSCON_I2SDIV_MDIV_MASK) },  /* Fake entry for lower limit. */
+    {   8, SYSCON_I2SDIV_PDIV_2  | (  2 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  10, SYSCON_I2SDIV_PDIV_25 | (  2 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  12, SYSCON_I2SDIV_PDIV_3  | (  2 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  15, SYSCON_I2SDIV_PDIV_25 | (  3 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  16, SYSCON_I2SDIV_PDIV_2  | (  4 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  18, SYSCON_I2SDIV_PDIV_3  | (  3 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  20, SYSCON_I2SDIV_PDIV_25 | (  4 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  24, SYSCON_I2SDIV_PDIV_3  | (  4 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  25, SYSCON_I2SDIV_PDIV_25 | (  5 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  28, SYSCON_I2SDIV_PDIV_2  | (  7 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  30, SYSCON_I2SDIV_PDIV_3  | (  5 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  32, SYSCON_I2SDIV_PDIV_2  | (  8 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  35, SYSCON_I2SDIV_PDIV_25 | (  7 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  36, SYSCON_I2SDIV_PDIV_3  | (  6 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  40, SYSCON_I2SDIV_PDIV_25 | (  8 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  42, SYSCON_I2SDIV_PDIV_3  | (  7 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  44, SYSCON_I2SDIV_PDIV_2  | ( 11 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  45, SYSCON_I2SDIV_PDIV_25 | (  9 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  48, SYSCON_I2SDIV_PDIV_3  | (  8 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  50, SYSCON_I2SDIV_PDIV_25 | ( 10 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  52, SYSCON_I2SDIV_PDIV_2  | ( 13 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  54, SYSCON_I2SDIV_PDIV_3  | (  9 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  55, SYSCON_I2SDIV_PDIV_25 | ( 11 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  56, SYSCON_I2SDIV_PDIV_2  | ( 14 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  60, SYSCON_I2SDIV_PDIV_3  | ( 10 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  64, SYSCON_I2SDIV_PDIV_2  | ( 16 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  65, SYSCON_I2SDIV_PDIV_25 | ( 13 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  66, SYSCON_I2SDIV_PDIV_3  | ( 11 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  68, SYSCON_I2SDIV_PDIV_2  | ( 17 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  70, SYSCON_I2SDIV_PDIV_25 | ( 14 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  72, SYSCON_I2SDIV_PDIV_3  | ( 12 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  75, SYSCON_I2SDIV_PDIV_25 | ( 15 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  76, SYSCON_I2SDIV_PDIV_2  | ( 19 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  78, SYSCON_I2SDIV_PDIV_3  | ( 13 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  80, SYSCON_I2SDIV_PDIV_25 | ( 16 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  84, SYSCON_I2SDIV_PDIV_3  | ( 14 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  85, SYSCON_I2SDIV_PDIV_25 | ( 17 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  88, SYSCON_I2SDIV_PDIV_2  | ( 22 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  90, SYSCON_I2SDIV_PDIV_3  | ( 15 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  92, SYSCON_I2SDIV_PDIV_2  | ( 23 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  95, SYSCON_I2SDIV_PDIV_25 | ( 19 & SYSCON_I2SDIV_MDIV_MASK) },
+    {  96, SYSCON_I2SDIV_PDIV_3  | ( 16 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 100, SYSCON_I2SDIV_PDIV_25 | ( 20 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 102, SYSCON_I2SDIV_PDIV_3  | ( 17 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 104, SYSCON_I2SDIV_PDIV_2  | ( 26 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 105, SYSCON_I2SDIV_PDIV_25 | ( 21 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 108, SYSCON_I2SDIV_PDIV_3  | ( 18 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 110, SYSCON_I2SDIV_PDIV_25 | ( 22 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 112, SYSCON_I2SDIV_PDIV_2  | ( 28 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 114, SYSCON_I2SDIV_PDIV_3  | ( 19 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 115, SYSCON_I2SDIV_PDIV_25 | ( 23 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 116, SYSCON_I2SDIV_PDIV_2  | ( 29 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 120, SYSCON_I2SDIV_PDIV_3  | ( 20 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 124, SYSCON_I2SDIV_PDIV_2  | ( 31 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 125, SYSCON_I2SDIV_PDIV_25 | ( 25 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 126, SYSCON_I2SDIV_PDIV_3  | ( 21 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 128, SYSCON_I2SDIV_PDIV_2  | ( 32 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 130, SYSCON_I2SDIV_PDIV_25 | ( 26 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 132, SYSCON_I2SDIV_PDIV_3  | ( 22 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 135, SYSCON_I2SDIV_PDIV_25 | ( 27 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 136, SYSCON_I2SDIV_PDIV_2  | ( 34 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 138, SYSCON_I2SDIV_PDIV_3  | ( 23 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 140, SYSCON_I2SDIV_PDIV_25 | ( 28 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 144, SYSCON_I2SDIV_PDIV_3  | ( 24 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 145, SYSCON_I2SDIV_PDIV_25 | ( 29 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 148, SYSCON_I2SDIV_PDIV_2  | ( 37 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 150, SYSCON_I2SDIV_PDIV_3  | ( 25 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 152, SYSCON_I2SDIV_PDIV_2  | ( 38 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 155, SYSCON_I2SDIV_PDIV_25 | ( 31 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 156, SYSCON_I2SDIV_PDIV_3  | ( 26 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 160, SYSCON_I2SDIV_PDIV_25 | ( 32 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 162, SYSCON_I2SDIV_PDIV_3  | ( 27 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 164, SYSCON_I2SDIV_PDIV_2  | ( 41 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 165, SYSCON_I2SDIV_PDIV_25 | ( 33 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 168, SYSCON_I2SDIV_PDIV_3  | ( 28 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 170, SYSCON_I2SDIV_PDIV_25 | ( 34 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 172, SYSCON_I2SDIV_PDIV_2  | ( 43 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 174, SYSCON_I2SDIV_PDIV_3  | ( 29 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 175, SYSCON_I2SDIV_PDIV_25 | ( 35 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 176, SYSCON_I2SDIV_PDIV_2  | ( 44 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 180, SYSCON_I2SDIV_PDIV_3  | ( 30 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 184, SYSCON_I2SDIV_PDIV_2  | ( 46 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 185, SYSCON_I2SDIV_PDIV_25 | ( 37 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 186, SYSCON_I2SDIV_PDIV_3  | ( 31 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 188, SYSCON_I2SDIV_PDIV_2  | ( 47 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 190, SYSCON_I2SDIV_PDIV_25 | ( 38 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 192, SYSCON_I2SDIV_PDIV_3  | ( 32 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 195, SYSCON_I2SDIV_PDIV_25 | ( 39 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 196, SYSCON_I2SDIV_PDIV_2  | ( 49 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 198, SYSCON_I2SDIV_PDIV_3  | ( 33 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 200, SYSCON_I2SDIV_PDIV_25 | ( 40 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 204, SYSCON_I2SDIV_PDIV_3  | ( 34 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 205, SYSCON_I2SDIV_PDIV_25 | ( 41 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 208, SYSCON_I2SDIV_PDIV_2  | ( 52 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 210, SYSCON_I2SDIV_PDIV_3  | ( 35 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 212, SYSCON_I2SDIV_PDIV_2  | ( 53 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 215, SYSCON_I2SDIV_PDIV_25 | ( 43 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 216, SYSCON_I2SDIV_PDIV_3  | ( 36 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 220, SYSCON_I2SDIV_PDIV_25 | ( 44 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 222, SYSCON_I2SDIV_PDIV_3  | ( 37 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 224, SYSCON_I2SDIV_PDIV_2  | ( 56 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 225, SYSCON_I2SDIV_PDIV_25 | ( 45 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 228, SYSCON_I2SDIV_PDIV_3  | ( 38 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 230, SYSCON_I2SDIV_PDIV_25 | ( 46 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 232, SYSCON_I2SDIV_PDIV_2  | ( 58 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 234, SYSCON_I2SDIV_PDIV_3  | ( 39 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 235, SYSCON_I2SDIV_PDIV_25 | ( 47 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 236, SYSCON_I2SDIV_PDIV_2  | ( 59 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 240, SYSCON_I2SDIV_PDIV_3  | ( 40 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 244, SYSCON_I2SDIV_PDIV_2  | ( 61 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 245, SYSCON_I2SDIV_PDIV_25 | ( 49 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 246, SYSCON_I2SDIV_PDIV_3  | ( 41 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 248, SYSCON_I2SDIV_PDIV_2  | ( 62 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 250, SYSCON_I2SDIV_PDIV_25 | ( 50 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 252, SYSCON_I2SDIV_PDIV_3  | ( 42 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 255, SYSCON_I2SDIV_PDIV_25 | ( 51 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 256, SYSCON_I2SDIV_PDIV_2  | ( 64 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 258, SYSCON_I2SDIV_PDIV_3  | ( 43 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 260, SYSCON_I2SDIV_PDIV_25 | ( 52 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 264, SYSCON_I2SDIV_PDIV_3  | ( 44 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 265, SYSCON_I2SDIV_PDIV_25 | ( 53 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 268, SYSCON_I2SDIV_PDIV_2  | ( 67 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 270, SYSCON_I2SDIV_PDIV_3  | ( 45 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 272, SYSCON_I2SDIV_PDIV_2  | ( 68 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 275, SYSCON_I2SDIV_PDIV_25 | ( 55 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 276, SYSCON_I2SDIV_PDIV_3  | ( 46 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 280, SYSCON_I2SDIV_PDIV_25 | ( 56 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 282, SYSCON_I2SDIV_PDIV_3  | ( 47 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 284, SYSCON_I2SDIV_PDIV_2  | ( 71 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 285, SYSCON_I2SDIV_PDIV_25 | ( 57 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 288, SYSCON_I2SDIV_PDIV_3  | ( 48 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 290, SYSCON_I2SDIV_PDIV_25 | ( 58 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 292, SYSCON_I2SDIV_PDIV_2  | ( 73 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 294, SYSCON_I2SDIV_PDIV_3  | ( 49 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 295, SYSCON_I2SDIV_PDIV_25 | ( 59 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 296, SYSCON_I2SDIV_PDIV_2  | ( 74 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 300, SYSCON_I2SDIV_PDIV_3  | ( 50 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 304, SYSCON_I2SDIV_PDIV_2  | ( 76 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 305, SYSCON_I2SDIV_PDIV_25 | ( 61 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 306, SYSCON_I2SDIV_PDIV_3  | ( 51 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 308, SYSCON_I2SDIV_PDIV_2  | ( 77 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 310, SYSCON_I2SDIV_PDIV_25 | ( 62 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 312, SYSCON_I2SDIV_PDIV_3  | ( 52 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 315, SYSCON_I2SDIV_PDIV_25 | ( 63 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 316, SYSCON_I2SDIV_PDIV_2  | ( 79 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 318, SYSCON_I2SDIV_PDIV_3  | ( 53 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 320, SYSCON_I2SDIV_PDIV_25 | ( 64 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 324, SYSCON_I2SDIV_PDIV_3  | ( 54 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 325, SYSCON_I2SDIV_PDIV_25 | ( 65 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 328, SYSCON_I2SDIV_PDIV_2  | ( 82 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 330, SYSCON_I2SDIV_PDIV_3  | ( 55 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 332, SYSCON_I2SDIV_PDIV_2  | ( 83 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 335, SYSCON_I2SDIV_PDIV_25 | ( 67 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 336, SYSCON_I2SDIV_PDIV_3  | ( 56 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 340, SYSCON_I2SDIV_PDIV_25 | ( 68 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 342, SYSCON_I2SDIV_PDIV_3  | ( 57 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 344, SYSCON_I2SDIV_PDIV_2  | ( 86 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 345, SYSCON_I2SDIV_PDIV_25 | ( 69 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 348, SYSCON_I2SDIV_PDIV_3  | ( 58 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 350, SYSCON_I2SDIV_PDIV_25 | ( 70 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 352, SYSCON_I2SDIV_PDIV_2  | ( 88 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 354, SYSCON_I2SDIV_PDIV_3  | ( 59 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 355, SYSCON_I2SDIV_PDIV_25 | ( 71 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 356, SYSCON_I2SDIV_PDIV_2  | ( 89 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 360, SYSCON_I2SDIV_PDIV_3  | ( 60 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 364, SYSCON_I2SDIV_PDIV_2  | ( 91 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 365, SYSCON_I2SDIV_PDIV_25 | ( 73 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 366, SYSCON_I2SDIV_PDIV_3  | ( 61 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 368, SYSCON_I2SDIV_PDIV_2  | ( 92 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 370, SYSCON_I2SDIV_PDIV_25 | ( 74 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 372, SYSCON_I2SDIV_PDIV_3  | ( 62 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 375, SYSCON_I2SDIV_PDIV_25 | ( 75 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 376, SYSCON_I2SDIV_PDIV_2  | ( 94 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 378, SYSCON_I2SDIV_PDIV_3  | ( 63 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 380, SYSCON_I2SDIV_PDIV_25 | ( 76 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 384, SYSCON_I2SDIV_PDIV_3  | ( 64 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 385, SYSCON_I2SDIV_PDIV_25 | ( 77 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 388, SYSCON_I2SDIV_PDIV_2  | ( 97 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 390, SYSCON_I2SDIV_PDIV_3  | ( 65 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 392, SYSCON_I2SDIV_PDIV_2  | ( 98 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 395, SYSCON_I2SDIV_PDIV_25 | ( 79 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 396, SYSCON_I2SDIV_PDIV_3  | ( 66 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 400, SYSCON_I2SDIV_PDIV_25 | ( 80 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 402, SYSCON_I2SDIV_PDIV_3  | ( 67 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 404, SYSCON_I2SDIV_PDIV_2  | (101 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 405, SYSCON_I2SDIV_PDIV_25 | ( 81 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 408, SYSCON_I2SDIV_PDIV_3  | ( 68 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 410, SYSCON_I2SDIV_PDIV_25 | ( 82 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 412, SYSCON_I2SDIV_PDIV_2  | (103 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 414, SYSCON_I2SDIV_PDIV_3  | ( 69 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 415, SYSCON_I2SDIV_PDIV_25 | ( 83 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 416, SYSCON_I2SDIV_PDIV_2  | (104 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 420, SYSCON_I2SDIV_PDIV_3  | ( 70 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 424, SYSCON_I2SDIV_PDIV_2  | (106 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 425, SYSCON_I2SDIV_PDIV_25 | ( 85 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 426, SYSCON_I2SDIV_PDIV_3  | ( 71 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 428, SYSCON_I2SDIV_PDIV_2  | (107 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 430, SYSCON_I2SDIV_PDIV_25 | ( 86 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 432, SYSCON_I2SDIV_PDIV_3  | ( 72 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 435, SYSCON_I2SDIV_PDIV_25 | ( 87 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 436, SYSCON_I2SDIV_PDIV_2  | (109 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 438, SYSCON_I2SDIV_PDIV_3  | ( 73 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 440, SYSCON_I2SDIV_PDIV_25 | ( 88 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 444, SYSCON_I2SDIV_PDIV_3  | ( 74 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 445, SYSCON_I2SDIV_PDIV_25 | ( 89 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 448, SYSCON_I2SDIV_PDIV_2  | (112 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 450, SYSCON_I2SDIV_PDIV_3  | ( 75 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 452, SYSCON_I2SDIV_PDIV_2  | (113 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 455, SYSCON_I2SDIV_PDIV_25 | ( 91 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 456, SYSCON_I2SDIV_PDIV_3  | ( 76 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 460, SYSCON_I2SDIV_PDIV_25 | ( 92 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 462, SYSCON_I2SDIV_PDIV_3  | ( 77 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 464, SYSCON_I2SDIV_PDIV_2  | (116 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 465, SYSCON_I2SDIV_PDIV_25 | ( 93 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 468, SYSCON_I2SDIV_PDIV_3  | ( 78 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 470, SYSCON_I2SDIV_PDIV_25 | ( 94 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 472, SYSCON_I2SDIV_PDIV_2  | (118 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 474, SYSCON_I2SDIV_PDIV_3  | ( 79 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 475, SYSCON_I2SDIV_PDIV_25 | ( 95 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 476, SYSCON_I2SDIV_PDIV_2  | (119 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 480, SYSCON_I2SDIV_PDIV_3  | ( 80 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 484, SYSCON_I2SDIV_PDIV_2  | (121 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 485, SYSCON_I2SDIV_PDIV_25 | ( 97 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 486, SYSCON_I2SDIV_PDIV_3  | ( 81 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 488, SYSCON_I2SDIV_PDIV_2  | (122 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 490, SYSCON_I2SDIV_PDIV_25 | ( 98 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 492, SYSCON_I2SDIV_PDIV_3  | ( 82 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 495, SYSCON_I2SDIV_PDIV_25 | ( 99 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 496, SYSCON_I2SDIV_PDIV_2  | (124 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 498, SYSCON_I2SDIV_PDIV_3  | ( 83 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 500, SYSCON_I2SDIV_PDIV_25 | (100 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 504, SYSCON_I2SDIV_PDIV_3  | ( 84 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 505, SYSCON_I2SDIV_PDIV_25 | (101 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 508, SYSCON_I2SDIV_PDIV_2  | (127 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 510, SYSCON_I2SDIV_PDIV_3  | ( 85 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 515, SYSCON_I2SDIV_PDIV_25 | (103 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 516, SYSCON_I2SDIV_PDIV_3  | ( 86 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 520, SYSCON_I2SDIV_PDIV_25 | (104 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 522, SYSCON_I2SDIV_PDIV_3  | ( 87 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 525, SYSCON_I2SDIV_PDIV_25 | (105 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 528, SYSCON_I2SDIV_PDIV_3  | ( 88 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 530, SYSCON_I2SDIV_PDIV_25 | (106 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 534, SYSCON_I2SDIV_PDIV_3  | ( 89 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 535, SYSCON_I2SDIV_PDIV_25 | (107 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 540, SYSCON_I2SDIV_PDIV_3  | ( 90 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 545, SYSCON_I2SDIV_PDIV_25 | (109 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 546, SYSCON_I2SDIV_PDIV_3  | ( 91 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 550, SYSCON_I2SDIV_PDIV_25 | (110 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 552, SYSCON_I2SDIV_PDIV_3  | ( 92 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 555, SYSCON_I2SDIV_PDIV_25 | (111 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 558, SYSCON_I2SDIV_PDIV_3  | ( 93 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 560, SYSCON_I2SDIV_PDIV_25 | (112 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 564, SYSCON_I2SDIV_PDIV_3  | ( 94 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 565, SYSCON_I2SDIV_PDIV_25 | (113 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 570, SYSCON_I2SDIV_PDIV_3  | ( 95 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 575, SYSCON_I2SDIV_PDIV_25 | (115 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 576, SYSCON_I2SDIV_PDIV_3  | ( 96 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 580, SYSCON_I2SDIV_PDIV_25 | (116 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 582, SYSCON_I2SDIV_PDIV_3  | ( 97 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 585, SYSCON_I2SDIV_PDIV_25 | (117 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 588, SYSCON_I2SDIV_PDIV_3  | ( 98 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 590, SYSCON_I2SDIV_PDIV_25 | (118 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 594, SYSCON_I2SDIV_PDIV_3  | ( 99 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 595, SYSCON_I2SDIV_PDIV_25 | (119 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 600, SYSCON_I2SDIV_PDIV_3  | (100 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 605, SYSCON_I2SDIV_PDIV_25 | (121 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 606, SYSCON_I2SDIV_PDIV_3  | (101 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 610, SYSCON_I2SDIV_PDIV_25 | (122 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 612, SYSCON_I2SDIV_PDIV_3  | (102 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 615, SYSCON_I2SDIV_PDIV_25 | (123 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 618, SYSCON_I2SDIV_PDIV_3  | (103 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 620, SYSCON_I2SDIV_PDIV_25 | (124 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 624, SYSCON_I2SDIV_PDIV_3  | (104 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 625, SYSCON_I2SDIV_PDIV_25 | (125 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 630, SYSCON_I2SDIV_PDIV_3  | (105 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 635, SYSCON_I2SDIV_PDIV_25 | (127 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 636, SYSCON_I2SDIV_PDIV_3  | (106 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 642, SYSCON_I2SDIV_PDIV_3  | (107 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 648, SYSCON_I2SDIV_PDIV_3  | (108 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 654, SYSCON_I2SDIV_PDIV_3  | (109 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 660, SYSCON_I2SDIV_PDIV_3  | (110 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 666, SYSCON_I2SDIV_PDIV_3  | (111 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 672, SYSCON_I2SDIV_PDIV_3  | (112 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 678, SYSCON_I2SDIV_PDIV_3  | (113 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 684, SYSCON_I2SDIV_PDIV_3  | (114 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 690, SYSCON_I2SDIV_PDIV_3  | (115 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 696, SYSCON_I2SDIV_PDIV_3  | (116 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 702, SYSCON_I2SDIV_PDIV_3  | (117 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 708, SYSCON_I2SDIV_PDIV_3  | (118 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 714, SYSCON_I2SDIV_PDIV_3  | (119 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 720, SYSCON_I2SDIV_PDIV_3  | (120 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 726, SYSCON_I2SDIV_PDIV_3  | (121 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 732, SYSCON_I2SDIV_PDIV_3  | (122 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 738, SYSCON_I2SDIV_PDIV_3  | (123 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 744, SYSCON_I2SDIV_PDIV_3  | (124 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 750, SYSCON_I2SDIV_PDIV_3  | (125 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 756, SYSCON_I2SDIV_PDIV_3  | (126 & SYSCON_I2SDIV_MDIV_MASK) },
+    { 762, SYSCON_I2SDIV_PDIV_3  | (127 & SYSCON_I2SDIV_MDIV_MASK) }
+};
+
+
+#define I2S_CHL_TX0   0x1
+#define I2S_CHL_TX1   0x2
+#define I2S_CHL_TX2   0x4
+#define I2S_CHL_TX_ALL   (I2S_CHL_TX0 | \
+                            I2S_CHL_TX1 | \
+                            I2S_CHL_TX2)
+
+#define I2S_CHL_RX0   0x10
+#define I2S_CHL_RX1   0x20
+#define I2S_CHL_RX2   0x40
+#define I2S_CHL_RX_ALL   (I2S_CHL_RX0 | \
+                           I2S_CHL_RX1 | \
+                           I2S_CHL_RX2)
+
+#define I2S_CHL_ALL         (I2S_CHL_TX_ALL | I2S_CHL_RX_ALL)
+
+/*
+ * When we get to the multichannel case the pre-fill and enable code
+ * will go to the dma driver's start routine.
+ */
+static void ep93xx_audio_enable(unsigned long ulChlMask)
+{
+    int i;
+    unsigned long ulTemp;
+
+    DPRINTK("ep93xx_audio_enable - enter\n");
+
+    /*
+     * Disable the channels, disable the i2s controller to clear out the
+     * fifo.  Disabling the controller will clear the flags in i2s_csr.
+     */
+    if(ulChlMask & I2S_CHL_TX0)
+        outl( 0, I2STX0En );
+    if(ulChlMask & I2S_CHL_TX1)
+        outl( 0, I2STX1En );
+    if(ulChlMask & I2S_CHL_TX2)
+        outl( 0, I2STX2En );
+
+    if(ulChlMask & I2S_CHL_RX0)
+        outl( 0, I2SRX0En );
+    if(ulChlMask & I2S_CHL_RX1)
+        outl( 0, I2SRX1En );
+    if(ulChlMask & I2S_CHL_RX2)
+        outl( 0, I2SRX2En );
+    ulTemp = inl( I2SRX2En ); /* input to push the outl's past the wrapper */
+
+    if((ulChlMask & I2S_CHL_ALL) == I2S_CHL_ALL)
+    {
+
+        /*
+         * Disable the i2s controller to clear out the fifo and clear
+         * the flags in i2s_csr.
+         */
+        outl( 0, I2SGlCtrl );
+        ulTemp = inl( I2SGlCtrl );
+
+        /*
+         * Enable the i2s controller.  It is important not to just
+         * leave the i2s controller enabled and skip this step.
+         */
+        outl( 1, I2SGlCtrl );
+        ulTemp = inl( I2SGlCtrl );
+     }
+
+    /*
+     * Prefill the tx fifo with zeros.
+     */
+    for( i = 0 ; i < 8 ; i++ )
+    {
+        if(ulChlMask & I2S_CHL_TX0)
+        {
+            outl( 0, I2STX0Lft );
+            outl( 0, I2STX0Rt );
+        }
+        if(ulChlMask & I2S_CHL_TX1)
+        {
+            outl( 0, I2STX1Lft );
+            outl( 0, I2STX1Rt );
+        }
+        if(ulChlMask & I2S_CHL_TX2)
+        {
+            outl( 0, I2STX2Lft );
+            outl( 0, I2STX2Rt );
+        }
+        ulTemp = inl( I2SRX2En ); /* input to push the outl's past the wrapper */
+    }
+
+    /*
+     * Enable the tx channels.
+     */
+    if(ulChlMask & I2S_CHL_TX0)
+        outl( 1, I2STX0En );
+    if(ulChlMask & I2S_CHL_TX1)
+        outl( 1, I2STX1En );
+    if(ulChlMask & I2S_CHL_TX2)
+        outl( 1, I2STX2En );
+
+    if(ulChlMask & I2S_CHL_RX0)
+        outl( 1, I2SRX0En );
+    if(ulChlMask & I2S_CHL_RX1)
+        outl( 1, I2SRX1En );
+    if(ulChlMask & I2S_CHL_RX2)
+        outl( 1, I2SRX2En );
+    ulTemp = inl( I2SRX2En ); /* input to push the outl's past the wrapper */
+
+    DPRINTK("ep93xx_audio_enable - EXIT\n");
+
+}
+
+
+static void ep93xx_audio_disable(unsigned long ulChlMask)
+{
+    DPRINTK("ep93xx_audio_disable - enter\n");
+    audio_has_been_initialized = 0;
+
+    /*
+     * Disable the channels, disable the i2s controller to clear out the
+     * fifo.  Disabling the controller will clear the flags in i2s_csr.
+     */
+    if(ulChlMask & I2S_CHL_TX0)
+        outl( 0, I2STX0En );
+    if(ulChlMask & I2S_CHL_TX1)
+        outl( 0, I2STX1En );
+    if(ulChlMask & I2S_CHL_TX2)
+        outl( 0, I2STX2En );
+
+    if(ulChlMask & I2S_CHL_RX0)
+        outl( 0, I2SRX0En );
+    if(ulChlMask & I2S_CHL_RX1)
+        outl( 0, I2SRX1En );
+    if(ulChlMask & I2S_CHL_RX2)
+        outl( 0, I2SRX2En );
+
+    if((ulChlMask & I2S_CHL_ALL) == I2S_CHL_ALL)
+	outl( 0, I2SGlCtrl );
+
+	DPRINTK("ep93xx_audio_disable - EXIT\n");
+}
+
+
+/*
+ * ep93xx_calc_closest_freq
+ * 
+ *   ulPLLFreq           -  PLL output Frequency (Mhz)
+ *   ulRequestedMClkFreq -  Requested Video Clock Frequency.
+ *   pulActualMClkFreq   -  Returned Actual Video Rate.
+ *   pulI2SDiv           -  Video Divider register.
+ *
+ *   Return            0 - Failure
+ *                     1 - Success
+ */
+static int ep93xx_calc_closest_freq
+(
+    ulong   ulPLLFreq, 
+    ulong   ulRequestedMClkFreq,
+    ulong * pulActualMClkFreq,
+    ulong * pulI2SDiv
+)
+{
+	ulong   ulLower;
+	ulong   ulUpper;
+	ulong   ulDiv;
+	int     x;
+
+	/*
+	 * Calculate the closest divisor.
+	 */
+	ulDiv =  (ulPLLFreq * 2)/ ulRequestedMClkFreq;
+
+	for(x = 1; x < sizeof(I2SDivTable)/sizeof(DIV_TABLE); x++)
+	{
+
+		/*
+		 * Calculate the next greater and lower value.
+		 */
+		ulLower = I2SDivTable[x - 1].ulTotalDiv;     
+		ulUpper = I2SDivTable[x].ulTotalDiv;     
+
+		/*
+		 * Check to see if it is in between the two values.
+		 */
+		if(ulLower <= ulDiv && ulDiv < ulUpper)
+		{
+			break;
+		}
+	}
+
+	/*
+	 * Return if we did not find a divisor.
+	 */
+	if(x == sizeof(I2SDivTable)/sizeof(DIV_TABLE))
+	{
+		DPRINTK("couldn't find a divisor.\n");
+
+		*pulActualMClkFreq  = 0;
+		*pulI2SDiv          = 0;
+		return -1;
+	}
+
+	/*
+	 * See which is closer, the upper or the lower case.
+	 */
+	if(ulUpper * ulRequestedMClkFreq - ulPLLFreq * 2 >  
+		ulPLLFreq * 2 - ulLower * ulRequestedMClkFreq)
+	{
+		x-=1;
+	}
+	*pulActualMClkFreq  = (ulPLLFreq * 2)/ I2SDivTable[x].ulTotalDiv;
+	*pulI2SDiv          = I2SDivTable[x].ulI2SDiv;
+
+	return 0;
+}
+
+/*
+ * ep93xx_get_PLL_frequency
+ *
+ * Given a value for ClkSet1 or ClkSet2, calculate the PLL1 or PLL2 frequency.
+ */
+static ulong ep93xx_get_PLL_frequency( ulong ulCLKSET )
+{
+	ulong ulX1FBD, ulX2FBD, ulX2IPD, ulPS, ulPLL_Freq;
+
+	ulPS = (ulCLKSET & SYSCON_CLKSET1_PLL1_PS_MASK) >> SYSCON_CLKSET1_PLL1_PS_SHIFT;
+	ulX1FBD = (ulCLKSET & SYSCON_CLKSET1_PLL1_X1FBD1_MASK) >> SYSCON_CLKSET1_PLL1_X1FBD1_SHIFT;
+	ulX2FBD = (ulCLKSET & SYSCON_CLKSET1_PLL1_X2FBD2_MASK) >> SYSCON_CLKSET1_PLL1_X2FBD2_SHIFT;
+	ulX2IPD = (ulCLKSET & SYSCON_CLKSET1_PLL1_X2IPD_MASK) >> SYSCON_CLKSET1_PLL1_X2IPD_SHIFT;
+                                                                                                                             
+	/*
+	 * This may be off by a very small fraction of a percent.
+	 */
+	ulPLL_Freq = (((0x00e10000 * (ulX1FBD+1)) / (ulX2IPD+1)) * (ulX2FBD+1)) >> ulPS;
+                                                                                                                             
+	return ulPLL_Freq;
+}
+
+/*
+ * SetSampleRate
+ * 		disables i2s channels and sets up i2s divisors
+ * 		in syscon for the requested sample rate.
+ *
+ * lFrequency - Sample Rate in Hz
+ */
+static void ep93xx_set_samplerate(long lFrequency)
+{
+	ulong ulRequestedMClkFreq, ulPLL1_CLOCK, ulPLL2_CLOCK;
+	ulong ulMClkFreq1, ulMClkFreq2, ulClkSet1, ulClkSet2;
+	ulong ulI2SDiv, ulI2SDiv1, ulI2SDiv2, ulI2SDIV, actual_samplerate;
+    
+	/*
+	 * Clock ratios: MCLK to SCLK and SCLK to LRCK
+	 */
+	ulong ulM2SClock  = 4;
+	ulong ulS2LRClock = 64;
+
+	DPRINTK( "ep93xx_set_samplerate = %d Hz.\n", (int)lFrequency );
+
+	/*
+	 * Read CLKSET1 and CLKSET2 in the System Controller and calculate
+	 * the PLL frequencies from that.
+	 */
+	ulClkSet1 =	inl(SYSCON_CLKSET1);
+	ulClkSet2 =	inl(SYSCON_CLKSET2);
+	ulPLL1_CLOCK = ep93xx_get_PLL_frequency( ulClkSet1 );
+	ulPLL2_CLOCK = ep93xx_get_PLL_frequency( ulClkSet2 );
+
+	DPRINTK( "ClkSet1=0x%08x Clkset2=0x%08x  PLL1=%d Hz  PLL2=%d Hz\n", 
+		(int)ulClkSet1, (int)ulClkSet2, (int)ulPLL1_CLOCK, (int)ulPLL2_CLOCK );
+
+	ulRequestedMClkFreq = ( lFrequency * ulM2SClock * ulS2LRClock);
+
+	ep93xx_calc_closest_freq
+	(
+		ulPLL1_CLOCK, 
+		ulRequestedMClkFreq,
+		&ulMClkFreq1,
+		&ulI2SDiv1
+	);
+	ep93xx_calc_closest_freq
+	(
+		ulPLL2_CLOCK, 
+		ulRequestedMClkFreq,
+		&ulMClkFreq2,
+		&ulI2SDiv2
+	);
+
+	/*
+	 * See which is closer, MClk rate 1 or MClk rate 2.
+	 */
+	if(abs(ulMClkFreq1 - ulRequestedMClkFreq) < abs(ulMClkFreq2 -ulRequestedMClkFreq))
+	{
+		ulI2SDiv = ulI2SDiv1;
+		actual_samplerate = ulMClkFreq1/ (ulM2SClock * ulS2LRClock);
+		DPRINTK( "ep93xx_set_samplerate - using PLL1\n" );
+	}
+	else
+	{
+		ulI2SDiv = ulI2SDiv2 | SYSCON_I2SDIV_PSEL;
+		actual_samplerate = ulMClkFreq1 / (ulM2SClock * ulS2LRClock);
+		DPRINTK( "ep93xx_set_samplerate - using PLL2\n" );
+	}
+
+	/*
+	 * Calculate the new I2SDIV register value and write it out.
+	 */
+	ulI2SDIV = ulI2SDiv | SYSCON_I2SDIV_SENA |  SYSCON_I2SDIV_ORIDE | 
+				SYSCON_I2SDIV_SPOL| SYSCON_I2SDIV_LRDIV_64 | 
+				SYSCON_I2SDIV_SDIV | SYSCON_I2SDIV_MENA | SYSCON_I2SDIV_ESEL;
+
+	DPRINTK("I2SDIV set to 0x%08x\n", (unsigned int)ulI2SDIV );
+	
+	SysconSetLocked(SYSCON_I2SDIV, ulI2SDIV);
+	audio_clocks_enabled_in_syscon = 1;
+
+}
+
+/*
+ * BringUpI2S
+ *
+ * This routine sets up the I2S Controller.
+ */
+static void ep93xx_init_i2s_controller( void )
+{
+	unsigned int uiDEVCFG;
+	
+	DPRINTK("ep93xx_init_i2s_controller - enter\n");
+	
+	/*
+	 * Configure the multiplexed Ac'97 pins to be I2S.  Also configure 
+	 * EGPIO[4,5,6,13] to be SDIN's and SDOUT's for the second and third
+	 * I2S stereo channels if the codec is a 6 channel codec.
+	 */
+	uiDEVCFG = inl(SYSCON_DEVCFG);
+	
+#ifdef CONFIG_CODEC_CS4271
+	uiDEVCFG |= SYSCON_DEVCFG_I2SonAC97;
+
+#elif defined(CONFIG_CODEC_KENWOOD)
+	uiDEVCFG |= SYSCON_DEVCFG_I2SonAC97;
+
+#else /* CONFIG_CODEC_CS4228A */
+	uiDEVCFG |= SYSCON_DEVCFG_I2SonAC97 | SYSCON_DEVCFG_A1onG | SYSCON_DEVCFG_A2onG;
+#endif
+	    
+	SysconSetLocked(SYSCON_DEVCFG, uiDEVCFG);
+
+	/* Configure I2S Tx channel */
+
+	/*
+	 * Justify Left, MSB first	
+	*/
+	outl( 0, I2STXLinCtrlData );
+
+	/*
+	 * WL = 24 bits 
+	 */
+	outl( 1, I2STXWrdLen );
+
+	/*
+	 * Set the I2S control block to master mode.
+	 * Tx bit clk rate determined by word legnth 
+	 * Do gate off last 8 clks (24 bit samples in a 32 bit field)
+	 * LRclk = I2S timing; LRck = 0 for left
+	 */
+	outl( (i2s_txcc_mstr | i2s_txcc_trel), I2STxClkCfg );
+	
+	/* Configure I2S rx channel */
+    
+	/*
+	 * First, clear all config bits.
+	 */
+	outl( 0, I2SRXLinCtrlData );
+
+	/*
+	 * WL = 24 bits 
+	 */
+	outl( 1, I2SRXWrdLen );
+
+	/* 
+	 * Set the I2S control block to master mode.
+	 * Rx bit clk rate determined by word legnth 
+	 * Do gate off last 8 clks 
+	 * setting i2s_rxcc_rrel gives us I2S timing
+	 * clearing i2s_rlrs gives us LRck = 0 for left, 1 for right
+	 * setting i2s_rxcc_nbcg specifies to not gate off extra 8 clocks 
+	 */
+	outl( (i2s_rxcc_bcr_64x | i2s_rxcc_nbcg |i2s_rxcc_mstr | i2s_rxcc_rrel), I2SRxClkCfg );
+
+	/* 
+	 * Do an input to push the outl's past the wrapper 
+	 */
+	uiDEVCFG = inl(SYSCON_DEVCFG);
+    
+	DPRINTK("ep93xx_init_i2s_controller - EXIT\n");
+}
+
+/*
+ * ep93xx_init_i2s_codec
+ *
+ * Note that codec must be getting i2s clocks for any codec
+ * register writes to work.
+ */
+static void ep93xx_init_i2s_codec( void )
+{
+#if defined(CONFIG_ARCH_EDB9301) || defined(CONFIG_ARCH_EDB9302)
+	unsigned int uiPADR, uiPADDR;
+#endif
+
+#if defined(CONFIG_ARCH_EDB9315A)
+	unsigned int uiPBDR, uiPBDDR;
+#endif
+
+#if defined(CONFIG_ARCH_EDB9307A) || defined(CONFIG_ARCH_EDB9302A)
+	unsigned int uiPHDR, uiPHDDR, uiDEVCFG;;
+#endif
+
+	DPRINTK("ep93xx_init_i2s_codec - enter\n");
+    
+	if( !audio_clocks_enabled_in_syscon )
+	{
+		DPRINTK("ep93xx_init_i2s_codec - EXIT - clocks not enabled\n");
+		return;
+	}
+
+#ifdef CONFIG_CODEC_CS4271
+
+	/*
+	 * Some EDB9301 boards use EGPIO1 (port 1, bit 1) for the I2S reset.
+	 * EGPIO1 has a pulldown so if it isn't configured as an output, it is low.
+	 */
+#if defined(CONFIG_ARCH_EDB9301) || defined(CONFIG_ARCH_EDB9302)
+	uiPADR  = inl(GPIO_PADR);
+	uiPADDR = inl(GPIO_PADDR);
+    
+	/* Clear bit 1 of the data register */
+	outl( (uiPADR & 0xfd), GPIO_PADR );
+	uiPADR  = inl(GPIO_PADR);
+
+	/* Set bit 1 of the DDR to set it to output
+	 * Now we are driving the reset pin low.
+	 */
+	outl( (uiPADDR | 0x02), GPIO_PADDR );
+	uiPADDR = inl(GPIO_PADDR);
+
+	udelay( 2 );  /* plenty of time */
+
+	/* Set bit 1 of the data reg.  Now we drive the reset pin high. */
+	outl( (uiPADR | 0x02),  GPIO_PADR );
+	uiPADR  = inl(GPIO_PADR);
+#endif
+
+#if defined(CONFIG_ARCH_EDB9315A)
+    
+	uiPBDR  = inl(GPIO_PBDR);
+	uiPBDDR = inl(GPIO_PBDDR);
+    
+	/* Clear bit 1 of the data register */
+	outl( (uiPBDR & 0xbf), GPIO_PBDR );
+	uiPBDR  = inl(GPIO_PBDR);
+
+	/* Set bit 1 of the DDR to set it to output
+	 * Now we are driving the reset pin low.
+	 */
+	outl( (uiPBDDR | 0x40), GPIO_PBDDR );
+	uiPBDDR = inl(GPIO_PBDDR);
+
+	udelay( 2 );  /* plenty of time */
+
+	/* Set bit 1 of the data reg.  Now we drive the reset pin high. */
+	outl( (uiPBDR | 0x40),  GPIO_PBDR );
+	uiPBDR  = inl(GPIO_PBDR);
+#endif
+
+#if defined(CONFIG_ARCH_EDB9307A) || defined(CONFIG_ARCH_EDB9302A)
+    
+	/* Setup bit 11 in DEV_CONFIG for Port HonIDE to do GPIO */
+	uiDEVCFG = inl(SYSCON_DEVCFG);
+	uiDEVCFG |= SYSCON_DEVCFG_HonIDE;
+	
+	/* Unlock SYSCON_DEVCFG */
+	SysconSetLocked(SYSCON_DEVCFG, uiDEVCFG);
+	
+	uiPHDR  = inl(GPIO_PHDR);
+	uiPHDDR = inl(GPIO_PHDDR);
+    
+	/* Clear bit 3 of the data register */
+	outl( (uiPHDR & 0xfb), GPIO_PHDR );
+	uiPHDR  = inl(GPIO_PHDR);
+
+	/* Set bit 3 of the DDR to set it to output
+	 * Now we are driving the reset pin low.
+	 */
+	outl( (uiPHDDR | 0x04), GPIO_PHDDR );
+	uiPHDDR = inl(GPIO_PHDDR);
+
+	udelay( 2 );  /* plenty of time */
+
+	/* Set bit 3 of the data reg.  Now we drive the reset pin high. */
+	outl( (uiPHDR | 0x04),  GPIO_PHDR );
+	uiPHDR  = inl(GPIO_PHDR);
+#endif
+	/*
+	 * Write to the control port, setting the enable control port bit
+	 * so that we can write to the control port.  OK?
+	 */
+	SSPDriver->Write( SSP_Handle, 7, 0x02 );
+
+	/* Select slave, 24Bit I2S serial mode */
+	SSPDriver->Write( SSP_Handle, 1, 0x01 );
+	SSPDriver->Write( SSP_Handle, 6, 0x10 );
+
+	/* Set AMUTE (auto-mute) bit. */
+	SSPDriver->Write( SSP_Handle, 2, 0x00 );
+
+#else // CONFIG_CODEC_CS4228A
+
+	/* Nothing needs to happen here */
+
+#endif
+    
+	DPRINTK("ep93xx_init_i2s_codec - EXIT\n");
+}
+
+/*
+ * ep93xx_automute_i2s_codec
+ *
+ * Note that codec must be getting i2s clocks for any codec
+ * register writes to work.
+ */
+static void ep93xx_automute_i2s_codec( void )
+{
+	DPRINTK("ep93xx_automute_i2s_codec - enter\n");
+
+	if( !audio_clocks_enabled_in_syscon )
+	{
+		DPRINTK("ep93xx_automute_i2s_codec - EXIT - clocks not enabled\n");
+		return;
+	}
+
+#ifdef CONFIG_CODEC_CS4271
+
+	/*
+	 * The automute bit is set by default for the CS4271.
+	 * Clear the driver's mute flag and use the set_volume routine
+	 * to write the current volume out with the mute bit cleared.
+	 */
+	mute = 0;
+	ep93xx_set_volume(0);
+
+#elif defined(CONFIG_CODEC_KENWOOD)
+
+#else // CONFIG_ARCH_CS4228A
+
+	SSPDriver->Write( SSP_Handle, 4, 0 );
+
+	/* Unmute the DACs */
+	SSPDriver->Write( SSP_Handle, 5, 0xF0 );
+
+	/* Unmute the MUTEC pin, turn on automute. */
+	SSPDriver->Write( SSP_Handle, 5, 0x40 );
+    
+	mute = 0;
+    
+#endif
+
+	DPRINTK("ep93xx_automute_i2s_codec - EXIT\n");
+}
+
+static int ep93xx_set_volume( int reg )
+{
+#ifdef CONFIG_CODEC_CS4271
+	int iMute = 0;
+#endif
+    
+	if( !audio_clocks_enabled_in_syscon )
+	{
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_CODEC_CS4271
+	/*
+	 * CS4271 DAC attenuation is 0 to 127 dB in 1 dB steps
+	 */
+	if( mute )
+	{
+		iMute = 0x80;
+	}
+
+	/*
+	 * Write the volume for DAC1 and DAC2 (reg 4 and 5)
+	 */
+	SSPDriver->Write( SSP_Handle, 4, (reg | iMute) );
+	SSPDriver->Write( SSP_Handle, 5, (reg | iMute) );
+	volume = 127;	
+
+#else // CONFIG_CODEC_CS4228A
+
+	/*
+	 * CS4228A DAC attenuation is 0 to 90.5 dB in 0.5 dB steps
+	 * Write the volume for DAC1 and DAC2 (reg 7 and 8)
+	 */
+	SSPDriver->Write( SSP_Handle, 7, reg );
+	SSPDriver->Write( SSP_Handle, 8, reg );
+	volume = 181;
+	
+#endif
+
+	return 0;
+}
+
+/*
+ * ep93xx_audio_init
+ * Note that the codec powers up with its DAC's muted and
+ * the serial format set to 24 bit I2S mode.
+ */
+static void ep93xx_audio_init(void *dummy)
+{
+	/*
+	 * Mute the DACs. Disable all audio channels.  
+	 * Must do this to change sample rate.
+	 */
+	ep93xx_audio_disable( 0 );
+
+	/*
+	 * Set up the i2s clocks in syscon.  Enable them.
+	 */ 
+	ep93xx_set_samplerate( AUDIO_SAMPLE_RATE_DEFAULT );
+
+	/*
+	 * Set i2s' controller serial format, and enable 
+	 * the i2s controller.
+	 */
+	ep93xx_init_i2s_controller();
+	
+	/*
+	 * Initialize codec serial format, etc.
+	 */
+	ep93xx_init_i2s_codec();
+
+	/*
+	 * Clear the fifo and enable the tx0 channel.
+	 */
+    ep93xx_audio_enable(I2S_CHL_ALL);
+
+	/*
+	 * Set the volume for the first time.
+	 */
+	ep93xx_set_volume( AUDIO_DEFAULT_VOLUME );
+	
+	/*
+	 * Unmute the DAC and set the mute pin MUTEC to automute.
+	 */
+	ep93xx_automute_i2s_codec();
+	
+	audio_has_been_initialized = 1;
+	
+	DPRINTK("ep93xx_audio_init - EXIT\n");
+}
+
+static void print_audio_format( long format )
+{
+	switch( format )
+	{
+		case SNDRV_PCM_FORMAT_S8:
+			DPRINTK( "AFMT_S8\n" );		   
+			break;
+			
+		case SNDRV_PCM_FORMAT_U8:		   
+			DPRINTK( "AFMT_U8\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_S16_LE:
+			DPRINTK( "AFMT_S16_LE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_S16_BE:
+			DPRINTK( "AFMT_S16_BE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_U16_LE:
+			DPRINTK( "AFMT_U16_LE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_U16_BE:
+			DPRINTK( "AFMT_U16_BE\n" );
+			break;
+			
+		case SNDRV_PCM_FORMAT_S24_LE:
+			DPRINTK( "AFMT_S24_LE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_S24_BE:
+			DPRINTK( "AFMT_S24_BE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_U24_LE:
+			DPRINTK( "AFMT_U24_LE\n" );		   
+			break;
+
+		case SNDRV_PCM_FORMAT_U24_BE:
+			DPRINTK( "AFMT_U24_BE\n" );		   
+			break;
+		default:
+			DPRINTK( "Unsupported Audio Format\n" );		   
+			break;
+	}
+}
+
+/*
+ * We convert to 24 bit samples that occupy 32 bits each.
+ * Formats we support:
+ *
+ * AFMT_S8
+ * AFMT_U8		   
+ * AFMT_S16_LE		Little endian signed 16
+ * AFMT_U16_LE		Little endian U16
+ * AFMT_S24_LE		Little endian signed 24
+ * AFMT_U24_LE		Little endian U24
+ *
+ */
+static void audio_set_format( audio_stream_t * s, long val )
+{
+	DPRINTK( "audio_set_format enter.  Format requested (%d) %d ", 
+				(int)val,SNDRV_PCM_FORMAT_S16_LE);
+	print_audio_format( val );
+	
+	switch( val )
+	{
+		case SNDRV_PCM_FORMAT_S8:
+			s->audio_format = SNDRV_PCM_FORMAT_S8;
+			s->audio_stream_bitwidth = 8;
+			break;
+			
+		case SNDRV_PCM_FORMAT_U8:		   
+			s->audio_format = SNDRV_PCM_FORMAT_U8;
+			s->audio_stream_bitwidth = 8;
+			break;
+			
+		case SNDRV_PCM_FORMAT_S16_LE:
+		case SNDRV_PCM_FORMAT_S16_BE:
+			s->audio_format = SNDRV_PCM_FORMAT_S16_LE;
+			s->audio_stream_bitwidth = 16;
+			break;
+
+		case SNDRV_PCM_FORMAT_U16_LE:
+		case SNDRV_PCM_FORMAT_U16_BE:
+			s->audio_format = SNDRV_PCM_FORMAT_U16_LE;
+			s->audio_stream_bitwidth = 16;
+			break;
+
+		case SNDRV_PCM_FORMAT_S24_LE:
+		case SNDRV_PCM_FMTBIT_S24_BE:		
+			s->audio_format = SNDRV_PCM_FORMAT_S24_LE;
+			s->audio_stream_bitwidth = 24;
+			break;
+
+		case SNDRV_PCM_FORMAT_U24_LE:
+		case SNDRV_PCM_FMTBIT_U24_BE:		
+			s->audio_format = SNDRV_PCM_FORMAT_U24_LE;
+			s->audio_stream_bitwidth = 24;
+			break;
+
+		default:
+			s->audio_format = SNDRV_PCM_FORMAT_U24_LE;
+			s->audio_stream_bitwidth = 24;
+			break;
+
+	}
+
+	DPRINTK( "audio_set_format EXIT format set to be (%d) ", (int)s->audio_format );
+	print_audio_format( (long)s->audio_format );
+}
+
+static __inline__ unsigned long copy_to_user_S24_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	int * user_ptr = (int *)to;	/* 32 bit user buffer */
+	int * dma_ptr = (int *)from;	/* 32 bit dma buffer  */
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (int)(*dma_ptr++), user_ptr++ );
+			__put_user( (int)(*dma_ptr++), user_ptr++ );
+			to_count -= 8;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (int)(*dma_ptr++), user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count -= 4;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U24_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	unsigned int * user_ptr = (unsigned int *)to;	/* 32 bit user buffer */
+	int * dma_ptr = (int *)from;	/* 32 bit dma buffer  */
+	
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((unsigned int)(*dma_ptr++) ) ^ 0x8000, user_ptr++ );
+			__put_user( ((unsigned int)(*dma_ptr++) ) ^ 0x8000, user_ptr++ );
+			to_count -= 8;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((unsigned int)(*dma_ptr++) ) ^ 0x8000, user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count -= 4;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_S16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	short * user_ptr = (short *)to;	/* 16 bit user buffer */
+	int * dma_ptr = (int *)from;	/* 32 bit dma buffer  */
+
+	int shift = 8;
+	
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (short)( (*dma_ptr++) >> shift ), user_ptr++ );
+			__put_user( (short)( (*dma_ptr++) >> shift ), user_ptr++ );
+			to_count -= 4;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (short)((*dma_ptr++) >> shift), user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count -= 2;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	short * user_ptr = (short *)to;	/* 16 bit user buffer */
+	int * dma_ptr = (int *)from;	/* 32 bit dma buffer  */
+
+	int shift = 8;
+	
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((short)( (*dma_ptr++) >> shift )) ^ 0x8000, user_ptr++ );
+			__put_user( ((short)( (*dma_ptr++) >> shift )) ^ 0x8000, user_ptr++ );
+			to_count -= 4;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((short)( (*dma_ptr++) >> shift )) ^ 0x8000, user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count -= 2;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_S8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	char * user_ptr = (char *)to;  /*  8 bit user buffer */
+	int * dma_ptr = (int *)from;    /* 32 bit dma buffer  */
+
+	int shift = 16;
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (char)( (*dma_ptr++) >> shift ), user_ptr++ );
+			__put_user( (char)( (*dma_ptr++) >> shift ), user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( (char)((*dma_ptr++) >> shift), user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count--;
+		}
+	}
+	
+	return total_to_count;
+}
+
+static __inline__ unsigned long copy_to_user_U8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	unsigned long to_count
+)
+{
+	int total_to_count = to_count;
+	char * user_ptr = (char *)to;  /*  8 bit user buffer */
+	int * dma_ptr = (int *)from;    /* 32 bit dma buffer  */
+
+	int shift = 16;
+
+	if( state->input_stream->audio_num_channels != 1 ) 
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((char)( (*dma_ptr++) >> shift )) ^ 0x80, user_ptr++ );
+			__put_user( ((char)( (*dma_ptr++) >> shift )) ^ 0x80, user_ptr++ );
+			to_count -= 2;
+		}
+	}
+	else
+	{
+		while (to_count > 0) 
+		{
+			__put_user( ((char)( (*dma_ptr++) >> shift )) ^ 0x80, user_ptr++ );
+			dma_ptr++;	/* skip right channel sample */
+			to_count--;
+		}
+	}
+	
+	return total_to_count;
+}
+
+/*
+ * Returns negative for error
+ * Returns # of bytes transferred out of the from buffer
+ * for success.
+ */
+static __inline__ int copy_to_user_with_conversion
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount
+)
+{
+	int ret=0;
+	
+	if( toCount == 0 )
+	{
+		DPRINTK("copy_to_user_with_conversion - nothing to copy!\n");
+	}
+
+	switch( state->input_stream->audio_format )
+	{
+		case SNDRV_PCM_FORMAT_S8:
+			ret = copy_to_user_S8( state, to, from, toCount );
+			break;
+			
+		case SNDRV_PCM_FORMAT_U8:
+			ret = copy_to_user_U8( state, to, from, toCount );
+			break;
+
+		case SNDRV_PCM_FORMAT_S16_LE:
+			ret = copy_to_user_S16_LE( state, to, from, toCount );
+			break;
+		
+		case SNDRV_PCM_FORMAT_U16_LE:
+			ret = copy_to_user_U16_LE( state, to, from, toCount );
+			break;
+
+		case SNDRV_PCM_FORMAT_S24_LE:
+			ret = copy_to_user_S24_LE( state, to, from, toCount );
+			break;
+		
+		case SNDRV_PCM_FORMAT_U24_LE:
+			ret = copy_to_user_U24_LE( state, to, from, toCount );
+			break;
+			
+		default:
+			__copy_to_user( (char *)to, from, toCount);
+			ret = toCount;
+			break;
+		}
+
+	return ret;
+}
+
+static __inline__ int copy_from_user_S24_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int * dma_buffer = (int *)to;
+	int val;
+	unsigned int * user_buffer = (unsigned int *)from;
+	unsigned int data;
+	
+	int toCount0 = toCount;
+	int mono = (state->output_stream->audio_num_channels == 1);
+
+	if (!mono)
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = (unsigned int)data;
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = (unsigned int)data;
+			toCount -= 8;
+		}
+	}
+	else
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			val = (unsigned int)data;
+			*dma_buffer++ = val;
+			*dma_buffer++ = val;
+			toCount -= 8;
+		}
+	} 
+
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in a two 32 bit samples (left & right) going out.  So
+	 * mono   = (2 bytes in)/(8 bytes out)
+	 * stereo = (4 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+		return toCount0 / 4;
+	
+	return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_U24_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int * dma_buffer = (int *)to;
+	int val;
+	unsigned int * user_buffer = (unsigned int *)from;
+	unsigned int data;
+	
+	int toCount0 = toCount;
+	int mono = (state->output_stream->audio_num_channels == 1);
+
+	if (!mono) 
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = ((unsigned int)data ^ 0x8000);
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = ((unsigned int)data ^ 0x8000);
+			toCount -= 8;
+		}
+	}
+	else
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			val = ((unsigned int)data ^ 0x8000);
+			*dma_buffer++ = val;
+			*dma_buffer++ = val;
+			toCount -= 8;
+		}
+	}
+	
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in a two 32 bit (left & right) samples going out.  So
+	 * mono   = (2 bytes in)/(8 bytes out)
+	 * stereo = (4 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+		return toCount0 / 4;
+	
+	return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_S16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int * dma_buffer = (int *)to;
+	int val;
+	unsigned short * user_buffer = (unsigned short *)from;
+	unsigned short data;
+	
+	int toCount0 = toCount;
+	int mono = (state->output_stream->audio_num_channels == 1);
+	int shift = 8;
+
+	if (!mono)
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = (unsigned int)data << shift;
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = (unsigned int)data << shift;
+			toCount -= 8;
+		}
+	}
+	else
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			val = (unsigned int)data << shift;
+			*dma_buffer++ = val;
+			*dma_buffer++ = val;
+			toCount -= 8;
+		}
+	} 
+
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in a two 32 bit samples (left & right) going out.  So
+	 * mono   = (2 bytes in)/(8 bytes out)
+	 * stereo = (4 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+		return toCount0 / 4;
+	
+	return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_U16_LE
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int * dma_buffer = (int *)to;
+	int val;
+	unsigned short * user_buffer = (unsigned short *)from;
+	unsigned short data;
+	
+	int toCount0 = toCount;
+	int mono = (state->output_stream->audio_num_channels == 1);
+	int shift = 8;
+
+	if (!mono) 
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = ((unsigned int)data ^ 0x8000) << shift;
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = ((unsigned int)data ^ 0x8000) << shift;
+			toCount -= 8;
+		}
+	}
+	else
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			val = ((unsigned int)data ^ 0x8000) << shift;
+			*dma_buffer++ = val;
+			*dma_buffer++ = val;
+			toCount -= 8;
+		}
+	}
+	
+	/*
+	 * Each mono or stereo 16 bit sample going in results
+	 * in a two 32 bit (left & right) samples going out.  So
+	 * mono   = (2 bytes in)/(8 bytes out)
+	 * stereo = (4 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+		return toCount0 / 4;
+	
+	return toCount0 / 2;
+}
+
+static __inline__ int copy_from_user_S8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int * dma_buffer = (int *)to;
+	int val;
+	unsigned char * user_buffer = (unsigned char *)from;
+	unsigned char data;
+	
+	int toCount0 = toCount;
+	int mono = (state->output_stream->audio_num_channels == 1);
+	int shift = 16;
+
+	if (!mono) 
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = (unsigned int)data << shift;
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = (unsigned int)data << shift;
+			toCount -= 8;
+		}
+	}
+	else
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			val = (unsigned int)data << shift;
+			*dma_buffer++ = val;
+			*dma_buffer++ = val;
+			toCount -= 8;
+		}
+	}
+	
+
+	/*
+	 * Each mono or stereo 8 bit sample going in results
+	 * in a two 32 bit samples (left & right) going out.  So
+	 * mono   = (1 byte  in)/(8 bytes out)
+	 * stereo = (2 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+		return toCount0 / 8;
+	
+	return toCount0 / 4;
+}
+
+static __inline__ int copy_from_user_U8
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	unsigned int * dma_buffer = (unsigned int *)to;
+	unsigned int val;
+	unsigned char * user_buffer = (unsigned char *)from;
+	unsigned char data;
+	
+	int toCount0 = toCount;
+	int mono = (state->output_stream->audio_num_channels == 1);
+	int shift = 16;
+
+	if (!mono)
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = ((unsigned int)data ^ 0x80) << shift;
+			__get_user(data, user_buffer++);
+			*dma_buffer++ = ((unsigned int)data ^ 0x80) << shift;
+			toCount -= 8;
+		}
+	}
+	else
+	{
+		while (toCount > 0) 
+		{
+			__get_user(data, user_buffer++);
+			val = ((unsigned int)data ^ 0x80) << shift;
+			*dma_buffer++ = val;
+			*dma_buffer++ = val;
+			toCount -= 8;
+		}
+	}
+	
+
+	/*
+	 * Each mono or stereo 8 bit sample going in results
+	 * in a two 32 bit samples (left & right) going out.  So
+	 * mono   = (1 byte  in)/(8 bytes out)
+	 * stereo = (2 bytes in)/(8 bytes out)
+	 */
+	if( mono )
+		return toCount0 / 8;
+	
+	return toCount0 / 4;
+}
+
+/*
+ * Returns negative for error
+ * Returns # of bytes transferred out of the from buffer
+ * for success.
+ */
+static __inline__ int copy_from_user_with_conversion
+(
+	audio_state_t *state,
+	const char *to, 
+	const char *from, 
+	int toCount 
+)
+{
+	int ret=0;
+	//DPRINTK("copy_from_user_with_conversion\n");	
+	if( toCount == 0 )
+	{
+		DPRINTK("copy_from_user_with_conversion - nothing to copy!\n");
+	}
+
+	switch( state->output_stream->audio_format )
+	{
+		case SNDRV_PCM_FORMAT_S8:
+			//DPRINTK("SNDRV_PCM_FORMAT_S8\n");
+			ret = copy_from_user_S8( state, to, from, toCount );
+			break;
+			
+		case SNDRV_PCM_FORMAT_U8:
+			//DPRINTK("SNDRV_PCM_FORMAT_U8\n");
+			ret = copy_from_user_U8( state, to, from, toCount );
+			break;
+
+		case SNDRV_PCM_FORMAT_S16_LE:
+			//DPRINTK("SNDRV_PCM_FORMAT_S16_LE\n");
+			ret = copy_from_user_S16_LE( state, to, from, toCount );
+			break;
+				
+		case SNDRV_PCM_FORMAT_U16_LE:
+			//DPRINTK("SNDRV_PCM_FORMAT_U16_LE\n");
+			ret = copy_from_user_U16_LE( state, to, from, toCount );
+			break;
+
+		case SNDRV_PCM_FORMAT_S24_LE:
+			//DPRINTK("SNDRV_PCM_FORMAT_S16_LE\n");
+			ret = copy_from_user_S24_LE( state, to, from, toCount );
+			break;
+				
+		case SNDRV_PCM_FORMAT_U24_LE:
+			//DPRINTK("SNDRV_PCM_FORMAT_U16_LE\n");
+			ret = copy_from_user_U24_LE( state, to, from, toCount );
+			break;
+			
+		default:
+			__copy_from_user( (char *)to, from, toCount);
+			ret = toCount;
+			break;
+	}
+	
+	return ret;
+}
+
+/*
+ *  audio_dma2usr_ratio()
+ *
+ *  For audio playback, we convert samples of arbitrary format to be 32 bit 
+ *  for our hardware. We're scaling a user buffer to a dma buffer.  So when
+ *  report byte counts, we scale them acording to the ratio of DMA sample
+ *  size to user buffer sample size.  When we report # of DMA fragments,
+ *  we don't scale that.  So:
+ *   - The fragment size the app sees  = (stream->fragsize/stream->dma2usr_ratio)
+ *   - The # of fragments the app sees = stream->nbfrags
+ *
+ *	User sample type can be stereo/mono/8/16/32 bit.  
+ *  DMA sample type will be either CM (compact mode) where two 16 bit 
+ *  samples together in a 32 bit word become a stereo sample or non-CM 
+ *  where each channel gets a 32 bit word.
+ *
+ *  Any time usr sample type changes, we need to call this function.
+ *
+ *  Also adjust the size and number of dma fragments if sample size changed.
+ *
+ *  Input format       Input sample     Output sample size    ratio (out:in)
+ *  bits   channels    size (bytes)       CM   non-CM          CM   non-CM
+ *   8       mono          1               4      8            4:1   8:1
+ *   8      stereo         2		   4      8            2:1   4:1
+ *   16      mono          2		   4      8            2:1   4:1
+ *   16     stereo         4		   4      8            1:1   2:1
+ *
+ *   24      mono          3		   4      8             X    8:3 not a real case
+ *   24     stereo         6		   4      8             X    8:6 not a real case
+ *   32      mono          4		   4      8             X    2:1
+ *   32     stereo         8		   4      8             X    1:1
+ *
+ */
+static void audio_dma2usr_ratio( audio_stream_t * stream )
+{
+	unsigned int dma_sample_size, user_sample_size;
+	
+	dma_sample_size = 8;	/* each stereo sample is 2 * 32 bits */
+	
+	if( stream->audio_num_channels != 1 )
+	{
+		// If stereo 16 bit, user sample is 4 bytes.
+		// If stereo  8 bit, user sample is 2 bytes.
+		user_sample_size = stream->audio_stream_bitwidth / 4;
+	}
+	else
+	{
+		// If mono 16 bit, user sample is 2 bytes.
+		// If mono  8 bit, user sample is 1 bytes.
+		user_sample_size = stream->audio_stream_bitwidth / 8;
+	}
+
+	/* dma2usr_ratio = (4 or 8) / (4, 2, or 1) = 8, 4, 2, or 1 */
+	stream->dma2usr_ratio = dma_sample_size / user_sample_size;
+	DPRINTK("stream->dma2usr_ratio = %d\n",stream->dma2usr_ratio);
+}
+
+/*---------------------------------------------------------------------------------------------*/
+
+/*
+ * audio_dma_start
+ *
+ * Our Ac97 has a specific start order that it likes.  Enable the 
+ * Ac97 channel AFTER enabling DMA.  Our I2S is not so picky.
+ */
+static void audio_dma_start( audio_state_t * state, audio_stream_t * stream )
+{
+	int err;
+
+	DPRINTK("audio_dma_start\n");
+
+	err = ep93xx_dma_start( stream->dmahandles[0],
+				stream->NumDmaChannels, 
+				stream->dmahandles );
+	if (state->hw_enable){
+		state->hw_enable( state->output_stream == stream );
+	}
+}
+
+/*
+ * audio_dma_pause
+ */
+static void audio_dma_pause( audio_state_t * state, audio_stream_t * stream )
+{
+	DPRINTK("audio_dma_pause\n");
+	if (state->hw_disable){
+		state->hw_disable( state->output_stream == stream );
+	}
+	
+	ep93xx_dma_pause( stream->dmahandles[0],
+			  stream->NumDmaChannels, 
+			  stream->dmahandles );
+}
+
+/*
+ * audio_deallocate_buffers
+ * 
+ * This function frees all buffers
+ */
+static void audio_deallocate_buffers( snd_pcm_substream_t *substream, audio_stream_t *s )
+{
+	int frag, i;
+	audio_state_t  *state = (audio_state_t *)substream->private_data;
+	
+	DPRINTK("EP93xx - audio_deallocate_buffers\n");
+
+	/* ensure DMA won't run anymore */
+	audio_dma_pause( state, s );
+	s->active = 0;
+	s->stopped = 0;
+
+	for( i=0 ; i<s->NumDmaChannels ; i++ )
+	{
+		ep93xx_dma_flush( s->dmahandles[0] );
+	}
+	
+	if (s->buffers) 
+	{
+		for (frag = 0; frag < s->nbfrags; frag++) 
+		{
+			if (!s->buffers[frag].master)
+			{
+				continue;
+			}
+
+			s->buffers[frag].start = NULL;
+			s->buffers[frag].master = 0;
+			s->buffers[frag].dma_addr = (dma_addr_t)NULL;			
+		}
+
+		/* Free the space allocated to the array of buf structs. */
+		kfree(s->buffers);
+		s->buffers = NULL;
+	}
+
+	s->buf_idx = 0;
+	s->buf = NULL;
+
+	DPRINTK("EP93xx - audio_deallocate_buffers - EXIT\n");
+}
+
+
+/*
+ * audio_allocate_buffers
+ *
+ * This function allocates the buffer structure array and buffer data space
+ * according to the current number of fragments and fragment size.
+ * Note that the output_stream and input_stream structs are allocated
+ * in ep93xx-ac97.c or ep93xx-i2s.c.
+ */
+static int audio_allocate_buffers( snd_pcm_substream_t *substream, audio_stream_t * s)
+{
+	int frag;
+	int dmasize = 0;
+	char *dmabuf = NULL;
+	dma_addr_t dmaphys = 0;
+	
+	struct snd_dma_buffer *pcmbuf = &substream->dma_buffer;
+	
+	if (s->buffers){
+		DPRINTK("%s BUSY\n",__FUNCTION__);
+		return -EBUSY;
+	}
+
+//	DPRINTK("EP93xx audio_allocate_buffers ENTER\n" );
+	
+	/* Allocate space for the array of audio_buf_t structs. */
+	s->buffers = (audio_buf_t *)
+		kmalloc(sizeof(audio_buf_t) * s->nbfrags, GFP_KERNEL);
+
+	if (!s->buffers)
+	{
+		DPRINTK(AUDIO_NAME ": unable to allocate audio memory\n ");
+		audio_deallocate_buffers(substream,s);
+		return -ENOMEM;
+	}
+
+	memset( s->buffers, 0, sizeof(audio_buf_t) * s->nbfrags );
+
+	/*
+	 * Let's allocate non-cached memory for DMA buffers.
+	 * We try to allocate all memory at once.
+	 * If this fails (a common reason is memory fragmentation),
+	 * then we allocate more smaller buffers.
+	 */
+	
+	for (frag = 0; frag < s->nbfrags; frag++) 
+	{
+		audio_buf_t *buf = &s->buffers[frag];
+
+		if (!dmasize) 
+		{
+			dmasize	= s->externedfragsize * s->nbfrags;
+			DPRINTK("the s->externedfragsize = %x\n",s->externedfragsize);
+			DPRINTK("the s->nbfrags = %x\n",s->nbfrags);
+			DPRINTK("the dmasize = %x\n",dmasize);
+
+			do {
+				dmabuf	= pcmbuf->area;
+				dmaphys	= pcmbuf->addr;
+			} while (!dmabuf && dmasize);
+		
+			/*
+			 * If we do fail to allocate enough for all the frags, 
+			 * deallocate whatever we did get and quit.
+			 */
+			if (!dmabuf)
+			{
+				DPRINTK(AUDIO_NAME ": unable to allocate audio memory\n ");
+				audio_deallocate_buffers(substream, s);
+				return -ENOMEM;
+			}
+
+			DPRINTK("EP93xx allocated %x bytes:  dmabuf=0x%08x  dmaphys=0x%08x\n",
+					dmasize, (int)dmabuf, (int)dmaphys );
+			
+			/*
+			 * Success!	 Save the size of this chunk to use when we deallocate it.
+			 */
+			buf->master = dmasize;
+			memzero(dmabuf, dmasize);
+		}
+
+		/*
+		 * Save the start address of the buf fragment.
+		 * We know the size of the fragment is fragsize.
+		 */
+		buf->start = dmabuf;
+		buf->dma_addr = dmaphys;
+		DPRINTK("buf->start=%x,buf->dma_addr=%x\n",buf->start,buf->dma_addr);
+		buf->stream = s;
+		buf->size = 0;
+		buf->reportedsize = s->fragsize;
+		buf->sent = 0;
+
+		sema_init(&buf->sem, 1);
+
+		/*
+		 * Now if we only allocated the minimal one frag of space, the
+		 * dmasize will be ==0 after this subtraction so it will allocate more
+		 * for the next frag.  Otherwise, the next time(s) thru this for loop
+		 * will dole out frag sized pieces of this big master chunk.
+		 */
+		//dmabuf += s->fragsize;
+		//dmaphys += s->fragsize;
+		//dmasize -= s->fragsize;
+
+		dmabuf += s->externedfragsize;
+		dmaphys += s->externedfragsize;
+		dmasize -= s->externedfragsize;
+	}
+
+	/*
+	 * Initialize the stream.
+	 */
+	s->buf_idx = 0;			/* Init the current buffer index. */
+	s->buf = &s->buffers[0];	/* Point buf to the current buffer struct. */
+	s->bytecount = 0;
+	s->externedbytecount = 0;
+	s->getptrCount = 0;
+	s->fragcount = 0;
+
+//	DPRINTK("EP93xx audio_allocate_buffers -- exit SUCCESS\n" );
+	return 0;
+
+}
+
+/*
+ * DMA callback functions
+ */
+static void audio_dma_tx_callback
+( 
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+	unsigned int buf_id;
+    int handle, removed = 0;
+	
+	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)user_data;
+	audio_state_t *state = (audio_state_t *)(substream->private_data);
+	audio_stream_t *s = state->output_stream;
+
+	DPRINTK( "audio_dma_tx_callback  - enter\n"); 
+	
+	switch( device )
+	{
+    		case DMATx_I2S3:
+			handle = s->dmahandles[2];
+			break;
+
+    		case DMATx_I2S2:
+			handle = s->dmahandles[1];
+			break;
+
+		case DMATx_I2S1:
+		default:
+			handle = s->dmahandles[0];
+			break;
+	}
+	
+	if(s->stopped == 0)
+	{	
+		/*
+		 * If we are mapped, get one buffer back and recycle it.
+		 */
+		if( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0 )
+		{
+		   	audio_buf_t *buf = (audio_buf_t *)buf_id;
+			
+			/* Accounting */
+			s->bytecount += s->fragsize;
+			
+			DPRINTK("s->bytecount=%x %x\n",s->bytecount,s->externedfragsize);
+	
+			/* Recycle buffer */
+			snd_pcm_period_elapsed(substream);	
+            if(s->stopped == 0)
+                ep93xx_dma_add_buffer( s->dmahandles[0],    /* dma instance */
+                            (unsigned int)buf->dma_addr, /* source  */
+                            0,          /* dest */
+                            s->externedfragsize,    /*s->fragsize,*/    /* size     */
+                            0,      /* is the last chunk?   */
+                            (unsigned int) buf ); /* buf id     */
+		}
+	}
+	else
+	{
+		/* stop the dma after remove all the buffer */
+		while( ep93xx_dma_remove_buffer( handle, &buf_id ) >= 0)
+		{	
+			/* Accounting */
+			s->bytecount += s->fragsize;
+			
+			DPRINTK("s->bytecount=%x %x\n",s->bytecount,s->externedfragsize);
+	
+            removed = 1;
+        }
+        /* Recycle buffer */
+        if(removed)
+            snd_pcm_period_elapsed(substream);
+
+	}
+}
+
+static void audio_dma_rx_callback
+(
+	ep93xx_dma_int_t DMAInt,
+	ep93xx_dma_dev_t device, 
+	unsigned int user_data 
+)
+{
+	unsigned int buf_id;
+	int handle;
+
+	snd_pcm_substream_t *substream	= (snd_pcm_substream_t *)user_data;
+	audio_state_t *state = (audio_state_t *)(substream->private_data);
+	audio_stream_t *s = state->input_stream;
+
+	DPRINTK("audio_dma_rx_callback\n");
+	switch( device )
+	{
+		case DMARx_I2S3:
+			handle = s->dmahandles[2];
+			break;
+
+    		case DMARx_I2S2:
+			handle = s->dmahandles[1];
+			break;
+
+		case DMARx_I2S1:
+		default:
+			handle = s->dmahandles[0];
+			break;
+	}
+
+	/*
+	 * Keep removing and recycling buffers as long as there are buffers
+	 * to remove.
+	 */
+	while( !ep93xx_dma_remove_buffer( handle, &buf_id ) )
+	{
+	   	audio_buf_t *buf = (audio_buf_t *)buf_id;
+   
+		/* Accounting */
+		s->bytecount += s->fragsize;
+
+		DPRINTK("s->bytecount=%x %x\n",s->bytecount,s->externedfragsize);
+
+		/* Recycle buffer */
+		if(s->stopped==0)
+		{	
+		 	ep93xx_dma_add_buffer( s->dmahandles[0], 	/* dma instance */
+						(unsigned int)buf->dma_addr, /* source 	*/
+						0, 			/* dest */
+						s->externedfragsize,	/*s->fragsize,*/	/* size 	*/
+						0,		/* is the last chunk? 	*/
+						(unsigned int) buf ); /* buf id		*/	
+
+		}
+
+    }
+    snd_pcm_period_elapsed(substream);
+
+}
+
+static int audio_release(snd_pcm_substream_t *substream)
+{
+	int i;
+	audio_state_t *state = (audio_state_t *)substream->private_data;
+
+	DPRINTK("EP93xx - audio_release -- enter.  \n");
+			
+
+	down(&state->sem);
+
+	/*read data from codec to controller */
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE) 
+	{
+		audio_deallocate_buffers(substream, state->input_stream);
+		
+		for( i=0 ; i < state->input_stream->NumDmaChannels ; i++ )
+		{
+			ep93xx_dma_free( state->input_stream->dmahandles[i] );
+		}
+		state->rd_ref = 0;
+	}
+	
+	/*write data from controller to codec*/
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ) 
+	{
+		/*
+		 * Wait for all our buffers to play.
+		 */
+		//audio_sync(substream);
+		
+		/*
+		 * audio_deallocate_buffers will pause and flush the dma
+		 * then deallocate the buffers.
+		 */
+		audio_deallocate_buffers(substream, state->output_stream);
+		for( i=0 ; i < state->output_stream->NumDmaChannels ; i++ )
+		{
+			ep93xx_dma_free( state->output_stream->dmahandles[i] );
+		}
+		state->wr_ref = 0;
+	}
+
+	up(&state->sem);
+
+	DPRINTK("EP93xx - audio_release -- EXIT\n");
+
+	return 0;
+}
+
+
+/*
+ *ep93xx_i2s_pcm_hw_params
+ *set the pcm dma buffer to the runtime pcm dma buffer
+ */
+static int ep93xx_i2s_pcm_hw_params(snd_pcm_substream_t *substream,
+				snd_pcm_hw_params_t *params)
+{
+	DPRINTK("ep93xx_i2s_pcm_hw_params----ENTER\n");
+	
+	return snd_pcm_lib_malloc_pages(substream,params_buffer_bytes(params));	
+}
+
+/*
+ *free the runtime_data buffer 
+ */
+static int ep93xx_i2s_pcm_hw_free(snd_pcm_substream_t *substream)
+{
+	DPRINTK("ep93xx_i2s_pcm_hw_free----ENTER\n");
+	
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/*
+ *ep93xx_i2s_pcm_prepare: need to finish these functions as lower
+ *chip_set_sample_format
+ *chip_set_sample_rate
+ *chip_set_channels
+ *chip_set_dma_setup
+ */
+static int ep93xx_i2s_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	audio_state_t *state = (audio_state_t *) substream->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+					state->output_stream : state->input_stream;
+    unsigned long ulChlMask = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+                    I2S_CHL_TX_ALL : I2S_CHL_RX_ALL ;
+
+	DPRINTK("ep93xx_snd_pcm_prepare - ENTER\n");
+    DPRINTK("Prepare\n");
+    DPRINTK("The runtime item : \n");
+    DPRINTK("runtime->dma_addr    = 0x%x\n", runtime->dma_addr);
+    DPRINTK("runtime->dma_area    = 0x%x\n", runtime->dma_area);
+    DPRINTK("runtime->dma_bytes   = 0x%x\n", runtime->dma_bytes);
+    DPRINTK("runtime->frame_bits  = 0x%x\n", runtime->frame_bits);
+    DPRINTK("runtime->buffer_size = 0x%x\n", runtime->buffer_size);
+    DPRINTK("runtime->period_size = 0x%x\n", runtime->period_size);
+    DPRINTK("runtime->periods     = 0x%x\n", runtime->periods);
+    DPRINTK("runtime->rate        = 0x%x\n", runtime->rate);
+    DPRINTK("runtime->format      = 0x%x\n", runtime->format);
+    DPRINTK("runtime->channels    = %d\n", runtime->channels);
+    DPRINTK("runtime->min_align   = %d\n", runtime->min_align);
+    DPRINTK("runtime->avail_max   = %d\n", runtime->avail_max);
+    DPRINTK("runtime->hw_ptr_base      = %d\n", runtime->hw_ptr_base);
+    DPRINTK("runtime->hw_ptr_interrupt = %d\n", runtime->hw_ptr_interrupt);
+    DPRINTK("runtime->silence_filled     = %d\n", runtime->silence_filled);
+    DPRINTK("runtime->silence_start      = %d\n", runtime->silence_start);
+    DPRINTK("runtime->silence_size       = %d\n", runtime->silence_size);
+    DPRINTK("runtime->silence_threshold  = %d\n", runtime->silence_threshold);
+    DPRINTK("runtime->boundary    = %d\n", runtime->boundary);
+    DPRINTK("runtime->stop_threshold  = %d\n", runtime->stop_threshold);
+    DPRINTK("runtime->start_threshold = %d\n", runtime->start_threshold);
+    DPRINTK("runtime->xfer_align      = %d\n", runtime->xfer_align);
+    DPRINTK("status->byte_align = %d\n", runtime->byte_align);
+    DPRINTK("status->min_align  = %d\n", runtime->min_align);
+    DPRINTK("status->hw_ptr    = %d\n", runtime->status->hw_ptr);
+    DPRINTK("control->appl_ptr = %d\n", runtime->control->appl_ptr);
+    DPRINTK("control->avail_min = %d\n", runtime->control->avail_min);
+
+    /* set requestd format when available */
+    stream->audio_num_channels = runtime->channels;
+    stream->fragsize = frames_to_bytes (runtime, runtime->period_size);
+    stream->nbfrags = runtime->periods;
+
+    /* set the audio format */
+    audio_set_format( stream, runtime->format );
+
+    /*
+     * Unmute the DAC and set the mute pin MUTEC to automute.
+     */
+    //ep93xx_automute_i2s_codec();
+
+    audio_dma2usr_ratio( stream );
+
+    /* set the stream->period_size to the value of dma space */
+    stream->externedfragsize = stream->fragsize * stream->dma2usr_ratio;
+    DPRINTK("stream->period_size = 0x%x\n",stream->externedfragsize);
+    stream->bytecount = 0;
+    stream->externedbytecount = 0;
+
+    if((!state->rd_ref) || (!state->wr_ref))
+    {
+        /*
+         * The stream is the only opened stream, so we can change the
+         * sampling rate.
+         */
+        ep93xx_audio_disable( ulChlMask );
+        ep93xx_set_samplerate( runtime->rate );
+        ep93xx_init_i2s_controller();
+        ep93xx_audio_enable(ulChlMask);
+        state->master_rate = runtime->rate;
+    }
+    else
+    {
+        if(state->master_rate  != runtime->rate)
+            return -1;
+        ep93xx_audio_disable( ulChlMask);
+        ep93xx_audio_enable(ulChlMask);
+    }
+
+	DPRINTK("ep93xx_snd_pcm_prepare - EXIT\n");
+	return 0;	
+}
+
+/*
+ *start/stop/pause dma translate
+ */
+static int ep93xx_i2s_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
+{	
+	audio_state_t  *state = (audio_state_t *)substream->private_data;
+	audio_stream_t *stream = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+					state->output_stream:state->input_stream;
+	
+	int ret = 0, i;
+	unsigned long flags;
+
+	switch (cmd)
+	{
+		case SNDRV_PCM_TRIGGER_START:
+			stream->stopped = 0;
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			{
+				/*
+		 	 	 * Allocate dma buffers if we haven't already done so.
+		 		 */
+				if( !stream->buffers && audio_allocate_buffers(substream, stream) )
+				{
+					DPRINTK("%s error %i\n", __FUNCTION__, __LINE__);
+					return -ENOMEM;
+				}
+		
+				/*
+		 		 * If we haven't already started the DMA start it.
+				 * But don't start it if we are waiting on a trigger.
+				 */
+				if( !stream->active && !stream->stopped )
+				{
+					stream->active = 1;
+					audio_dma_start( state, stream );
+				}
+
+				/* Add the audio data to dma request */
+				local_irq_save(flags);
+				
+				for (i = 0; i < stream->nbfrags; i++) 
+				{
+					audio_buf_t *buf = stream->buf;
+	 				ep93xx_dma_add_buffer( stream->dmahandles[0],	/* dma instance */
+							(unsigned int)buf->dma_addr, 	/* source */
+							0, 				/* dest */
+							stream->externedfragsize,	/* size	*/
+							0,				/* is the last chunk? 	*/
+							(unsigned int) buf ); 		/* buf id	*/	
+					NEXT_BUF(stream, buf);
+				}
+
+				local_irq_restore(flags);
+			}
+			if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			{
+				/* Allocate dma buffers if we haven't already done so. */
+				if( !stream->buffers && audio_allocate_buffers(substream, stream) )
+				{
+					DPRINTK("%s error %i\n", __FUNCTION__, __LINE__);
+					return -ENOMEM;
+				}
+				
+				/*
+				 * If we haven't already started the DMA start it.
+				 * But don't start it if we are waiting on a trigger.
+				 */
+				if( !stream->active && !stream->stopped )
+				{
+					stream->active = 1;
+					audio_dma_start( state, stream );
+				}
+
+				local_irq_save(flags);
+				for (i = 0; i < stream->nbfrags; i++) 
+				{
+					audio_buf_t *buf = stream->buf;
+	 				ep93xx_dma_add_buffer( stream->dmahandles[0],	/* dma instance */
+							(unsigned int)buf->dma_addr, 	/* source */
+							0, 				/* dest */
+							stream->externedfragsize,	/* size	*/
+							0,				/* is the last chunk? 	*/
+							(unsigned int) buf ); 		/* buf id	*/	
+					NEXT_BUF(stream, buf);
+				}
+				local_irq_restore(flags);
+			}
+			break;
+
+		case SNDRV_PCM_TRIGGER_STOP:
+            DPRINTK("TrigerStop\n");
+            ep93xx_dma_pause( stream->dmahandles[0] ,1, 0);
+            stream->active = 0;
+            stream->stopped = 1;
+            ep93xx_dma_flush(stream->dmahandles[0]);
+            if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+            {
+
+                /*
+                 * Fill the tx fifo with zeros. We have only two channels.
+                 */
+                for( i = 0 ; i < 8 ; i++ )
+                {
+                    unsigned long ulTemp;
+                    outl( 0, I2STX0Lft );
+                    outl( 0, I2STX0Rt );
+                    ulTemp = inl( I2SRX2En ); /* input to push the outl's past the wrapper */
+                }
+            }
+			break;
+
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			break;
+
+		default:
+			ret = -EINVAL;
+			DPRINTK("SNDRV_PCM_TRIGGER didnot support this command %x",cmd);
+	}
+
+	return ret;
+}
+
+/*
+ * Get the frame location
+ */
+static snd_pcm_uframes_t ep93xx_i2s_pcm_pointer(snd_pcm_substream_t *substream)
+{
+	audio_state_t *state = (audio_state_t *)(substream->private_data);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	audio_stream_t *stream 	= (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+					state->output_stream:state->input_stream;
+	snd_pcm_uframes_t pointer = 0;
+
+ 	pointer = bytes_to_frames(runtime,stream->bytecount);
+
+	if (pointer >= runtime->buffer_size)
+	{
+  		pointer = 0;
+	   	stream->bytecount=0;
+		stream->externedbytecount=0;
+	}
+	return pointer;
+}
+
+static int ep93xx_i2s_pcm_open(snd_pcm_substream_t *substream)
+{
+	audio_state_t *state = substream->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+	int err = 0;
+
+	DPRINTK("ep93xx_i2s_pcm_open----ENTER\n");
+	
+	/* set the hardware description*/
+	runtime->hw = ep93xx_i2s_pcm_hardware;
+
+
+	down(&state->sem);
+	
+	/*write :output direction*/
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ) 
+	{
+		DPRINTK("ep93xx_audio_open -- FMODE_WRITE\n");
+		
+		strncpy( os->devicename, state->output_id, MAX_DEVICE_NAME );
+
+		/* 
+	 	 * Request DMA channels 
+	 	 */
+		err = ep93xx_dma_request( 	&os->dmahandles[0], 
+						os->devicename,
+                       				state->output_dma );
+		if (err)
+		{
+			up(&state->sem);
+			DPRINTK("ep93xx_audio_open -- EXIT ERROR dma request failed\n");
+			return err;
+		}
+		/* 
+	 	 * Config DMA channels 
+	 	 */
+		err = ep93xx_dma_config(os->dmahandles[0], 
+					IGNORE_CHANNEL_ERROR, 
+					0, 
+					audio_dma_tx_callback,
+					(unsigned int)substream );
+		if (err) 
+		{
+			ep93xx_dma_free( os->dmahandles[0] );
+			up(&state->sem);
+			DPRINTK("ep93xx_audio_attach -- EXIT ERROR dma config failed\n");
+			return err;
+		}
+
+		os->NumDmaChannels = 1;
+		state->wr_ref = 1;
+		audio_deallocate_buffers(substream,os);
+
+		os->fragsize 	= AUDIO_FRAGSIZE_DEFAULT;
+		os->nbfrags  	= AUDIO_NBFRAGS_DEFAULT;
+
+		os->reportedfrags = os->dma2usr_ratio * AUDIO_NBFRAGS_DEFAULT ;
+
+		os->mapped = 0;
+		os->stopped = 0;
+		init_waitqueue_head(&os->wq);
+	}
+	
+	/*read :input direction*/
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE) 
+	{
+		strncpy( is->devicename, state->input_id, MAX_DEVICE_NAME );
+		
+		/* 
+	 	 * Request DMA channels 
+	 	 */
+		err = ep93xx_dma_request( 	&is->dmahandles[0], 
+						is->devicename,
+                       				state->input_dma);
+		if (err) 
+		{
+			up(&state->sem);
+			DPRINTK("ep93xx_audio_attach -- EXIT ERROR dma request failed\n");
+			return err;
+		}
+		
+		/* 
+	 	 * Config DMA channels 
+	 	 */
+		err = ep93xx_dma_config( 	is->dmahandles[0], 
+						IGNORE_CHANNEL_ERROR, 
+						0,
+						audio_dma_rx_callback, 
+						(unsigned int)substream );
+		if (err) 
+		{
+			ep93xx_dma_free( is->dmahandles[0] );
+			up(&state->sem);
+			DPRINTK("ep93xx_audio_attach -- EXIT ERROR dma config failed\n");
+			return err;
+		}
+
+		is->NumDmaChannels = 1;
+		state->rd_ref = 1;
+		audio_deallocate_buffers(substream,is);
+		is->fragsize 	= AUDIO_FRAGSIZE_DEFAULT;
+		is->nbfrags 	= AUDIO_NBFRAGS_DEFAULT;
+
+		is->reportedfrags = is->dma2usr_ratio * AUDIO_NBFRAGS_DEFAULT ;
+
+		is->mapped = 0;
+		is->stopped = 	0;
+		init_waitqueue_head(&is->wq);
+	}
+
+	up(&state->sem);
+
+	DPRINTK("ep93xx_audio_open -- EXIT\n");
+	return err;
+}
+
+/*
+ *free the HW dma channel
+ *free the HW dma buffer
+ *free the Hw dma decrotion using function :kfree
+ *shut down the ac97 codec and  Ac97 controller
+ */
+static int ep93xx_i2s_pcm_close(snd_pcm_substream_t *substream)
+{
+	int ret;
+
+	DPRINTK("ep93xx_i2s_pcm_close----ENTER\n");
+
+	ret = audio_release(substream);
+	if(ret!=0)
+		DPRINTK("%s error %x",__FUNCTION__,ret);
+
+	DPRINTK("ep93xx_i2s_pcm_close----EXIT\n");
+	return 0;
+}
+
+static int ep93xx_i2s_pcm_playback_copy(snd_pcm_substream_t * substream,int channel, 
+				snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+
+	audio_state_t *state = (audio_state_t *)substream->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	audio_stream_t *stream = state->output_stream;
+	int ret = 0;
+
+	int tocount = frames_to_bytes(runtime,count);
+
+	size_t dma_csize = runtime->dma_bytes / runtime->channels;
+	char *hwbuf;
+
+	if( channel == -1 )
+	{
+		hwbuf = runtime->dma_area  + stream->dma2usr_ratio * frames_to_bytes(runtime, pos);
+		DPRINTK("copy channel=%x,pos=%x,frames=%x\n ",channel,pos,count);
+
+	}
+	else
+	{
+		hwbuf = runtime->dma_area + (channel * dma_csize) + samples_to_bytes(runtime, pos);
+		DPRINTK("copy channel=%x,pos=%x,frames=%x\n ",channel,pos,count);
+	}
+	if(copy_from_user_with_conversion(state,hwbuf,(const char*)src,(tocount * stream->dma2usr_ratio)) <=0 )
+	{
+		printk(KERN_ERR "copy_from_user_with_conversion() failed\n");
+		return -EFAULT;
+	}
+
+	return ret;
+}
+
+static int ep93xx_i2s_pcm_capture_copy(snd_pcm_substream_t * substream,int channel, 
+				snd_pcm_uframes_t pos,void __user *src, snd_pcm_uframes_t count)
+{
+	audio_state_t *state 		= (audio_state_t *)(substream->private_data);
+	snd_pcm_runtime_t *runtime 	= substream->runtime;
+	audio_stream_t *stream 		= state->input_stream;
+	int ret = 0;
+
+	int tocount = frames_to_bytes(runtime,count);
+	
+	size_t dma_csize = runtime->dma_bytes / runtime->channels;
+	char *hwbuf;
+
+	if( channel == -1 )
+	{
+		hwbuf = runtime->dma_area  + stream->dma2usr_ratio * frames_to_bytes(runtime, pos);
+		DPRINTK("copy channel=%x,pos=%x,frames=%x\n ",channel,pos,count);
+
+	}
+	else
+	{
+		hwbuf = runtime->dma_area + (channel * dma_csize) + samples_to_bytes(runtime, pos);
+		DPRINTK("copy channel=%x,pos=%x,frames=%x\n ",channel,pos,count);
+	}
+	if(copy_to_user_with_conversion(state,(const char*)src,hwbuf,tocount) <= 0)
+	{
+		printk(KERN_ERR "copy_to_user_with_conversion() failed\n");
+		return -EFAULT;
+	}
+
+	return ret;	
+}
+
+static ep93xx_i2s_pcm_slience(snd_pcm_substream_t* substream,int channel,
+               snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+    audio_state_t *state = (audio_state_t *)substream->private_data;
+    snd_pcm_runtime_t *runtime = substream->runtime;
+    audio_stream_t *stream = state->output_stream;
+    int ret = 0;
+
+    int tocount = frames_to_bytes(runtime,count);
+
+    size_t dma_csize = runtime->dma_bytes / runtime->channels;
+    char *hwbuf;
+
+    if( channel == -1 )
+    {
+        hwbuf = runtime->dma_area  + stream->dma2usr_ratio * frames_to_bytes(runtime, pos);
+        DPRINTK("copy channel=%x,pos=%x,frames=%x\n ",channel,pos,count);
+
+    }
+    else
+    {
+        hwbuf = runtime->dma_area + (channel * dma_csize) + samples_to_bytes(runtime, pos);
+        DPRINTK("copy channel=%x,pos=%x,frames=%x\n ",channel,pos,count);
+    }
+    memset(hwbuf,0x00,(tocount * stream->dma2usr_ratio));
+    return ret;
+}
+
+static snd_pcm_ops_t ep93xx_i2s_pcm_playback_ops = {
+	.open		= ep93xx_i2s_pcm_open,
+	.close		= ep93xx_i2s_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= ep93xx_i2s_pcm_hw_params,
+	.hw_free	= ep93xx_i2s_pcm_hw_free,
+	.prepare	= ep93xx_i2s_pcm_prepare,
+	.trigger	= ep93xx_i2s_pcm_trigger,
+	.pointer	= ep93xx_i2s_pcm_pointer,
+	.copy		= ep93xx_i2s_pcm_playback_copy,
+    .silence    = ep93xx_i2s_pcm_slience,
+};
+
+static snd_pcm_ops_t ep93xx_i2s_pcm_capture_ops = {
+	.open		= ep93xx_i2s_pcm_open,
+	.close		= ep93xx_i2s_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= ep93xx_i2s_pcm_hw_params,
+	.hw_free	= ep93xx_i2s_pcm_hw_free,
+	.prepare	= ep93xx_i2s_pcm_prepare,
+	.trigger	= ep93xx_i2s_pcm_trigger,
+	.pointer	= ep93xx_i2s_pcm_pointer,
+	.copy 		= ep93xx_i2s_pcm_capture_copy,
+};
+
+static int ep93xx_i2s_pcm_new(snd_card_t *card, audio_state_t *state, snd_pcm_t **rpcm)
+{
+	snd_pcm_t *pcm;
+	int play = state->output_stream? 1 : 0;/*SNDRV_PCM_STREAM_PLAYBACK*/
+	int capt = state->input_stream ? 1 : 0;/*SNDRV_PCM_STREAM_CAPTURE*/
+	int ret = 0;
+
+	DPRINTK("ep93xx_i2s_pcm_new----ENTER\n");
+
+	/* Register the new pcm device interface */
+	ret = snd_pcm_new(card, "EP93xx-i2s-PCM", 0, play, capt, &pcm);
+	if (ret){
+		DPRINTK("%s--%x:card=%x,play=%x,capt=%x,&pcm=%x\n",__FUNCTION__,ret,card,play,capt,pcm);
+		goto out;
+	}
+
+	/* allocate the pcm(DMA) memory */
+	ret = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,0, 128*1024, 128*1024);
+
+	DPRINTK("The substream item : \n");
+	DPRINTK("pcm->streams[0].substream->dma_buffer.addr  = 0x%x\n", pcm->streams[0].substream->dma_buffer.addr);
+	DPRINTK("pcm->streams[0].substream->dma_buffer.area  = 0x%x\n", pcm->streams[0].substream->dma_buffer.area);
+	DPRINTK("pcm->streams[0].substream->dma_buffer.bytes = 0x%x\n", pcm->streams[0].substream->dma_buffer.bytes);
+	DPRINTK("pcm->streams[1].substream->dma_buffer.addr  = 0x%x\n", pcm->streams[1].substream->dma_buffer.addr);
+	DPRINTK("pcm->streams[1].substream->dma_buffer.area  = 0x%x\n", pcm->streams[1].substream->dma_buffer.area);
+	DPRINTK("pcm->streams[1].substream->dma_buffer.bytes = 0x%x\n", pcm->streams[1].substream->dma_buffer.bytes);	
+
+	pcm->private_data = state;
+	
+	/* seem to free the pcm data struct-->self dma buffer */
+	pcm->private_free = (void*) snd_pcm_lib_preallocate_free_for_all;
+
+	/* alsa pcm ops setting for SNDRV_PCM_STREAM_PLAYBACK */
+	if (play) {
+		int stream = SNDRV_PCM_STREAM_PLAYBACK;
+		snd_pcm_set_ops(pcm, stream, &ep93xx_i2s_pcm_playback_ops);
+		
+	}
+
+	/* alsa pcm ops setting for SNDRV_PCM_STREAM_CAPTURE */	
+	if (capt) {
+		int stream = SNDRV_PCM_STREAM_CAPTURE;
+		snd_pcm_set_ops(pcm, stream, &ep93xx_i2s_pcm_capture_ops);
+	}
+
+	if (rpcm)
+		*rpcm = pcm;
+	
+	DPRINTK("ep93xx_i2s_pcm_new----EXIT\n");
+ out:
+	return ret;
+}
+
+static int ep93xx_i2s_volume_info_double(snd_kcontrol_t *kcontrol, 
+					snd_ctl_elem_info_t * uinfo)
+{
+#ifdef CONFIG_CODEC_CS4271
+	int mask = (kcontrol->private_value >> 16) & 0x7f;
+#else // CONFIG_ARCH_CS4228A
+	int mask = (kcontrol->private_value >> 16) & 0xb5;
+#endif	
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int ep93xx_i2s_volume_get_double(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+#ifdef CONFIG_CODEC_CS4271
+	int mask = (kcontrol->private_value >> 16) & 0x7f;
+#else // CONFIG_ARCH_CS4228A
+	int mask = (kcontrol->private_value >> 16) & 0xb5;
+#endif	
+	int val = 0;
+	
+	val = volume;
+	ucontrol->value.integer.value[0] = volume & mask;
+	
+	return 0;
+}
+
+static int ep93xx_i2s_volume_put_double(snd_kcontrol_t * kcontrol,
+                                       snd_ctl_elem_value_t * ucontrol)
+{
+#ifdef CONFIG_CODEC_KENWOOD
+
+#else
+	int reg1 = (kcontrol->private_value) & 0xf;
+	int reg2 = (kcontrol->private_value >> 4) & 0xf;
+#ifdef CONFIG_CODEC_CS4271
+	int mask = (kcontrol->private_value >> 16) & 0x7f;
+#else // CONFIG_ARCH_CS4228A
+	int mask = (kcontrol->private_value >> 16) & 0xb5;
+#endif	
+	int val = 0;
+	
+	//spin_lock_irqsave(&emu->reg_lock, flags);
+	val = mask - (ucontrol->value.integer.value[0] & mask);
+	volume = ucontrol->value.integer.value[0] & mask;
+
+	DPRINTK("reg1 = 0x%x\n", reg1);
+	DPRINTK("reg2 = 0x%x\n", reg2);
+	DPRINTK("mask = %d\n", mask);
+	DPRINTK("val = %d\n", val);
+	DPRINTK("volume = %d\n", volume);
+	
+	SSPDriver->Write( SSP_Handle, reg1, val );
+	SSPDriver->Write( SSP_Handle, reg2, val );
+	
+	//spin_unlock_irqrestore(&emu->reg_lock, flags);
+
+#endif
+
+	return 1;
+
+}
+
+/*
+ * EP93xx i2s mixer control interface.
+ */
+#define EP93XX_VOLUME(xname, reg1, reg2, mask) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .info = ep93xx_i2s_volume_info_double, \
+  .get = ep93xx_i2s_volume_get_double, \
+  .put = ep93xx_i2s_volume_put_double, \
+  .private_value = (reg1) | (reg2 << 4) | (mask << 16) \
+}
+
+static snd_kcontrol_new_t snd_ep93xx_i2s_controls[] = {
+#ifdef CONFIG_CODEC_CS4271
+
+	EP93XX_VOLUME("Master Playback Volume", 0x4, 0x5, 0x7f),
+
+#else // CONFIG_ARCH_CS4228A
+    
+	EP93XX_VOLUME("Master Playback Volume", 0x7, 0x8, 0xb5),
+	EP93XX_VOLUME("PCM Playback 1 Volume", 0x9, 0xa, 0xb5),
+	EP93XX_VOLUME("PCM Playback 2 Volume", 0xb, 0xc, 0xb5),
+
+#endif
+};
+
+static int __init ep93xx_i2s_mixer_new(snd_card_t *card, audio_state_t *state)
+{
+	int idx, err;
+
+	snd_assert(card != NULL, return -EINVAL);
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_ep93xx_i2s_controls); idx++) {
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_ep93xx_i2s_controls[idx], state))) < 0)
+			return err;
+	}
+
+	strcpy(card->mixername, "EP93XX I2S MIXER");
+	return 0;
+}
+
+/* module power management */
+#ifdef CONFIG_PM
+static int ep93xx_i2s_suspend(struct device * dev, u32 state, u32 level)
+{
+	return 0;
+}
+
+static int ep93xx_i2s_resume(struct device * dev, u32 level)
+{
+	return 0;
+}
+#endif /* COMFIG_PM */
+
+/* module init & exit */
+static int ep93xx_i2s_probe(struct device *dev)
+{
+	snd_card_t *card;
+	int err = -ENOMEM;
+
+#ifdef CONFIG_CODEC_KENWOOD
+
+#else
+
+	/*
+	 * Open an instance of the SSP driver for I2S codec register access.
+	 */
+	SSP_Handle = SSPDriver->Open(I2S_CODEC,0);
+	if( SSP_Handle < 1 )
+	{
+		DPRINTK( "Couldn't open SSP driver!\n");
+		return -ENODEV;
+	}
+
+#endif
+
+	/*
+	 * Enable audio early on, give the DAC time to come up.
+	 */ 
+	ep93xx_audio_init( 0 );
+
+	/* register the soundcard */
+	card = snd_card_new(-1, 0, THIS_MODULE, 0);
+
+	card->dev = dev;
+
+	if (card == NULL) {
+		DPRINTK(KERN_ERR "snd_card_new() failed\n");
+		goto error;
+	}
+
+	strcpy(card->driver,    "ep93xx i2s");
+	strcpy(card->shortname, "ep93xx i2s audio");
+	strcpy(card->longname,  "Cirrus Logic ep93xx i2s audio");
+
+	/* pcm */
+	if (ep93xx_i2s_pcm_new(card, &audio_state, &ep93xx_i2s_pcm) < 0)
+		goto error;
+
+	/* mixer */
+	if (ep93xx_i2s_mixer_new(card, &audio_state) < 0)
+		goto error;
+
+	if ((err = snd_card_register(card)) == 0) {
+		printk( KERN_INFO "Cirrus Logic ep93xx i2s audio initialized\n" );
+		return 0;
+	}
+
+error:
+	snd_card_free(card);
+	return err;
+}
+
+static int ep93xx_i2s_remove(struct device *dev)
+{
+	snd_card_t *card = dev_get_drvdata(dev);
+
+	if (card) {
+		snd_card_free(card);
+		dev_set_drvdata(dev, NULL);
+	}
+
+	return 0;
+}
+
+static struct device_driver ep93xx_i2s_device = {
+	.name       = "ep93xxi2s",
+	.bus        = &platform_bus_type,
+	.probe      = ep93xx_i2s_probe,
+	.remove     = ep93xx_i2s_remove,
+#ifdef CONFIG_PM
+	.suspend    = ep93xx_i2s_suspend,
+	.resume     = ep93xx_i2s_resume,
+#endif
+};
+
+static int __init ep93xx_i2s_init(void)
+{
+	return driver_register(&ep93xx_i2s_device);
+}
+
+static void __exit ep93xx_i2s_exit(void)
+{
+	driver_unregister(&ep93xx_i2s_device);
+}
+
+module_init(ep93xx_i2s_init);
+module_exit(ep93xx_i2s_exit);
+
+MODULE_AUTHOR("Fred Wei");
+MODULE_DESCRIPTION("Cirrus Logic EP93xx I2S audio module");
+MODULE_LICENSE("GPL");
diff -burN linux-2.6.8.1-orig/sound/arm/ep93xx-i2s.h linux-2.6.8.1/sound/arm/ep93xx-i2s.h
--- linux-2.6.8.1-orig/sound/arm/ep93xx-i2s.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.8.1/sound/arm/ep93xx-i2s.h	2007-01-15 12:17:43.000000000 +0900
@@ -0,0 +1,112 @@
+/*
+ * linux/sound/arm/ep93xx-i2s.c -- ALSA PCM interface for the edb93xx i2s audio
+ *
+ * Author:      Fred Wei
+ * Created:     July 19, 2005
+ * Copyright:   Cirrus Logic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/*
+ *  Getting this from the rme96xx driver.  Has same numerical value
+ *  as AC3.  Hmmmm.
+ */
+
+#define EP93XX_DEFAULT_NUM_CHANNELS      2
+#define EP93XX_DEFAULT_FORMAT            SNDRV_PCM_FORMAT_S16_LE
+#define EP93XX_DEFAULT_BIT_WIDTH         16
+
+/*
+ * Buffer Management
+ */
+
+typedef struct {
+
+	int 				size;		/* buffer size */
+	int 				reportedsize;	/* buffer size */
+	int 				sent;		/* indicates that dma has the buf */
+	char 				*start;		/* points to actual buffer */
+	dma_addr_t 			dma_addr;	/* physical buffer address */
+	struct semaphore 		sem;		/* down before touching the buffer */
+	int 				master;		/* owner for buffer allocation, */
+							/* contains size when true */
+	struct audio_stream_s 		*stream;	/* owning stream */
+
+} audio_buf_t;
+
+#define MAX_DEVICE_NAME 20
+
+typedef struct audio_stream_s {
+
+	/* dma stuff */
+	int			dmahandles[3];		/* handles for dma driver instances */
+	char			devicename[MAX_DEVICE_NAME]; /* string - name of device */
+	int			NumDmaChannels;		/* 1, 2, or 3 DMA channels */
+	
+	audio_buf_t 		*buffers;		/* array of audio buffer structures */
+	audio_buf_t 		*buf;			/* current buffer used by read/write */
+	u_int 			buf_idx;		/* index for the pointer above... */
+	u_int 			fragsize;		/* fragment i.e. buffer size */
+	u_int 			nbfrags;		/* nbr of fragments i.e. buffers */
+	u_int			reportedfrags;		/* # of frags reported to app */
+	u_int 			externedfragsize;	/* fragment i.e. buffer size */
+	int 			bytecount;		/* nbr of processed bytes */
+	int 			externedbytecount;	/* nbr of processed bytes */
+	int 			getptrCount;		/* value of bytecount last time */
+							/* anyone asked via GETxPTR 		*/
+	int 			fragcount;		/* nbr of fragment transitions 		*/
+	ep93xx_dma_int_t 	dma_ch;			/* DMA channel ID 			*/
+	wait_queue_head_t 	wq;			/* for poll 				*/
+	int 			mapped;			/* mmap()'ed buffers 			*/
+	int 			active;			/* actually in progress 		*/
+	int 			stopped;		/* might be active but stopped 		*/
+
+	/*
+	 * Data about the file format that we are configured to play.
+	 */
+	long 			audio_num_channels;		/* Range: 1 to 6 */
+	long 			audio_format;
+	long 			audio_stream_bitwidth;		/* Range: 8, 16, 24, 32 */
+
+	int			dma2usr_ratio;
+} audio_stream_t;
+
+
+/*
+ * State structure for one instance
+ */
+typedef struct {
+	audio_stream_t 			*output_stream;
+	audio_stream_t 			*input_stream;
+	
+	ep93xx_dma_dev_t 		output_dma;
+	ep93xx_dma_dev_t 		input_dma;
+	
+	char 				*output_id;
+	char 				*input_id;
+
+    int                 master_rate;    /* Locked sampling rate */
+	int 				rd_ref:1;		/* open reference for recording */
+	int 				wr_ref:1;		/* open reference for playback */
+	
+	/* Pointers to init, shutdown, and ioctl functions. */
+	void 				(*hw_enable)(int input_or_output_stream);
+	void 				(*hw_disable)(int input_or_output_stream);
+	int 				(*client_ioctl)(struct inode *, struct file *, uint, ulong);
+	void				(*set_hw_serial_format)( long );
+
+	struct 				semaphore Loopsem;	/* to protect against races in attach() */
+	struct 				semaphore sem;		/* to protect against races in attach() */
+
+	/*
+	 * Data about how the audio controller and codec are set up.
+	 */
+	int				DAC_bit_width;		/* 16, 20, 24 bits */
+	int				bCompactMode;		/* set if 32bits = a stereo sample */
+
+} audio_state_t;
+
diff -burN linux-2.6.8.1-orig/sound/core/memalloc.c linux-2.6.8.1/sound/core/memalloc.c
--- linux-2.6.8.1-orig/sound/core/memalloc.c	2004-08-14 19:56:23.000000000 +0900
+++ linux-2.6.8.1/sound/core/memalloc.c	2007-01-24 13:03:31.000000000 +0900
@@ -263,8 +263,8 @@
 	if (pg > 0)
 		gfp_flags |= __GFP_NOWARN;
 	res = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
-	if (res != NULL)
-		mark_pages(res, pg);
+//	if (res != NULL)
+//		mark_pages(res, pg);
 
 	return res;
 }
